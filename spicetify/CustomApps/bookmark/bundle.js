(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  'use strict';

  // This file will likely become a generated file in the future. Please
  // avoid adding extra APIs or exports here.

  const i18n = require('../../../libs/spotify-i18n')({
    'cs': require('./json/cs.json'),
    'de': require('./json/de.json'),
    'el': require('./json/el.json'),
    'en': require('./json/en.json'),
    'es': require('./json/es.json'),
    'es-419': require('./json/es-419.json'),
    'fi': require('./json/fi.json'),
    'fr': require('./json/fr.json'),
    'fr-CA': require('./json/fr-CA.json'),
    'hu': require('./json/hu.json'),
    'id': require('./json/id.json'),
    'it': require('./json/it.json'),
    'ja': require('./json/ja.json'),
    'nl': require('./json/nl.json'),
    'pl': require('./json/pl.json'),
    'pt-BR': require('./json/pt-BR.json'),
    'sv': require('./json/sv.json'),
    'th': require('./json/th.json'),
    'tr': require('./json/tr.json'),
    'vi': require('./json/vi.json'),
    'zh-Hant': require('./json/zh-Hant.json'),
    'zsm': require('./json/zsm.json')
  });

  module.exports = i18n;

  },{"../../../libs/spotify-i18n":562,"./json/cs.json":2,"./json/de.json":3,"./json/el.json":4,"./json/en.json":5,"./json/es-419.json":6,"./json/es.json":7,"./json/fi.json":8,"./json/fr-CA.json":9,"./json/fr.json":10,"./json/hu.json":11,"./json/id.json":12,"./json/it.json":13,"./json/ja.json":14,"./json/nl.json":15,"./json/pl.json":16,"./json/pt-BR.json":17,"./json/sv.json":18,"./json/th.json":19,"./json/tr.json":20,"./json/vi.json":21,"./json/zh-Hant.json":22,"./json/zsm.json":23}],2:[function(require,module,exports){
  module.exports={
    "Artist": "Umělec",
    "Title": "Název",
    "Name": "Jméno",
    "RecentlyAdded": "Nedávno přidané",
    "FullAlbumsOnly": "Pouze uložená alba",
    "Filter": "Filtr",
    "LoadingError": "Sbírku Tvoje knihovna teď není možné načíst.<br /> Zkus to prosím o něco později.",
    "ErrorTitle": "Chyba",
    "ErrorMessage": "Sbírku Tvoje knihovna se nepodařilo načíst.",
    "ErrorEscapeMessage": "Znovu načíst",
    "NoSongsSaved": "Žádné skladby nebyly uloženy!",
    "DateAdded": "Datum přidání",
    "SortedByLabel": "Seřazeno podle {0}",
    "GoToBrowse": "Procházet",
    "Following": "Sleduješ",
  }
  },{}],3:[function(require,module,exports){
  module.exports={
    "Artist": "Künstler",
    "Title": "Titel",
    "Name": "Name",
    "RecentlyAdded": "Kürzlich hinzugefügt",
    "FullAlbumsOnly": "Nur gespeicherte Alben",
    "Filter": "Filter",
    "LoadingError": "Deine Bibliothek kann gerade nicht geladen werden.<br /> Versuche es später noch einmal.",
    "ErrorTitle": "Fehler",
    "ErrorMessage": "Deine Bibliothek wurde nicht geladen",
    "ErrorEscapeMessage": "Neu laden",
    "NoSongsSaved": "Keine Songs gespeichert!",
    "DateAdded": "Datum hinzugefügt",
    "SortedByLabel": "Sortiert nach {0}",
    "GoToBrowse": "Zu 'Browse' wechseln",
    "Following": "Folge ich",
  }
  },{}],4:[function(require,module,exports){
  module.exports={
    "Artist": "Καλλιτέχνης",
    "Title": "Τίτλος",
    "Name": "Όνομα",
    "RecentlyAdded": "Πρόσφατες προσθήκες",
    "FullAlbumsOnly": "Μόνο αποθηκευμένα άλμπουμ",
    "Filter": "Φίλτρο",
    "LoadingError": "Δεν είναι δυνατή η φόρτωση της Βιβλιοθήκης αυτή τη στιγμή.<br /> Δοκίμασε ξανά σε λίγο.",
    "ErrorTitle": "Σφάλμα",
    "ErrorMessage": "Η φόρτωση της Βιβλιοθήκης απέτυχε",
    "ErrorEscapeMessage": "Επανάληψη φόρτωσης",
    "NoSongsSaved": "Δεν υπάρχουν αποθηκευμένα τραγούδια!",
    "DateAdded": "Προστέθηκε ημερομηνία",
    "SortedByLabel": "Ταξινόμηση κατά {0}",
    "GoToBrowse": "Μετάβαση στην Περιήγηση",
    "Following": "Aκολουθείται",
  }
  },{}],5:[function(require,module,exports){
  module.exports={
    "Artist": "Artist",
    "Title": "Title",
    "Name": "Name",
    "RecentlyAdded": "Recently Added",
    "FullAlbumsOnly": "Saved Albums Only",
    "Filter": "Filter",
    "LoadingError": "Your Library can't load right now.<br /> Please try again soon.",
    "ErrorTitle": "Error",
    "ErrorMessage": "Your Library failed to load",
    "ErrorEscapeMessage": "Reload",
    "NoSongsSaved": "No songs saved!",
    "DateAdded": "Date Added",
    "SortedByLabel": "Sorted by {0}",
    "GoToBrowse": "Go to Browse",
    "Following": "Following",
  }
  },{}],6:[function(require,module,exports){
  module.exports={
    "Artist": "Artista",
    "Title": "Título",
    "Name": "Nombre",
    "RecentlyAdded": "Agregados recientemente",
    "FullAlbumsOnly": "Solo álbumes guardados",
    "Filter": "Filtrar",
    "LoadingError": "Tu Biblioteca no se puede cargar por el momento.<br />Inténtalo de nuevo más tarde.",
    "ErrorTitle": "Error",
    "ErrorMessage": "No fue posible cargar Tu Biblioteca.",
    "ErrorEscapeMessage": "Volver a cargar",
    "NoSongsSaved": "¡No se ha guardado ninguna canción!",
    "DateAdded": "Fecha agregada",
    "SortedByLabel": "Clasificados por {0}",
    "GoToBrowse": "Ir a Explorar",
    "Following": "Siguiendo",
  }
  },{}],7:[function(require,module,exports){
  module.exports={
    "Artist": "Artista",
    "Title": "Título",
    "Name": "Nombre",
    "RecentlyAdded": "Añadidos recientemente",
    "FullAlbumsOnly": "Solo álbumes guardados",
    "Filter": "Filtrar",
    "LoadingError": "No es posible cargar Tu biblioteca en este momento.<br /> Por favor, vuelve a intentarlo dentro de un rato.",
    "ErrorTitle": "Error",
    "ErrorMessage": "No se ha podido cargar Tu biblioteca",
    "ErrorEscapeMessage": "Volver a cargar",
    "NoSongsSaved": "¡No se ha guardado ninguna canción!",
    "DateAdded": "Fecha en la que se añadió",
    "SortedByLabel": "Ordenar según {0}",
    "GoToBrowse": "Ir a Explorar",
    "Following": "Siguiendo",
  }
  },{}],8:[function(require,module,exports){
  module.exports={
    "Artist": "Artisti",
    "Title": "Nimi",
    "Name": "Nimi",
    "RecentlyAdded": "Äskettäin lisätyt",
    "FullAlbumsOnly": "Vain tallennetut albumit",
    "Filter": "Suodatin",
    "LoadingError": "Omaa kirjastoa ei voi juuri nyt ladata.<br /> Yritä hetken kuluttua uudelleen.",
    "ErrorTitle": "Virhe",
    "ErrorMessage": "Oman kirjaston lataus epäonnistui",
    "ErrorEscapeMessage": "Lataa uudelleen",
    "NoSongsSaved": "Ei tallennettuja kappaleita!",
    "DateAdded": "Lisäyspäivä",
    "SortedByLabel": "Lajitteluperuste {0}",
    "GoToBrowse": "Siirry Browse-toimintoon",
    "Following": "Seurataan",
  }
  },{}],9:[function(require,module,exports){
  module.exports={
    "Artist": "Artiste",
    "Title": "Titre",
    "Name": "Nom",
    "RecentlyAdded": "Ajoutés récemment",
    "FullAlbumsOnly": "Albums enregistrés uniquement",
    "Filter": "Filtrer",
    "LoadingError": "Impossible de charger votre Bibliothèque pour l'instant.<br /> Veuillez réessayer plus tard.",
    "ErrorTitle": "Erreur",
    "ErrorMessage": "Échec du chargement de votre Bibliothèque.",
    "ErrorEscapeMessage": "Recharger",
    "NoSongsSaved": "Aucune chanson enregistrée!",
    "DateAdded": "Ajouté le",
    "SortedByLabel": "Trié par {0}",
    "GoToBrowse": "Aller à Parcourir",
    "Following": "Suivis",
  }
  },{}],10:[function(require,module,exports){
  module.exports={
    "Artist": "Artiste",
    "Title": "Titre",
    "Name": "Nom",
    "RecentlyAdded": "Ajoutés récemment",
    "FullAlbumsOnly": "Albums sauvegardés uniquement",
    "Filter": "Filtre",
    "LoadingError": "Impossible de charger Bibliothèque pour le moment.<br />Veuillez réessayer plus tard.",
    "ErrorTitle": "Erreur",
    "ErrorMessage": "Impossible de charger Bibliothèque",
    "ErrorEscapeMessage": "Recharger",
    "NoSongsSaved": "Aucun titre sauvegardé !",
    "DateAdded": "Ajouté le",
    "SortedByLabel": "Tri par {0}",
    "GoToBrowse": "Aller à Parcourir",
    "Following": "Abonné",
  }
  },{}],11:[function(require,module,exports){
  module.exports={
    "Artist": "Előadó",
    "Title": "Cím",
    "Name": "Név",
    "RecentlyAdded": "Mostanában hozzáadott",
    "FullAlbumsOnly": "Csak a mentett albumok",
    "Filter": "Szűrő",
    "LoadingError": "A Gyűjteményed jelenleg nem tölthető be.<br /> Próbálkozz újra kicsit később.",
    "ErrorTitle": "Hiba",
    "ErrorMessage": "Nem sikerült betölteni a Gyűjteményed",
    "ErrorEscapeMessage": "Újratöltés",
    "NoSongsSaved": "Nincs mentett szám.",
    "DateAdded": "Dátum hozzáadva",
    "SortedByLabel": "{0} alapján kiválasztva",
    "GoToBrowse": "Böngészés lap megnyitása",
    "Following": "Követések",
  }
  },{}],12:[function(require,module,exports){
  module.exports={
    "Artist": "Artis",
    "Title": "Judul",
    "Name": "Nama",
    "RecentlyAdded": "Baru Dimuat",
    "FullAlbumsOnly": "Hanya Album Tersimpan",
    "Filter": "Filter",
    "LoadingError": "Koleksi Kamu tidak dapat dimuat saat ini.<br />Coba lagi segera.",
    "ErrorTitle": "Kesalahan",
    "ErrorMessage": "Koleksi Kamu gagal dimuat",
    "ErrorEscapeMessage": "Muat ulang",
    "NoSongsSaved": "Tidak ada lagu yang tersimpan!",
    "DateAdded": "Tanggal Dimuat",
    "SortedByLabel": "Disortir menurut {0}",
    "GoToBrowse": "Ke Browse",
    "Following": "Mengikuti",
  }
  },{}],13:[function(require,module,exports){
  module.exports={
    "Artist": "Artista",
    "Title": "Titolo",
    "Name": "Nome",
    "RecentlyAdded": "Aggiunti di recente",
    "FullAlbumsOnly": "Solo album salvati",
    "Filter": "Filtra",
    "LoadingError": "Impossibile caricare La tua libreria ora.<br /> Riprova più tardi.",
    "ErrorTitle": "Errore",
    "ErrorMessage": "Caricamento di La tua libreria non riuscito",
    "ErrorEscapeMessage": "Ricarica",
    "NoSongsSaved": "Nessun brano salvato.",
    "DateAdded": "Aggiunto il",
    "SortedByLabel": "Ordinati per {0}",
    "GoToBrowse": "Vai a Naviga",
    "Following": "Following",
  }
  },{}],14:[function(require,module,exports){
  module.exports={
    "Artist": "アーティスト",
    "Title": "タイトル",
    "Name": "名前",
    "RecentlyAdded": "最近追加した曲",
    "FullAlbumsOnly": "保存したアルバムのみ",
    "Filter": "フィルター",
    "LoadingError": "My Musicは現在ロードできません。<br />しばらくしてから再試行してください。",
    "ErrorTitle": "エラー",
    "ErrorMessage": "My Musicのロードに失敗しました。",
    "ErrorEscapeMessage": "リロード",
    "NoSongsSaved": "保存した曲がありません。",
    "DateAdded": "追加日",
    "SortedByLabel": "表示順: {0}",
    "GoToBrowse": "Browseに進む",
    "Following": "フォロー中",
  }
  },{}],15:[function(require,module,exports){
  module.exports={
    "Artist": "Artiest",
    "Title": "Titel",
    "Name": "Naam",
    "RecentlyAdded": "Onlangs toegevoegd",
    "FullAlbumsOnly": "Alleen opgeslagen albums",
    "Filter": "Filter",
    "LoadingError": "Je Bibliotheek kan nu niet worden geladen. <br /> Probeer het zo nog eens.",
    "ErrorTitle": "Fout",
    "ErrorMessage": "Kon je Bibliotheek niet laden",
    "ErrorEscapeMessage": "Opnieuw laden",
    "NoSongsSaved": "Geen opgeslagen nummers!",
    "DateAdded": "Datum toegevoegd",
    "SortedByLabel": "Gesorteerd op {0}",
    "GoToBrowse": "Ga naar Bladeren.",
    "Following": "Volgend",
  }
  },{}],16:[function(require,module,exports){
  module.exports={
    "Artist": "Wykonawca",
    "Title": "Tytuł",
    "Name": "Nazwa",
    "RecentlyAdded": "Ostatnio dodane",
    "FullAlbumsOnly": "Tylko zapisane albumy",
    "Filter": "Filtruj",
    "LoadingError": "Nie można obecnie załadować kolekcji Biblioteka.<br /> Spróbuj ponownie później.",
    "ErrorTitle": "Błąd",
    "ErrorMessage": "Załadowanie kolekcji Biblioteka nie powiodło się",
    "ErrorEscapeMessage": "Załaduj ponownie",
    "NoSongsSaved": "Brak zapisanych utworów!",
    "DateAdded": "Data dodania",
    "SortedByLabel": "Posortowano wg {0}",
    "GoToBrowse": "Przejdź do katalogu przeglądania",
    "Following": "Obserwujesz",
  }
  },{}],17:[function(require,module,exports){
  module.exports={
    "Artist": "Artista",
    "Title": "Título",
    "Name": "Nome",
    "RecentlyAdded": "Adicionados recentemente",
    "FullAlbumsOnly": "Apenas álbuns salvos",
    "Filter": "Filtrar",
    "LoadingError": "Não é possível carregar a Sua Biblioteca no momento.<br /> Tente de novo daqui a pouco.",
    "ErrorTitle": "Erro",
    "ErrorMessage": "Falha ao carregar a Sua Biblioteca",
    "ErrorEscapeMessage": "Recarregar",
    "NoSongsSaved": "Nenhuma música salva!",
    "DateAdded": "Adicionado em",
    "SortedByLabel": "Classificado por {0}",
    "GoToBrowse": "Ir para Navegar",
    "Following": "Seguindo",
  }
  },{}],18:[function(require,module,exports){
  module.exports={
    "Artist": "Artist",
    "Title": "Titel",
    "Name": "Namn",
    "RecentlyAdded": "Senast tillagd",
    "FullAlbumsOnly": "Endast sparade album",
    "Filter": "Filtrera",
    "LoadingError": "Det går inte att läsa in Ditt bibliotek just nu.<br />Försök igen om en liten stund.",
    "ErrorTitle": "Fel",
    "ErrorMessage": "Det gick inte att läsa in Ditt bibliotek",
    "ErrorEscapeMessage": "Läs in igen",
    "NoSongsSaved": "Inga låtar har sparats!",
    "DateAdded": "Tillagd",
    "SortedByLabel": "Sorterade efter {0}",
    "GoToBrowse": "Gå till Utforska",
    "Following": "Följer",
  }
  },{}],19:[function(require,module,exports){
  module.exports={
    "Artist": "ศิลปิน",
    "Title": "ชื่อ",
    "Name": "ชื่อ",
    "RecentlyAdded": "เพิ่มล่าสุด",
    "FullAlbumsOnly": "เฉพาะอัลบั้มที่บันทึกไว้",
    "Filter": "ตัวกรอง",
    "LoadingError": "ไม่สามารถโหลดคอลเลกชันของคุณได้ในขณะนี้<br /> โปรดรอสักครู่แล้วลองใหม่อีกครั้ง",
    "ErrorTitle": "ผิดพลาด",
    "ErrorMessage": "โหลดคอลเลกชันของคุณไม่สำเร็จ",
    "ErrorEscapeMessage": "โหลดใหม่",
    "NoSongsSaved": "ไม่มีเพลงที่บันทึก!",
    "DateAdded": "วันที่เพิ่ม",
    "SortedByLabel": "เรียงตาม {0}",
    "GoToBrowse": "ไปที่หน้ารายการ",
    "Following": "กำลังติดตาม",
  }
  },{}],20:[function(require,module,exports){
  module.exports={
    "Artist": "Sanatçı",
    "Title": "Başlık",
    "Name": "Adı",
    "RecentlyAdded": "Yeni Eklenenler",
    "FullAlbumsOnly": "Yalnızca Kaydedilmiş Albümler",
    "Filter": "Filtrele",
    "LoadingError": "Kitaplığın şu anda yüklenemiyor.<br />Lütfen birazdan tekrar dene.",
    "ErrorTitle": "Hata",
    "ErrorMessage": "Kitaplığın yüklenemedi",
    "ErrorEscapeMessage": "Tekrar yükle",
    "NoSongsSaved": "Kayıtlı şarkı yok!",
    "DateAdded": "Tarih Eklendi",
    "SortedByLabel": "{0} olarak sıralandı",
    "GoToBrowse": "Gözat'a Git",
    "Following": "Takip Ediliyor",
  }
  },{}],21:[function(require,module,exports){
  module.exports={
    "Artist": "Nghệ sĩ",
    "Title": "Tiêu đề",
    "Name": "Tên",
    "RecentlyAdded": "Mới thêm Gần đây",
    "FullAlbumsOnly": "Chỉ các Album đã lưu",
    "Filter": "Bộ lọc",
    "LoadingError": "Thư viện của bạn không thể tải ngay bây giờ.<br /> Vui lòng thử lại sau.",
    "ErrorTitle": "Lỗi",
    "ErrorMessage": "Thư viện của bạn không thể tải",
    "ErrorEscapeMessage": "Tải lại",
    "NoSongsSaved": "Không có bài hát nào đã được lưu!",
    "DateAdded": "Đã Thêm Ngày",
    "SortedByLabel": "Sắp xếp theo {0}",
    "GoToBrowse": "Đi tới Duyệt tìm",
    "Following": "Đang theo dõi",
  }
  },{}],22:[function(require,module,exports){
  module.exports={
    "Artist": "藝人",
    "Title": "標題",
    "Name": "名稱",
    "RecentlyAdded": "最近新增",
    "FullAlbumsOnly": "僅顯示儲存的專輯",
    "Filter": "篩選",
    "LoadingError": "目前無法載入你的音樂庫。<br/> 請稍後再試一次。",
    "ErrorTitle": "錯誤",
    "ErrorMessage": "無法載入你的音樂庫",
    "ErrorEscapeMessage": "重新載入",
    "NoSongsSaved": "沒有已儲存的歌曲！",
    "DateAdded": "已加入日期",
    "SortedByLabel": "依 {0} 排序",
    "GoToBrowse": "前往瀏覽",
    "Following": "正在關注",
  }
  },{}],23:[function(require,module,exports){
  module.exports={
    "Artist": "Artis",
    "Title": "Tajuk",
    "Name": "Nama",
    "RecentlyAdded": "Baru-baru ini ditambah",
    "FullAlbumsOnly": "Album Disimpan Sahaja",
    "Filter": "Penapis",
    "LoadingError": "Pustaka Anda tidak dapat dimuatkan sekarang.<br /> Sila cuba lagi kemudian.",
    "ErrorTitle": "Ralat",
    "ErrorMessage": "Pustaka Anda gagal untuk dimuatkan",
    "ErrorEscapeMessage": "Muatkan semula",
    "NoSongsSaved": "Tiada lagu disimpan!",
    "DateAdded": "Tarikh Ditambah",
    "SortedByLabel": "Susun ikut {0}",
    "GoToBrowse": "Pergi ke Semak imbas",
    "Following": "Mengikuti",
  }
  },{}],24:[function(require,module,exports){
  (function (global){
  'use strict';
  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _reactDom = require('react-dom');

  var _reactDom2 = _interopRequireDefault(_reactDom);

  var _reactRedux = require('react-redux');

  var _actions = require('./src/actions');

  var _actions2 = _interopRequireDefault(_actions);

  var _store = require('./src/store');

  var _store2 = _interopRequireDefault(_store);

  var _App = require('./src/components/App');

  var _App2 = _interopRequireDefault(_App);

  var _spotifyHandlebars = require('../../libs/spotify-handlebars');

  var _spotifyHandlebars2 = _interopRequireDefault(_spotifyHandlebars);

  var _helpers = require('../../libs/spotify-handlebars/helpers');

  var _helpers2 = _interopRequireDefault(_helpers);

  var _liveModels = require('../../libs/live-models');

  var _liveModels2 = _interopRequireDefault(_liveModels);

  var _spotifyEvents = require('../../libs/spotify-events');

  var _spotifyEvents2 = _interopRequireDefault(_spotifyEvents);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  _spotifyHandlebars2.default.register(_helpers2.default);

  _liveModels2.default.register();
  _spotifyEvents2.default.attach();

  _reactDom2.default.render(_react2.default.createElement(
    _reactRedux.Provider,
    { store: _store2.default },
    _react2.default.createElement(_App2.default, null)
  ), document.getElementById('root'));

  _store2.default.dispatch(_actions2.default.startApp());

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../libs/glue/strings":163,"../../libs/live-models":376,"../../libs/spotify-events":510,"../../libs/spotify-handlebars":559,"../../libs/spotify-handlebars/helpers":549,"./src/actions":27,"./src/components/App":28,"./src/store":45,"react":1253,"react-dom":1157,"react-redux":1169}],25:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const START_APP = exports.START_APP = 'START_APP';
  const ACTIVATE_APP = exports.ACTIVATE_APP = 'ACTIVATE_APP';
  const DEACTIVATE_APP = exports.DEACTIVATE_APP = 'DEACTIVATE_APP';
  const GO_ONLINE = exports.GO_ONLINE = 'GO_ONLINE';
  const GO_OFFLINE = exports.GO_OFFLINE = 'GO_OFFLINE';
  const INITIALIZE_URI = exports.INITIALIZE_URI = 'INITIALIZE_URI';
  const CHANGE_URI = exports.CHANGE_URI = 'CHANGE_URI';
  const WATCH_ACTIVE_STATUS = exports.WATCH_ACTIVE_STATUS = 'WATCH_ACTIVE_STATUS';
  const WATCH_APP_URI = exports.WATCH_APP_URI = 'WATCH_APP_URI';

  const startApp = exports.startApp = () => ({
    type: START_APP
  });

  const activateApp = exports.activateApp = () => ({
    type: ACTIVATE_APP
  });

  const deactivateApp = exports.deactivateApp = () => ({
    type: DEACTIVATE_APP
  });

  const goOnline = exports.goOnline = () => ({
    type: GO_ONLINE
  });

  const goOffline = exports.goOffline = () => ({
    type: GO_OFFLINE
  });

  const initializeUri = exports.initializeUri = uri => ({
    type: INITIALIZE_URI,
    uri
  });

  const changeUri = exports.changeUri = uri => ({
    type: CHANGE_URI,
    uri
  });

  const watchActiveStatus = exports.watchActiveStatus = () => ({
    type: WATCH_ACTIVE_STATUS
  });

  const watchAppUri = exports.watchAppUri = () => ({
    type: WATCH_APP_URI
  });

  },{}],26:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const UPDATE = exports.UPDATE = 'UPDATE';
  const CHANGE_CATEGORY = exports.CHANGE_CATEGORY = 'CHANGE_CATEGORY';
  const CHANGE_TEXT_FILTER = exports.CHANGE_TEXT_FILTER = 'CHANGE_TEXT_FILTER';
  const STORE_SCROLL_POSITION = exports.STORE_SCROLL_POSITION = 'STORE_SCROLL_POSITION';
  const RESTORE_SCROLL_POSITION = exports.RESTORE_SCROLL_POSITION = 'RESTORE_SCROLL_POSITION';
  const UPDATE_COLLECTION_ITEMS = exports.UPDATE_COLLECTION_ITEMS = 'UPDATE_COLLECTION_ITEMS';

  const updateBookmark = exports.updateBookmark = () => ({
    type: UPDATE
  });

  const changeTextFilter = exports.changeTextFilter = value => ({
    type: CHANGE_TEXT_FILTER,
    value
  });

  const changeCategory = exports.changeCategory = sortOrder => ({
    type: CHANGE_CATEGORY,
    sortOrder
  });

  const restoreScrollPosition = exports.restoreScrollPosition = scrollPosition => ({
    type: RESTORE_SCROLL_POSITION,
    scrollPosition
  });

  const storeScrollPosition = exports.storeScrollPosition = scrollPosition => ({
    type: STORE_SCROLL_POSITION,
    scrollPosition
  });

  const updateCollectionItems = exports.updateCollectionItems = (items, previousActionType) => ({
    type: UPDATE_COLLECTION_ITEMS,
    items,
    previousActionType
  });

  },{}],27:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _app = require('./app');

  var app = _interopRequireWildcard(_app);

  var _collection = require('./collection');

  var collection = _interopRequireWildcard(_collection);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  exports.default = _extends({}, app, collection);

  },{"./app":25,"./collection":26}],28:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.App = undefined;

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _reactRedux = require('react-redux');

  var _collection = require('../reducers/collection');

  var _Header = require('./Header');

  var _Header2 = _interopRequireDefault(_Header);

  var _Content = require('./Content');

  var _Content2 = _interopRequireDefault(_Content);

  var _Filter = require('./Filter');

  var _Filter2 = _interopRequireDefault(_Filter);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  // APPBOOK App init behaviour
  class App extends _react2.default.Component {
    renderCollection() {
      return [_react2.default.createElement(
        'div',
        { key: 'key_App__header', className: 'App__header' },
        _react2.default.createElement(_Header2.default, { view: this.props.view })
      ), _react2.default.createElement(_Filter2.default, { key: 'Filter' }), _react2.default.createElement(
        'div',
        { key: 'key_App__content', className: 'App__content' },
        _react2.default.createElement(_Content2.default, null)
      )];
    }

    render() {
      if (this.props.isLoading) {
        return null;
      }

      return _react2.default.createElement(
        'div',
        {
          className: 'App',
          'data-uri': "spotify:app:bookmark",
          'data-play-source': 'bookmark'
        },
        this.renderCollection()
      );
    }
  }

  exports.App = App;
  App.propTypes = {
    isEmpty: _propTypes2.default.bool,
    isLoading: _propTypes2.default.bool,
  };

  const mapStateToProps = state => {
    return {
      isEmpty: (0, _collection.isEmpty)(state.collection),
      isLoading: (0, _collection.isLoading)(state.collection),
    };
  };

  App.defaultProps = {
    isEmpty: false
  };

  exports.default = (0, _reactRedux.connect)(mapStateToProps)(App);

  },{"../reducers/collection":43,"./Content":30,"./Filter":32,"./Header":33,"prop-types":827,"react":1253,"react-redux":1169}],29:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _reactDom = require('react-dom');

  var _reactDom2 = _interopRequireDefault(_reactDom);

  var _player = require('../../../../libs/spotify-events/player');

  var _player2 = _interopRequireDefault(_player);

  var _item = require("list_item");

  var _item2 = _interopRequireDefault(_item);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  class CollectionCard extends _react2.default.PureComponent {
    componentDidMount() {
      this.updatePlayerEvents();
    }

    componentDidUpdate() {
      this.updatePlayerEvents();
    }

    updatePlayerEvents() {
      const node = _reactDom2.default.findDOMNode(this);
      if (node) _player2.default.update(node);
    }

    formatTime(e){
      const t = e < 0;
      let n = Math.floor(Math.abs(e)/1e3);
      let a = Math.floor(n/60);
      return(n%=60)<10&&(n=`0${n}`),t&&(a=`-${a}`),[a,n].join(":")
    }

    render() {
      const { item } = this.props;
      item.targetUri = item.uri;
      if (!item.imageUrl) {
        item.noImage = true;
      }

      if (item.time !== undefined) {
        item.timeFormatted = this.formatTime(item.time);
      }

      item.removeButton = true;
      item.removeButtonTooltip = "Remove from bookmark";

      return _react2.default.createElement('div', {
        dangerouslySetInnerHTML: { __html: (0, _item2.default)(item) }
      });
    }
  }

  exports.default = CollectionCard;
  CollectionCard.propTypes = {
    item: _propTypes2.default.object,
    view: _propTypes2.default.string
  };

  },{"list_item": 166,"../../../../libs/glue/templates/cards/card.hbs":168,"../../../../libs/spotify-events/player":518,"prop-types":827,"react":1253,"react-dom":1157}],30:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Content = undefined;

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _reactRedux = require('react-redux');

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  var _collection = require('../reducers/collection');

  var _CollectionCard = require('./CollectionCard');

  var _CollectionCard2 = _interopRequireDefault(_CollectionCard);

  var _Sort = require('./Sort');

  var _Sort2 = _interopRequireDefault(_Sort);

  var _GlueResponsiveVirtualGrid = require('../../../../libs/glue/components/GlueResponsiveVirtualGrid');

  var _GlueResponsiveVirtualGrid2 = _interopRequireDefault(_GlueResponsiveVirtualGrid);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// APPBOOK Content
  class Content extends _react2.default.Component {
    render() {
      const { view, items } = this.props;
      return _react2.default.createElement(
        'div',
        { className: 'Content container', 'data-ta-id': `${view}-ul` },
        _react2.default.createElement(
          'div',
          { className: 'section-divider' },
          _react2.default.createElement(_Sort2.default, { view: view }),
        ),
        !this.props.isLoading && _react2.default.createElement(_GlueResponsiveVirtualGrid2.default, {
          items: items,
          renderItem: item => _react2.default.createElement(_CollectionCard2.default, { item: item, view: view }),
          onScrollEnded: () => this.props.storeScrollPosition(window.scrollY)
        })
      );
    }
  }

  exports.Content = Content;
  Content.propTypes = {
    isLoading: _propTypes2.default.bool,
    items: _propTypes2.default.array,
    view: _propTypes2.default.string,
    storeScrollPosition: _propTypes2.default.func
  };

  const mapStateToProps = state => ({
    items: (0, _collection.getItems)(state.collection),
    isLoading: (0, _collection.isLoading)(state.collection),
    view: state.app.sectionId
  });

  const mapDispatchToProps = dispatch => ({
    storeScrollPosition: y => dispatch(_actions2.default.storeScrollPosition(y))
  });

  exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Content);

  },{"../../../../libs/glue/components/GlueResponsiveVirtualGrid":135,"../actions":27,"../reducers/collection":43,"./CollectionCard":29,"./Sort":35,"prop-types":827,"react":1253,"react-redux":1169}],32:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _searchBar = require('../../../../libs/glue/templates/header/search-bar.hbs');

  var _searchBar2 = _interopRequireDefault(_searchBar);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  class Filter extends _react2.default.Component {
    shouldComponentUpdate() {
      return false;
    }

    render() {
      return _react2.default.createElement('div', { dangerouslySetInnerHTML: { __html: (0, _searchBar2.default)() } });
    }
  }
  exports.default = Filter;

  },{"../../../../libs/glue/templates/header/search-bar.hbs":180,"react":1253}],33:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _pageHeader = require('../../../../libs/glue/templates/headers/page-header.hbs');

  var _pageHeader2 = _interopRequireDefault(_pageHeader);

  var _i18n = require('../../i18n');

  var _i18n2 = _interopRequireDefault(_i18n);

  var _spotifyEvents = require('../../../../libs/spotify-events');

  var _spotifyEvents2 = _interopRequireDefault(_spotifyEvents);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// APPBOOK HEADER
  class Header extends _react2.default.Component {
    render() {
      const title = "Bookmark";

      return _react2.default.createElement('div', {
        className: 'Header',
        dangerouslySetInnerHTML: {
          __html: (0, _pageHeader2.default)({ background: { type: 'color' }, title })
        },
        ref: container => _spotifyEvents2.default.update(container)
      });
    }
  }

  exports.default = Header;
  Header.propTypes = {
    view: _propTypes2.default.string
  };

  },{"../../../../libs/glue/templates/headers/page-header.hbs":194,"../../../../libs/spotify-events":510,"../../i18n":1,"prop-types":827,"react":1253}],34:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SavedAlbumsToggle = undefined;

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  var _reactRedux = require('react-redux');

  var _i18n = require('../../i18n');

  var _i18n2 = _interopRequireDefault(_i18n);

  var _GlueToggle = require('../../../../libs/glue/components/GlueToggle');

  var _GlueToggle2 = _interopRequireDefault(_GlueToggle);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  class SavedAlbumsToggle extends _react2.default.Component {
    render() {
      const id = 'saved-albums-toggle';
      return _react2.default.createElement(
        'div',
        {
          className: 'section-auxiliary',
          'data-ta-id': 'saved-albums-only-filter-wrapper'
        },
        _react2.default.createElement(
          'label',
          { htmlFor: id },
          _i18n2.default.get('FullAlbumsOnly')
        ),
        _react2.default.createElement(_GlueToggle2.default, {
          labelId: id,
          isActive: this.props.savedAlbumsOnly,
          onChange: value => this.props.onChange(value)
        })
      );
    }
  }

  exports.SavedAlbumsToggle = SavedAlbumsToggle;
  SavedAlbumsToggle.propTypes = {
    onChange: _propTypes2.default.func,
    savedAlbumsOnly: _propTypes2.default.bool
  };

  const mapStateToProps = state => ({});

  const mapDispatchToProps = dispatch => ({});

  exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(SavedAlbumsToggle);

  },{"../../../../libs/glue/components/GlueToggle":136,"../../i18n":1,"../actions":27,"prop-types":827,"react":1253,"react-redux":1169}],35:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Sort = undefined;

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _reactRedux = require('react-redux');

  var _i18n = require('../../i18n');

  var _i18n2 = _interopRequireDefault(_i18n);

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  var _cosmos = require('../middlewares/cosmos');

  var _GlueDropdown = require('../../../../libs/glue/components/GlueDropdown');

  var _GlueDropdown2 = _interopRequireDefault(_GlueDropdown);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  class Sort extends _react2.default.Component {
    getOptions() {
      return [
        { label: "All", value: _cosmos.CAT_ALL },
        { label: "Page", value: _cosmos.CAT_PAGE },
        { label: "Track", value: _cosmos.CAT_TRACK },
        { label: "Track with time", value: _cosmos.CAT_TRACK_TIME }
      ];
    }

    render() {
      const id = `sort-${this.props.view}`;
      return _react2.default.createElement(
        'div',
        { 'data-ta-id': 'sorting-wrapper' },
        _react2.default.createElement(
          'label',
          { htmlFor: id },
          _i18n2.default.get('SortedByLabel', '')
        ),
        _react2.default.createElement(_GlueDropdown2.default, {
          options: this.getOptions(),
          value: this.props.sortOrder,
          onChange: this.props.onChange,
          labelId: id
        }),
      );
    }
  }

  exports.Sort = Sort;
  Sort.propTypes = {
    view: _propTypes2.default.string,
    sortOrder: _propTypes2.default.string,
    onChange: _propTypes2.default.func,
  };

  const mapStateToProps = state => ({
    view: state.app.sectionId,
    sortOrder: state.collection.sortOrder,
  });

  const mapDispatchToProps = dispatch => ({
    onChange: sortOrder => dispatch(_actions2.default.changeCategory(sortOrder)),
  });

  exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(Sort);

  },{"../../../../libs/glue/components/GlueDropdown":133,"../../i18n":1,"../actions":27,"../middlewares/cosmos":38,"prop-types":827,"react":1253,"react-redux":1169}],37:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  var _live = require('../../../../libs/live');

  var _live2 = _interopRequireDefault(_live);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = store => next => action => {
    const result = next(action);

    switch (action.type) {
      case _actions2.default.INITIALIZE_URI:
      case _actions2.default.CHANGE_URI:
        window.parent.postMessage({
          type: 'notify_ready',
          pageId: 'bookmark'
        }, '*');
        break;

      case _actions2.default.START_APP:
        store.dispatch(_actions2.default.watchActiveStatus());
        store.dispatch(_actions2.default.watchAppUri());
        // Don't add your app's own startup things here. Instead, create your own
        // middleware that listens for START_APP actions and kicks off its startup
        // there. If you need to wait until basic info about the app's state is
        // ready, such as the current URI, then listen for INITIALIZE_URI actions
        // instead of START_APP.
        break;

      case _actions2.default.WATCH_ACTIVE_STATUS:
        window.addEventListener('message', ({ data }) => {
          if (data && data.name === 'set_active') {
            if (data.active) {
              // zlink has reactivated the app's iframe, meaning the user has
              // navigated back to the app after previously navigating away
              // to a different one
              store.dispatch(_actions2.default.activateApp());
            } else {
              // zlink has deactivated the the app's iframe, meaning the user
              // has left the app for now and our iframe is being hidden
              store.dispatch(_actions2.default.deactivateApp());
            }
          }
        });
        break;

      case _actions2.default.WATCH_APP_URI:
        (0, _live2.default)('spotify:application').on('update', ({ state }) => {
          if (!state) {
            // sometimes the application live model updates but doesn't contain a
            // state property, in which case there is nothing to do here
            return;
          }
          const uri = state.getURI();
          if (store.getState().app.uri === uri) {
            // if the URI in the application live model update isn't different from
            // the URI currently in the store then there's nothing to do here
            return;
          }
          if (store.getState().app.uri === undefined) {
            store.dispatch(_actions2.default.initializeUri(uri));
          } else {
            store.dispatch(_actions2.default.changeUri(uri));
          }
        });
        break;

      default:
        break;
    }

    return result;
  };

  },{"../../../../libs/live":413,"../actions":27}],38:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CAT_PAGE = exports.CAT_TRACK = exports.CAT_TRACK_TIME = undefined;

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  var _localStorage = require("localStorage");

  const CAT_ALL = exports.CAT_ALL = "CAT_ALL";
  const CAT_PAGE = exports.CAT_PAGE = "CAT_PAGE";
  const CAT_TRACK = exports.CAT_TRACK = "CAT_TRACK";
  const CAT_TRACK_TIME = exports.CAT_TRACK_TIME = "CAT_TRACK_TIME";

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // APPBOOK Fetch
  function getItems() {
    _localStorage.useZlink(true)
    const resultRaw = _localStorage.get("bookmark_spicetify");
    _localStorage.useZlink(false)
    if (resultRaw) {
      const resultsList = JSON.parse(resultRaw);
      return resultsList;
    }
    return [];
  }

  function matchUriType(uri, types) {
    const type = uri.split(":")[1];
    return types.some(t => t === type);
  }

  exports.default = store => next => action => {
    const result = next(action);
    const state = store.getState();

    switch (action.type) {
      case _actions2.default.INITIALIZE_URI:
      case _actions2.default.ACTIVATE_APP:
      case _actions2.default.CHANGE_URI:
      case _actions2.default.UPDATE:
      case _actions2.default.CHANGE_TEXT_FILTER:
      case _actions2.default.CHANGE_CATEGORY: {
        let items = getItems();

        switch (state.collection.sortOrder) {
          case CAT_PAGE:
            items = items.filter((item) => matchUriType(item.uri, ["app"]));
            break;
          case CAT_TRACK:
            items = items
              .filter((item) => matchUriType(item.uri, ["track", "episode", "local"]));
            break;
          case CAT_TRACK_TIME:
            items = items.filter((item) => item.time !== undefined);
            break;
        }

        if (state.collection.textFilter) {
          items = items.filter((item) => {
            /** @type {string[]} */
            const queryWords = state.collection.textFilter.split(" ")
              .map(w => w.toLocaleLowerCase());

            const titleWords = item.title.split(" ")
              .map(w => w.toLocaleLowerCase());

            return queryWords.every(q => titleWords.some(t => t.startsWith(q)))
          });
        }

        store.dispatch(_actions2.default.updateCollectionItems(items, action.type));
      }
      default:
        // Do nothing
    }

    return result;
  };

  },{"../actions":27, "localStorage":418}],39:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _center = require('../../../../libs/spotify-events/center');

  var _center2 = _interopRequireDefault(_center);

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // APPBOOK INITIALIZE_URI
  exports.default = store => next => action => {
    const result = next(action);

    switch (action.type) {
      case _actions2.default.INITIALIZE_URI:
        {
          _center2.default.on('filter-request', (uri, filter) => {
            store.dispatch(_actions2.default.changeTextFilter(filter));
          });
          _center2.default.on('bookmark-update', () => {
            store.dispatch(_actions2.default.updateBookmark());
          });
          document.addEventListener("bookmark-update", () => {
            store.dispatch(_actions2.default.updateBookmark());
          });
          break;
        }

      default:
      // do nothing
    }

    return result;
  };

  },{"../../../../libs/spotify-events/center":471,"../actions":27}],40:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const scrollKey = state => `${state.collection.username}-${state.app.sectionId}-scroll-top`;

  const sortKey = state => `${state.collection.username}-${state.app.sectionId}-sort`;

  const scrollRestoreWhitelist = [_actions2.default.INITIALIZE_URI, _actions2.default.CHANGE_URI];

  exports.default = store => next => action => {
    const result = next(action);

    switch (action.type) {
      case _actions2.default.INITIALIZE_URI:
      case _actions2.default.CHANGE_URI:
        {
          const state = store.getState();
          const sortOrder = localStorage.getItem(sortKey(state));

          if (sortOrder) {
            store.dispatch(_actions2.default.restoreSortOrder(sortOrder));
          }
          break;
        }

      case _actions2.default.UPDATE_COLLECTION_ITEMS:
        {
          const state = store.getState();
          if (scrollRestoreWhitelist.includes(action.previousActionType)) {
            const scrollPosition = localStorage.getItem(scrollKey(state));
            if (scrollPosition) {
              store.dispatch(_actions2.default.restoreScrollPosition(parseInt(scrollPosition, 10)));
            }
          }
          break;
        }

      case _actions2.default.CHANGE_SORT_ORDER:
        {
          const state = store.getState();
          localStorage.setItem(sortKey(state), action.sortOrder);
          break;
        }

      case _actions2.default.STORE_SCROLL_POSITION:
        {
          const state = store.getState();
          localStorage.setItem(scrollKey(state), action.scrollPosition);
          break;
        }

      default:
      // do nothing
    }

    return result;
  };

  },{"../actions":27}],41:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = () => next => action => {
    const result = next(action);

    switch (action.type) {
      case _actions2.default.RESTORE_SCROLL_POSITION:
        {
          window.scrollTo(window.scrollX, action.scrollPosition);
          break;
        }

      default:
      // do nothing
    }

    return result;
  };

  },{"../actions":27}],42:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.default = app;

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const defaultState = {
    active: true, // true by default because we don't load until the user arrives
    online: true, // true by default because that's right most of the time
    uri: undefined, // undefined because we don't know until we ask bridge
    sectionId: undefined // undefined because we don't know until we ask bridge
  };

  function app(state = defaultState, action) {
    switch (action.type) {
      case _actions2.default.ACTIVATE_APP:
        return _extends({}, state, { active: true });

      case _actions2.default.DEACTIVATE_APP:
        return _extends({}, state, { active: false });

      case _actions2.default.GO_ONLINE:
        return _extends({}, state, { online: true });

      case _actions2.default.GO_OFFLINE:
        return _extends({}, state, { online: false });

      case _actions2.default.INITIALIZE_URI:
      case _actions2.default.CHANGE_URI:
        {
          // e.g. spotify:app:collection:music
          const [,,
          /* spotify */featureId, sectionId] = action.uri.split(':');
          return _extends({}, state, {
            uri: action.uri,
            featureId,
            sectionId: sectionId || 'main'
          });
        }

      default:
        return state;
    }
  }

  },{"../actions":27}],43:[function(require,module,exports){
  (function (global){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isEmpty = exports.isLoading = exports.isFiltering = exports.getItems = undefined;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.default = collection;

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  var _actions = require('../actions');

  var _actions2 = _interopRequireDefault(_actions);

  var _cosmos = require('../middlewares/cosmos');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const defaultState = {
    collectionItems: [],
    textFilter: '',
    isFiltering: false,
    isLoading: true,
    sortOrder: _cosmos.CAT_ALL,
    username: global && global.__spotify && global.__spotify.username
  };

  function collection(state = defaultState, action) {
    switch (action.type) {
      case _actions2.default.INITIALIZE_URI:
      case _actions2.default.CHANGE_URI:
        {
          return _extends({}, state, {
            collectionItems: [],
            isLoading: true,
            sortOrder: _cosmos.CAT_ALL,
            textFilter: ''
          });
        }
      case _actions2.default.UPDATE:
        {
          return _extends({}, state, {});
        }
      case _actions2.default.CHANGE_TEXT_FILTER:
        {
          return _extends({}, state, {
            isFiltering: true,
            textFilter: action.value
          });
        }
      case _actions2.default.CHANGE_CATEGORY:
      case _actions2.default.RESTORE_CATEGORY:
        {
          return _extends({}, state, {
            sortOrder: action.sortOrder
          });
        }

      case _actions2.default.UPDATE_COLLECTION_ITEMS:
        {
          return _extends({}, state, {
            collectionItems: action.items,
            isFiltering: false,
            isLoading: false
          });
        }

      default:
        return state;
    }
  }

  const getItems = exports.getItems = state => state.collectionItems;
  const isFiltering = exports.isFiltering = state => state.isFiltering;
  const isLoading = exports.isLoading = state => state.isLoading;
  const isEmpty = exports.isEmpty = state => {
    const items = getItems(state);
    return !isLoading(state) && !isFiltering(state) && (!items || items.length === 0) && state.textFilter.length < 1;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../actions":27,"../middlewares/cosmos":38,"spotify-liburi":1282}],44:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createReducer;

  var _redux = require('redux');

  var _app = require('./app');

  var _app2 = _interopRequireDefault(_app);

  var _collection = require('./collection');

  var _collection2 = _interopRequireDefault(_collection);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function createReducer() {
    return (0, _redux.combineReducers)({
      app: _app2.default,
      collection: _collection2.default
    });
  }

  },{"./app":42,"./collection":43,"redux":1261}],45:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _redux = require('redux');

  var _reducers = require('./reducers');

  var _reducers2 = _interopRequireDefault(_reducers);

  var _app = require('./middlewares/app');

  var _app2 = _interopRequireDefault(_app);

  var _cosmos = require('./middlewares/cosmos');

  var _cosmos2 = _interopRequireDefault(_cosmos);

  var _events = require('./middlewares/events');

  var _events2 = _interopRequireDefault(_events);

  var _localStorage = require('./middlewares/localStorage');

  var _localStorage2 = _interopRequireDefault(_localStorage);

  var _window = require('./middlewares/window');

  var _window2 = _interopRequireDefault(_window);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = (0, _redux.createStore)((0, _reducers2.default)(), undefined, (0, _redux.compose)((0, _redux.applyMiddleware)(_app2.default, _cosmos2.default, _events2.default, _localStorage2.default, _window2.default)));

  },{"./middlewares/app":37,"./middlewares/cosmos":38,"./middlewares/events":39,"./middlewares/localStorage":40,"./middlewares/window":41,"./reducers":44,"redux":1261}],46:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const isShow = exports.isShow = view => ['videos', 'podcasts'].includes(view);

  const getBrowseUrl = exports.getBrowseUrl = view => ({
    videos: 'spotify:app:genre:videos',
    podcasts: 'spotify:app:genre:podcasts'
  })[view] || 'spotify:app:browse:releases';

  },{}],47:[function(require,module,exports){
  'use strict';

  var _eventTypes = require('../../../libs/event-types');

  var _eventTypes2 = _interopRequireDefault(_eventTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * @param {String} type The event type.
   * @param {Object} params Parameters to send with the event.
   * @param {Object} extra Extra stuff to send.
   */

  const Event = function (type, params, extra) {
    if (!type) {
      throw new Error('An event type needs to be specified');
    }
    /**
     * The event type
     *
     * @type {String}
     */
    this.type = type;

    /**
     * Parameters
     *
     * @type {Object}
     */
    this.params = typeof params === 'undefined' ? {} : params;

    /**
     * Extra stuff to send
     *
     * @type {Object}
     */
    this.extra = extra || {};
  };

  Event.TYPES = _eventTypes2.default;

  module.exports = Event;

  },{"../../../libs/event-types":131}],48:[function(require,module,exports){
  'use strict';

  var _spotifyCosmosApi = require('spotify-cosmos-api');

  var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

  var _jsonStableStringify = require('json-stable-stringify');

  var _jsonStableStringify2 = _interopRequireDefault(_jsonStableStringify);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  let subscriptions = [];

  module.exports = {
    get,
    subscribe,
    clearSubscriptions,
    fetch
  };

  /**
   * Debug API
   * Exposed on the window for debugging and TA tests
   */
  if (typeof window !== 'undefined') {
    window.abba = {
      get,
      // this should only be used by TA tests for logging purposes
      getAll,
      getRequestedFlagNames
    };
  }

  function _getFlagsFromCosmos(requestedFlags, callback) {
    _spotifyCosmosApi2.default.resolver.post({
      url: 'sp://abba/v1/flags',
      body: {
        flags: requestedFlags
      }
    }, (err, response) => {
      if (err) {
        callback(err);
      } else {
        const { flags = [] } = response.getJSONBody();
        callback(null, flags);
      }
    });
  }

  function fetch(flags) {
    if (typeof flags === 'string') {
      return fetch([flags]).then(cells => cells[flags]);
    }

    const cells = {};
    const overrides = readOverrides();
    const notOverridden = flags.reduce((acc, flag) => {
      if (overrides.hasOwnProperty(flag)) {
        console.warn(`Abba: Override for ${flag} : ${overrides[flag]}`);
        cells[flag] = overrides[flag];
      } else {
        acc.push(flag);
      }
      return acc;
    }, []);

    if (!notOverridden.length) {
      return Promise.resolve(cells);
    }

    return new Promise((resolve, reject) => {
      _getFlagsFromCosmos(notOverridden, (err, fetchedFlags) => {
        if (err) {
          reject(err);
          return;
        }
        fetchedFlags.forEach(flag => {
          cells[flag.featureName] = flag.cell;
        });
        if (Object.keys(cells).length !== flags.length) {
          flags.forEach(flag => {
            if (!cells.hasOwnProperty(flag)) {
              cells[flag] = null;
            }
          });
        }
        resolve(cells);
      });
    });
  }

  function get(flag, callback) {
    const overrides = readOverrides();
    if (overrides.hasOwnProperty(flag)) {
      console.warn(`Abba: Override for ${flag} : ${overrides[flag]}`);
      setTimeout(() => callback(null, overrides[flag]), 0);
      return;
    }

    _getFlagsFromCosmos([flag], (err, flags) => {
      if (err) {
        callback(err);
        return;
      }
      const featureFlagCell = flags[0] && flags[0].featureName === flag && flags[0].cell;
      callback(null, featureFlagCell || null);
    });
  }

  function getAll(callback) {
    console.warn('Abba:getAll should only be used by TA tests for logging purposes.');
    _spotifyCosmosApi2.default.resolver.get({
      url: 'sp://abba/v1/all_flags',
      body: {}
    }, (err, response) => {
      if (err) {
        callback(err);
      } else {
        const { flags = [] } = response.getJSONBody();
        // {"featureName":"s4a-hub-canvas","cell":"Control"}
        const flagMap = flags.reduce((acc, flagObj) => {
          acc[flagObj.featureName] = flagObj.cell;
          return acc;
        }, {});
        callback(null, (0, _jsonStableStringify2.default)(flagMap, { space: 2 }));
      }
    });
  }

  function getRequestedFlagNames(callback) {
    _spotifyCosmosApi2.default.resolver.get({
      url: 'sp://abba/v1/requested_flag_names',
      body: {}
    }, (err, response) => {
      if (err) {
        callback(err);
      } else {
        callback(null, JSON.stringify(response.getJSONBody().sort(), null, 2));
      }
    });
  }

  function subscribe(flag, callback) {
    let oldValue;

    const update = newValue => {
      // ABBA might pub even though the value we're after haven't actually
      // changed, so must make sure that the flag we're tracking actually
      // changed value.
      if (newValue !== oldValue) {
        oldValue = newValue;
        callback(null, newValue);
      }
    };

    let cosmosSubscription = _spotifyCosmosApi2.default.resolver.subscribe({
      url: 'sp://abba/v1/flags',
      body: {
        flags: [flag]
      }
    }, subscribeError => {
      if (subscribeError) {
        callback(subscribeError);
        return;
      }

      get(flag, (err, newValue) => {
        if (err) {
          callback(err);
          return;
        }
        update(newValue);
      });
    });

    let subscription = {
      cancel: () => {
        if (cosmosSubscription) cosmosSubscription.cancel();
        const index = subscriptions[flag].indexOf(subscription);
        if (index !== -1) {
          subscriptions[flag].splice(index, 1);
        }
        subscription = cosmosSubscription = null;
      },
      _update: update
    };

    if (!(flag in subscriptions)) {
      subscriptions[flag] = [];
    }
    subscriptions[flag].push(subscription);

    return subscription;
  }

  function clearSubscriptions() {
    subscriptions = [];
  }

  function readOverrides() {
    const value = typeof __spotify !== 'undefined' && __spotify.product_state ? __spotify.product_state.abbaOverrides || __spotify.product_state.abbaoverrides : '';
    if (value) {
      try {
        return JSON.parse(value);
      } catch (e) {
        console.error('error parsing value=%o, error=%o', value, e);
      }
    }
    return {};
  }

  },{"json-stable-stringify":750,"spotify-cosmos-api":1272}],119:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _debug = require('../../../../debug');

  var _debug2 = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const debug = (0, _debug2.default)('saf:VisibilityObserver'); // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API

  const UNKNOWN = 'visible_unknown';
  const NOT_VISIBLE = 'visible_0';
  const VISIBLE_FIFTY_PCT = 'visible_50';
  const VISIBLE_HUNDRED_PCT = 'visible_100';

  class VisibilityObserver {
    constructor(callback, options = { threshold: [0.0, 0.5, 1.0] }) {
      this.currentState = UNKNOWN;
      this.callback = callback;
      this.intersectionObserver = new IntersectionObserver(this._onObservation.bind(this), options);
    }

    _onObservation(entries) {
      const newPercentage = entries[0].intersectionRatio;
      let newState = UNKNOWN;

      if (newPercentage === 1.0) {
        newState = VISIBLE_HUNDRED_PCT;
      } else if (newPercentage >= 0.5) {
        newState = VISIBLE_FIFTY_PCT;
      } else if (newPercentage < 0.5) {
        newState = NOT_VISIBLE;
      }

      if (newState !== this.currentState) {
        this.currentState = newState;
        this.callback(this.currentState);
        debug('new state', this.currentState);
      }
    }

    observe(targetElement) {
      this.intersectionObserver.observe(targetElement);
    }

    disconnect() {
      this.intersectionObserver.disconnect();
    }
  }

  exports.default = VisibilityObserver;

  },{"../../../../debug":129}],120:[function(require,module,exports){
  'use strict';

  const TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

  const COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

  const ERROR_PREFIX = 'bridge.cosmosRequest: ';

  // Base function that doesn't have any dependencies on it's own. Expects to get
  // state (a plain, empty object) injected in addition to a bridge request
  // function.
  function cosmosRequest(state, bridge, opts, callback) {
    if (opts.url) {
      throw new Error(`${ERROR_PREFIX}"url" is not a valid option, did you mean "uri"?`);
    }

    if (typeof opts.uri !== 'string') {
      throw new Error(`${ERROR_PREFIX}Expected uri to be string.`);
    }

    if (COSMOS_VERBS.indexOf(opts.method) === -1) {
      throw new Error(`${ERROR_PREFIX}Method must match valid verb in uppercase (GET, POST etc)`);
    }

    if (opts.body && typeof opts.body !== 'string') {
      throw new Error(`${ERROR_PREFIX}If body is provided it should be a string.`);
    }

    if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') {
      throw new Error(`${ERROR_PREFIX}Expected headers be a plain object.`);
    }

    const cosmosOptions = {
      action: opts.method,
      uri: opts.uri
    };
    if (opts.body) cosmosOptions.body = opts.body;
    if (opts.headers) cosmosOptions.headers = opts.headers;

    /* Cosmos requires each request to have a unique ID. Ideally, this would be
    uuids, but unfortunately, it is integers. This means that in apps that for
    some reason need to use spotify-cosmos-api, there would between the two
    counters if cosmosRequest started from 0. To make it safe for the two
    implemenations to co-exist if needed, we begin counting at
    significantly higher number: */
    state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
    state.requestIDCounter++;

    const requestArguments = [state.requestIDCounter, cosmosOptions];

    let isCanceled = false;
    const stateRequestIDCounter = state.requestIDCounter;

    function cancelFunction() {
      isCanceled = true;
      bridge('cosmos_request_cancel', [stateRequestIDCounter]);
    }

    // run is a recursive function that does a bridge request and then keeps
    // pulling values after every response in the case of a subscription. In
    // case we are not subscribing, or the cancelFunction has been called,
    // run sends cosmos_request_cancel and terminates.
    function run(isFirst, requestIDCounter) {
      const messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
      bridge(messageName, requestArguments, function (error, responseString) {
        // The request to cancel may not have gotten to the bridge
        // before the original request got resolved,
        // so make sure not to continue if we detect it's been canceled.
        if (isCanceled) {
          return;
        }
        try {
          if (callback) {
            if (error) {
              callback(error);
            } else {
              callback(null, responseString);
            }
          }
        } finally {
          if (opts.method !== 'SUB') {
            // If the request was a non-SUB, tell core to clean up the request.
            // NOTE: Not sure if this is strictly necessary,
            // have not been to investigate in C++-land, so for now
            // we are just mimicing the behavior of spotify-cosmos-api.
            bridge('cosmos_request_cancel', [requestIDCounter]);
          } else if (!isCanceled) {
            // maybe canceled in above callback
            run(false, requestIDCounter);
          }
        }
      });
    }

    run(true, stateRequestIDCounter);

    return cancelFunction;
  }

  module.exports = cosmosRequest;

  },{}],121:[function(require,module,exports){
  (function (global){
  'use strict';

  const debug = require('../debug')('bridge');
  const defer = require('spotify-deferred');

  const cosmosBaseFunction = require('./cosmos');

  // NOTE: Implicit global state.
  let scheduledCoreFlush = false;
  let cosmosState = null;

  exports.cosmos = cosmos;
  exports.cosmosJSON = cosmosJSON;
  exports.request = request;
  exports._request = _request;

  function cosmos() {
    if (!cosmosState) cosmosState = {};

    const baseArguments = [cosmosState, request];
    const cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
    return cancelFunction;
  }

  function _createCallbackWrapper(callback) {
    return function callbackWrapper(err, response) {
      let newErr = err;
      if (!newErr) {
        if (response && !response.body && response.status >= 400) {
          newErr = new Error(`${response.uri} responded with status ${response.status}`);
          callback(newErr, response);
          return;
        }
        let parsedResponse;
        try {
          parsedResponse = JSON.parse(response.body);
        } catch (e) {
          e.message = `Failed to parse cosmos response: ${e.message}`;
          callback(e);
          return;
        }
        callback(null, parsedResponse);
      } else {
        callback(newErr, response);
      }
    };
  }

  function cosmosJSON(opts, callback) {
    if (opts.body) {
      opts.body = JSON.stringify(opts.body);
    }
    const callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
    const cancelFunction = cosmos(opts, callbackWrapper);
    return cancelFunction;
  }

  function request(name, optArgs, optCallback) {
    const args = optArgs || [];
    const callback = getCallback(name, args, optCallback);

    debug(`req:${name}`, args);

    exports._request(name, args, callback);

    if (name.endsWith('_metadata') && !scheduledCoreFlush) {
      scheduledCoreFlush = true;
      defer(flushCore);
    }

    return exports;
  }

  function _request(name, args, callback) {
    if (global && typeof global._getSpotifyModule === 'function') {
      global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
        name: name,
        args: args
      }), {
        onSuccess: getSuccessHandler(callback),
        onFailure: getFailureHandler(callback, name, args)
      });
    }
  }

  function getCallback(name, args, optUserCallback) {
    const userCallback = optUserCallback || function () {};

    return function (error, data) {
      if (error) {
        if (error.name === 'timeout') {
          // Set the delay between 300ms and 400ms
          const delay = 300 + Math.floor(Math.random() * 100);

          debug('timeout', error.message);

          // Retry the request
          setTimeout(function () {
            request(name, args, userCallback);
          }, delay);
          return;
        }
      }

      debug(`res:${name}`, args, data);

      userCallback(error, data);
    };
  }

  function getSuccessHandler(requestCallback) {
    return function (data) {
      let parsed;

      debug('success', data);

      try {
        parsed = JSON.parse(data);
      } catch (error) {
        requestCallback(error);
      }

      if (parsed) {
        requestCallback(null, parsed);
      }
    };
  }

  function getFailureHandler(requestCallback, name, args) {
    return function (data) {
      let parsed;

      debug('failure', data);
      try {
        parsed = JSON.parse(data);
      } catch (error) {
        if (data instanceof Error) {
          requestCallback(data);
        } else {
          error.message += `\nResponse Data: ${data}`;
          requestCallback(error);
        }
      }

      if (parsed) {
        requestCallback(createError(name, args, parsed));
      }
    };
  }

  function createError(name, args, response) {
    const argsString = JSON.stringify(args);
    const innerDebug = ` (bridge message: '${name}', args: ${argsString})`;
    const msg = response.message + innerDebug;
    const error = new Error(msg);
    error.name = response.error;

    return error;
  }

  function flushCore() {
    scheduledCoreFlush = false;
    request('core_flush');
  }

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../debug":129,"./cosmos":120,"spotify-deferred":1275}],122:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const operationCanceledError = {
    name: 'OperationCanceledError',
    message: 'An async operation was cancelled'
  };

  class CancellationToken {
    // Internal constructor: only a CancellationTokenSource should create
    // a CancellationToken.
    constructor(source) {
      this.source = source;
      this.requestId = source.requestId;
    }

    isCanceled() {
      return this.requestId !== this.source.requestId;
    }

    throwIfCanceled() {
      if (this.isCanceled()) {
        throw operationCanceledError;
      }
    }

    errorIfCanceled() {
      if (this.isCanceled()) {
        return operationCanceledError;
      }
      return undefined;
    }

    operationCanceledError() {
      return operationCanceledError;
    }
  }

  class CancellationTokenSource {
    constructor() {
      this.requestId = 0;
    }

    // Create a new token that can be cancelled by canlling cancel() in the
    // CancellationTokenSource.
    token() {
      return new CancellationToken(this);
    }

    // Cancel all the tokens created so far.
    cancel() {
      this.requestId++;
    }
  }
  exports.default = CancellationTokenSource;

  },{}],123:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _focus = require('./src/focus');

  Object.keys(_focus).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _focus[key];
      }
    });
  });

  var _activity = require('./src/activity');

  Object.keys(_activity).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _activity[key];
      }
    });
  });

  var _state = require('./src/state');

  Object.keys(_state).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _state[key];
      }
    });
  });

  },{"./src/activity":124,"./src/focus":125,"./src/state":127}],124:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.subscribeToActivity = subscribeToActivity;
  exports.enableActivityMonitorForWindow = enableActivityMonitorForWindow;
  exports._onActivity = _onActivity;
  exports._reset = _reset;

  var _debug = require('../../debug');

  var _debug2 = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const ACTIVE = true;
  const INACTIVE = false;

  const debug = (0, _debug2.default)('client-state:activity');
  const subscribers = [];

  /**
   * Subscribing to Activity means you get notified when the user is active
   * AND when the user has become inactive, give your passed threshold for inactivity.
   * There is an automatic 100ms throttle on mousemove and keydown so you don't get
   * more spammed then you need to.
   *
   * @param {integer} msInactive
   * @param {function} fn
   * @return {function} unsubscribe
   */
  function subscribeToActivity(msInactive, fn) {
    const found = _findReference(fn);
    if (found === -1) {
      subscribers.push({
        fn: fn,
        msInactive: msInactive,
        isActive: false
      });
    } else {
      const sub = subscribers[found];
      sub.msInactive = msInactive;
      clearTimeout(sub.inactiveTimeout);
      sub.inactiveTimeout = setTimeout(sub.fn.bind(null, INACTIVE), sub.msInactive);
    }
    return unsubscribe.bind(null, fn);
  }

  function unsubscribe(fn) {
    const found = _findReference(fn);
    if (found !== -1) {
      subscribers.splice(found, 1);
      return true;
    }
    return false;
  }
  /**
   * This is needed because Zelda is made up of multiple iframes with their own window objects
   * So for each one you have to enable this so we can track activity throughout Zelda
   */
  function enableActivityMonitorForWindow(localWindow) {
    debug('enableActivityMonitorForWindow');
    localWindow.addEventListener('mousemove', _onActivity);
    localWindow.addEventListener('mouseup', _onActivity);
    localWindow.addEventListener('keydown', _onActivity);
    localWindow.addEventListener('scroll', _onActivity, true);
    return disableActivityMonitorForWindow.bind(null, localWindow);
  }

  function disableActivityMonitorForWindow(localWindow) {
    debug('disableActivityMonitorForWindow');
    localWindow.removeEventListener('mousemove', _onActivity);
    localWindow.removeEventListener('mouseup', _onActivity);
    localWindow.removeEventListener('keydown', _onActivity);
    localWindow.removeEventListener('scroll', _onActivity, true);
  }

  /**
   * Exposed for unit tests only
   */
  function _onActivity() {
    subscribers.forEach(sub => {
      if (!sub.isActive) {
        sub.isActive = true;
        sub.fn(ACTIVE);
      }

      clearTimeout(sub.inactiveTimeout);
      sub.inactiveTimeout = setTimeout(() => {
        sub.isActive = false;
        sub.fn(INACTIVE);
      }, sub.msInactive);
    });
  }

  function _findReference(fn) {
    let found = -1;
    subscribers.some((x, i) => {
      if (x.fn === fn) {
        found = i;
        return true;
      }
      return false;
    });
    return found;
  }

  /**
   * Exposed for unit tests only
   */
  function _reset() {
    subscribers.length = 0;
  }

  },{"../../debug":129}],125:[function(require,module,exports){
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Checks if the document has focus every 500 ms.
   *
   * Usage:
   * import { subscribeToFocusChange } from '../libs/client-state';
   * const unsubscribe = subscribeToFocusChange(hasFocus => {});
   * unsubscribe();
   */
  exports.subscribeToFocusChange = subscribeToFocusChange;
  exports._setIntervalTime = _setIntervalTime;


  const listeners = [];
  let started = false;
  let focus = false;
  let focusCheckInterval;
  let intervalTime = 500;

  function subscribeToFocusChange(fn) {
    if (!listeners.includes(fn)) {
      listeners.push(fn);
      if (started) {
        fn(focus);
      } else {
        _start();
      }
    }
    return _unsubscribe.bind(null, fn);
  }

  /**
   * Only to be used my unit tests
   */
  function _setIntervalTime(ms) {
    intervalTime = ms;
  }

  function _unsubscribe(fn) {
    const index = listeners.indexOf(fn);
    if (index !== -1) {
      listeners.splice(index, 1);
      if (listeners.length < 1) {
        _stop();
      }
      return true;
    }
    return false;
  }

  function _start() {
    if (started) {
      return;
    }
    started = true;
    focusCheckInterval = setInterval(_checkFocus, intervalTime);
    focus = document.hasFocus();
    _notifyListeners();
  }

  function _stop() {
    clearInterval(focusCheckInterval);
    started = false;
  }

  function _checkFocus() {
    const currentFocus = document.hasFocus();
    if (currentFocus !== focus) {
      focus = currentFocus;
      _notifyListeners();
    }
  }

  function _notifyListeners() {
    listeners.forEach(x => {
      x(focus);
    });
  }

  },{}],126:[function(require,module,exports){
  (function (global){
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const hasFlag = exports.hasFlag = name => {
    return !!(global.__spotify && global.__spotify.product_state && global.__spotify.product_state.hasOwnProperty(name));
  };

  const hasValue = exports.hasValue = (name, value) => {
    return hasFlag(name) && global.__spotify.product_state[name] === value;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],127:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._setPlayerThrottleTime = exports._destroy = exports.subscribeToClientState = exports.getClientState = exports.initClientState = undefined;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _redux = require('redux');

  var _eventDispatcher = require('../../event-dispatcher');

  var _eventDispatcher2 = _interopRequireDefault(_eventDispatcher);

  var _eventTypes = require('../../event-types');

  var _eventTypes2 = _interopRequireDefault(_eventTypes);

  var _debug = require('../../debug');

  var _debug2 = _interopRequireDefault(_debug);

  var _focus = require('./focus');

  var _activity = require('./activity');

  var _spotifyCosmosApi = require('spotify-cosmos-api');

  var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

  var _spotifyPlayer = require('spotify-player');

  var _messageProxy = require('../../message-proxy');

  var _uuidJs = require('uuid-js');

  var _uuidJs2 = _interopRequireDefault(_uuidJs);

  var _ramda = require('ramda');

  var R = _interopRequireWildcard(_ramda);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.initClientState = initClientState;
  exports.getClientState = getClientState;
  exports.subscribeToClientState = subscribeToClientState;
  exports._destroy = _destroy;
  exports._setPlayerThrottleTime = _setPlayerThrottleTime;


  const SECONDS_MS = 1000;
  const MINUTES_MS = SECONDS_MS * 60;
  const DEFAULT_INACTIVE_TIMEOUT_MS = 3 * MINUTES_MS;

  const INITIAL_STATE = {
    current_app_uri: 'spotify:app:browse',
    focus: true,
    is_paused: false,
    is_playing: false,
    ad_playing: false,
    video_playing: false,
    context_uri: '',
    user_active: true,
    session_uuid: _uuidJs2.default.create().toString()
  };

  // If you add a key here, be sure to add it to INITIAL_STATE above
  const playerStateFilters = {
    context_uri: _simplePlayerFilter,
    is_playing: _simplePlayerFilter,
    is_paused: _simplePlayerFilter,
    ad_playing: _adFilter,
    video_playing: _videoFilter
  };

  _checkKeys(INITIAL_STATE, playerStateFilters);

  const debug = (0, _debug2.default)('client-state:state');

  let store;
  let prevState = _extends({}, INITIAL_STATE);
  let subscribers = [];
  let player;
  let playerUpdateThrottle;
  let playerThrottleTime = 200; // milliseconds
  let initialized = false;

  function initClientState() {
    if (initialized) {
      return;
    }
    initialized = true;
    debug('init');
    store = (0, _redux.createStore)((state = {}, action) => {
      return _extends({}, state, action.updates);
    }, INITIAL_STATE);

    _setupListeners();
  }

  /**
   * @param {Array|Function} optKeys - optional set of keys
   * @param {Function} fn
   * @return {Function} unsubscribe
   */
  function subscribeToClientState(optKeys, fn) {
    const subscriber = typeof optKeys === 'function' ? optKeys : fn;
    if (!subscribers.includes(subscriber)) {
      if (Array.isArray(optKeys)) {
        subscribers.push({ fn: subscriber, keys: optKeys });
      } else {
        subscribers.push({ fn: subscriber, keys: 'all' });
      }
    }
    return unsubscribe.bind(null, subscriber);
  }

  function unsubscribe(subscriber) {
    let index = -1;
    subscribers.some((sub, i) => {
      if (sub.fn === subscriber) {
        index = i;
        return true;
      }
      return false;
    });
    if (index !== -1) {
      subscribers.splice(index, 1);
    }
  }

  /**
   * @return {Object} current state
   */
  function getClientState() {
    return store.getState();
  }
  /**
   * Exposed for unit tests only
   */
  function _destroy() {
    store = '';
    prevState = _extends({}, INITIAL_STATE);
    player = null;
    subscribers = [];
    _removeListeners();
    initialized = false;
  }

  function _setPlayerThrottleTime(ms) {
    playerThrottleTime = ms;
  }

  function _setupListeners() {
    store.subscribe(_onStoreDispatch);
    _eventDispatcher2.default.addEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, _onNavigationStateChange);
    (0, _focus.subscribeToFocusChange)(_onFocusChange);
    (0, _activity.subscribeToActivity)(DEFAULT_INACTIVE_TIMEOUT_MS, _onActivity);

    // player subscription (we dont ever control the player, so the passed strings are meaningless)
    player = new _spotifyPlayer.Player(_spotifyCosmosApi2.default.resolver, 'spotify:app:zlink', 'zlink', '0.1.0');
    player.subscribe(_onPlayerChange);
    (0, _messageProxy.messageProxy)({ method: 'REPLY', uri: 'client-state' }, (_, reply) => {
      reply(null, { state: getClientState() });
    });
  }

  function _onStoreDispatch() {
    const newState = store.getState();
    const changedKeys = [];
    const delta = {};
    Object.keys(newState).forEach(key => {
      if (prevState[key] !== newState[key]) {
        changedKeys.push(key);
        delta[key] = newState[key];
      }
    });
    subscribers.forEach(sub => {
      if (sub.keys === 'all' || _oneMatch(sub.keys, changedKeys)) {
        sub.fn(delta);
      }
    });
    // post so other nested iframes can subscribe to client state changes
    (0, _messageProxy.messageProxy)({
      method: 'POST',
      uri: 'client-state',
      body: { state: newState }
    });
    prevState = newState;
    debug('_onStoreDispatch. new state:', newState, 'changed-keys:', changedKeys);
  }

  function _removeListeners() {
    _eventDispatcher2.default.removeEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, _onNavigationStateChange);
  }

  function _onNavigationStateChange(event) {
    _dispatch({ current_app_uri: event.params.uri });
  }

  function _onFocusChange(focus) {
    _dispatch({ focus });
  }

  function _onActivity(active) {
    // check this value so we don't spam the dispatcher
    if (store.getState().user_active !== active) {
      _dispatch({ user_active: active });
    }
  }

  function _onPlayerChange(err, response) {
    if (err || !response) return;
    clearTimeout(playerUpdateThrottle);
    playerUpdateThrottle = setTimeout(() => {
      const playerState = response.getJSONBody();
      const currentState = store.getState();
      const updates = Object.keys(playerStateFilters).reduce((sum, key) => {
        return playerStateFilters[key](key, sum, playerState, currentState);
      }, {});
      if (Object.keys(updates).length) {
        _dispatch(updates);
      }
    }, playerThrottleTime);
  }

  function _dispatch(updates) {
    // since this is the only module that can update the store we dont need an action type
    store.dispatch({ type: '', updates });
  }

  function _oneMatch(arr1, arr2) {
    return arr1.some(x => arr2.includes(x));
  }

  function _checkKeys(obj1, obj2) {
    const validStateKeys = Object.keys(obj1);
    const newKeys = Object.keys(obj2);
    const foundBadKey = newKeys.some(newKey => !validStateKeys.includes(newKey));
    if (foundBadKey) {
      throw new Error('Uh oh. Found an unexpected state key. Forget to add it to INITIAL_STATE?');
    }
  }

  /**
   * Player State Filters
   * This is needed because some of the keys/values we care about
   * are nested in other keys in the player or
   * require additional logic to determine
   */

  function _simplePlayerFilter(key, updates, playerState, currentState) {
    if (playerState.hasOwnProperty(key) && currentState[key] !== playerState[key]) {
      updates[key] = playerState[key];
    }
    return updates;
  }

  function _adFilter(key, updates, playerState, currentState) {
    const adPlaying = R.path(['track', 'metadata', 'is_advertisement'], playerState) === 'true';
    if (currentState[key] !== adPlaying) {
      updates[key] = adPlaying;
    }
    return updates;
  }

  function _videoFilter(key, updates, playerState, currentState) {
    const videoPlaying = R.path(['track', 'metadata', 'media.type'], playerState) === 'video';
    if (currentState[key] !== videoPlaying) {
      updates[key] = videoPlaying;
    }
    return updates;
  }

  },{"../../debug":129,"../../event-dispatcher":130,"../../event-types":131,"../../message-proxy":437,"./activity":124,"./focus":125,"ramda":913,"redux":1261,"spotify-cosmos-api":1272,"spotify-player":1283,"uuid-js":1303}],128:[function(require,module,exports){
  'use strict';

  const parser = require('../live/util/parser');

  const sortMap = {
    track: {
      _replace: '',
      artists: {
        _replace: 'artist'
      },
      disc: {
        _replace: 'discNumber'
      },
      number: {
        _replace: 'trackNumber'
      },
      duration: {
        _replace: 'length'
      }
    },
    timeSinceAdded: {
      _reverse: true,
      _replace: 'addTime'
    },
    addedBy: {
      _replace: '',
      name: {
        _replace: 'addedByDisplayName'
      }
    }
  };

  function reverse(direction) {
    return direction === 'ASC' ? 'DESC' : 'ASC';
  }

  function walk(query, mapping, optDirection, incomingCollector) {
    const results = [];
    const collector = incomingCollector && incomingCollector.slice() || [];

    query.mask.forEach(item => {
      const itemCollector = collector.slice();

      if (item.key) {
        const hasReplace = mapping && mapping[item.key] && mapping[item.key]._replace !== null && mapping[item.key]._replace !== undefined;

        let value = hasReplace ? mapping[item.key]._replace : item.key;
        if (value !== '') {
          // Only add the direction if there's not another sub object
          if (!item.mask) {
            const doReverse = !!(mapping && mapping[item.key] && mapping[item.key]._reverse);
            if (optDirection) {
              const newOptDirection = optDirection.toUpperCase();
              const direction = doReverse ? reverse(newOptDirection) : newOptDirection;
              value += ` ${direction}`;
            }
          }
          itemCollector.push(value);
        }
      }

      if (item.mask) {
        const subLookUp = walk(item, mapping[item.key], optDirection, itemCollector);
        if (subLookUp.length) {
          results.push(subLookUp);
        }
      } else {
        if (itemCollector.length) {
          results.push(itemCollector.join('.'));
        }
      }
    });
    return results;
  }

  function getParams(query, optDirection, optMap) {
    const parsed = parser(query);
    if (!query) return null;

    const map = optMap || sortMap;
    const result = walk(parsed, map, optDirection);

    return result.join(',');
  }

  module.exports = getParams;

  },{"../live/util/parser":416}],129:[function(require,module,exports){
  'use strict';

  let initialized = false;
  let debug;

  /**
   * This module is needed so that the debug module can be enabled before it's used
   * via the 'debugEnabled' product state flag or the 'data-debug' iframe attribute
   * assigned by zlink. If debug is 'import'ed instead of required it gets evaluated
   * and potentially used by other 'import'ed modules before getting enabled.
   *
   * This works exactly the same as the debug module except we dynamically
   * require 'debug' only the first time a debug namespace is created.
   * @param {String} namespace
   * @return {Function}
   */
  const spDebug = function spDebug(namespace) {
    if (!initialized) {
      debug = require('debug');
      spDebug.enable = debug.enable.bind(debug);
      spDebug.disable = debug.disable.bind(debug);
      /**
       * This attribute is updated by zlink when it loads an app's iframe
       */
      if (typeof window !== 'undefined' && window.frameElement) {
        const enabled = window.frameElement.getAttribute('data-debug');
        if (enabled) debug.enable(enabled);
      }

      const productState = typeof __spotify !== 'undefined' && __spotify.product_state ? __spotify.product_state : {};
      const debugEnable = productState.debugEnable || productState.debugenable;
      if (debugEnable) {
        debug.enable(debugEnable);
      }

      if (typeof __spotify !== 'undefined' && __spotify.product_state && __spotify.product_state['ta-environment'] === '1') {
        /**
         * Normal CEF object-formatting results in missing data in Selenium logs, so we use
         * JSON.stringify objects to force a string representation.
         * Also, colors are not supported in Selenium-exported logs, and attempted use will result in junk characters.
         */
        debug.useColors = () => false;
        debug.formatters.o = obj => {
          try {
            return JSON.stringify(obj);
          } catch (e) {
            console.error('Unable to stringify object', e);
            return '';
          }
        };
      }
      initialized = true;
    }

    return debug(namespace);
  };

  module.exports = spDebug;

  },{"debug":704}],130:[function(require,module,exports){
  'use strict';

  function EventDispatcher() {
    // In order to not have prototype nor constructor
    this._listeners = Object.create(null);
  }

  /**
   * Add an event listener.
   *
   * @param {String} type What type of event to listen to.
   * @param {Function} callback Callback function to execute when triggered.
   * @param {Number?} priority The priority(?).
   */
  EventDispatcher.prototype.addEventListener = function (type, callback, priority = 0) {
    if (!type || !callback) {
      throw new Error('Both event type and callback need to be defined');
    }

    if (!this._listeners[type]) {
      this._listeners[type] = [];
    }

    const handlers = this._listeners[type];
    // Check if this callback is already registered
    if (handlers.every(function (h) {
      return h.callback !== callback;
    })) {
      const newHandler = {
        callback: callback,
        priority: priority
      };

      // Insert the handler in the right position
      let pos = 0;
      while (pos < handlers.length && handlers[pos].priority > newHandler.priority) {
        pos++;
      }
      handlers.splice(pos, 0, newHandler);
    }
  };

  /**
   * Remove an event listener.
   *
   * @param {String} type What type of event to stop listening to.
   * @param {Function} listener The listener to remove.
   */
  EventDispatcher.prototype.removeEventListener = function (type, listener) {
    const handlers = this._listeners[type] || [];
    for (let i = 0; i < handlers.length; i++) {
      if (handlers[i].callback === listener) {
        handlers.splice(i, 1);
        return;
      }
    }
  };

  /**
   * Add an event listener and automatically removes it when the predicate function is satisfied.
   *
   * @param {String} type What type of event to listen to.
   * @param {Function} callback Callback function to execute when triggered.
   * @param {Function} predicate Callback function to determine if event should be considered complete.
   * @param {Number?} priority The priority(?).
   */
  EventDispatcher.prototype.addEventListenerOnce = function (type, callback, predicate = () => true, priority = 0) {
    // Removes the event listener after the callback is triggered for the first time
    // That matches the predicate
    const innerCallback = evt => {
      if (predicate(evt)) {
        this.removeEventListener(type, innerCallback);
        callback(evt);
      }
    };

    this.addEventListener(type, innerCallback, priority);
  };

  /**
   * Dispatch an event
   *
   * @param {Object} event The event to dispatch.
   */
  EventDispatcher.prototype.dispatchEvent = function (event) {
    // Iterate on a copy of the array since an event callback might
    // unbind its listener, which would mutate the listeners array and make
    // the for loop act up.
    const handlers = this._listeners[event.type] ? this._listeners[event.type].slice() : [];
    for (let i = 0, len = handlers.length; i < len; i++) {
      const evt = handlers[i];
      evt.callback(event);
    }
  };

  EventDispatcher.prototype.reset = function () {
    this._listeners = Object.create(null);
  };

  module.exports = new EventDispatcher();

  },{}],131:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = {
    // App notifications
    APP_NOTIFY_LOADED: 'notify_loaded',

    // Connection state notifications
    CONNECTION_STATE_CHANGE: 'connection-state-change',
    CONNECTION_OFFLINE_ERROR: 'offline-error',

    // Window events
    WINDOW_ENTER_FULLSCREEN: 'enter_fullscreen',
    WINDOW_LEAVE_FULLSCREEN: 'leave_fullscreen',

    // Spotify Connect
    SPCONNECT_DEVICE_STATE: 'connectdevice',

    // Social / Facebook
    SOCIAL_ERROR: 'socialerror',

    // Navigation
    NAVIGATION_OPEN_URI: 'open_uri',
    NAVIGATION_LOGOUT: 'logout',
    NAVIGATION_HISTORY_BACK: 'browse_backward',
    NAVIGATION_HISTORY_CHANGE: 'historychange',
    NAVIGATION_HISTORY_FORWARD: 'browse_forward',
    NAVIGATION_HISTORY_GO: 'history_go',
    NAVIGATION_HISTORY_REMOVE: 'history_remove',
    NAVIGATION_STATE_CHANGE: 'statechange',
    NAVIGATION_SHOW_SHARE: 'show_share',
    NAVIGATION_SHOW_ABOUT: 'show_about',
    NAVIGATION_SHOW_SCANNABLE: 'show_scannable',
    NAVIGATION_SHOW_PREFERENCES: 'show_preferences',
    NAVIGATION_SHOW_HELP: 'show_help',
    NAVIGATION_SHOW_COMMUNITY: 'show_community',
    NAVIGATION_SHOW_ACCOUNT: 'show_account',
    NAVIGATION_SHOW_LICENSES: 'show_licenses',
    NAVIGATION_SHOW_LICENSING_INFORMATION: 'show_licensing_information',
    NAVIGATION_SHOW_SCTA_INFORMATION: 'show_scta_information',
    NAVIGATION_SHOW_SEARCH: 'show_search',
    NAVIGATION_SHOW_FULL_SCREEN_MODAL: 'show_full_screen_modal',
    NAVIGATION_SHOW_FIND_FRIENDS: 'show_find_friends',
    NAVIGATION_SHOW_NPS_SURVEY: 'show_nps_survey',
    NAVIGATION_REFRESH_VIEWS: 'refresh-view',
    NAVIGATION_UPGRADE: 'upgrade_premium',

    // Views
    VIEW_LOADED: 'view_loaded',
    VIEW_UNLOADED: 'view_unloaded',
    VIEW_ACTIVATE: 'view_activate',
    VIEW_DEACTIVATE: 'view_deactivate',

    // Context menu
    CONTEXT_CLIENT_SHOW_UI: 'client_show_context_ui',
    CONTEXT_SHOW_UI: 'show_context_ui',

    // Messages
    MESSAGE_NOTIFICATION: 'notification_message',
    MESSAGE_USER: 'user-message',

    // Player
    PLAYER_EVENT: 'player_event',
    PLAYER_SYNC_PROGRESS: 'sync_progress',
    PLAYER_VOLUME: 'volume',
    PLAYER_VOLUME_UP: 'volume_up',
    PLAYER_VOLUME_DOWN: 'volume_down',
    PLAYER_SEEK: 'seek',
    PLAYER_SHUFFLE: 'set_shuffle',
    PLAYER_REPEAT: 'set_repeat',
    PLAYER_PAUSE: 'pause',
    PLAYER_RESUME: 'resume',
    PLAYER_NEXT: 'skip_to_next',
    PLAYER_PREV: 'skip_to_prev',
    PLAYER_PROGRESS_DRAG_START: 'player_progress_drag_start',
    PLAYER_PROGRESS_DRAG_END: 'player_progress_drag_end',

    DEBUG_SET_BILLBOARD_TIMEOUT: 'debug:ad:set:billboard_timeout',
    DEBUG_DISABLE_AD_LEADERBOARD_REFRESH_ON_NAVIGATE_OR_REFOCUS: 'debug:ad:override:leaderboard:refreshnavigation',
    DEBUG_ENABLE_AD_LEADERBOARD_REFRESH_ON_NAVIGATE_OR_REFOCUS: 'debug:ad:enable:leaderboard:refreshnavigation',
    DEBUG_FORCE_REFRESH_LEADERBOARD: 'debug:ad:force_refresh:leaderboard',
    DEBUG_FORCE_REFRESH_HPTO: 'debug:ad:force_refresh:hpto',
    DEBUG_FORCE_REFRESH_BILLBOARD: 'debug:ad:force_refresh:billboard',
    DEBUG_OVERRIDE_AD_LEADERBOARD_HTML: 'debug:ad:override:leaderboard:html',
    DEBUG_RECEIVED_AD_LEADERBOARD_HTML: 'debug:received:ad:leaderboard:html',
    DEBUG_OVERRIDE_AD_LEADERBOARD_FLAGS: 'debug:ad:override:leaderboard:flags',
    DEBUG_OVERRIDE_AD_LEADERBOARD_REFRESH_INTERVAL: 'debug:ad:override:leaderboard:refreshinterval',

    // UI
    UI_SIDEBAR_RESIZE: 'ui:sidebar:resized',

    // Application
    APPLICATION_INACTIVE: 'application:inactive',
    APPLICATION_INITIALIZED: 'application:initialized',

    // Popovers
    POPOVER_OPENED: 'popover:opened',
    POPOVER_CLOSED: 'popover:closed',

    // Layout events
    LAYOUT_SIDEBAR_RESIZED: 'layout:sidebar:resized',

    // Playlist control messages
    CONTROL_MESSAGE_DELETE: 'delete',
    CONTROL_MESSAGE_NEW_PLAYLIST: 'create_new_playlist',
    CONTROL_MESSAGE_NEW_FOLDER: 'create_new_folder',
    CONTROL_MESSAGE_UNDO: 'undo_action',

    // Stations
    THUMB_UP: 'thumb-up',
    THUMB_DOWN: 'thumb-down',

    // Daily Mix
    HEART: 'heart',
    BAN_TRACK: 'ban-track',
    BAN_ARTIST: 'ban-artist',

    // Feedback
    BAN_TRACK_WITH_SCOPE: 'ban-track-with-scope',
    BAN_ARTIST_WITH_SCOPE: 'ban-artist-with-scope',
    UNDO_FEEDBACK: 'undo-feedback',
    SHOW_NOTIFICATION_BUBBLE: 'show-notification-bubble',

    // CAPPING  MESSAGES
    CAPPING_OPEN_UPSELL_MESSAGE: 'capping:open:upsellmessage',
    CAPPING_OPEN_WELCOME_MESSAGE: 'capping:open:welcomemessage',

    // Usable State
    USABLE_STATE_NOT_SUCCESSFUL: 'usable_state_not_successful',

    // ViewLoadTimer Debugging
    TOGGLE_VIEW_LOAD_TIMER_DEBUGGING: 'toggle_view_load_timer_debugging',

    RIGHT_SIDEBAR_SHOWN: 'right_sidebar_shown',
    RIGHT_SIDEBAR_HIDDEN: 'right_sidebar_hidden',

    MESSAGE_BAR_SHOWN: 'message_bar_shown',
    MESSAGE_BAR_HIDDEN: 'message_bar_hidden',

    VIDEO_PLAYER_MODE_CHANGED: 'video_player_mode_changed',

    SHOW_CREDITS: 'show_credits',

    TOGGLE_EXPERIMENT: 'experiments:toggle_experiment',

    SHOW_PLAYSTATION_MODAL: 'show_playstation_modal',
    HIDE_PLAYSTATION_MODAL: 'hide_playstation_modal'
  };

  },{}],132:[function(require,module,exports){
  (function (global){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addDebouncedScrollListener = addDebouncedScrollListener;
  exports.removeDebouncedScrollListener = removeDebouncedScrollListener;
  exports.requestFrame = requestFrame;
  exports.cancelFrame = cancelFrame;
  exports._reset = _reset;
  let scrollNodeToListenerInfoList = new global.Map();
  let idToScrollNode = {};
  let frameListenerInfoList = [];
  let hasQueuedScroll = false;
  let lastScrollEvent = null;
  let lastFrameRequestId = 0;
  let globalIdCounter = 0;

  function onScroll(event) {
    lastScrollEvent = event;

    if (!hasQueuedScroll) {
      hasQueuedScroll = true;

      const listenerInfoList = scrollNodeToListenerInfoList.get(event.target);
      if (listenerInfoList) {
        let list;
        requestFrame(() => {
          hasQueuedScroll = false;

          // Make a copy so that a potential handler that removes a handler
          // doesn't disturb the loop. This same copy will also be used in the
          // write handler, to prevent disturbing the write loop when handlers are
          // removed in the read loop.
          list = listenerInfoList.slice();

          callReadHandlers(list, lastScrollEvent);
        }, () => {
          callWriteHandlers(list, lastScrollEvent);
        });
      }
    }
  }

  function onFrame(timestamp) {
    lastFrameRequestId = 0;

    // Remove all current listeners as they are only valid for one frame. Just
    // like the regular requestAnimationFrame the handler needs to request a new
    // frame if it needs one.
    const listenerInfoList = frameListenerInfoList;
    frameListenerInfoList = [];

    callReadHandlers(listenerInfoList, timestamp);
    callWriteHandlers(listenerInfoList, timestamp);
  }

  function callReadHandlers(listenerInfoList, handlerArgument) {
    listenerInfoList.forEach(listenerInfo => {
      if (listenerInfo.readFunction) {
        listenerInfo.readFunction(handlerArgument);
      }
    });
  }

  function callWriteHandlers(listenerInfoList, handlerArgument) {
    listenerInfoList.forEach(listenerInfo => {
      if (typeof listenerInfo.writeFunction === 'function') {
        listenerInfo.writeFunction(handlerArgument);
      }
    });
  }

  function addDebouncedScrollListener(scrollNode, readFunction, writeFunction) {
    if (readFunction !== null && typeof readFunction !== 'function') {
      throw new TypeError('The callback provided to addDebouncedScrollListener as parameter 2 is ' + 'not a function.');
    }
    if (writeFunction !== undefined && typeof writeFunction !== 'function') {
      throw new TypeError('The callback provided to addDebouncedScrollListener as parameter 3 is ' + 'not a function.');
    }

    if (!scrollNodeToListenerInfoList.has(scrollNode)) {
      scrollNode.addEventListener('scroll', onScroll);
      scrollNodeToListenerInfoList.set(scrollNode, []);
    }

    const id = ++globalIdCounter;
    const listenerInfo = {
      id,
      readFunction,
      writeFunction
    };

    idToScrollNode[id] = scrollNode;
    scrollNodeToListenerInfoList.get(scrollNode).push(listenerInfo);

    return id;
  }

  function removeDebouncedScrollListener(id) {
    const scrollNode = idToScrollNode[id];
    if (scrollNode) {
      delete idToScrollNode[id];

      const listenerInfoList = scrollNodeToListenerInfoList.get(scrollNode);
      if (listenerInfoList) {
        for (let i = 0; i < listenerInfoList.length; i++) {
          if (listenerInfoList[i].id === id) {
            listenerInfoList.splice(i, 1);
            break;
          }
        }
      }

      if (listenerInfoList.length === 0) {
        scrollNode.removeEventListener('scroll', onScroll);
        scrollNodeToListenerInfoList.delete(scrollNode);
      }
    }
  }

  function requestFrame(readFunction, writeFunction) {
    if (readFunction !== null && typeof readFunction !== 'function') {
      throw new TypeError('The callback provided to requestFrame as parameter 1 is not a function.');
    }
    if (writeFunction !== undefined && typeof writeFunction !== 'function') {
      throw new TypeError('The callback provided to requestFrame as parameter 2 is not a function.');
    }

    if (lastFrameRequestId === 0) {
      lastFrameRequestId = window.requestAnimationFrame(onFrame);
    }

    const id = ++globalIdCounter;
    const listenerInfo = {
      id,
      readFunction,
      writeFunction
    };

    frameListenerInfoList.push(listenerInfo);

    return id;
  }

  function cancelFrame(id) {
    for (let i = 0; i < frameListenerInfoList.length; i++) {
      if (frameListenerInfoList[i].id === id) {
        frameListenerInfoList.splice(i, 1);
        break;
      }
    }

    if (lastFrameRequestId !== 0 && frameListenerInfoList.length === 0) {
      window.cancelAnimationFrame(lastFrameRequestId);
      lastFrameRequestId = 0;
    }
  }

  // Use only for testing, to be able to reset the state for each test
  function _reset() {
    scrollNodeToListenerInfoList = new global.Map();
    idToScrollNode = {};
    frameListenerInfoList = [];
    hasQueuedScroll = false;
    lastScrollEvent = null;
    lastFrameRequestId = 0;
    globalIdCounter = 0;
  }

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],133:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  class GlueDropdown extends _react2.default.PureComponent {
    constructor(...args) {
      super(...args);

      this.onChange = this.onChange.bind(this);
    }

    onChange(event) {
      this.props.onChange(event.target.value);
    }

    render() {
      const { value, options, labelId } = this.props;

      const { onChange } = this;

      return _react2.default.createElement(
        'select',
        {
          className: 'GlueDropdown',
          value: value,
          onChange: onChange,
          id: labelId
        },
        options.map(option => _react2.default.createElement(
          'option',
          { key: option.value, value: option.value },
          option.label
        ))
      );
    }
  }

  exports.default = GlueDropdown;
  GlueDropdown.propTypes = {
    options: _propTypes2.default.arrayOf(_propTypes2.default.shape({
      label: _propTypes2.default.string,
      value: _propTypes2.default.string
    })),
    value: _propTypes2.default.string,
    onChange: _propTypes2.default.func
  };

  GlueDropdown.defaultProps = {
    options: [],
    value: '',
    onChange() {}
  };

  },{"prop-types":827,"react":1253}],135:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _reactDom = require('react-dom');

  var _reactDom2 = _interopRequireDefault(_reactDom);

  var _reactVirtualized = require('react-virtualized');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // This class uses react-virtualized's Grid component wrappend in a
  // WindowScroller HOC together with some logic for adapting said grid to its
  // responsive items, and some workarounds for triggering react-virtualized's
  // performance optimised paths even when used with a WindowScroller.
  class GlueResponsiveVirtualGrid extends _react2.default.Component {
    constructor(props) {
      super(props);

      this.state = {
        columnWidth: -1,
        rowHeight: -1,
        columnCount: -1,
        rowCount: -1,
        rowWidth: -1,
        itemsCount: this.props.items.length
      };

      this.gridNode = null;
      this.lastScrollToIndexTopOfCell = -1;
      this.lastScrollToIndexRowHeight = -1;

      this.cellRenderer = this.cellRenderer.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onScroll = this.onScroll.bind(this);
    }

    componentDidMount() {
      this.rowContainer.ownerDocument.defaultView.addEventListener('resize', this.onResize, false);
      this.onResize();
      this.scrollAfterRender();
    }

    componentWillReceiveProps(nextProps) {
      if (nextProps.items.length !== this.state.itemsCount) {
        this.setState({
          itemsCount: nextProps.items.length,
          rowCount: Math.ceil(nextProps.items.length / this.state.columnCount)
        });
      }
    }

    componentDidUpdate() {
      this.scrollAfterRender();
    }

    componentWillUnmount() {
      this.rowContainer.ownerDocument.defaultView.removeEventListener('resize', this.onResize, false);
      clearTimeout(this.debouncedScrollTimeoutId);
    }

    onScroll() {
      if (this.props.onScrollEnded) {
        if (this.debouncedScrollTimeoutId) {
          clearTimeout(this.debouncedScrollTimeoutId);
        }
        this.debouncedScrollTimeoutId = setTimeout(this.props.onScrollEnded, 150);
      }
    }

    onResize() {
      if (!this.cell) return;
      const cellNode = _reactDom2.default.findDOMNode(this.cell);
      const cellDimensions = cellNode.getBoundingClientRect();
      const cellMarginBottom = parseInt(cellNode.ownerDocument.defaultView.getComputedStyle(cellNode).marginBottom, 10) || 0;
      const rowDimensions = this.rowContainer.getBoundingClientRect();

      const columnWidth = cellDimensions.width;
      const rowWidth = rowDimensions.width;
      const rowHeight = cellDimensions.height + cellMarginBottom;
      const columnCount = Math.floor(rowWidth / cellDimensions.width);
      const rowCount = Math.ceil(this.state.itemsCount / columnCount);

      this.setState({
        columnWidth,
        rowHeight,
        columnCount,
        rowCount,
        rowWidth
      });
    }

    scrollAfterRender() {
      if (this.gridNode && this.props.indexToScrollTo > -1) {
        const scrollY = window.pageYOffset;
        const gridRect = this.gridNode.getBoundingClientRect();
        const rowIndex = Math.floor(this.props.indexToScrollTo / this.state.columnCount);
        const topOfCell = scrollY + gridRect.top + rowIndex * this.state.rowHeight;
        const topOfCellDiffers = topOfCell !== this.lastScrollToIndexTopOfCell;
        const rowHeightDiffers = this.state.rowHeight !== this.lastScrollToIndexRowHeight;

        if (topOfCellDiffers || rowHeightDiffers) {
          this.lastScrollToIndexTopOfCell = topOfCell;
          this.lastScrollToIndexRowHeight = this.state.rowHeight;
          this.props.scrollToPositionY(topOfCell, this.state.rowHeight);
        }
      }
    }

    cellRenderer({ columnIndex, rowIndex, key, style }) {
      const index = rowIndex * this.state.columnCount + columnIndex;

      return _react2.default.createElement(
        'div',
        {
          key: key,
          style: style,
          className: 'col-xs-12 col-sm-8 col-md-6 col-lg-4'
        },
        this.renderItem(index)
      );
    }

    renderItem(index) {
      let item = this.props.items[index === -1 ? 0 : index];
      if (!item) return null;
      if (index === -1) {
        item = _extends({}, item, {
          uri: 'spotify:internal:no-play',
          link: 'spotify:internal:no-play'
        });
      }
      return this.props.renderItem(item, index);
    }

    render() {
      return _react2.default.createElement(
        'div',
        {
          ref: node => {
            this.gridNode = node;
          },
          className: 'GlueResponsiveVirtualGrid'
        },
        _react2.default.createElement(
          'div',
          {
            className: 'row standard-grid',
            ref: rowContainer => this.rowContainer = rowContainer
          },

          // Render an invisible cell used for measuring.
          _react2.default.createElement(
            'div',
            {
              ref: cell => this.cell = cell,
              style: {
                opacity: '0'
              },
              className: 'GlueResponsiveVirtualGrid__sample-cell col-xs-12 col-sm-8 col-md-6 col-lg-4 '
            },
            this.renderItem(-1)
          ),
          _react2.default.createElement(
            'div',
            { 'data-ta-id': 'list-items' },
            _react2.default.createElement(
              _reactVirtualized.WindowScroller,
              { onScroll: this.onScroll },
              ({ height, isScrolling, scrollTop }) => {
                // This is a hack to tell the Grid to clean up it's cell cache,
                // which it doesn't normally use when a WindowScroller controls its
                // scrolling.
                if (this.gridInstance) this.gridInstance._debounceScrollEnded();

                return _react2.default.createElement(_reactVirtualized.Grid, {
                  ref: gridInstance => this.gridInstance = gridInstance
                  // When using the WindowScroller HOC, the Grid doesn't scroll
                  // itself anymore, so we must tell it the WindowScroller is
                  // scrolling to trigger `react-virtualized`'s' cell caching during
                  // the scroll.
                  , cellRangeRenderer: args => (0, _reactVirtualized.defaultCellRangeRenderer)(_extends({}, args, { isScrolling })),
                  cellRenderer: this.cellRenderer,
                  columnCount: this.state.columnCount,
                  columnWidth: this.state.columnWidth,
                  autoHeight: true,
                  height: height,
                  rowCount: this.state.rowCount,
                  rowHeight: this.state.rowHeight,
                  scrollTop: scrollTop,
                  width: this.state.rowWidth,
                  onSectionRendered: this.props.onSectionRendered,
                  overscanColumnCount: 0,
                  overscanRowCount: 1,
                  tabIndex: null,
                  containerStyle: { overflow: 'visible' },
                  style: { overflowX: 'visible', overflowY: 'visible' }
                });
              }
            )
          )
        )
      );
    }
  }

  exports.default = GlueResponsiveVirtualGrid;
  GlueResponsiveVirtualGrid.propTypes = {
    items: _propTypes2.default.array,
    renderItem: _propTypes2.default.func,
    onScrollEnded: _propTypes2.default.func,
    onSectionRendered: _propTypes2.default.func,
    indexToScrollTo: _propTypes2.default.number,
    scrollToPositionY: _propTypes2.default.func
  };

  GlueResponsiveVirtualGrid.defaultProps = {
    items: [],
    renderItem: () => null,
    onScrollEnded() {},
    onSectionRendered() {},
    indexToScrollTo: -1,
    scrollToPositionY() {}
  };

  },{"prop-types":827,"react":1253,"react-dom":1157,"react-virtualized":1238}],136:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _classnames = require('classnames');

  var _classnames2 = _interopRequireDefault(_classnames);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  class GlueToggle extends _react2.default.PureComponent {
    constructor(...args) {
      super(...args);

      this.handleChange = this.handleChange.bind(this);
    }

    handleChange() {
      if (this.props.isDisabled) return;

      this.props.onChange(!this.props.isActive);
    }

    render() {
      const { isActive, isDisabled, labelId, taId } = this.props;
      return _react2.default.createElement(
        'div',
        {
          className: (0, _classnames2.default)('GlueToggle', {
            'GlueToggle--is-active': isActive,
            'GlueToggle--is-disabled': isDisabled
          })
        },
        _react2.default.createElement('input', {
          type: 'checkbox',
          name: labelId,
          id: labelId,
          className: 'glue-hidden-visually',
          onChange: this.handleChange,
          checked: isActive,
          disabled: isDisabled,
          'data-ta-id': taId
        }),
        _react2.default.createElement(
          'div',
          {
            className: 'GlueToggle__toggle',
            onClick: this.handleChange,
            'aria-hidden': 'true'
          },
          _react2.default.createElement('div', { className: 'GlueToggle__toggle-inner' })
        )
      );
    }
  }

  exports.default = GlueToggle;
  GlueToggle.propTypes = {
    isActive: _propTypes2.default.bool,
    isDisabled: _propTypes2.default.bool,
    onChange: _propTypes2.default.func,
    labelId: _propTypes2.default.string,
    taId: _propTypes2.default.string
  };

  GlueToggle.defaultProps = {
    isActive: false,
    isDisabled: false,
    onChange: () => {}
  };

  },{"classnames":698,"prop-types":827,"react":1253}],137:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "a {0} další(ch)",
    "Artist": "Umělec",
    "By": "od",
    "ByLabel": "Od",
    "Create Similar Playlist": "Vytvořit podobný playlist",
    "DateAdded": "Datum přidání",
    "Duration": "Délka",
    "Recommended Songs": "Doporučené skladby",
    "Filter": "Filtr",
    "Follow": "Sledovat",
    "Follower": "Sledující",
    "FollowersLabel": {
      "one": "Sledující",
      "other": "sledujících"
    },
    "FollowersCount": {
      "one": "{0} sledující",
      "other": "{0} sledujících"
    },
    "Following": "Sleduješ",
    "FollowingLabel": "Sleduješ",
    "ListenersLabel": "Posluchačů měsíčně",
    "FollowsYou": "Sleduje tě",
    "HoldToPreview": "Pro náhled klikni a podrž",
    "ListenCount": {
      "one": "1 přehrání",
      "other": "{0} přehrání"
    },
    "ListenReactionMulti": "{0} posluchačů ve tvé síti",
    "ListenReactionSingle": "{0} uživatelů tohle poslouchá",
    "LocalFile": "Místní soubory",
    "More": "dalších",
    "MoreSongsLoad": "Během přehrávání se načtou další skladby.",
    "Pause": "Pozastavit",
    "Play": "Přehrát",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Přehrávání spustíš stisknutím klávesy Enter",
    "Popularity": "Popularita",
    "Progress": "Postup",
    "Remove": "Odstranit",
    "RemoveYourMusic": "Odstranit ze sbírky Tvoje knihovna",
    "Save": "Uložit",
    "SaveYourMusic": "Uložit do sbírky Tvoje knihovna",
    "Saved": "Uloženo",
    "StartRadio": "Spustit rádio",
    "Time": "Čas",
    "Title": "Název",
    "Toplist": "Top skladby",
    "Track": "Skladba",
    "Unfollow": "Přestat sledovat",
    "User": "Uživatel",
    "ViewAll": "Zobrazit vše",
    "HoursShort": "{0} h",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} s",
    "ErrorTitle": "Při zobrazování této stránky došlo k problému!",
    "ErrorMessage": "Tato stránka buď neexistuje, nebo došlo k chybě.",
    "OfflineTitle": "Tato stránka není dostupná offline!",
    "OfflineMessage": "Pro načtení přejdi prosím online.",
    "MadeFor": "Speciálně pro uživatele {0}",
    "heart_label": "Líbí se mi",
    "undo_heart_label": "Líbilo se mi",
    "ban_label": "Odstranit",
    "format_list.ban_label": "Nelíbí se mi",
    "format_list.undo_ban_label": "Tohle se ti nelíbí",
    "VariousArtistsCapitalized": "Různí umělci"
  }
  },{}],138:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "und {0} weitere",
    "Artist": "Künstler",
    "By": "von",
    "ByLabel": "Von",
    "Create Similar Playlist": "Ähnliche Playlist erstellen",
    "DateAdded": "Datum hinzugefügt",
    "Duration": "Dauer",
    "Recommended Songs": "Empfohlene Songs",
    "Filter": "Filter",
    "Follow": "Folgen",
    "Follower": "Follower",
    "FollowersLabel": {
      "one": "Follower",
      "other": "Follower"
    },
    "FollowersCount": {
      "one": "{0} Follower",
      "other": "{0} Follower"
    },
    "Following": "Folge ich",
    "FollowingLabel": "Folge ich",
    "ListenersLabel": "Monatliche Hörer",
    "FollowsYou": "Folgt dir",
    "HoldToPreview": "Zum Reinhören gedrückt halten",
    "ListenCount": {
      "one": "1 Wiedergabe",
      "other": "{0} Mal abgespielt"
    },
    "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
    "ListenReactionSingle": "{0} hört sich das an",
    "LocalFile": "Lokale Datei",
    "More": "Mehr",
    "MoreSongsLoad": "Während du Musik hörst, werden weitere Songs geladen.",
    "Pause": "Pause",
    "Play": "Play",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
    "Popularity": "Beliebtheit",
    "Progress": "Fortschritt",
    "Remove": "Entfernen",
    "RemoveYourMusic": "Aus Bibliothek entfernen",
    "Save": "Speichern",
    "SaveYourMusic": "In Bibliothek speichern",
    "Saved": "Gespeichert",
    "StartRadio": "Radio starten",
    "Time": "Dauer",
    "Title": "Titel",
    "Toplist": "Top-Songs",
    "Track": "Song",
    "Unfollow": "Nicht mehr folgen",
    "User": "Benutzer",
    "ViewAll": "Mehr Darstellung",
    "HoursShort": "{0} Std.",
    "MinutesShort": "{0} Min.",
    "SecondsShort": "{0} Sek.",
    "ErrorTitle": "Bei der Anzeige dieser Seite ist ein Fehler aufgetreten.",
    "ErrorMessage": "Diese Seite ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
    "OfflineTitle": "Diese Seite ist offline nicht verfügbar.",
    "OfflineMessage": "Geh zum Laden online.",
    "MadeFor": "Für {0}",
    "heart_label": "Gefällt mir",
    "undo_heart_label": "Gefällt mir",
    "ban_label": "Entfernen",
    "format_list.ban_label": "Gefällt mir nicht",
    "format_list.undo_ban_label": "Das gefällt dir nicht",
    "VariousArtistsCapitalized": "Diverse Künstler"
  }
  },{}],139:[function(require,module,exports){
  module.exports={
    "Album": "Άλμπουμ",
    "AndMore": "και άλλοι {0}",
    "Artist": "Καλλιτέχνης",
    "By": "από",
    "ByLabel": "Από",
    "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
    "DateAdded": "Προστέθηκε ημερομηνία",
    "Duration": "Διάρκεια",
    "Recommended Songs": "Προτεινόμενα τραγούδια",
    "Filter": "Φίλτρο",
    "Follow": "Ακολούθησε",
    "Follower": "Οπαδός",
    "FollowersLabel": {
      "one": "Οπαδός",
      "other": "Ακόλουθοι"
    },
    "FollowersCount": {
      "one": "{0} οπαδός",
      "other": "{0} οπαδοί"
    },
    "Following": "Aκολουθείται",
    "FollowingLabel": "Aκολουθείται",
    "ListenersLabel": "Μηνιαίοι ακροατές",
    "FollowsYou": "Σε ακολουθεί",
    "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
    "ListenCount": {
      "one": "1 αναπαραγωγή",
      "other": "{0} αναπαραγωγές"
    },
    "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
    "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
    "LocalFile": "Τοπικό αρχείο",
    "More": "Περισσότερα",
    "MoreSongsLoad": "Περισσότερα τραγούδια φορτώνουν ενώ ακούς",
    "Pause": "Παύση",
    "Play": "Αναπαραγωγή",
    "Playlist": "Λίστα",
    "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
    "Popularity": "Δημοφιλία",
    "Progress": "Πρόοδος",
    "Remove": "Αφαίρεση",
    "RemoveYourMusic": "Αφαίρεση από τη Βιβλιοθήκη",
    "Save": "Αποθήκευση",
    "SaveYourMusic": "Αποθήκευση στη Βιβλιοθήκη",
    "Saved": "Αποθηκεύτηκε",
    "StartRadio": "Έναρξη ράδιο",
    "Time": "Διάρκεια",
    "Title": "Τίτλος",
    "Toplist": "Κορυφαία τραγούδια",
    "Track": "Τραγούδι",
    "Unfollow": "Άρση ακολούθησης",
    "User": "Χρήστης",
    "ViewAll": "Δες τα όλα",
    "HoursShort": "{0} ώρα",
    "MinutesShort": "{0} λεπ.",
    "SecondsShort": "{0} δευτ.",
    "ErrorTitle": "Παρουσιάστηκε πρόβλημα κατά την προβολή αυτής της σελίδας!",
    "ErrorMessage": "Αυτή η σελίδα δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
    "OfflineTitle": "Αυτή η σελίδα δεν είναι διαθέσιμη εκτός σύνδεσης!",
    "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
    "MadeFor": "Ειδικά για: {0}",
    "heart_label": "Μου αρέσει",
    "undo_heart_label": "Αρέσει σε",
    "ban_label": "Αφαίρεση",
    "format_list.ban_label": "Δεν μου αρέσει",
    "format_list.undo_ban_label": "Δεν σου αρέσει αυτό",
    "VariousArtistsCapitalized": "Διάφοροι καλλιτέχνες"
  }
  },{}],140:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "and {0} more",
    "Artist": "Artist",
    "By": "by",
    "ByLabel": "By",
    "Create Similar Playlist": "Create Similar Playlist",
    "DateAdded": "Date Added",
    "Duration": "Duration",
    "Recommended Songs": "Recommended Songs",
    "Filter": "Filter",
    "Follow": "Follow",
    "Follower": "Follower",
    "FollowersLabel": {
      "one": "Follower",
      "other": "Followers"
    },
    "FollowersCount": {
      "one": "{0} follower",
      "other": "{0} followers"
    },
    "Following": "Following",
    "FollowingLabel": "Following",
    "ListenersLabel": "Monthly Listeners",
    "FollowsYou": "Follows You",
    "HoldToPreview": "Click and Hold to Preview",
    "ListenCount": {
      "one": "1 play",
      "other": "{0} plays"
    },
    "ListenReactionMulti": "{0} listeners in your network",
    "ListenReactionSingle": "{0} listens to this",
    "LocalFile": "Local File",
    "More": "More",
    "MoreSongsLoad": "More songs load as you listen",
    "Pause": "Pause",
    "Play": "Play",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Press Enter to play",
    "Popularity": "Popularity",
    "Progress": "Progress",
    "Remove": "Remove",
    "RemoveYourMusic": "Remove from Your Library",
    "Save": "Save",
    "SaveYourMusic": "Save to Your Library",
    "Saved": "Saved",
    "StartRadio": "Start Radio",
    "Time": "Time",
    "Title": "Title",
    "Toplist": "Top songs",
    "Track": "Song",
    "Unfollow": "Unfollow",
    "User": "User",
    "ViewAll": "View All",
    "HoursShort": "{0} hr",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} sec",
    "ErrorTitle": "There was a problem displaying this page!",
    "ErrorMessage": "This page either does not exist or an error occurred.",
    "OfflineTitle": "This page is not available offline!",
    "OfflineMessage": "Please go online to load.",
    "MadeFor": "Made for {0}",
    "heart_label": "Like",
    "undo_heart_label": "Liked",
    "ban_label": "Remove",
    "format_list.ban_label": "Don't like",
    "format_list.undo_ban_label": "You don't like this",
    "VariousArtistsCapitalized": "Various artists"
  }
  },{}],141:[function(require,module,exports){
  module.exports={
    "Album": "Álbum",
    "AndMore": "y {0} más",
    "Artist": "Artista",
    "By": "por",
    "ByLabel": "De",
    "Create Similar Playlist": "Crear playlist similar",
    "DateAdded": "Fecha agregada",
    "Duration": "Duración",
    "Recommended Songs": "Canciones recomendadas",
    "Filter": "Filtrar",
    "Follow": "Seguir",
    "Follower": "Seguidor",
    "FollowersLabel": {
      "one": "Seguidor",
      "other": "Seguidores"
    },
    "FollowersCount": {
      "one": "{0} seguidor",
      "other": "{0} seguidores"
    },
    "Following": "Siguiendo",
    "FollowingLabel": "Siguiendo",
    "ListenersLabel": "Oyentes mensuales",
    "FollowsYou": "Te sigue",
    "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
    "ListenCount": {
      "one": "1 reproducción",
      "other": "{0} reproducciones"
    },
    "ListenReactionMulti": "{0} oyentes en tu red",
    "ListenReactionSingle": "{0} escucha esto",
    "LocalFile": "Archivo local",
    "More": "Más",
    "MoreSongsLoad": "Se cargarán más canciones a medida que escuchas",
    "Pause": "Pausa",
    "Play": "Reproducir",
    "Playlist": "Lista",
    "PressEnterToPlay": "Presiona Enter para reproducir",
    "Popularity": "Popularidad",
    "Progress": "Progreso",
    "Remove": "Eliminar",
    "RemoveYourMusic": "Eliminar de Tu Biblioteca",
    "Save": "Guardar",
    "SaveYourMusic": "Guardar en Tu Biblioteca",
    "Saved": "Guardado",
    "StartRadio": "Comenzar Radio",
    "Time": "Tiempo",
    "Title": "Título",
    "Toplist": "Canciones más reproducidas",
    "Track": "Canción",
    "Unfollow": "Dejar de seguir",
    "User": "Usuario",
    "ViewAll": "Ver todos",
    "HoursShort": "{0} hr",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} seg",
    "ErrorTitle": "Hubo un problema al mostrar esta página.",
    "ErrorMessage": "Puede ser que esta página no exista o que haya ocurrido un error.",
    "OfflineTitle": "Esta página no se encuentra disponible sin conexión.",
    "OfflineMessage": "Conéctate a la red para cargar.",
    "MadeFor": "Hecho para {0}",
    "heart_label": "Me gusta",
    "undo_heart_label": "Te gusta esto",
    "ban_label": "Eliminar",
    "format_list.ban_label": "No me gusta",
    "format_list.undo_ban_label": "No te gusta esto",
    "VariousArtistsCapitalized": "Varios artistas"
  }
  },{}],142:[function(require,module,exports){
  module.exports={
    "Album": "Álbum",
    "AndMore": "y {0} más",
    "Artist": "Artista",
    "By": "por",
    "ByLabel": "De",
    "Create Similar Playlist": "Crear playlist similar",
    "DateAdded": "Fecha en la que se añadió",
    "Duration": "Duración",
    "Recommended Songs": "Canciones recomendadas",
    "Filter": "Filtrar",
    "Follow": "Seguir",
    "Follower": "Seguidor",
    "FollowersLabel": {
      "one": "Seguidor",
      "other": "Seguidores"
    },
    "FollowersCount": {
      "one": "{0} seguidor",
      "other": "{0} seguidores"
    },
    "Following": "Siguiendo",
    "FollowingLabel": "Siguiendo",
    "ListenersLabel": "Oyentes mensuales",
    "FollowsYou": "Te sigue",
    "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
    "ListenCount": {
      "one": "1 reproducción",
      "other": "{0} reproducciones"
    },
    "ListenReactionMulti": "{0} oyentes en tu red",
    "ListenReactionSingle": "{0} escucha esto",
    "LocalFile": "Archivo local",
    "More": "Más",
    "MoreSongsLoad": "Se cargarán más canciones mientras escuchas",
    "Pause": "Pausar",
    "Play": "Reproducir",
    "Playlist": "Lista",
    "PressEnterToPlay": "Pulsa Intro para reproducir",
    "Popularity": "Popularidad",
    "Progress": "Completado",
    "Remove": "Retirar",
    "RemoveYourMusic": "Eliminar de Tu biblioteca",
    "Save": "Guardar",
    "SaveYourMusic": "Guardar en Tu biblioteca",
    "Saved": "Guardada",
    "StartRadio": "Comenzar radio",
    "Time": "Tiempo",
    "Title": "Título",
    "Toplist": "Canciones más escuchadas",
    "Track": "Canción",
    "Unfollow": "Dejar de seguir",
    "User": "Usuario",
    "ViewAll": "Ver todos",
    "HoursShort": "{0} hr",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} seg",
    "ErrorTitle": "Se ha producido un problema al mostrar esta página.",
    "ErrorMessage": "Esta página no existe o se ha producido un error.",
    "OfflineTitle": "Esta página no está disponible sin conexión.",
    "OfflineMessage": "Por favor, conéctate para cargar.",
    "MadeFor": "Hecha para {0}",
    "heart_label": "Me gusta",
    "undo_heart_label": "Te gusta",
    "ban_label": "Retirar",
    "format_list.ban_label": "No me gusta",
    "format_list.undo_ban_label": "No te gusta esto",
    "VariousArtistsCapitalized": "Varios artistas"
  }
  },{}],143:[function(require,module,exports){
  module.exports={
    "Album": "Albumi",
    "AndMore": "ja {0} muuta",
    "Artist": "Artisti",
    "By": "tekijältä",
    "ByLabel": "tekijältä",
    "Create Similar Playlist": "Luo samankaltainen soittolista",
    "DateAdded": "Lisäyspäivä",
    "Duration": "Kesto",
    "Recommended Songs": "Suositellut kappaleet",
    "Filter": "Suodatin",
    "Follow": "Seuraa",
    "Follower": "Seuraaja",
    "FollowersLabel": {
      "one": "Seuraaja",
      "other": "Seuraajat"
    },
    "FollowersCount": {
      "one": "{0} seuraaja",
      "other": "{0} seuraajaa"
    },
    "Following": "Seurataan",
    "FollowingLabel": "Seurataan",
    "ListenersLabel": "Kuuntelijat kuukauden aikana",
    "FollowsYou": "Seuraa sinua",
    "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
    "ListenCount": {
      "one": "1 toisto",
      "other": "{0} toistoa"
    },
    "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
    "ListenReactionSingle": "{0} kuuntelee tätä",
    "LocalFile": "Paikallinen tiedosto",
    "More": "Lisää",
    "MoreSongsLoad": "Lisää kappaleita ladataan kuuntelun aikana",
    "Pause": "Tauko",
    "Play": "Toista",
    "Playlist": "Soittolista",
    "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
    "Popularity": "Suosio",
    "Progress": "Edistyminen",
    "Remove": "Poista",
    "RemoveYourMusic": "Poista omasta kirjastosta",
    "Save": "Tallenna",
    "SaveYourMusic": "Tallenna omaan kirjastoon",
    "Saved": "Tallennettu",
    "StartRadio": "Käynnistä radio",
    "Time": "Kesto",
    "Title": "Nimi",
    "Toplist": "Suosituimmat kappaleet",
    "Track": "Kappale",
    "Unfollow": "Lopeta seuraaminen",
    "User": "Käyttäjä",
    "ViewAll": "Näytä kaikki",
    "HoursShort": "{0} h",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} s",
    "ErrorTitle": "Sivun näyttämisessä ilmeni ongelma!",
    "ErrorMessage": "Sivua ei ole, tai tapahtui virhe.",
    "OfflineTitle": "Sivu ei ole saatavilla offline-tilassa!",
    "OfflineMessage": "Siirry online-tilaan, jotta voit ladata.",
    "MadeFor": "Luotu käyttäjälle {0}",
    "heart_label": "Tykkää",
    "undo_heart_label": "Tykätty",
    "ban_label": "Poista",
    "format_list.ban_label": "En tykkää",
    "format_list.undo_ban_label": "Et tykkää tästä",
    "VariousArtistsCapitalized": "Eri esittäjiä"
  }
  },{}],144:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "et {0} autres",
    "Artist": "Artiste",
    "By": "par",
    "ByLabel": "Par",
    "Create Similar Playlist": "Créer une liste de lecture semblable",
    "DateAdded": "Ajouté le",
    "Duration": "Durée",
    "Recommended Songs": "Chansons recommandées",
    "Filter": "Filtrer",
    "Follow": "Suivre",
    "Follower": "Abonné",
    "FollowersLabel": {
      "one": "Abonné",
      "other": "Abonné"
    },
    "FollowersCount": {
      "one": "{0} abonné",
      "other": "{0} abonnés"
    },
    "Following": "Suivis",
    "FollowingLabel": "Suivis",
    "ListenersLabel": "Auditeurs mensuels",
    "FollowsYou": "Vous suit",
    "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
    "ListenCount": {
      "one": "1 lecture",
      "other": "{0} écoutes"
    },
    "ListenReactionMulti": "{0} auditeurs dans votre réseau",
    "ListenReactionSingle": "{0} écoute ceci",
    "LocalFile": "Fichier local",
    "More": "Plus",
    "MoreSongsLoad": "D'autres chansons se chargent pendant que vous écoutez",
    "Pause": "Pause",
    "Play": "Lecture",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
    "Popularity": "Popularité",
    "Progress": "Progression",
    "Remove": "Supprimer",
    "RemoveYourMusic": "Supprimer de la Bibliothèque",
    "Save": "Sauvegarder",
    "SaveYourMusic": "Enregistrer dans la Bibliothèque",
    "Saved": "Sauvegardé",
    "StartRadio": "Lancer la radio",
    "Time": "Durée",
    "Title": "Titre",
    "Toplist": "Meilleures chansons",
    "Track": "Titre",
    "Unfollow": "Ne plus suivre",
    "User": "Utilisateur",
    "ViewAll": "Voir tout",
    "HoursShort": "{0} h",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} s",
    "ErrorTitle": "Un problème est survenu lors de l'affichage de cette page!",
    "ErrorMessage": "Cette page n'existe pas ou une erreur s'est produite.",
    "OfflineTitle": "Cette page n'est pas accessible hors ligne!",
    "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu.",
    "MadeFor": "Créée pour {0}",
    "heart_label": "J'aime",
    "undo_heart_label": "A aimé",
    "ban_label": "Supprimer",
    "format_list.ban_label": "Je n'aime pas",
    "format_list.undo_ban_label": "Vous n’aimez pas cela",
    "VariousArtistsCapitalized": "Différents artistes"
  }
  },{}],145:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "et {0} autres",
    "Artist": "Artiste",
    "By": "par",
    "ByLabel": "Par",
    "Create Similar Playlist": "Créer une playlist similaire",
    "DateAdded": "Ajouté le",
    "Duration": "Durée",
    "Recommended Songs": "Titres recommandés",
    "Filter": "Filtre",
    "Follow": "S'abonner",
    "Follower": "Abonné",
    "FollowersLabel": {
      "one": "Abonné",
      "other": "Abonnés"
    },
    "FollowersCount": {
      "one": "{0} abonné",
      "other": "{0} abonnés"
    },
    "Following": "Abonné",
    "FollowingLabel": "Abonné",
    "ListenersLabel": "Nombres de personnes qui écoutent par mois",
    "FollowsYou": "Est abonné à vous",
    "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
    "ListenCount": {
      "one": "1 lecture",
      "other": "{0} écoutes"
    },
    "ListenReactionMulti": "{0} auditeurs dans votre réseau",
    "ListenReactionSingle": "{0} écoute ceci.",
    "LocalFile": "Fichier local",
    "More": "Plus",
    "MoreSongsLoad": "D'autres titres se chargent pendant que vous écoutez.",
    "Pause": "Pause",
    "Play": "Lire",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
    "Popularity": "Popularité",
    "Progress": "Progression",
    "Remove": "Supprimer",
    "RemoveYourMusic": "Supprimer de Bibliothèque",
    "Save": "Sauvegarder",
    "SaveYourMusic": "Sauvegarder dans Bibliothèque",
    "Saved": "Sauvegardé",
    "StartRadio": "Ecouter la radio",
    "Time": "Durée",
    "Title": "Titre",
    "Toplist": "Top titres",
    "Track": "Titre",
    "Unfollow": "Se désabonner",
    "User": "Utilisateur",
    "ViewAll": "Présentation tout",
    "HoursShort": "{0} h",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} s",
    "ErrorTitle": "Problème d'affichage !",
    "ErrorMessage": "Cette page n'existe pas, ou une erreur s'est produite.",
    "OfflineTitle": "Cette page n'est pas disponible hors connexion !",
    "OfflineMessage": "Connectez-vous pour procéder au chargement.",
    "MadeFor": "Concocté pour {0}",
    "heart_label": "J'aime",
    "undo_heart_label": "A aimé",
    "ban_label": "Supprimer",
    "format_list.ban_label": "Je n'aime pas",
    "format_list.undo_ban_label": "Vous n'aimez pas ce contenu",
    "VariousArtistsCapitalized": "Différents artistes"
  }
  },{}],146:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "és még {0} felhasználó",
    "Artist": "Előadó",
    "By": "tőle:",
    "ByLabel": "Tőle:",
    "Create Similar Playlist": "Hasonló műsorlista létrehozása",
    "DateAdded": "Dátum hozzáadva",
    "Duration": "Időtartam",
    "Recommended Songs": "Ajánlott dalok",
    "Filter": "Szűrő",
    "Follow": "Követés",
    "Follower": "Követő",
    "FollowersLabel": {
      "one": "Követő",
      "other": "Követők"
    },
    "FollowersCount": {
      "one": "{0} követő",
      "other": "{0} követő"
    },
    "Following": "Követések",
    "FollowingLabel": "Követések",
    "ListenersLabel": "Hallgatók havonta",
    "FollowsYou": "Téged követ",
    "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
    "ListenCount": {
      "one": "1 lejátszás",
      "other": "{0} lejátszás"
    },
    "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
    "ListenReactionSingle": "{0} már meghallgatta",
    "LocalFile": "Helyi fájl",
    "More": "Több",
    "MoreSongsLoad": "Lesz még szám, csak hallgasd tovább",
    "Pause": "Szünet",
    "Play": "Lejátszás",
    "Playlist": "Lejátszási lista",
    "PressEnterToPlay": "Lejátszás az Enterrel",
    "Popularity": "Népszerűség",
    "Progress": "Állapot",
    "Remove": "Eltávolítás",
    "RemoveYourMusic": "Törlés a Gyűjteményemből",
    "Save": "Mentés",
    "SaveYourMusic": "Mentés a Gyűjteményedbe",
    "Saved": "Mentett",
    "StartRadio": "Rádió bekapcsolása",
    "Time": "Idő",
    "Title": "Cím",
    "Toplist": "Toplista",
    "Track": "Dal",
    "Unfollow": "Nem követem",
    "User": "Felhasználó",
    "ViewAll": "Mindent mutat",
    "HoursShort": "{0} óra",
    "MinutesShort": "{0} perc",
    "SecondsShort": "{0} mp",
    "ErrorTitle": "Hiba történt az oldal megjelenítésekor.",
    "ErrorMessage": "Az oldal nem létezik, vagy hiba történt.",
    "OfflineTitle": "Ez az oldal offline módban nem érhető el.",
    "OfflineMessage": "Csatlakozz az internethez, majd indítsd el.",
    "MadeFor": "{0} felhasználónak készült",
    "heart_label": "Tetszik",
    "undo_heart_label": "Kedvelted",
    "ban_label": "Eltávolítás",
    "format_list.ban_label": "Nem tetszik",
    "format_list.undo_ban_label": "Ez nem tetszett neked",
    "VariousArtistsCapitalized": "Különböző előadók"
  }
  },{}],147:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "dan {0} lagi",
    "Artist": "Artis",
    "By": "menurut",
    "ByLabel": "Dari",
    "Create Similar Playlist": "Buat Playlist Serupa",
    "DateAdded": "Tanggal Dimuat",
    "Duration": "Durasi",
    "Recommended Songs": "Lagu yang Direkomendasikan",
    "Filter": "Filter",
    "Follow": "Ikuti",
    "Follower": "Pengikut",
    "FollowersLabel": {
      "one": "Pengikut",
      "other": "Pengikut"
    },
    "FollowersCount": {
      "one": "{0} pengikut",
      "other": "{0} pengikut"
    },
    "Following": "Mengikuti",
    "FollowingLabel": "Mengikuti",
    "ListenersLabel": "Pendengar Bulanan",
    "FollowsYou": "Mengikutimu",
    "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
    "ListenCount": {
      "one": "1 pemutaran",
      "other": "{0} permainan"
    },
    "ListenReactionMulti": "{0} pendengar di jaringanmu",
    "ListenReactionSingle": "{0} mendengarkan ini",
    "LocalFile": "File Lokal",
    "More": "Lainnya",
    "MoreSongsLoad": "Lebih banyak lagu dimuat saat kamu mendengarkan",
    "Pause": "Jeda",
    "Play": "Play",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Tekan Enter untuk memainkan",
    "Popularity": "Popularitas",
    "Progress": "Kemajuan",
    "Remove": "Hapus",
    "RemoveYourMusic": "Hapus dari Koleksi Kamu",
    "Save": "Simpan",
    "SaveYourMusic": "Simpan ke Koleksi Kamu",
    "Saved": "Tersimpan",
    "StartRadio": "Mulai Radio",
    "Time": "Waktu",
    "Title": "Judul",
    "Toplist": "Lagu teratas",
    "Track": "Lagu",
    "Unfollow": "Berhenti mengikuti",
    "User": "Pengguna",
    "ViewAll": "Lihat Semua",
    "HoursShort": "{0} jam",
    "MinutesShort": "{0} mnt",
    "SecondsShort": "{0} dtk",
    "ErrorTitle": "Ada masalah saat menampilkan halaman ini!",
    "ErrorMessage": "Halaman ini tidak ada atau terjadi kesalahan.",
    "OfflineTitle": "Halaman ini tidak tersedia secara offline!",
    "OfflineMessage": "Alihkan ke online untuk memuat.",
    "MadeFor": "Dibuat untuk {0}",
    "heart_label": "Suka",
    "undo_heart_label": "Disukai",
    "ban_label": "Hapus",
    "format_list.ban_label": "Tidak suka",
    "format_list.undo_ban_label": "Kamu tidak suka ini",
    "VariousArtistsCapitalized": "Berbagai artis"
  }
  },{}],148:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "e altri {0}",
    "Artist": "Artista",
    "By": "per",
    "ByLabel": "di",
    "Create Similar Playlist": "Crea playlist simile",
    "DateAdded": "Aggiunto il",
    "Duration": "Durata",
    "Recommended Songs": "Brani consigliati",
    "Filter": "Filtra",
    "Follow": "Segui",
    "Follower": "Follower",
    "FollowersLabel": {
      "one": "Follower",
      "other": "Follower"
    },
    "FollowersCount": {
      "one": "{0} follower",
      "other": "{0} follower"
    },
    "Following": "Following",
    "FollowingLabel": "Following",
    "ListenersLabel": "Ascoltatori questo mese",
    "FollowsYou": "Ti segue",
    "HoldToPreview": "Tieni premuto per un'anteprima",
    "ListenCount": {
      "one": "1 riproduzione",
      "other": "{0} riproduzioni"
    },
    "ListenReactionMulti": "{0} ascoltatori nella tua rete",
    "ListenReactionSingle": "{0} ascolta questo",
    "LocalFile": "File locale",
    "More": "Più",
    "MoreSongsLoad": "Durante l'ascolto vengono caricati altri brani",
    "Pause": "Pausa",
    "Play": "Play",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Premi Invio per riprodurre",
    "Popularity": "Popolarità",
    "Progress": "Progress",
    "Remove": "Rimuovi",
    "RemoveYourMusic": "Elimina da La tua libreria",
    "Save": "Salva",
    "SaveYourMusic": "Salva in La tua libreria",
    "Saved": "Salvato",
    "StartRadio": "Crea una radio",
    "Time": "Durata",
    "Title": "Titolo",
    "Toplist": "Brani top",
    "Track": "Brano",
    "Unfollow": "Non seguire più",
    "User": "Utente",
    "ViewAll": "Visualizza tutto",
    "HoursShort": "{0} ore",
    "MinutesShort": "{0} min.",
    "SecondsShort": "{0} sec",
    "ErrorTitle": "Si è verificato un errore nella visualizzazione di questa pagina.",
    "ErrorMessage": "Questa pagina non esiste o si è verificato un errore.",
    "OfflineTitle": "Questa pagina non è disponibile offline.",
    "OfflineMessage": "Passa online per caricare.",
    "MadeFor": "Realizzata per {0}",
    "heart_label": "Preferiti",
    "undo_heart_label": "Preferiti",
    "ban_label": "Rimuovi",
    "format_list.ban_label": "Non mi piace",
    "format_list.undo_ban_label": "Questo elemento non ti piace",
    "VariousArtistsCapitalized": "Artisti vari"
  }
  },{}],149:[function(require,module,exports){
  module.exports={
    "Album": "アルバム",
    "AndMore": "その他{0}人",
    "Artist": "アーティスト",
    "By": "/",
    "ByLabel": "/",
    "Create Similar Playlist": "同様のプレイリストを作成",
    "DateAdded": "追加日",
    "Duration": "期間",
    "Recommended Songs": "おすすめの曲",
    "Filter": "フィルター",
    "Follow": "フォロー",
    "Follower": "フォロワー",
    "FollowersLabel": {
      "one": "フォロワー",
      "other": "フォロワー"
    },
    "FollowersCount": {
      "one": "{0}人のフォロワー",
      "other": "{0}人のフォロワー"
    },
    "Following": "フォロー中",
    "FollowingLabel": "フォロー中",
    "ListenersLabel": "今月のリスナー",
    "FollowsYou": "あなたをフォローしています",
    "HoldToPreview": "プレビューするには、クリックを押しします",
    "ListenCount": {
      "one": "1回再生",
      "other": "{0}回再生"
    },
    "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
    "ListenReactionSingle": "{0}さんはこれを聴いています",
    "LocalFile": "ローカルファイル",
    "More": "詳細",
    "MoreSongsLoad": "再生すると、さらに曲がロードされます",
    "Pause": "一時停止",
    "Play": "曲の再生",
    "Playlist": "プレイリスト",
    "PressEnterToPlay": "再生するにはEnterキーを押します",
    "Popularity": "人気",
    "Progress": "進捗",
    "Remove": "削除",
    "RemoveYourMusic": "My Musicから削除",
    "Save": "保存",
    "SaveYourMusic": "My Musicに保存",
    "Saved": "保存済み",
    "StartRadio": "Radioを開始",
    "Time": "時間",
    "Title": "タイトル",
    "Toplist": "トップ曲",
    "Track": "ソング",
    "Unfollow": "フォローをやめる",
    "User": "ユーザー",
    "ViewAll": "すべて表示",
    "HoursShort": "{0} 時間",
    "MinutesShort": "{0} 分",
    "SecondsShort": "{0} 秒",
    "ErrorTitle": "このページの表示中に問題が発生しました。",
    "ErrorMessage": "このページは存在しないか、表示中にエラーが発生しました。",
    "OfflineTitle": "このページはオフラインでは利用できません。",
    "OfflineMessage": "ロードするには、インターネットに接続してください。",
    "MadeFor": " {0}さんのために作られたプレイリスト",
    "heart_label": "いいね！",
    "undo_heart_label": "お気に入り",
    "ban_label": "削除",
    "format_list.ban_label": "この曲を削除する",
    "format_list.undo_ban_label": "この曲を削除する",
    "VariousArtistsCapitalized": "様々なアーティスト"
  }
  },{}],150:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "en {0} meer",
    "Artist": "Artiest",
    "By": "van",
    "ByLabel": "Van",
    "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
    "DateAdded": "Datum toegevoegd",
    "Duration": "Duur",
    "Recommended Songs": "Aanbevolen nummers",
    "Filter": "Filter",
    "Follow": "Volgen",
    "Follower": "Volger",
    "FollowersLabel": {
      "one": "Volger",
      "other": "Volger"
    },
    "FollowersCount": {
      "one": "{0} volger",
      "other": "{0} volgers"
    },
    "Following": "Volgend",
    "FollowingLabel": "Volgend",
    "ListenersLabel": "Luisteraars per maand",
    "FollowsYou": "Volgt jou",
    "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
    "ListenCount": {
      "one": "1 keer afgespeeld",
      "other": "{0} keer afgespeeld"
    },
    "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
    "ListenReactionSingle": "{0} luistert hiernaar",
    "LocalFile": "Lokaal bestand",
    "More": "Meer",
    "MoreSongsLoad": "Meer nummers worden geladen terwijl je luistert",
    "Pause": "Pauze",
    "Play": "Afspelen",
    "Playlist": "Afspeellijst",
    "PressEnterToPlay": "Druk op Enter om af te spelen",
    "Popularity": "Populariteit",
    "Progress": "Voortgang",
    "Remove": "Verwijderen",
    "RemoveYourMusic": "Verwijderen uit Bibliotheek",
    "Save": "Opslaan",
    "SaveYourMusic": "Opslaan in Bibliotheek",
    "Saved": "Opgeslagen",
    "StartRadio": "Radio starten",
    "Time": "Tijd",
    "Title": "Titel",
    "Toplist": "Topnummers",
    "Track": "Nummer",
    "Unfollow": "Niet meer volgen",
    "User": "Gebruiker",
    "ViewAll": "Alles bekijken",
    "HoursShort": "{0} uur",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} sec",
    "ErrorTitle": "Er is een fout opgetreden bij het weergeven van deze pagina.",
    "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
    "OfflineTitle": "Deze pagina is niet offline beschikbaar.",
    "OfflineMessage": "Ga online om te laden.",
    "MadeFor": "Gemaakt voor {0}",
    "heart_label": "Vind ik leuk",
    "undo_heart_label": "Geliked",
    "ban_label": "Verwijderen",
    "format_list.ban_label": "Niet leuk",
    "format_list.undo_ban_label": "Je vindt dit niet leuk",
    "VariousArtistsCapitalized": "Diverse artiesten"
  }
  },{}],151:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "i {0} więcej",
    "Artist": "Wykonawca",
    "By": "według",
    "ByLabel": "-",
    "Create Similar Playlist": "Utwórz podobną playlistę",
    "DateAdded": "Data dodania",
    "Duration": "Czas trwania",
    "Recommended Songs": "Polecane utwory",
    "Filter": "Filtruj",
    "Follow": "Obserwuj",
    "Follower": "Obserwujący",
    "FollowersLabel": {
      "one": "Obserwujący",
      "other": "Obserwatorzy"
    },
    "FollowersCount": {
      "one": "{0} obserwujący",
      "other": "{0} obserwujących"
    },
    "Following": "Obserwujesz",
    "FollowingLabel": "Obserwujesz",
    "ListenersLabel": "Słuchacze w tym miesiącu",
    "FollowsYou": "Obserwuje Cię",
    "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
    "ListenCount": {
      "one": "1 odtworzenie",
      "other": "Liczba odtworzeń: {0}"
    },
    "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
    "ListenReactionSingle": "Użytkownik {0} słucha tego",
    "LocalFile": "Plik lokalny",
    "More": "Więcej",
    "MoreSongsLoad": "Więcej utworów będzie się pojawiać w miarę słuchania",
    "Pause": "Pauza",
    "Play": "Odtwórz",
    "Playlist": "Playlista",
    "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
    "Popularity": "Popularność",
    "Progress": "Postęp",
    "Remove": "Usuń",
    "RemoveYourMusic": "Usuń z Biblioteki",
    "Save": "Zapisz",
    "SaveYourMusic": "Zapisz w Bibliotece",
    "Saved": "Zapisany",
    "StartRadio": "Włącz radio",
    "Time": "Czas",
    "Title": "Tytuł",
    "Toplist": "Najpopularniejsze utwory",
    "Track": "Utwór",
    "Unfollow": "Przestań obserwować",
    "User": "Użytkownik",
    "ViewAll": "Wyświetl wszystko",
    "HoursShort": "{0} godz.",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} s",
    "ErrorTitle": "Wystąpił błąd podczas wyświetlania tej strony!",
    "ErrorMessage": "Ta strona nie istnieje lub wystąpił błąd.",
    "OfflineTitle": "Ta strona nie jest dostępna w trybie offline!",
    "OfflineMessage": "Przejdź do trybu online, aby załadować.",
    "MadeFor": "Przygotowana dla {0}",
    "heart_label": "Lubię to",
    "undo_heart_label": "Polubiono",
    "ban_label": "Usuń",
    "format_list.ban_label": "Nie lubię",
    "format_list.undo_ban_label": "Nie podoba Ci się",
    "VariousArtistsCapitalized": "Różni wykonawcy"
  }
  },{}],152:[function(require,module,exports){
  module.exports={
    "Album": "Álbum",
    "AndMore": "e mais {0}",
    "Artist": "Artista",
    "By": "de",
    "ByLabel": "De",
    "Create Similar Playlist": "Criar playlist similar",
    "DateAdded": "Adicionado em",
    "Duration": "Duração",
    "Recommended Songs": "Músicas recomendadas",
    "Filter": "Filtrar",
    "Follow": "Seguir",
    "Follower": "Seguidor",
    "FollowersLabel": {
      "one": "Seguidor",
      "other": "Seguidores"
    },
    "FollowersCount": {
      "one": "{0} seguidor",
      "other": "{0} seguidores"
    },
    "Following": "Seguindo",
    "FollowingLabel": "Seguindo",
    "ListenersLabel": "Ouvintes mensais",
    "FollowsYou": "Segue você",
    "HoldToPreview": "Clique e segure para a prévia",
    "ListenCount": {
      "one": "1 reprodução",
      "other": "{0} reproduções"
    },
    "ListenReactionMulti": "{0} ouvintes na sua rede",
    "ListenReactionSingle": "{0} ouvem isso",
    "LocalFile": "Arquivo local",
    "More": "Mais",
    "MoreSongsLoad": "Mais músicas serão carregadas à medida que você for escutando",
    "Pause": "Pause",
    "Play": "Play",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Pressione Enter para tocar",
    "Popularity": "Popularidade",
    "Progress": "Progresso",
    "Remove": "Remover",
    "RemoveYourMusic": "Remover da Sua Biblioteca",
    "Save": "Salvar",
    "SaveYourMusic": "Salvar na Sua Biblioteca",
    "Saved": "Salvo",
    "StartRadio": "Abrir rádio",
    "Time": "Tempo",
    "Title": "Título",
    "Toplist": "Músicas mais tocadas",
    "Track": "Música",
    "Unfollow": "Deixar de seguir",
    "User": "Usuário",
    "ViewAll": "Ver tudo",
    "HoursShort": "{0} h",
    "MinutesShort": "{0} m",
    "SecondsShort": "{0} s",
    "ErrorTitle": "Tivemos um problema ao mostrar esta página!",
    "ErrorMessage": "Essa página não existe ou ocorreu um erro.",
    "OfflineTitle": "Essa página não está disponível offline!",
    "OfflineMessage": "Fique online para carregar.",
    "MadeFor": "Feito para {0}",
    "heart_label": "Curtir",
    "undo_heart_label": "Curtiu",
    "ban_label": "Remover",
    "format_list.ban_label": "Não curto",
    "format_list.undo_ban_label": "Você não curte isso",
    "VariousArtistsCapitalized": "Vários artistas"
  }
  },{}],153:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "och {0} till",
    "Artist": "Artist",
    "By": "av",
    "ByLabel": "Av",
    "Create Similar Playlist": "Skapa en liknande spellista",
    "DateAdded": "Tillagd",
    "Duration": "Längd",
    "Recommended Songs": "Rekommenderade låtar",
    "Filter": "Filtrera",
    "Follow": "Följ",
    "Follower": "Följare",
    "FollowersLabel": {
      "one": "Följare",
      "other": "Följare"
    },
    "FollowersCount": {
      "one": "{0} följare",
      "other": "{0} följare"
    },
    "Following": "Följer",
    "FollowingLabel": "Följer",
    "ListenersLabel": "Lyssnare per månad",
    "FollowsYou": "Följer dig",
    "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
    "ListenCount": {
      "one": "1 uppspelning",
      "other": "{0} uppspelningar"
    },
    "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
    "ListenReactionSingle": "{0} lyssnar på detta",
    "LocalFile": "Lokal fil",
    "More": "Mer",
    "MoreSongsLoad": "Fler låtar läses in medan du lyssnar",
    "Pause": "Pausa",
    "Play": "Spela upp",
    "Playlist": "Spellista",
    "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
    "Popularity": "Popularitet",
    "Progress": "Lyssnat",
    "Remove": "Ta bort",
    "RemoveYourMusic": "Ta bort från Ditt bibliotek",
    "Save": "Spara",
    "SaveYourMusic": "Spara i Ditt bibliotek",
    "Saved": "Sparade",
    "StartRadio": "Starta radio",
    "Time": "Tid",
    "Title": "Titel",
    "Toplist": "Topplåtar",
    "Track": "Låt",
    "Unfollow": "Sluta följa",
    "User": "Användare",
    "ViewAll": "Visa alla",
    "HoursShort": "{0} tim",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} sek",
    "ErrorTitle": "Det uppstod ett fel när den här sidan skulle visas!",
    "ErrorMessage": "Den här sidan finns inte eller så uppstod ett fel.",
    "OfflineTitle": "Den här sidan är inte tillgänglig offline!",
    "OfflineMessage": "Anslut till internet om du vill läsa in appen.",
    "MadeFor": "Skapad för {0}",
    "heart_label": "Gilla",
    "undo_heart_label": "Gillar",
    "ban_label": "Ta bort",
    "format_list.ban_label": "Gillar inte",
    "format_list.undo_ban_label": "Du gillar inte det här",
    "VariousArtistsCapitalized": "Olika artister"
  }
  },{}],154:[function(require,module,exports){
  module.exports={
    "Album": "อัลบั้ม",
    "AndMore": "และอีก {0} คน",
    "Artist": "ศิลปิน",
    "By": "โดย",
    "ByLabel": "จาก",
    "Create Similar Playlist": "สร้างเพลย์ลิสต์ที่คล้ายกัน",
    "DateAdded": "เพิ่มวันที่แล้ว",
    "Duration": "ระยะเวลา",
    "Recommended Songs": "เพลงที่แนะนำ",
    "Filter": "ตัวกรอง",
    "Follow": "ติดตาม",
    "Follower": "ผู้ติดตาม",
    "FollowersLabel": {
      "one": "ผู้ติดตาม",
      "other": "ผู้ติดตาม"
    },
    "FollowersCount": {
      "one": "ผู้ติดตาม {0} คน",
      "other": "ผู้ติดตาม {0} คน"
    },
    "Following": "กำลังติดตาม",
    "FollowingLabel": "กำลังติดตาม",
    "ListenersLabel": "ผู้ฟังรายเดือน",
    "FollowsYou": "ติดตามคุณ",
    "HoldToPreview": "คลิกค้างไว้เพื่อฟังตัวอย่าง",
    "ListenCount": {
      "one": "เล่น 1 ครั้ง",
      "other": "เล่น {0} ครั้ง"
    },
    "ListenReactionMulti": "ผู้ฟัง {0} คนในเครือข่ายของคุณ",
    "ListenReactionSingle": "{0} ฟังรายการนี้",
    "LocalFile": "ไฟล์ในเครื่อง",
    "More": "เพิ่มเติม",
    "MoreSongsLoad": "เราจะโหลดเพลงเพิ่มระหว่างที่คุณฟัง",
    "Pause": "หยุดชั่วคราว",
    "Play": "เล่น",
    "Playlist": "เพลย์ลิสต์",
    "PressEnterToPlay": "กด Enter เพื่อเล่น",
    "Popularity": "ความนิยม",
    "Progress": "ความคืบหน้า",
    "Remove": "ลบ",
    "RemoveYourMusic": "ลบจากคอลเลกชันของคุณ",
    "Save": "บันทึก",
    "SaveYourMusic": "บันทึกในคอลเลกชันของคุณ",
    "Saved": "บันทึกแล้ว",
    "StartRadio": "เริ่มต้นวิทยุ",
    "Time": "เวลา",
    "Title": "ชื่อ",
    "Toplist": "เพลงยอดนิยม",
    "Track": "เพลง",
    "Unfollow": "เลิกติดตาม",
    "User": "ผู้ใช้",
    "ViewAll": "ดูทั้งหมด",
    "HoursShort": "{0} ชั่วโมง",
    "MinutesShort": "{0} นาที",
    "SecondsShort": "{0} วินาที",
    "ErrorTitle": "เกิดปัญหาในการแสดงผลหน้านี้!",
    "ErrorMessage": "ไม่มีหน้านี้หรือเกิดข้อผิดพลาดขึ้น",
    "OfflineTitle": "ไม่สามารถใช้งานหน้านี้ขณะออฟไลน์ได้!",
    "OfflineMessage": "โปรดใช้งานแบบออนไลน์เพื่อโหลด",
    "MadeFor": "จัดทำเพื่อ {0}",
    "heart_label": "ถูกใจ",
    "undo_heart_label": "ถูกใจแล้ว",
    "ban_label": "ลบ",
    "format_list.ban_label": "ไม่ชอบ",
    "format_list.undo_ban_label": "คุณไม่ชอบเนื้อหานี้",
    "VariousArtistsCapitalized": "รวมศิลปิน"
  }
  },{}],155:[function(require,module,exports){
  module.exports={
    "Album": "Albüm",
    "AndMore": "ve {0} daha",
    "Artist": "Sanatçı",
    "By": "-",
    "ByLabel": "-",
    "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
    "DateAdded": "Tarih Eklendi",
    "Duration": "Süre",
    "Recommended Songs": "Önerilen Şarkılar",
    "Filter": "Filtrele",
    "Follow": "Takip Et",
    "Follower": "Takipçi",
    "FollowersLabel": {
      "one": "Takipçi",
      "other": "Takipçi"
    },
    "FollowersCount": {
      "one": "{0} takipçi",
      "other": "{0} takipçi"
    },
    "Following": "Takip Ediliyor",
    "FollowingLabel": "Takip Ediliyor",
    "ListenersLabel": "Aylık Dinleyici",
    "FollowsYou": "Seni Takip Ediyor",
    "HoldToPreview": "Basılı Tut ve Önizle",
    "ListenCount": {
      "one": "1 çalma",
      "other": "{0} dinleme"
    },
    "ListenReactionMulti": "Ağında {0} dinleyici",
    "ListenReactionSingle": "{0} bunu dinliyor",
    "LocalFile": "Yerel Dosya",
    "More": "Daha fazla",
    "MoreSongsLoad": "Sen dinledikçe daha fazla şarkı yüklenir",
    "Pause": "Duraklat",
    "Play": "Çal",
    "Playlist": "Çalma listesi",
    "PressEnterToPlay": "Çalmak için Enter'a bas",
    "Popularity": "Popülerlik",
    "Progress": "Progress",
    "Remove": "Çıkar",
    "RemoveYourMusic": "Kitaplığın'dan kaldır",
    "Save": "Kaydet",
    "SaveYourMusic": "Kitaplığın'a kaydet",
    "Saved": "Kaydedildi",
    "StartRadio": "Radyoyu Başlat",
    "Time": "Saat",
    "Title": "Başlık",
    "Toplist": "En çok dinlenen şarkılar",
    "Track": "Şarkı",
    "Unfollow": "Takip Etmeyi Bırak",
    "User": "Kullanıcı",
    "ViewAll": "Tümünü Görüntüle",
    "HoursShort": "{0} sa",
    "MinutesShort": "{0} dk",
    "SecondsShort": "{0} sn",
    "ErrorTitle": "Bu sayfa görüntülenirken bir sorun oluştu!",
    "ErrorMessage": "Bu sayfa yok veya bir hata oluştu.",
    "OfflineTitle": "Bu sayfa çevrimdışı kullanılamaz!",
    "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol.",
    "MadeFor": "{0} İçin Yapıldı",
    "heart_label": "Beğen",
    "undo_heart_label": "Beğenildi",
    "ban_label": "Çıkar",
    "format_list.ban_label": "Beğenme",
    "format_list.undo_ban_label": "Bunu beğenmedin",
    "VariousArtistsCapitalized": "Çeşitli sanatçılar"
  }
  },{}],156:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "và thêm {0}",
    "Artist": "Nghệ sĩ",
    "By": "của",
    "ByLabel": "Của",
    "Create Similar Playlist": "Tạo Playlist Tương tự",
    "DateAdded": "Đã Thêm Ngày",
    "Duration": "Thời lượng",
    "Recommended Songs": "Bài hát Gợi ý",
    "Filter": "Bộ lọc",
    "Follow": "Theo dõi",
    "Follower": "Người theo dõi",
    "FollowersLabel": {
      "one": "Người theo dõi",
      "other": "Người theo dõi"
    },
    "FollowersCount": {
      "one": "{0} người theo dõi",
      "other": "{0} người theo dõi"
    },
    "Following": "Đang theo dõi",
    "FollowingLabel": "Đang theo dõi",
    "ListenersLabel": "Người nghe Hàng tháng",
    "FollowsYou": "Theo dõi Bạn",
    "HoldToPreview": "Nhấp và Giữ để Xem trước",
    "ListenCount": {
      "one": "1 lượt phát",
      "other": "{0} phát"
    },
    "ListenReactionMulti": "{0} người nghe trong mạng lưới của bạn",
    "ListenReactionSingle": "{0} nghe bản này",
    "LocalFile": "File trên máy",
    "More": "Tuỳ chọn...",
    "MoreSongsLoad": "Tải được nhiều bài hát hơn khi bạn nghe",
    "Pause": "Tạm dừng",
    "Play": "Phát",
    "Playlist": "Playlist",
    "PressEnterToPlay": "Nhấn Enter để phát",
    "Popularity": "Mức độ phổ biến",
    "Progress": "Tiến độ",
    "Remove": "Xóa",
    "RemoveYourMusic": "Xóa khỏi Thư viện",
    "Save": "Lưu",
    "SaveYourMusic": "Lưu vào Thư viện",
    "Saved": "Đã lưu",
    "StartRadio": "Bắt đầu Radio",
    "Time": "Thời gian",
    "Title": "Tiêu đề",
    "Toplist": "Các bài hát hàng đầu",
    "Track": "Bài hát",
    "Unfollow": "Hủy theo dõi",
    "User": "Người dùng",
    "ViewAll": "Xem Tất cả",
    "HoursShort": "{0} giờ",
    "MinutesShort": "{0} phút",
    "SecondsShort": "{0} giây",
    "ErrorTitle": "Đã có sự cố xảy ra khi hiển thị trang này!",
    "ErrorMessage": "Nội dung này hoặc không tồn tại hoặc đã có lỗi xảy ra.",
    "OfflineTitle": "Trang này không có ở chế độ offline!",
    "OfflineMessage": "Vui lòng truy cập trực tuyến để tải.",
    "MadeFor": "Dành cho {0}",
    "heart_label": "Thích",
    "undo_heart_label": "Đã thích",
    "ban_label": "Xóa",
    "format_list.ban_label": "Không thích",
    "format_list.undo_ban_label": "Bạn không thích điều này",
    "VariousArtistsCapitalized": "Nhiều nghệ sĩ"
  }
  },{}],157:[function(require,module,exports){
  module.exports={
    "Album": "專輯",
    "AndMore": "還有 {0} 首",
    "Artist": "藝人",
    "By": "－",
    "ByLabel": "來自",
    "Create Similar Playlist": "建立相似的播放清單",
    "DateAdded": "已加入日期",
    "Duration": "長度",
    "Recommended Songs": "推薦歌曲",
    "Filter": "篩選",
    "Follow": "關注",
    "Follower": "粉絲",
    "FollowersLabel": {
      "one": "粉絲",
      "other": "粉絲"
    },
    "FollowersCount": {
      "one": "{0} 粉絲",
      "other": "{0} 位粉絲"
    },
    "Following": "正在關注",
    "FollowingLabel": "正在關注",
    "ListenersLabel": "每月聽眾",
    "FollowsYou": "關注你",
    "HoldToPreview": "按住即可預覽",
    "ListenCount": {
      "one": "1 個播放項目",
      "other": "播放了 {0} 次"
    },
    "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
    "ListenReactionSingle": "{0} 收聽了這首歌曲",
    "LocalFile": "本機檔案",
    "More": "更多",
    "MoreSongsLoad": "聆聽時載入更多歌曲",
    "Pause": "暫停",
    "Play": "播放",
    "Playlist": "播放列表",
    "PressEnterToPlay": "請按 Enter 播放",
    "Popularity": "流行",
    "Progress": "進度",
    "Remove": "移除",
    "RemoveYourMusic": "從你的音樂庫中移除",
    "Save": "儲存",
    "SaveYourMusic": "儲存至你的音樂庫",
    "Saved": "已儲存",
    "StartRadio": "啟用電臺",
    "Time": "時間",
    "Title": "標題",
    "Toplist": "當紅歌曲",
    "Track": "歌曲",
    "Unfollow": "取消關注",
    "User": "使用者",
    "ViewAll": "檢視全部",
    "HoursShort": "{0} 小時",
    "MinutesShort": "{0} 分鐘",
    "SecondsShort": "{0} 秒鐘",
    "ErrorTitle": "顯示這個頁面時出現問題！",
    "ErrorMessage": "這個頁面可能不存在或發生錯誤。",
    "OfflineTitle": "離線時無法進入這個頁面！",
    "OfflineMessage": "請上網以載入。",
    "MadeFor": "專為 {0} 精心打造",
    "heart_label": "讚",
    "undo_heart_label": "已按讚",
    "ban_label": "移除",
    "format_list.ban_label": "不喜歡",
    "format_list.undo_ban_label": "你不喜歡這個",
    "VariousArtistsCapitalized": "多位藝人"
  }
  },{}],158:[function(require,module,exports){
  module.exports={
    "Album": "Album",
    "AndMore": "dan {0} lagi",
    "Artist": "Artis",
    "By": "oleh",
    "ByLabel": "Lebih banyak lagi oleh",
    "Create Similar Playlist": "Cipta Senarai Main Serupa",
    "DateAdded": "Tarikh Ditambah",
    "Duration": "Tempoh",
    "Recommended Songs": "Lagu yang Dicadangkan",
    "Filter": "Penapis",
    "Follow": "Ikut",
    "Follower": "Pengikut",
    "FollowersLabel": {
      "one": "Pengikut",
      "other": "Pengikut"
    },
    "FollowersCount": {
      "one": "{0} pengikut",
      "other": "{0} pengikut"
    },
    "Following": "Mengikuti",
    "FollowingLabel": "Mengikuti",
    "ListenersLabel": "Pendengar Bulanan",
    "FollowsYou": "Megikuti Anda",
    "HoldToPreview": "Klik dan Tahan untuk Pratonton",
    "ListenCount": {
      "one": "1 main",
      "other": "{0} main"
    },
    "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
    "ListenReactionSingle": "{0} mendengar ini",
    "LocalFile": "Fail Setempat",
    "More": "Lebih banyak",
    "MoreSongsLoad": "Lebih banyak lagu dimuatkan semasa anda mendengar",
    "Pause": "Jeda",
    "Play": "Main",
    "Playlist": "Senarai main",
    "PressEnterToPlay": "Tekan Enter untuk main",
    "Popularity": "Populariti",
    "Progress": "Perkembangan",
    "Remove": "Keluarkan",
    "RemoveYourMusic": "Keluarkan daripada Pustaka Anda",
    "Save": "Simpan",
    "SaveYourMusic": "Simpan ke Pustaka Anda",
    "Saved": "Disimpan",
    "StartRadio": "Mulakan Radio",
    "Time": "Masa",
    "Title": "Tajuk",
    "Toplist": "Lagu popular",
    "Track": "Lagu",
    "Unfollow": "Nyahikut",
    "User": "Pengguna",
    "ViewAll": "Lihat Semua",
    "HoursShort": "{0} jam",
    "MinutesShort": "{0} min",
    "SecondsShort": "{0} saat",
    "ErrorTitle": "Terdapat masalah untuk memaparkan laman ini!",
    "ErrorMessage": "Laman ini sama ada tidak wujud atau ralat telah berlaku.",
    "OfflineTitle": "Laman ini tidak tersedia di luar talian!",
    "OfflineMessage": "Sila ke online untuk memuatkan.",
    "MadeFor": "Dibuat untuk {0}",
    "heart_label": "Suka",
    "undo_heart_label": "Disukai",
    "ban_label": "Keluarkan",
    "format_list.ban_label": "Tidak suka",
    "format_list.undo_ban_label": "Anda tidak sukakannya",
    "VariousArtistsCapitalized": "Pelbagai artis"
  }
  },{}],159:[function(require,module,exports){
  'use strict';

  var _gridOverlay = require('./src/gridOverlay');

  var gridOverlay = _interopRequireWildcard(_gridOverlay);

  var _responsiveTitleType = require('./src/responsiveTitleType');

  var responsiveTitleType = _interopRequireWildcard(_responsiveTitleType);

  var _attentionHighlight = require('./src/attentionHighlight');

  var attentionHighlight = _interopRequireWildcard(_attentionHighlight);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  exports.gridOverlay = gridOverlay;
  exports.responsiveTitleType = responsiveTitleType;
  exports.attentionHighlight = attentionHighlight;

  },{"./src/attentionHighlight":160,"./src/gridOverlay":161,"./src/responsiveTitleType":162}],160:[function(require,module,exports){
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const HIDE_DELAY = exports.HIDE_DELAY = 2000;

  },{}],161:[function(require,module,exports){
  (function (global){
  'use strict';

  const cosmos = require('spotify-cosmos-api');

  const DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
  const DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
  const GRID_BASELINE = 8;

  let overlayElement = null;
  let baselineHighlightElement = null;
  let gridColor = '';
  let highlightGridColor = '';
  const gridModes = ['off', 'column', 'baseline'];
  let currentModeIndex = 0;

  /**
   * Listen for control messages to toggle the grid when a menu item is clicked
   * or a keyboard shortcut is pressed. This only happens if the user is a global
   * app developer.
   */
  function listen() {
    const isDeveloper = global.__spotify.developer_mode;
    if (isDeveloper) {
      cosmos.resolver.subscribe({
        url: 'sp://messages/v1/container/control'
      }, function (error, response) {
        if (error) return;
        const data = response.getJSONBody();
        if (data && data.type === 'toggle_grid') {
          toggle();
        }
      });
    }
  }

  /**
   * Toggle the grid overlay.
   */
  function toggle() {
    let newIndex = currentModeIndex + 1;
    if (newIndex > gridModes.length - 1) {
      newIndex = 0;
    }

    const mode = gridModes[newIndex];

    if (mode === 'off') {
      disable();
    } else {
      enable(mode);
    }
  }

  /**
   * Enable the grid overlay.
   *
   * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
   */
  function enable(mode) {
    if (!mode) {
      return;
    }

    if (gridModes[currentModeIndex] === mode) {
      return;
    }

    currentModeIndex = gridModes.indexOf(mode);

    if (overlayElement && overlayElement.parentNode) {
      overlayElement.parentNode.removeChild(overlayElement);
    }

    if (mode === 'baseline') {
      document.addEventListener('mousemove', onMouseMove, false);
    }

    overlayElement = createOverlayElement();

    document.body.appendChild(overlayElement);
  }

  /**
   * Disable the grid overlay.
   */
  function disable() {
    if (gridModes[currentModeIndex] === 'off') {
      return;
    }

    if (overlayElement && overlayElement.parentNode) {
      overlayElement.parentNode.removeChild(overlayElement);
    }

    currentModeIndex = gridModes.indexOf('off');
    overlayElement = null;
    baselineHighlightElement = null;

    document.removeEventListener('mousemove', onMouseMove, false);
  }

  /**
   * Set the color used for each grid column or baseline line.
   *
   * @param {string} color Any valid CSS color.
   * @param {string=} highlightColor Any valid CSS color. Can be omitted for
   *     column grid.
   */
  function setColor(color, highlightColor) {
    gridColor = color;
    highlightGridColor = highlightColor;
  }

  /**
   * Reset all state in this module.
   */
  function reset() {
    overlayElement = null;
    baselineHighlightElement = null;
    gridColor = '';
    highlightGridColor = '';
    currentModeIndex = 0;
  }

  /**
   * Mouse move handler that highlights the hovered baseline line.
   *
   * @param {Event} event A mousemove event object.
   *
   * @private
   */
  function onMouseMove(event) {
    if (!baselineHighlightElement) {
      baselineHighlightElement = document.createElement('div');
      baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
      baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
      overlayElement.appendChild(baselineHighlightElement);
    }

    // Calculate the Y position for the baseline line closest to the pointer
    const pointerPos = event.clientY + window.scrollY;
    const yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
    const y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

    baselineHighlightElement.style.top = `${y - 1}px`;
  }

  /**
   * Create the DOM nodes needed for the overlay, with the correct class names
   * and styles.
   *
   * @return {HTMLElement} The container element for the overlay.
   *
   * @private
   */
  function createOverlayElement() {
    const color = gridColor || DEFAULT_GRID_COLOR;

    const container = document.createElement('div');
    container.className = 'grid-overlay container';

    if (gridModes[currentModeIndex] === 'column') {
      const row = document.createElement('div');
      row.className = 'grid-overlay-row row';
      container.appendChild(row);

      const sizeLabel = createSizeLabel();
      container.appendChild(sizeLabel);

      const columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

      for (let i = 0; i < 12; i++) {
        const column = document.createElement('div');
        column.className = `grid-overlay-col-${i + 1} ${columnClassNames}`;

        column.style.backgroundColor = color;

        row.appendChild(column);
      }
    } else if (gridModes[currentModeIndex] === 'baseline') {
      container.classList.add('grid-overlay-baseline');

      const baselinePercentage = `${(GRID_BASELINE - 1) / GRID_BASELINE * 100}%`;

      const backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', `transparent ${baselinePercentage}, `, `${color} ${baselinePercentage}`, ')'].join('');

      container.style.backgroundImage = backgroundImage;

      // Because JSDOM is using the package 'cssstyle', which is stupid and
      // doesn't support gradients as values...
      container.style._backgroundImage = backgroundImage;
    }

    return container;
  }

  /**
   * Create the DOM nodes needed for the grid size label.
   *
   * @return {HTMLElement} A DOM node.
   *
   * @private
   */
  function createSizeLabel() {
    const sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

    const labelContainer = document.createElement('div');
    labelContainer.className = 'grid-overlay-label';

    sizes.forEach(function (size) {
      const label = document.createElement('span');
      label.className = `visible-${size.id}`;
      label.textContent = `${size.name} (${size.id})`;
      labelContainer.appendChild(label);
    });

    return labelContainer;
  }

  exports.listen = listen;
  exports.toggle = toggle;
  exports.enable = enable;
  exports.disable = disable;
  exports.setColor = setColor;
  exports.reset = reset;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"spotify-cosmos-api":1272}],162:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.loadFont = loadFont;
  exports.setSizeForTitle = setSizeForTitle;
  /**
   * Usage:
   *
   * loadFont().then(() => {
   *   setSizeForTitle(titleNode, {
   *     useLargeTitle: true,
   *   });
   * });
   */

  // There is a bottom padding in the title element, to allow the bottom border
  // of links to be rendered correctly. This number here is specified as a
  // percentage of the height of a single line.
  const PADDING_BOTTOM_PERCENTAGE = 0.07;
  function getSizeSpecs() {
    // Some characters in Thai are too big and get cropped at the top.
    if (window.__spotify.locale === 'th') {
      return {
        default: {
          fontSizes: [[48, 36], [36, 28]],
          lineHeights: [[75, 58], [58, 44]]
        },
        large: {
          fontSizes: [[96, 72, 48], [48, 36, 28]],
          lineHeights: [[148, 111, 75], [75, 58, 44]]
        }
      };
    }
    return {
      default: {
        fontSizes: [[48, 36], [36, 28]],
        lineHeights: [[56, 44], [44, 36]]
      },
      large: {
        fontSizes: [[96, 72, 48], [48, 36, 28]],
        lineHeights: [[110, 82, 56], [56, 44, 36]]
      }
    };
  }

  /**
   * The font must be loaded before any sizing can be done.
   *
   * @return {Promise}
   */
  function loadFont() {
    return document.fonts.load('500 48px spotify-circular');
  }

  /**
   * Set the type size for the provided title node. The font must be loaded
   * before calling this function.
   *
   * @param {HTMLElement} node The title node.
   * @param {Object=} options An optional object with options:
   *   - useLargeTitle: true/false (default: false)
   */
  function setSizeForTitle(node, options = {}) {
    const sizeSpecId = options.useLargeTitle ? 'large' : 'default';
    const { fontSizes, lineHeights } = getSizeSpecs()[sizeSpecId];

    let lineCount = 1;
    let sizeIndex = 0;
    let fontSize = fontSizes[0][0];
    let lineHeight = lineHeights[0][0];
    let renderedLineCount = lineCount + 1;
    let lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

    // Set initial values (largest type, one line, but clamped to two lines to
    // allow for the text to wrap so we can detect that it doesn't fit).
    node.style.webkitLineClamp = renderedLineCount;
    node.style.fontSize = `${fontSize}px`;
    node.style.lineHeight = `${lineHeight}px`;
    node.style.paddingBottom = `${lastBottomPadding}px`;
    node.style.marginBottom = `-${lastBottomPadding}px`;
    node.removeAttribute('title');

    while (lineCount <= fontSizes.length && node.offsetHeight - lastBottomPadding > lineHeight * lineCount) {
      sizeIndex++;

      if (!fontSizes[lineCount - 1][sizeIndex]) {
        sizeIndex = 0;
        lineCount++;
      }

      if (lineCount <= fontSizes.length) {
        fontSize = fontSizes[lineCount - 1][sizeIndex];
        lineHeight = lineHeights[lineCount - 1][sizeIndex];
        renderedLineCount = lineCount + 1;
        lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

        node.style.webkitLineClamp = renderedLineCount;
        node.style.fontSize = `${fontSize}px`;
        node.style.lineHeight = `${lineHeight}px`;
        node.style.paddingBottom = `${lastBottomPadding}px`;
        node.style.marginBottom = `-${lastBottomPadding}px`;
      }
    }

    if (lineCount > fontSizes.length) {
      // Add title attribute if the text still doesn't fit and gets truncated
      node.setAttribute('title', node.textContent.trim());
    }

    node.style.webkitLineClamp = renderedLineCount - 1;
  }

  },{}],163:[function(require,module,exports){
  'use strict';

  module.exports = {
    'cs': require('../i18n/json/cs.json'),
    'de': require('../i18n/json/de.json'),
    'el': require('../i18n/json/el.json'),
    'en': require('../i18n/json/en.json'),
    'es': require('../i18n/json/es.json'),
    'es-419': require('../i18n/json/es-419.json'),
    'fi': require('../i18n/json/fi.json'),
    'fr': require('../i18n/json/fr.json'),
    'fr-CA': require('../i18n/json/fr-CA.json'),
    'hu': require('../i18n/json/hu.json'),
    'id': require('../i18n/json/id.json'),
    'it': require('../i18n/json/it.json'),
    'ja': require('../i18n/json/ja.json'),
    'nl': require('../i18n/json/nl.json'),
    'pl': require('../i18n/json/pl.json'),
    'pt-BR': require('../i18n/json/pt-BR.json'),
    'sv': require('../i18n/json/sv.json'),
    'th': require('../i18n/json/th.json'),
    'tr': require('../i18n/json/tr.json'),
    'vi': require('../i18n/json/vi.json'),
    'zh-Hant': require('../i18n/json/zh-Hant.json'),
    'zsm': require('../i18n/json/zsm.json')
  };

  },{"../i18n/json/cs.json":137,"../i18n/json/de.json":138,"../i18n/json/el.json":139,"../i18n/json/en.json":140,"../i18n/json/es-419.json":141,"../i18n/json/es.json":142,"../i18n/json/fi.json":143,"../i18n/json/fr-CA.json":144,"../i18n/json/fr.json":145,"../i18n/json/hu.json":146,"../i18n/json/id.json":147,"../i18n/json/it.json":148,"../i18n/json/ja.json":149,"../i18n/json/nl.json":150,"../i18n/json/pl.json":151,"../i18n/json/pt-BR.json":152,"../i18n/json/sv.json":153,"../i18n/json/th.json":154,"../i18n/json/tr.json":155,"../i18n/json/vi.json":156,"../i18n/json/zh-Hant.json":157,"../i18n/json/zsm.json":158}],164:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;

    return "  <div class=\"b-add-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Save",{"name":"loc","hash":{},"data":data}))
      + "</div>\n  <div class=\"b-added-text b-alt-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Saved",{"name":"loc","hash":{},"data":data}))
      + "</div>\n  <div class=\"b-remove-text b-alt-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Remove",{"name":"loc","hash":{},"data":data}))
      + "</div>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;

    return "  <div class=\"b-add-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Follow",{"name":"loc","hash":{},"data":data}))
      + "</div>\n  <div class=\"b-added-text b-alt-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Following",{"name":"loc","hash":{},"data":data}))
      + "</div>\n  <div class=\"b-remove-text b-alt-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Unfollow",{"name":"loc","hash":{},"data":data}))
      + "</div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"track","album",{"name":"type","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"playlist","user","artist","station","show",{"name":"type","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"useData":true});

  },{"hbsfy/runtime":745}],165:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;

    return "<div class=\"b-play-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Play",{"name":"loc","hash":{},"data":data}))
      + "</div>\n<div class=\"b-pause-text b-alt-text\">"
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Pause",{"name":"loc","hash":{},"data":data}))
      + "</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],166:[function(require,module,exports){
  // APPBOOK Item
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./internal/image.hbs');
  HandlebarsCompiler.registerPartial('./internal/image.hbs', partial$0);
  var partial$1 = require('./internal/controls-play-button.hbs');
  HandlebarsCompiler.registerPartial('./internal/controls-play-button.hbs', partial$1);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return "card-horizontal-size-"
      + container.escapeExpression(((helper = (helper = helpers.size || (depth0 != null ? depth0.size : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"size","hash":{},"data":data}) : helper)));
  },"3":function(container,depth0,helpers,partials,data) {
      return "      card-video\n";
  },"5":function(container,depth0,helpers,partials,data) {
      return "card-type-station-"
      + container.escapeExpression((helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}));
  },"7":function(container,depth0,helpers,partials,data) {
      return "      card-show-attention-highlight\n";
  },"9":function(container,depth0,helpers,partials,data) {
      return "no-image-url";
  },"11":function(container,depth0,helpers,partials,data) {
      return "card-hidden-image";
  },"13":function(container,depth0,helpers,partials,data) {
      return "card--with-remove-button";
  },"15":function(container,depth0,helpers,partials,data) {
      return "data-context";
  },"17":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "    <div\n      class=\"card-image-wrapper\"\n      data-contextmenu-spy\n      data-ta-id=\"card-image-wrapper\"\n    >\n      <div class=\"card-image-hit-area\">\n        <a href=\""
      + container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n          data-drag-text=\""
      + container.escapeExpression(((helper = (helper = helpers.dragText || (depth0 != null ? depth0.dragText : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"dragText","hash":{},"data":data}) : helper)))
      + "\"\n          draggable=\"true\"\n          class=\"card-image-link "
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\"\n          data-interaction-target=\"image\"\n        >\n          <div class=\"card-hit-area-counter-scale\"></div>\n"
      + ((stack1 = container.invokePartial(partials["./internal/image.hbs"],depth0,{"name":"./internal/image.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "        </a>\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.size : depth0),"small",{"name":"compare","hash":{"operator":"!="},"fn":container.program(22, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n    </div>\n";
  },"18":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.targetUri || (depth0 != null ? depth0.targetUri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"targetUri","hash":{},"data":data}) : helper)));
  },"20":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"uri","hash":{},"data":data}) : helper)));
  },"22":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers.unless.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"23":function(container,depth0,helpers,partials,data) {
      var stack1;
    return "            <div class=\"card-overlay\"></div>\n"
      + ((stack1 = container.invokePartial(partials["./internal/controls-play-button.hbs"],depth0,{"name":"./internal/controls-play-button.hbs","data":data,"indent":"            ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"25":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "              "
      + ((stack1 = ((helper = (helper = helpers.titleHTML || (depth0 != null ? depth0.titleHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"titleHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "\n";
  },"27":function(container,depth0,helpers,partials,data) {
      var helper;

    return "              "
      + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"data":data}) : helper)))
      + "\n";
  },"29":function(container,depth0,helpers,partials,data) {
      var stack1;
    return "          <div class=\"card-info-subtitle-links\">\n"
      + ((stack1 = helpers.each.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"each","hash":{},"fn":container.program(30, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "          </div>\n";
  },"30":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "            <span>"
      + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "</span>"
      + ((stack1 = helpers.unless.call(alias1,(data && data.last),{"name":"unless","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n";
  },"31":function(container,depth0,helpers,partials,data) {
      return ", ";
  },"33":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.size : depth0),"small",{"name":"compare","hash":{"operator":"!="},"fn":container.program(34, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"34":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.description : depth0),{"name":"if","hash":{},"fn":container.program(35, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"35":function(container,depth0,helpers,partials,data) {
      var helper;

    return "              <div class=\"card-info-subtitle-description\" data-ta-id=\"card-description\">\n                "
      + container.escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"description","hash":{},"data":data}) : helper)))
      + "\n              </div>\n";
  },"37":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "          <div class=\"card-info-subtitle-links\">\n            "
      + ((stack1 = ((helper = (helper = helpers.subtitleHTML || (depth0 != null ? depth0.subtitleHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"subtitleHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "\n          </div>\n";
  },"39":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.size : depth0),"small",{"name":"compare","hash":{"operator":"!="},"fn":container.program(40, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"40":function(container,depth0,helpers,partials,data) {
      var helper;

    return "            <div class=\"card-info-subtitle-metadata\" data-ta-id=\"card-metadata\">\n              "
      + container.escapeExpression(((helper = (helper = helpers.metadata || (depth0 != null ? depth0.metadata : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"metadata","hash":{},"data":data}) : helper)))
      + "\n            </div>\n";
  },"42":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "        <button\n          type=\"button\"\n          class=\"card__remove-button button button-icon-only spoticon-x-16\"\n          data-card-remove-button\n"
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.removeButtonTooltip : depth0),{"name":"if","hash":{},"fn":container.program(43, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "          data-interaction-target=\"remove-button\"\n          data-interaction-intent=\"remove-card\"\n"
      + " bookmark-id=\""
      + container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"id","hash":{},"data":data}) : helper)))
      + "\">\n        </button>\n";
  },"43":function(container,depth0,helpers,partials,data) {
      var helper;

    return "          data-tooltip=\""
      + container.escapeExpression(((helper = (helper = helpers.removeButtonTooltip || (depth0 != null ? depth0.removeButtonTooltip : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"removeButtonTooltip","hash":{},"data":data}) : helper)))
      + "\"\n";
  }, "44":function(container,depth0,helpers,partials,data) {
    var helper;

    return "<div class=\"bookmark-fixed-height\"> <div class=\"bookmark-progress\">"
      + "<div class=\"bookmark-progress__bar\" style=\"--progress:"
      + container.escapeExpression(((helper = (helper = helpers.progress || (depth0 != null ? depth0.progress : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"progress","hash":{},"data":data}) : helper)))
      + "\"></div>"
      + "</div>"
      + "<span class=\"bookmark-progress__time\">"
      + container.escapeExpression(((helper = (helper = helpers.timeFormatted || (depth0 != null ? depth0.timeFormatted : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"timeFormatted","hash":{},"data":data}) : helper)))
      + "</span>"
      + "</div>\n";
  }, "compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function", buffer =
    "<div\n  class=\"\n    card\n    card-horizontal\n    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.size : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    card-type-"
      + alias3((helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}))
      + "\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.isVideo : depth0),true,{"name":"compare","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.showAttentionHighlight : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    "
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.noImage : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.removeButton : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  \"\n  data-log-context=\"media-object\"\n  data-log-data='{ \"name\": \""
      + alias3(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "\", \"target_uri\": \""
      + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" }'\n  data-uri=\""
      + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n data-time=\""
      + alias3(((helper = (helper = helpers.time || (depth0 != null ? depth0.time : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"time","hash":{},"data":data}) : helper)))
      + "\"\n  data-contextmenu\n  ";
    stack1 = ((helper = (helper = helpers.noContext || (depth0 != null ? depth0.noContext : depth0)) != null ? helper : alias2),(options={"name":"noContext","hash":{},"fn":container.noop,"inverse":container.program(15, data, 0),"data":data}),(typeof helper === alias4 ? helper.call(alias1,options) : helper));
    if (!helpers.noContext) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + "\n  data-contextmenu-spy\n  data-card-pressed-container\n  data-card-trigger-pressed-state\n  data-ta-id=\"card\"\n  data-interaction-context=\"card\"\n>\n  <div class=\"card-attention-highlight-box\">\n  </div>\n  <div class=\"card-horizontal-interior-wrapper\">\n"
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.noImage : depth0),{"name":"unless","hash":{},"fn":container.program(17, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    <div class=\"card-info-wrapper\">\n      <a\n href=\""
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.targetUri : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0),"inverse":container.program(20, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n        data-drag-text=\""
      + alias3(((helper = (helper = helpers.dragText || (depth0 != null ? depth0.dragText : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"dragText","hash":{},"data":data}) : helper)))
      + "\"\n        draggable=\"true\"\n        data-interaction-target=\"title\"\n      >\n        <div class=\"card-hit-area-counter-scale\"></div>\n        <div class=\"card-info-content-wrapper\">\n          <div class=\"card-info-title\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.titleHTML : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.program(27, data, 0),"data":data})) != null ? stack1 : "")
      + "          </div>\n\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.program(33, data, 0),"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleHTML : depth0),{"name":"if","hash":{},"fn":container.program(37, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.metadata : depth0),{"name":"if","hash":{},"fn":container.program(39, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.progress : depth0),{"name":"if","hash":{},"fn":container.program(44, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + "        </div>\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.removeButton : depth0),{"name":"if","hash":{},"fn":container.program(42, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </a>\n    </div>\n  </div>\n</div>\n";
  },"usePartial":true,"useData":true});

  },{"./internal/controls-play-button.hbs":169,"./internal/image.hbs":172,"hbsfy/runtime":745}],167:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./internal/image-with-overlay.hbs');
  HandlebarsCompiler.registerPartial('./internal/image-with-overlay.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "      card-video\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.isVideo : depth0),false,{"name":"compare","hash":{},"fn":container.program(4, data, 0),"inverse":container.program(6, data, 0),"data":data})) != null ? stack1 : "");
  },"4":function(container,depth0,helpers,partials,data) {
      return "";
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}),"episode",{"name":"compare","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"7":function(container,depth0,helpers,partials,data) {
      return "          card-video\n";
  },"9":function(container,depth0,helpers,partials,data) {
      return "card-type-station-"
      + container.escapeExpression((helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}));
  },"11":function(container,depth0,helpers,partials,data) {
      return "      card-show-attention-highlight\n";
  },"13":function(container,depth0,helpers,partials,data) {
      return "no-image-url";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function";

    return "<div\n  class=\"\n    card\n    card-type-"
      + alias3((helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}))
      + "\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.isVideo : depth0),true,{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "")
      + "    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.showAttentionHighlight : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    "
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  \"\n  data-uri=\""
      + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n  data-contextmenu\n  data-drag-text=\""
      + alias3(((helper = (helper = helpers.dragText || (depth0 != null ? depth0.dragText : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"dragText","hash":{},"data":data}) : helper)))
      + "\"\n  draggable=\"true\"\n  data-ta-id=\"card\"\n>\n  <div class=\"card-attention-highlight-box\">\n  </div>\n  <div class=\"card-image-wrapper\" data-contextmenu-spy data-ta-id=\"card-image-wrapper\">\n"
      + ((stack1 = container.invokePartial(partials["./internal/image-with-overlay.hbs"],depth0,{"name":"./internal/image-with-overlay.hbs","data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "  </div>\n</div>\n";
  },"usePartial":true,"useData":true});

  },{"./internal/image-with-overlay.hbs":171,"hbsfy/runtime":745}],168:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./internal/image-with-overlay.hbs');
  HandlebarsCompiler.registerPartial('./internal/image-with-overlay.hbs', partial$0);
  var partial$1 = require('./internal/controls.hbs');
  HandlebarsCompiler.registerPartial('./internal/controls.hbs', partial$1);
  var partial$2 = require('./internal/linked-image.hbs');
  HandlebarsCompiler.registerPartial('./internal/linked-image.hbs', partial$2);
  var partial$3 = require('./internal/controls.hbs');
  HandlebarsCompiler.registerPartial('./internal/controls.hbs', partial$3);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "      card-video\n";
  },"3":function(container,depth0,helpers,partials,data) {
      return "card-type-station-"
      + container.escapeExpression((helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}));
  },"5":function(container,depth0,helpers,partials,data) {
      return "      card-show-attention-highlight\n";
  },"7":function(container,depth0,helpers,partials,data) {
      return "added";
  },"9":function(container,depth0,helpers,partials,data) {
      return "no-image-url";
  },"11":function(container,depth0,helpers,partials,data) {
      return "data-context";
  },"13":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "      <div class=\"card-image-hit-area\" data-log-click=\"media-image\">\n"
      + ((stack1 = container.invokePartial(partials["./internal/image-with-overlay.hbs"],depth0,{"name":"./internal/image-with-overlay.hbs","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n";
  },"14":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["./internal/controls.hbs"],depth0,{"name":"./internal/controls.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"16":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "      <div class=\"card-image-hit-area\" data-card-trigger-pressed-state>\n"
      + ((stack1 = container.invokePartial(partials["./internal/linked-image.hbs"],depth0,{"name":"./internal/linked-image.hbs","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n";
  },"18":function(container,depth0,helpers,partials,data) {
      var helper;

    return "      <div class=\"card-progress\">\n        <div class=\"card-progress__bar\" style=\"--progress: "
      + container.escapeExpression(((helper = (helper = helpers.progress || (depth0 != null ? depth0.progress : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"progress","hash":{},"data":data}) : helper)))
      + "\"></div>\n      </div>\n";
  },"20":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "  <div\n    class=\"\n      card-info-wrapper\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0, blockParams, depths),"inverse":container.program(23, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.metadata : depth0),{"name":"if","hash":{},"fn":container.program(26, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    \"\n  >\n    <div class=\"card-info-title\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.noLink : depth0),{"name":"if","hash":{},"fn":container.program(28, data, 0, blockParams, depths),"inverse":container.program(30, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
      + "    </div>\n\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"if","hash":{},"fn":container.program(35, data, 0, blockParams, depths),"inverse":container.program(46, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.metadata : depth0),{"name":"if","hash":{},"fn":container.program(49, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n";
  },"21":function(container,depth0,helpers,partials,data) {
      return "        card-info-with-subtitle-links\n";
  },"23":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.description : depth0),{"name":"if","hash":{},"fn":container.program(24, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"24":function(container,depth0,helpers,partials,data) {
      return "          card-info-with-description\n";
  },"26":function(container,depth0,helpers,partials,data) {
      return "        card-info-with-metadata\n";
  },"28":function(container,depth0,helpers,partials,data) {
      var helper;

    return "        <span data-log-click=\"media-title\">\n          "
      + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"data":data}) : helper)))
      + "\n        </span>\n";
  },"30":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "      <a\n        href=\""
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.targetUri : depth0),{"name":"if","hash":{},"fn":container.program(31, data, 0),"inverse":container.program(33, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n        data-uri=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n        data-log-click=\"media-title\"\n        data-ta-id=\"card-title-link\"\n        title=\""
      + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "\"\n        data-interaction-target=\"title\"\n      >\n        "
      + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "\n      </a>\n";
  },"31":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.targetUri || (depth0 != null ? depth0.targetUri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"targetUri","hash":{},"data":data}) : helper)));
  },"33":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"uri","hash":{},"data":data}) : helper)));
  },"35":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var stack1;

    return "    <div class=\"card-info-subtitle-links\" data-interaction-context=\"subtitle-links\">\n"
      + ((stack1 = helpers.each.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.subtitleLinks : depth0),{"name":"each","hash":{},"fn":container.program(36, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    </div>\n";
  },"36":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.uri : depth0),"spotify:artist:0LyfQWJT6nXafLPZqxe9Of",{"name":"compare","hash":{},"fn":container.program(37, data, 0, blockParams, depths),"inverse":container.program(39, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "");
  },"37":function(container,depth0,helpers,partials,data) {
      return "        "
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),"VariousArtistsCapitalized",{"name":"loc","hash":{},"data":data}))
      + "\n";
  },"39":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "        <a\n          title=\""
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "\"\n          href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n          data-uri=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n          data-ta-id=\"card-subtitle-link\"\n          data-interaction-target=\""
      + alias4(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"index","hash":{},"data":data}) : helper)))
      + "\"\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depths[1] != null ? depths[1].uri : depths[1]),{"name":"type","hash":{},"data":data}),"album",{"name":"compare","hash":{"operator":"=="},"fn":container.program(40, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depths[1] != null ? depths[1].uri : depths[1]),{"name":"type","hash":{},"data":data}),"playlist",{"name":"compare","hash":{"operator":"=="},"fn":container.program(42, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "        >"
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "</a>"
      + ((stack1 = helpers.unless.call(alias1,(data && data.last),{"name":"unless","hash":{},"fn":container.program(44, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n";
  },"40":function(container,depth0,helpers,partials,data) {
      return "            data-log-click=\"artist-name\"\n";
  },"42":function(container,depth0,helpers,partials,data) {
      return "            data-log-click=\"owner-name\"\n";
  },"44":function(container,depth0,helpers,partials,data) {
      return ", ";
  },"46":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.description : depth0),{"name":"if","hash":{},"fn":container.program(47, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"47":function(container,depth0,helpers,partials,data) {
      var helper;

    return "      <div class=\"card-info-subtitle-description\" data-ta-id=\"card-description\">\n        "
      + container.escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"description","hash":{},"data":data}) : helper)))
      + "\n      </div>\n";
  },"49":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "    <div class=\"card-info-subtitle-metadata\" data-ta-id=\"card-metadata\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isNew : depth0),{"name":"if","hash":{},"fn":container.program(50, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      "
      + container.escapeExpression(((helper = (helper = helpers.metadata || (depth0 != null ? depth0.metadata : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"metadata","hash":{},"data":data}) : helper)))
      + "\n    </div>\n";
  },"50":function(container,depth0,helpers,partials,data) {
      return "      <div class=\"card-info-subtitle-new-mark\"></div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var stack1, helper, options, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function", buffer =
    "<div\n  class=\"\n    card\n    card-type-"
      + alias3((helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}))
      + "\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.isVideo : depth0),true,{"name":"compare","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.showAttentionHighlight : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.added : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    "
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(9, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  \"\n  data-log-context=\"media-object\"\n  data-interaction-context=\"card\"\n  data-log-data='{ \"name\": \""
      + alias3(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "\", \"target_uri\": \""
      + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" }'\n  data-uri=\""
      + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n  data-contextmenu\n  ";
    stack1 = ((helper = (helper = helpers.noContext || (depth0 != null ? depth0.noContext : depth0)) != null ? helper : alias2),(options={"name":"noContext","hash":{},"fn":container.noop,"inverse":container.program(11, data, 0, blockParams, depths),"data":data}),(typeof helper === alias4 ? helper.call(alias1,options) : helper));
    if (!helpers.noContext) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + "\n  data-card-pressed-container\n  data-ta-id=\"card\"\n>\n  <div class=\"card-attention-highlight-box\">\n  </div>\n  <div class=\"card-image-wrapper\" data-contextmenu-spy data-ta-id=\"card-image-wrapper\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.noLink : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0, blockParams, depths),"inverse":container.program(16, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.progress : depth0),{"name":"if","hash":{},"fn":container.program(18, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.title : depth0),{"name":"if","hash":{},"fn":container.program(20, data, 0, blockParams, depths),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n</div>\n";
  },"usePartial":true,"useData":true,"useDepths":true});

  },{"./internal/controls.hbs":170,"./internal/image-with-overlay.hbs":171,"./internal/linked-image.hbs":173,"hbsfy/runtime":745}],169:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "  <button\n    type=\"button\"\n    class=\"button button-play button-icon-with-stroke card-button-play\"\n    data-ta-id=\"card-button-play\"\n    data-log-click=\"play-button\"\n    data-interaction-target=\"play-pause-button\"\n    data-interaction-intent=\"play\"\n"
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.range : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
      + "  >\n  </button>\n";
  },"2":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, buffer =
    "      data-button=\"play\"\n      ";
    stack1 = ((helper = (helper = helpers.range || (depth0 != null ? depth0.range : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"range","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),options) : helper));
    if (!helpers.range) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + "\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "data-range=\""
      + alias4(((helper = (helper = helpers.start || (depth0 != null ? depth0.start : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"start","hash":{},"data":data}) : helper)))
      + ","
      + alias4(((helper = (helper = helpers.end || (depth0 != null ? depth0.end : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"end","hash":{},"data":data}) : helper)))
      + "\"";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.contextPage : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.program(9, data, 0),"data":data})) != null ? stack1 : "");
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, buffer =
    "        data-button=\"play\"\n        ";
    stack1 = ((helper = (helper = helpers.contextPage || (depth0 != null ? depth0.contextPage : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"contextPage","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),options) : helper));
    if (!helpers.contextPage) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + "\n";
  },"7":function(container,depth0,helpers,partials,data) {
      return "data-context-page=\""
      + container.escapeExpression(container.lambda(depth0, depth0))
      + "\"";
  },"9":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.trackUri : depth0),{"name":"if","hash":{},"fn":container.program(10, data, 0),"inverse":container.program(13, data, 0),"data":data})) != null ? stack1 : "");
  },"10":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, buffer =
    "          ";
    stack1 = ((helper = (helper = helpers.trackUri || (depth0 != null ? depth0.trackUri : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"trackUri","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),options) : helper));
    if (!helpers.trackUri) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + "\n          data-button=\"play\"\n";
  },"11":function(container,depth0,helpers,partials,data) {
      return "data-track-uri=\""
      + container.escapeExpression(container.lambda(depth0, depth0))
      + "\"";
  },"13":function(container,depth0,helpers,partials,data) {
      return "          data-button=\"play-context\"\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.uri : depth0),"playlist","track","album","station","artist","episode","collection-album","collection-artist","show",{"name":"type","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"useData":true});

  },{"hbsfy/runtime":745}],170:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./controls-play-button.hbs');
  HandlebarsCompiler.registerPartial('./controls-play-button.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.uri : depth0),"playlist","track","album","station","artist","show","collection-album","collection-artist",{"name":"type","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"track","album","collection-album",{"name":"type","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"playlist","artist","show","collection-artist",{"name":"type","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = (helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.uri : depth0),"station",{"name":"type","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"3":function(container,depth0,helpers,partials,data) {
      var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;

    return "      <button\n        type=\"button\"\n        data-button=\"add\"\n        class=\"button button-add card-button-add\"\n        data-ta-id=\"card-button-add\"\n        data-tooltip=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Save",{"name":"loc","hash":{},"data":data}))
      + "\"\n        data-tooltip-add=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Save",{"name":"loc","hash":{},"data":data}))
      + "\"\n        data-tooltip-remove=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Remove",{"name":"loc","hash":{},"data":data}))
      + "\"\n        data-log-click=\"add-button\"\n        data-interaction-target=\"save-remove-button\"\n        data-interaction-intent=\"save\"></button>\n";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, buffer = "";

    stack1 = ((helper = (helper = helpers.currentUserPlaylist || (depth0 != null ? depth0.currentUserPlaylist : depth0)) != null ? helper : helpers.helperMissing),(options={"name":"currentUserPlaylist","hash":{},"fn":container.noop,"inverse":container.program(6, data, 0),"data":data}),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),options) : helper));
    if (!helpers.currentUserPlaylist) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer;
  },"6":function(container,depth0,helpers,partials,data) {
      var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;

    return "      <button\n        type=\"button\"\n        data-button=\"add\"\n        class=\"button button-add card-button-add\"\n        data-ta-id=\"card-button-add\"\n        data-tooltip=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Follow",{"name":"loc","hash":{},"data":data}))
      + "\"\n        data-tooltip-add=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Follow",{"name":"loc","hash":{},"data":data}))
      + "\"\n        data-tooltip-remove=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Unfollow",{"name":"loc","hash":{},"data":data}))
      + "\"\n        data-log-click=\"follow-button\"\n        data-interaction-target=\"toggle-follow-state-button\"\n        data-interaction-intent=\"follow\"></button>\n";
  },"8":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}),"cluster",{"name":"compare","hash":{"operator":"!="},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"10":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.uri : depth0),"playlist","track","album","station","artist","collection-album","collection-artist",{"name":"type","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"11":function(container,depth0,helpers,partials,data) {
      return "    <button\n      type=\"button\"\n      data-button=\"contextmenu\"\n      class=\"button button-more button-no-border card-button-more\"\n      data-ta-id=\"card-button-context-menu\"\n      data-tooltip=\""
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),"More",{"name":"loc","hash":{},"data":data}))
      + "\"\n      data-log-click=\"context-menu-button\"\n      data-interaction-target=\"context-menu-button\"\n      data-interaction-intent=\"show-options\"></button>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.playButtonOnly : depth0),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = container.invokePartial(partials["./controls-play-button.hbs"],depth0,{"name":"./controls-play-button.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.playButtonOnly : depth0),{"name":"unless","hash":{},"fn":container.program(10, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"./controls-play-button.hbs":169,"hbsfy/runtime":745}],171:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./image.hbs');
  HandlebarsCompiler.registerPartial('./image.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "  <div class=\"card-overlay\"></div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["./image.hbs"],depth0,{"name":"./image.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.noPlayButton : depth0),{"name":"unless","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"./image.hbs":172,"hbsfy/runtime":745}],172:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./placeholder.hbs');
  HandlebarsCompiler.registerPartial('./placeholder.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return "style=\"background-image: url('"
      + container.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"imageUrl","hash":{},"data":data}) : helper)))
      + "')\"";
  },"3":function(container,depth0,helpers,partials,data) {
      var helper;

    return "      data-image-url=\""
      + container.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"imageUrl","hash":{},"data":data}) : helper)))
      + "\"\n";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(helpers.type || (depth0 && depth0.type) || alias2).call(alias1,(depth0 != null ? depth0.seedUri : depth0),{"name":"type","hash":{},"data":data}),"cluster",{"name":"compare","hash":{"operator":"!="},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.dominantColor : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      <div class=\"card-station-layer card-station-mask\"></div>\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"7":function(container,depth0,helpers,partials,data) {
      var helper;

    return "        <div class=\"card-station-layer card-station-highlight\" style=\"background-color:"
      + container.escapeExpression(((helper = (helper = helpers.dominantColor || (depth0 != null ? depth0.dominantColor : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"dominantColor","hash":{},"data":data}) : helper)))
      + "\"></div>\n";
  },"9":function(container,depth0,helpers,partials,data) {
      var helper;

    return "        <div class=\"card-station-overlay\" style=\"background-image: url("
      + container.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"imageUrl","hash":{},"data":data}) : helper)))
      + ")\"></div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return ((stack1 = container.invokePartial(partials["./placeholder.hbs"],depth0,{"name":"./placeholder.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "\n<div class=\"card-image-content-wrapper\">\n  <div\n    class=\"card-image\"\n    "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    data-ta-id=\"card-image\"\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  >\n  </div>\n\n"
      + ((stack1 = (helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(alias1,(depth0 != null ? depth0.uri : depth0),"station",{"name":"type","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"usePartial":true,"useData":true});

  },{"./placeholder.hbs":174,"hbsfy/runtime":745}],173:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./image-with-overlay.hbs');
  HandlebarsCompiler.registerPartial('./image-with-overlay.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.dragText || (depth0 != null ? depth0.dragText : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"dragText","hash":{},"data":data}) : helper)));
  },"3":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"data":data}) : helper)));
  },"5":function(container,depth0,helpers,partials,data) {
      return "no-image-url";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<a\n  href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n  data-uri=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n  data-log-click=\"media-image\"\n  draggable=\"true\"\n  data-drag-text=\""
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.dragText : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n  class=\"card-image-link "
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\"\n  data-interaction-target=\"image\"\n  aria-hidden=\"true\"\n>\n  <div class=\"card-hit-area-counter-scale\"></div>\n"
      + ((stack1 = container.invokePartial(partials["./image-with-overlay.hbs"],depth0,{"name":"./image-with-overlay.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</a>\n";
  },"usePartial":true,"useData":true});

  },{"./image-with-overlay.hbs":171,"hbsfy/runtime":745}],174:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<div class=\"card-placeholder-wrapper\">\n  <svg class=\"card-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n    <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n    <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n    <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n    <text class=\"track-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n    <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n    <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n    <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n    <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n    <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n    <text class=\"episode-placeholder\" x=\"5\" y=\"9.8\">&#xf26C;</text>\n  </svg>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],175:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./internal/image.hbs');
  HandlebarsCompiler.registerPartial('./internal/image.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return "        <div\n          class=\"card-puff__image\"\n          style=\"background-image: url("
      + container.escapeExpression(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"imageUrl","hash":{},"data":data}) : helper)))
      + ");\"\n        ></div>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "      <div class=\"card-puff__images\">\n"
      + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.images : depth0),{"name":"each","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.title : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"4":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "          <div class=\"\n            card-puff__card-image\n            card\n            card-type-"
      + container.escapeExpression((helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}))
      + "\n            "
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"unless","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n          \">\n"
      + ((stack1 = container.invokePartial(partials["./internal/image.hbs"],depth0,{"name":"./internal/image.hbs","data":data,"indent":"            ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "          </div>\n";
  },"5":function(container,depth0,helpers,partials,data) {
      return "no-image-url";
  },"7":function(container,depth0,helpers,partials,data) {
      var helper;

    return "        <div class=\"card-puff__title-container\" data-ta-id=\"card-title-link\">\n          <div class=\"card-puff__title\">"
      + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"data":data}) : helper)))
      + "</div>\n        </div>\n";
  },"9":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    <div class=\"card-puff__subtitle\" data-ta-id=\"puff-subtitle\">\n      "
      + container.escapeExpression(((helper = (helper = helpers.subtitle || (depth0 != null ? depth0.subtitle : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"subtitle","hash":{},"data":data}) : helper)))
      + "\n    </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<div\n  class=\"card card-puff\"\n  data-card-pressed-container\n  data-interaction-context=\"card-puff\"\n>\n  <div class=\"card-puff__image-wrapper\">\n    <a\n      href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n      class=\"card-puff__link\"\n      data-log-click=\"puff\"\n      draggable=\"false\"\n      data-card-trigger-pressed-state\n      aria-label="
      + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "\n      data-interaction-target=\"image\"\n    >\n      <div class=\"card-hit-area-counter-scale\"></div>\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.imageUrl : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.images : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    </a>\n  </div>\n\n  <div class=\"card-puff__info-container\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.subtitle : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n</div>\n";
  },"usePartial":true,"useData":true});

  },{"./internal/image.hbs":172,"hbsfy/runtime":745}],176:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "        <h1 class=\"hdr-l\">"
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"ErrorTitle",{"name":"loc","hash":{},"data":data}))
      + "</h1>\n        <div class=\"message\">"
      + ((stack1 = (helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"ErrorMessage",{"name":"loc","hash":{},"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function";

    return "        <h1 class=\"hdr-l\">"
      + container.escapeExpression(((helper = (helper = helpers.errorTitle || (depth0 != null ? depth0.errorTitle : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"errorTitle","hash":{},"data":data}) : helper)))
      + "</h1>\n        <div class=\"message\">"
      + ((stack1 = ((helper = (helper = helpers.errorMessage || (depth0 != null ? depth0.errorMessage : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"errorMessage","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "</div>\n";
  },"5":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "        <a class=\"button button-white\" href=\""
      + alias4(((helper = (helper = helpers.errorEscapeUrl || (depth0 != null ? depth0.errorEscapeUrl : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"errorEscapeUrl","hash":{},"data":data}) : helper)))
      + "\" data-log-click=\"error-escape\">"
      + alias4(((helper = (helper = helpers.errorEscapeMessage || (depth0 != null ? depth0.errorEscapeMessage : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"errorEscapeMessage","hash":{},"data":data}) : helper)))
      + "</a>\n";
  },"7":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "        <h1 class=\"hdr-l\">"
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"OfflineTitle",{"name":"loc","hash":{},"data":data}))
      + "</h1>\n        <div class=\"message\">"
      + ((stack1 = (helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"OfflineMessage",{"name":"loc","hash":{},"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"9":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function";

    return "        <h1 class=\"hdr-l\">"
      + container.escapeExpression(((helper = (helper = helpers.offlineTitle || (depth0 != null ? depth0.offlineTitle : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"offlineTitle","hash":{},"data":data}) : helper)))
      + "</h1>\n        <div class=\"message\">"
      + ((stack1 = ((helper = (helper = helpers.offlineMessage || (depth0 != null ? depth0.offlineMessage : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"offlineMessage","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "</div>\n";
  },"11":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "        <a class=\"button button-white\" href=\""
      + alias4(((helper = (helper = helpers.offlineEscapeUrl || (depth0 != null ? depth0.offlineEscapeUrl : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"offlineEscapeUrl","hash":{},"data":data}) : helper)))
      + "\" data-log-click=\"offline-escape\">"
      + alias4(((helper = (helper = helpers.offlineEscapeMessage || (depth0 != null ? depth0.offlineEscapeMessage : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"offlineEscapeMessage","hash":{},"data":data}) : helper)))
      + "</a>\n";
  },"13":function(container,depth0,helpers,partials,data) {
      var helper;

    return "  <div class=\"error-version text-muted\">"
      + container.escapeExpression(((helper = (helper = helpers.errorVersion || (depth0 != null ? depth0.errorVersion : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"errorVersion","hash":{},"data":data}) : helper)))
      + "</div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<div class=\"error-and-offline\" data-log-context=\"error-and-offline\">\n  <div class=\"container\">\n    <div class=\"error-content\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.useDefaultError : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.errorEscapeMessage : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    </div>\n    <div class=\"offline-content\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.useDefaultOffline : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.program(9, data, 0),"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.offlineEscapeMessage : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    </div>\n  </div>\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.errorVersion : depth0),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],177:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./cards/card.hbs');
  HandlebarsCompiler.registerPartial('./cards/card.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "  <div class=\"facepile\" data-tooltip title=\""
      + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"data":data}) : helper)))
      + "\" data-tooltip-instant>\n"
      + ((stack1 = container.invokePartial(partials["./cards/card.hbs"],depth0,{"name":"./cards/card.hbs","data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "  </div>\n";
  },"3":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "  <button\n    type=\"button\"\n    class=\"button facepile-badge\"\n    title=\""
      + alias4(((helper = (helper = helpers.badgeTooltip || (depth0 != null ? depth0.badgeTooltip : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"badgeTooltip","hash":{},"data":data}) : helper)))
      + "\"\n    data-tooltip\n    data-tooltip-instant\n    data-modal=\"spotify:modal:socialproof:"
      + alias4(container.lambda((depths[1] != null ? depths[1].uri : depths[1]), depth0))
      + "\"\n  >\n    +"
      + alias4(((helper = (helper = helpers.badgeCount || (depth0 != null ? depth0.badgeCount : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"badgeCount","hash":{},"data":data}) : helper)))
      + "\n  </button>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data,blockParams,depths) {
      var stack1;

    return ((stack1 = (helpers.facepile || (depth0 && depth0.facepile) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.users : depth0),{"name":"facepile","hash":{},"fn":container.program(1, data, 0, blockParams, depths),"inverse":container.program(3, data, 0, blockParams, depths),"data":data})) != null ? stack1 : "");
  },"usePartial":true,"useData":true,"useDepths":true});

  },{"./cards/card.hbs":168,"hbsfy/runtime":745}],178:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./facepile-common.hbs');
  HandlebarsCompiler.registerPartial('./facepile-common.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<div class=\"facepile-list\">\n"
      + ((stack1 = container.invokePartial(partials["./facepile-common.hbs"],depth0,{"name":"./facepile-common.hbs","data":data,"indent":"\t","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</div>\n";
  },"usePartial":true,"useData":true});

  },{"./facepile-common.hbs":177,"hbsfy/runtime":745}],179:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "gc-image-cols-"
      + container.escapeExpression(container.lambda(depth0, depth0));
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<div\n  class=\"card genre-card\"\n  data-card-pressed-container\n>\n  <a\n    href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n    draggable=\"false\"\n    data-log-click=\"genre-card\"\n    data-card-trigger-pressed-state\n    data-interaction-target=\"genre-card\"\n  >\n    <div class=\"card-hit-area-counter-scale\"></div>\n    <div class=\"gc-image-container\">\n      <div class=\"gc-image "
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.cols : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\" style=\"background-image: url('"
      + alias4(((helper = (helper = helpers.imageUrl || (depth0 != null ? depth0.imageUrl : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"imageUrl","hash":{},"data":data}) : helper)))
      + "')\"></div>\n      <div class=\"gc-label-container\">\n        <div class=\"gc-label-text-wrapper\">\n          <span class=\"gc-label-text\" data-ta-id=\"genre-card-title\">"
      + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "</span>\n        </div>\n      </div>\n    </div>\n  </a>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],180:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./search-field.hbs');
  HandlebarsCompiler.registerPartial('./search-field.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<section class=\"container\">\n  <div class=\"h-search-bar\">\n"
      + ((stack1 = container.invokePartial(partials["./search-field.hbs"],depth0,{"name":"./search-field.hbs","data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "  </div>\n</section>\n";
  },"usePartial":true,"useData":true});

  },{"./search-field.hbs":181,"hbsfy/runtime":745}],181:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "focus";
  },"3":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "          <li class=\"h-search-suggestion\">\n            <span class=\"h-search-matches\">"
      + alias4(((helper = (helper = helpers.matches || (depth0 != null ? depth0.matches : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"matches","hash":{},"data":data}) : helper)))
      + "</span> <span class=\"h-search-result\">"
      + alias4(((helper = (helper = helpers.result || (depth0 != null ? depth0.result : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"result","hash":{},"data":data}) : helper)))
      + "</span>\n          </li>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression, buffer =
    "<div class=\"h-search-field-outer-wrapper\" data-interaction-context=\"filter\">\n  <div class=\"h-search-field-wrapper\" data-filter>\n    <div class=\"h-search-wrapper spoticon-search-16 ";
    stack1 = ((helper = (helper = helpers.searchFocus || (depth0 != null ? depth0.searchFocus : depth0)) != null ? helper : alias2),(options={"name":"searchFocus","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data}),(typeof helper === alias3 ? helper.call(alias1,options) : helper));
    if (!helpers.searchFocus) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + "\">\n      <input class=\"h-search\" type=\"text\" placeholder=\""
      + alias4((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Filter",{"name":"loc","hash":{},"data":data}))
      + "\" value=\""
      + alias4(((helper = (helper = helpers.filterString || (depth0 != null ? depth0.filterString : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"filterString","hash":{},"data":data}) : helper)))
      + "\" />\n      <span class=\"h-search-close spoticon-x-16\" data-interaction-target=\"remove-filter-button\" data-interaction-intent=\"remove-filter\"></span>\n\n      <ul class=\"h-search-suggestions\">\n"
      + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.searchResult : depth0),{"name":"each","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </ul>\n    </div>\n  </div>\n</div>";
  },"useData":true});

  },{"hbsfy/runtime":745}],182:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../buttons/add-interior.hbs');
  HandlebarsCompiler.registerPartial('../../../buttons/add-interior.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "added";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<button\n  class=\"button button-with-stroke button-add "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isAdded : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\"\n  data-button=\"add\"\n  data-uri=\""
      + container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n  data-log-click=\"add-button\"\n  data-ta-id=\"page-header-button-add\"\n  data-interaction-target=\"add-remove-button\"\n  data-interaction-intent=\"add\"\n>\n"
      + ((stack1 = container.invokePartial(partials["../../../buttons/add-interior.hbs"],depth0,{"name":"../../../buttons/add-interior.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</button>";
  },"usePartial":true,"useData":true});

  },{"../../../buttons/add-interior.hbs":164,"hbsfy/runtime":745}],183:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;

    return "<button\n  class=\"button button-icon-with-stroke spoticon-more-16\"\n  data-button=\"contextmenu\"\n  data-tooltip=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"More",{"name":"loc","hash":{},"data":data}))
      + "\"\n  data-log-click=\"contextmenu-button\"\n  data-ta-id=\"page-header-button-more\"\n  aria-label=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"More",{"name":"loc","hash":{},"data":data}))
      + "\"\n  data-interaction-target=\"context-menu-button\"\n  data-interaction-intent=\"show-options\"\n>\n</button>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],184:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../buttons/play-interior.hbs');
  HandlebarsCompiler.registerPartial('../../../buttons/play-interior.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    data-uri=\""
      + container.escapeExpression(((helper = (helper = helpers.playContextUri || (depth0 != null ? depth0.playContextUri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"playContextUri","hash":{},"data":data}) : helper)))
      + "\"\n    data-context\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<button\n  class=\"button button-green button-play\"\n  data-button=\"play-context\"\n  data-log-click=\"play-button\"\n  data-ta-id=\"page-header-button-play\"\n"
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.playContextUri : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  data-interaction-target=\"play-pause-button\"\n>\n"
      + ((stack1 = container.invokePartial(partials["../../../buttons/play-interior.hbs"],depth0,{"name":"../../../buttons/play-interior.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</button>";
  },"usePartial":true,"useData":true});

  },{"../../../buttons/play-interior.hbs":165,"hbsfy/runtime":745}],185:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "    <div\n      class=\"\n        glue-page-header__background-image-loader\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.isLoaded : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      \"\n      data-glue-page-header-background-image-loader\n    >\n      <div\n        class=\"glue-page-header__background-image\"\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.background : depth0)) != null ? stack1.imageUrl : stack1),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "        data-glue-page-header-background-image\n        data-glue-page-header-background-image-url=\""
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.background : depth0)) != null ? stack1.imageUrl : stack1), depth0))
      + "\"\n        data-ta-id=\"page-header-background-image\"\n      >\n      </div>\n    </div>\n    <div class=\"glue-page-header__background-overlay\">\n    </div>\n    <div class=\"glue-page-header__background-image-overlay-gradient\">\n    </div>\n    <div\n      class=\"glue-page-header__background-scroll-overlay-ellipse-backdrop\"\n      data-glue-page-header-background-scroll-overlay-ellipse-backdrop\n    >\n    </div>\n    <div\n      class=\"glue-page-header__background-scroll-overlay-ellipse\"\n      data-glue-page-header-background-scroll-overlay-ellipse\n    >\n    </div>\n";
  },"2":function(container,depth0,helpers,partials,data) {
      return "          glue-page-header__background-image-loader--is-loaded\n";
  },"4":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "          style=\"background-image: url("
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.background : depth0)) != null ? stack1.imageUrl : stack1), depth0))
      + ")\"\n";
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "    <div\n      class=\"glue-page-header__background-color\"\n"
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.background : depth0)) != null ? stack1.color : stack1),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    >\n    </div>\n    <div class=\"glue-page-header__background-overlay\">\n    </div>\n    <div\n      class=\"glue-page-header__background-scroll-overlay\"\n      data-glue-page-header-background-scroll-overlay\n    >\n    </div>\n";
  },"7":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "        style=\"background-color: "
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.background : depth0)) != null ? stack1.color : stack1), depth0))
      + "\"\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<div\n  class=\"glue-page-header__background\"\n  data-glue-page-header-background\n>\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.background : depth0)) != null ? stack1.type : stack1),"image",{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(6, data, 0),"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],186:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../generic/button-play.hbs');
  HandlebarsCompiler.registerPartial('../generic/button-play.hbs', partial$0);
  var partial$1 = require('../generic/button-add.hbs');
  HandlebarsCompiler.registerPartial('../generic/button-add.hbs', partial$1);
  var partial$2 = require('../generic/button-more.hbs');
  HandlebarsCompiler.registerPartial('../generic/button-more.hbs', partial$2);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "    <div class=\"glue-page-header__button\">\n"
      + ((stack1 = container.invokePartial(partials["../generic/button-play.hbs"],depth0,{"name":"../generic/button-play.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "    </div>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "    <div class=\"glue-page-header__button\">\n"
      + ((stack1 = container.invokePartial(partials["../generic/button-add.hbs"],depth0,{"name":"../generic/button-add.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "    </div>\n";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "    <div class=\"glue-page-header__button\">\n"
      + ((stack1 = container.invokePartial(partials["../generic/button-more.hbs"],depth0,{"name":"../generic/button-more.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "    </div>\n";
  },"7":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers.each.call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.buttons : depth0)) != null ? stack1.customButtons : stack1),{"name":"each","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"8":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "      <div class=\"glue-page-header__button\">\n        "
      + ((stack1 = container.lambda(depth0, depth0)) != null ? stack1 : "")
      + "\n      </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<div class=\"glue-page-header__buttons\">\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.buttons : depth0)) != null ? stack1.playButton : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.buttons : depth0)) != null ? stack1.addButton : stack1),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.buttons : depth0)) != null ? stack1.moreButton : stack1),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.buttons : depth0)) != null ? stack1.customButtons : stack1),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</div>";
  },"usePartial":true,"useData":true});

  },{"../generic/button-add.hbs":182,"../generic/button-more.hbs":183,"../generic/button-play.hbs":184,"hbsfy/runtime":745}],187:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../facepile.hbs');
  HandlebarsCompiler.registerPartial('../../../facepile.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.escapeExpression;

    return "  <div class=\"glue-page-header__count-label\">\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.countLabel : depth0)) != null ? stack1.link : stack1),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      <div class=\"glue-page-header__count-label-text\">\n        "
      + alias2(container.lambda(((stack1 = (depth0 != null ? depth0.countLabel : depth0)) != null ? stack1.label : stack1), depth0))
      + "\n      </div>\n      <div class=\"glue-page-header__count-label-number\">\n        "
      + alias2((helpers.numeral || (depth0 && depth0.numeral) || helpers.helperMissing).call(alias1,((stack1 = (depth0 != null ? depth0.countLabel : depth0)) != null ? stack1.number : stack1),{"name":"numeral","hash":{},"data":data}))
      + "\n      </div>\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.countLabel : depth0)) != null ? stack1.link : stack1),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.countLabel : depth0)) != null ? stack1.facePile : stack1),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n";
  },"2":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "    <a\n      href=\""
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.countLabel : depth0)) != null ? stack1.link : stack1), depth0))
      + "\"\n      class=\"glue-page-header__count-label-link\"\n      data-glue-page-header-count-label-link\n      data-interaction-target=\"monthly-listeners-count\"\n    >\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    </a>\n";
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "      <div class=\"glue-page-header__count-label-facepile\">\n"
      + ((stack1 = container.invokePartial(partials["../../../facepile.hbs"],((stack1 = (depth0 != null ? depth0.countLabel : depth0)) != null ? stack1.facePile : stack1),{"name":"../../../facepile.hbs","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "      </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.countLabel : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"../../../facepile.hbs":178,"hbsfy/runtime":745}],188:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "  <div\n    class=\"glue-page-header__description\"\n    data-ta-id=\"page-header-description\"\n    data-glue-page-header-description\n  >\n    "
      + ((stack1 = ((helper = (helper = helpers.descriptionHTML || (depth0 != null ? depth0.descriptionHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"descriptionHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "\n  </div>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.description : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"4":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    <div\n      class=\"glue-page-header__description\"\n      data-ta-id=\"page-header-description\"\n      data-glue-page-header-description\n    >\n      "
      + container.escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"description","hash":{},"data":data}) : helper)))
      + "\n    </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.descriptionHTML : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "");
  },"useData":true});

  },{"hbsfy/runtime":745}],189:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../cards/card-without-link.hbs');
  HandlebarsCompiler.registerPartial('../../../cards/card-without-link.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "  <div class=\"glue-page-header__image\">\n    <div class=\"glue-page-header__image-inner\">\n      "
      + ((stack1 = ((helper = (helper = helpers.imageHTML || (depth0 != null ? depth0.imageHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"imageHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "\n    </div>\n  </div>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.image : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"4":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "    <div class=\"glue-page-header__image\">\n      <div class=\"glue-page-header__image-inner\">\n"
      + ((stack1 = container.invokePartial(partials["../../../cards/card-without-link.hbs"],(depth0 != null ? depth0.image : depth0),{"name":"../../../cards/card-without-link.hbs","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "      </div>\n    </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.imageHTML : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"../../../cards/card-without-link.hbs":167,"hbsfy/runtime":745}],190:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "  <span class=\"glue-page-header__label\" data-ta-id=\"page-header-label\">"
      + ((stack1 = ((helper = (helper = helpers.labelHTML || (depth0 != null ? depth0.labelHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"labelHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "</span>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.label : depth0),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"4":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    <span class=\"glue-page-header__label\" data-ta-id=\"page-header-label\">"
      + container.escapeExpression(((helper = (helper = helpers.label || (depth0 != null ? depth0.label : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"label","hash":{},"data":data}) : helper)))
      + "</span>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.labelHTML : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "");
  },"useData":true});

  },{"hbsfy/runtime":745}],191:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "  <div\n    class=\"glue-page-header__meta-info\"\n    data-ta-id=\"page-header-meta-info\"\n  >\n    "
      + ((stack1 = ((helper = (helper = helpers.metaInfoHTML || (depth0 != null ? depth0.metaInfoHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"metaInfoHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "\n  </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.metaInfoHTML : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"useData":true});

  },{"hbsfy/runtime":745}],192:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../navbar.hbs');
  HandlebarsCompiler.registerPartial('../../../navbar.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "  <div class=\"glue-page-header__navbar-wrapper\">\n"
      + ((stack1 = container.invokePartial(partials["../../../navbar.hbs"],(depth0 != null ? depth0.navBar : depth0),{"name":"../../../navbar.hbs","data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "  </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.navBar : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"../../../navbar.hbs":196,"hbsfy/runtime":745}],193:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "data-contextmenu";
  },"3":function(container,depth0,helpers,partials,data) {
      return "draggable=\"true\"";
  },"5":function(container,depth0,helpers,partials,data) {
      return "    data-glue-page-header-use-large-title\n";
  },"7":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    style=\"color: "
      + container.escapeExpression(((helper = (helper = helpers.titleColor || (depth0 != null ? depth0.titleColor : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"titleColor","hash":{},"data":data}) : helper)))
      + "\"\n";
  },"9":function(container,depth0,helpers,partials,data) {
      var stack1, helper;

    return "    "
      + ((stack1 = ((helper = (helper = helpers.titleHTML || (depth0 != null ? depth0.titleHTML : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"titleHTML","hash":{},"data":data}) : helper))) != null ? stack1 : "")
      + "\n";
  },"11":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    "
      + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"title","hash":{},"data":data}) : helper)))
      + "\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<h1\n  class=\"glue-page-header__title\"\n  data-uri=\""
      + container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n  data-ta-id=\"page-header-title\"\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.enableContextMenu : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.enableDragging : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  data-glue-page-header-title\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.useLargeTitle : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.titleColor : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ">\n"
      + "<span class=\"glue-page-header__title-text\" dir=\"auto\">"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.titleHTML : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.program(11, data, 0),"data":data})) != null ? stack1 : "")
      + "</span>"
      + "</h1>";
  },"useData":true});

  },{"hbsfy/runtime":745}],194:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./internal/page-header/background.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/background.hbs', partial$0);
  var partial$1 = require('./internal/page-header/image.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/image.hbs', partial$1);
  var partial$2 = require('./internal/page-header/label.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/label.hbs', partial$2);
  var partial$3 = require('./internal/page-header/title.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/title.hbs', partial$3);
  var partial$4 = require('./internal/page-header/description.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/description.hbs', partial$4);
  var partial$5 = require('./internal/page-header/meta-info.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/meta-info.hbs', partial$5);
  var partial$6 = require('./internal/page-header/buttons.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/buttons.hbs', partial$6);
  var partial$7 = require('./internal/page-header/count-label.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/count-label.hbs', partial$7);
  var partial$8 = require('./internal/page-header/buttons.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/buttons.hbs', partial$8);
  var partial$9 = require('./internal/page-header/image.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/image.hbs', partial$9);
  var partial$10 = require('./internal/page-header/title.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/title.hbs', partial$10);
  var partial$11 = require('./internal/page-header/buttons.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/buttons.hbs', partial$11);
  var partial$12 = require('./internal/page-header/navbar.hbs');
  HandlebarsCompiler.registerPartial('./internal/page-header/navbar.hbs', partial$12);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "      glue-page-header--with-navbar\n";
  },"3":function(container,depth0,helpers,partials,data) {
      return "      glue-page-header--with-count-label\n";
  },"5":function(container,depth0,helpers,partials,data) {
      return "      glue-page-header--with-responsive-height-small\n";
  },"7":function(container,depth0,helpers,partials,data) {
      return "      glue-page-header--with-responsive-height-large\n";
  },"9":function(container,depth0,helpers,partials,data) {
      return "      glue-page-header--"
      + container.escapeExpression((helpers.type || (depth0 && depth0.type) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.uri : depth0),{"name":"type","hash":{},"data":data}))
      + "\n";
  },"11":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    data-uri=\""
      + container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n";
  },"13":function(container,depth0,helpers,partials,data) {
      return "    data-context\n";
  },"15":function(container,depth0,helpers,partials,data) {
      return "    data-glue-page-header-sticky-height=\"160\"\n";
  },"17":function(container,depth0,helpers,partials,data) {
      return "    data-glue-page-header-sticky-height=\"116\"\n";
  },"19":function(container,depth0,helpers,partials,data) {
      var helper;

    return "    <div class=\"row\">\n      <div class=\""
      + container.escapeExpression(((helper = (helper = helpers.gridClasses || (depth0 != null ? depth0.gridClasses : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"gridClasses","hash":{},"data":data}) : helper)))
      + "\">\n";
  },"21":function(container,depth0,helpers,partials,data) {
      return "          glue-page-header__content--with-custom-image-size\n";
  },"23":function(container,depth0,helpers,partials,data) {
      return "          glue-page-header__content--with-button-placement-left\n";
  },"25":function(container,depth0,helpers,partials,data) {
      return "            glue-page-header__spacer--large\n";
  },"27":function(container,depth0,helpers,partials,data) {
      return "      </div>\n    </div>\n";
  },"29":function(container,depth0,helpers,partials,data) {
      var helper;

    return "        <div class=\"row\">\n          <div class=\""
      + container.escapeExpression(((helper = (helper = helpers.gridClasses || (depth0 != null ? depth0.gridClasses : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"gridClasses","hash":{},"data":data}) : helper)))
      + "\">\n";
  },"31":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["./internal/page-header/image.hbs"],depth0,{"name":"./internal/page-header/image.hbs","data":data,"indent":"            ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"33":function(container,depth0,helpers,partials,data) {
      return "          </div>\n        </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<header\n  class=\"\n    glue-page-header\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.navBar : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.countLabel : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.useResponsiveHeightSmall : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.useResponsiveHeightLarge : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    "
      + container.escapeExpression(((helper = (helper = helpers.modifiers || (depth0 != null ? depth0.modifiers : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"modifiers","hash":{},"data":data}) : helper)))
      + "\n  \"\n  data-glue-page-header\n  data-ta-id=\"page-header\"\n\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.buttons : depth0)) != null ? stack1.playButton : stack1),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.navBar : depth0),{"name":"if","hash":{},"fn":container.program(15, data, 0),"inverse":container.program(17, data, 0),"data":data})) != null ? stack1 : "")
      + ">\n"
      + ((stack1 = container.invokePartial(partials["./internal/page-header/background.hbs"],depth0,{"name":"./internal/page-header/background.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "\n  <div\n    class=\"\n      glue-page-header__content-wrapper\n      container\n    \"\n    data-glue-page-header-content\n  >\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.gridClasses : depth0),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    <div\n      class=\"\n        glue-page-header__content\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.useCustomImageSize : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.buttons : depth0)) != null ? stack1.buttonPlacementLeft : stack1),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      \"\n    >\n      <div class=\"glue-page-header__content-inner\" data-ta-id=\"page-header-inner-content\">\n"
      + ((stack1 = container.invokePartial(partials["./internal/page-header/image.hbs"],depth0,{"name":"./internal/page-header/image.hbs","data":data,"indent":"        ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "\n        <div class=\"glue-page-header__data\">\n"
      + ((stack1 = container.invokePartial(partials["./internal/page-header/label.hbs"],depth0,{"name":"./internal/page-header/label.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./internal/page-header/title.hbs"],depth0,{"name":"./internal/page-header/title.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./internal/page-header/description.hbs"],depth0,{"name":"./internal/page-header/description.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./internal/page-header/meta-info.hbs"],depth0,{"name":"./internal/page-header/meta-info.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./internal/page-header/buttons.hbs"],depth0,{"name":"./internal/page-header/buttons.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./internal/page-header/count-label.hbs"],depth0,{"name":"./internal/page-header/count-label.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "        </div>\n\n        <div class=\"\n          glue-page-header__spacer\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.useLargeSpacer : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "        \">\n        </div>\n      </div>\n\n"
      + ((stack1 = container.invokePartial(partials["./internal/page-header/buttons.hbs"],depth0,{"name":"./internal/page-header/buttons.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "    </div>\n\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.gridClasses : depth0),{"name":"if","hash":{},"fn":container.program(27, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n\n  <div\n    class=\"glue-page-header__sticky-wrapper\"\n    data-sticky-fixed-wrapper\n    aria-hidden=\"true\"\n  >\n    <div class=\"glue-page-header__sticky\" data-sticky>\n      <div class=\"container\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.gridClasses : depth0),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n        <div class=\"glue-page-header__sticky-inner\">\n"
      + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.hideImageInStickyHeader : depth0),{"name":"unless","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./internal/page-header/title.hbs"],depth0,{"name":"./internal/page-header/title.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./internal/page-header/buttons.hbs"],depth0,{"name":"./internal/page-header/buttons.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "        </div>\n\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.gridClasses : depth0),{"name":"if","hash":{},"fn":container.program(33, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n    </div>\n  </div>\n\n"
      + ((stack1 = container.invokePartial(partials["./internal/page-header/navbar.hbs"],depth0,{"name":"./internal/page-header/navbar.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</header>\n";
  },"usePartial":true,"useData":true});

  },{"./internal/page-header/background.hbs":185,"./internal/page-header/buttons.hbs":186,"./internal/page-header/count-label.hbs":187,"./internal/page-header/description.hbs":188,"./internal/page-header/image.hbs":189,"./internal/page-header/label.hbs":190,"./internal/page-header/meta-info.hbs":191,"./internal/page-header/navbar.hbs":192,"./internal/page-header/title.hbs":193,"hbsfy/runtime":745}],195:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return " data-navbar-item-matcher=\""
      + container.escapeExpression(((helper = (helper = helpers.matcher || (depth0 != null ? depth0.matcher : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"matcher","hash":{},"data":data}) : helper)))
      + "\"";
  },"3":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "  <a href=\""
      + alias4(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"url","hash":{},"data":data}) : helper)))
      + "\" data-log-click=\""
      + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
      + "\" draggable=\"false\" data-interaction-target=\"link\">"
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "</a>\n  ";
  },"5":function(container,depth0,helpers,partials,data) {
      var stack1;

    return " "
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.id : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.program(8, data, 0),"data":data})) != null ? stack1 : "")
      + " ";
  },"6":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "\n  <a data-log-click=\""
      + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
      + "\" draggable=\"false\" data-interaction-target=\"link\">"
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "</a>\n";
  },"8":function(container,depth0,helpers,partials,data) {
      var helper;

    return "  <p class=\"navbar-text\">"
      + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"data":data}) : helper)))
      + "</p>\n  ";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<li class=\""
      + alias4(((helper = (helper = helpers.className || (depth0 != null ? depth0.className : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"className","hash":{},"data":data}) : helper)))
      + "\" data-navbar-item-id=\""
      + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
      + "\""
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.matcher : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.url : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
      + "\n</li>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],196:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./navbar-item.hbs');
  HandlebarsCompiler.registerPartial('./navbar-item.hbs', partial$0);
  var partial$1 = require('./facepile.hbs');
  HandlebarsCompiler.registerPartial('./facepile.hbs', partial$1);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "no-overflow-menu";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["./navbar-item.hbs"],depth0,{"name":"./navbar-item.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"5":function(container,depth0,helpers,partials,data) {
      return "          <li class=\"overflow-menu-button\" data-navbar-item-id=\"navbar-overflow-menu\">\n            <a data-interaction-target=\"menu-overflow-button\" data-interaction-intent=\"show-overflowed-menu\">"
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),"More",{"name":"loc","hash":{},"data":data}))
      + "</a>\n          </li>\n";
  },"7":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.facePile : depth0)) != null ? stack1.users : stack1),{"name":"if","hash":{},"fn":container.program(8, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"8":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "            <div class=\"navbar-right facepile-list-container\">\n"
      + ((stack1 = container.invokePartial(partials["./facepile.hbs"],(depth0 != null ? depth0.facePile : depth0),{"name":"./facepile.hbs","data":data,"indent":"              ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "            </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression, buffer =
    "<div class=\"navbar-fixed-wrapper\" data-sticky-fixed-wrapper>\n  <div class=\"navbar\" data-sticky=\"true\">\n    <div class=\"container\">\n      <ul class=\"nav navbar-nav "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.noOverflowMenu : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\"\n        data-navbar=\"navbar\"\n        data-navbar-history-position=\""
      + alias4(((helper = (helper = helpers.historyPosition || (depth0 != null ? depth0.historyPosition : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"historyPosition","hash":{},"data":data}) : helper)))
      + "\"\n        data-navbar-active-id=\""
      + alias4(((helper = (helper = helpers.activeTab || (depth0 != null ? depth0.activeTab : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"activeTab","hash":{},"data":data}) : helper)))
      + "\"\n        data-log-context=\"navbar\"\n        data-interaction-context=\"navbar\"\n        data-interaction-list\n        >\n";
    stack1 = ((helper = (helper = helpers["nav-items"] || (depth0 != null ? depth0["nav-items"] : depth0)) != null ? helper : alias2),(options={"name":"nav-items","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data}),(typeof helper === alias3 ? helper.call(alias1,options) : helper));
    if (!helpers["nav-items"]) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.noOverflowMenu : depth0),{"name":"unless","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.facePile : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </ul>\n    </div>\n  </div>\n</div>\n";
  },"usePartial":true,"useData":true});

  },{"./facepile.hbs":178,"./navbar-item.hbs":195,"hbsfy/runtime":745}],197:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "true";
  },"3":function(container,depth0,helpers,partials,data) {
      return "false";
  },"5":function(container,depth0,helpers,partials,data) {
      return " enabled";
  },"7":function(container,depth0,helpers,partials,data) {
      return " disabled";
  },"9":function(container,depth0,helpers,partials,data) {
      return "enabled";
  },"11":function(container,depth0,helpers,partials,data) {
      return "disabled";
  },"13":function(container,depth0,helpers,partials,data) {
      return "aria-disabled=\"true\"";
  },"15":function(container,depth0,helpers,partials,data) {
      var helper;

    return "data-slider=\""
      + container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"id","hash":{},"data":data}) : helper)))
      + "\"";
  },"17":function(container,depth0,helpers,partials,data) {
      return "data-slider";
  },"19":function(container,depth0,helpers,partials,data) {
      var helper;

    return "data-ta-id=\""
      + container.escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"id","hash":{},"data":data}) : helper)))
      + "\"";
  },"21":function(container,depth0,helpers,partials,data) {
      var helper;

    return "aria-labelledby=\""
      + container.escapeExpression(((helper = (helper = helpers.labelId || (depth0 != null ? depth0.labelId : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"labelId","hash":{},"data":data}) : helper)))
      + "\"";
  },"23":function(container,depth0,helpers,partials,data) {
      var helper;

    return "data-uri=\""
      + container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"";
  },"25":function(container,depth0,helpers,partials,data) {
      var helper;

    return "data-slider-property=\""
      + container.escapeExpression(((helper = (helper = helpers.property || (depth0 != null ? depth0.property : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"property","hash":{},"data":data}) : helper)))
      + "\"";
  },"27":function(container,depth0,helpers,partials,data) {
      var helper;

    return "data-slider-allowed-property=\""
      + container.escapeExpression(((helper = (helper = helpers.allowedProperty || (depth0 != null ? depth0.allowedProperty : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"allowedProperty","hash":{},"data":data}) : helper)))
      + "\"";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "<div\n  tabindex=\"0\"\n  role=\"checkbox\"\n  aria-checked=\""
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.enabled : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n  class=\"slider"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.enabled : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.allowed : depth0),false,{"name":"compare","hash":{},"fn":container.program(7, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\"\n  data-ta-slider-state=\""
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.enabled : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.program(11, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n  "
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,(depth0 != null ? depth0.allowed : depth0),false,{"name":"compare","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.id : depth0),{"name":"if","hash":{},"fn":container.program(15, data, 0),"inverse":container.program(17, data, 0),"data":data})) != null ? stack1 : "")
      + "\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.id : depth0),{"name":"if","hash":{},"fn":container.program(19, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.labelId : depth0),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.uri : depth0),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.property : depth0),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.allowedProperty : depth0),{"name":"if","hash":{},"fn":container.program(27, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ">\n  <div></div>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],198:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./tracklist/row-start.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/row-start.hbs', partial$0);
  var partial$1 = require('./tracklist/play.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/play.hbs', partial$1);
  var partial$2 = require('./tracklist/save.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/save.hbs', partial$2);
  var partial$3 = require('./tracklist/name.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/name.hbs', partial$3);
  var partial$4 = require('./tracklist/artists.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/artists.hbs', partial$4);
  var partial$5 = require('./tracklist/album.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/album.hbs', partial$5);
  var partial$6 = require('./tracklist/local.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/local.hbs', partial$6);
  var partial$7 = require('./tracklist/more.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/more.hbs', partial$7);
  var partial$8 = require('./tracklist/time.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/time.hbs', partial$8);
  var partial$9 = require('./tracklist/popularity.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/popularity.hbs', partial$9);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["./tracklist/row-start.hbs"],depth0,{"name":"./tracklist/row-start.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/play.hbs"],depth0,{"name":"./tracklist/play.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/save.hbs"],depth0,{"name":"./tracklist/save.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/name.hbs"],depth0,{"name":"./tracklist/name.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/artists.hbs"],depth0,{"name":"./tracklist/artists.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/album.hbs"],depth0,{"name":"./tracklist/album.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/local.hbs"],depth0,{"name":"./tracklist/local.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/more.hbs"],depth0,{"name":"./tracklist/more.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/time.hbs"],depth0,{"name":"./tracklist/time.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/popularity.hbs"],depth0,{"name":"./tracklist/popularity.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</tr>\n";
  },"usePartial":true,"useData":true});

  },{"./tracklist/album.hbs":200,"./tracklist/artists.hbs":201,"./tracklist/local.hbs":213,"./tracklist/more.hbs":214,"./tracklist/name.hbs":215,"./tracklist/play.hbs":216,"./tracklist/popularity.hbs":217,"./tracklist/row-start.hbs":218,"./tracklist/save.hbs":219,"./tracklist/time.hbs":222,"hbsfy/runtime":745}],199:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('./tracklist/table-attributes.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/table-attributes.hbs', partial$0);
  var partial$1 = require('./tracklist/header/play.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/play.hbs', partial$1);
  var partial$2 = require('./tracklist/header/save.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/save.hbs', partial$2);
  var partial$3 = require('./tracklist/header/name.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/name.hbs', partial$3);
  var partial$4 = require('./tracklist/header/premium.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/premium.hbs', partial$4);
  var partial$5 = require('./tracklist/header/explicit.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/explicit.hbs', partial$5);
  var partial$6 = require('./tracklist/header/artists.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/artists.hbs', partial$6);
  var partial$7 = require('./tracklist/header/album.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/album.hbs', partial$7);
  var partial$8 = require('./tracklist/header/local.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/local.hbs', partial$8);
  var partial$9 = require('./tracklist/header/more.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/more.hbs', partial$9);
  var partial$10 = require('./tracklist/header/time.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/time.hbs', partial$10);
  var partial$11 = require('./tracklist/header/popularity.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/header/popularity.hbs', partial$11);
  var partial$12 = require('./tracklist/table-body-attributes.hbs');
  HandlebarsCompiler.registerPartial('./tracklist/table-body-attributes.hbs', partial$12);
  var partial$13 = require('./tracklist-search-row.hbs');
  HandlebarsCompiler.registerPartial('./tracklist-search-row.hbs', partial$13);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return "aria-labelledby=\""
      + container.escapeExpression(((helper = (helper = helpers.ariaLabel || (depth0 != null ? depth0.ariaLabel : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"ariaLabel","hash":{},"data":data}) : helper)))
      + "\"";
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["./tracklist-search-row.hbs"],depth0,{"name":"./tracklist-search-row.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "<table\n  class=\"tracklist-search "
      + container.escapeExpression(((helper = (helper = helpers.modifiers || (depth0 != null ? depth0.modifiers : depth0)) != null ? helper : alias2),(typeof helper === "function" ? helper.call(alias1,{"name":"modifiers","hash":{},"data":data}) : helper)))
      + "\"\n  "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.ariaLabel : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = container.invokePartial(partials["./tracklist/table-attributes.hbs"],depth0,{"name":"./tracklist/table-attributes.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ">\n  <thead class=\"tl-header\">\n    <tr>\n"
      + ((stack1 = container.invokePartial(partials["./tracklist/header/play.hbs"],depth0,{"name":"./tracklist/header/play.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/save.hbs"],depth0,{"name":"./tracklist/header/save.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/name.hbs"],depth0,{"name":"./tracklist/header/name.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/premium.hbs"],depth0,{"name":"./tracklist/header/premium.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/explicit.hbs"],depth0,{"name":"./tracklist/header/explicit.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/artists.hbs"],depth0,{"name":"./tracklist/header/artists.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/album.hbs"],depth0,{"name":"./tracklist/header/album.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/local.hbs"],depth0,{"name":"./tracklist/header/local.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/more.hbs"],depth0,{"name":"./tracklist/header/more.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/time.hbs"],depth0,{"name":"./tracklist/header/time.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ((stack1 = container.invokePartial(partials["./tracklist/header/popularity.hbs"],depth0,{"name":"./tracklist/header/popularity.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "    </tr>\n  </thead>\n  <tbody "
      + ((stack1 = container.invokePartial(partials["./tracklist/table-body-attributes.hbs"],depth0,{"name":"./tracklist/table-body-attributes.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + ">\n"
      + ((stack1 = (helpers.list || (depth0 && depth0.list) || alias2).call(alias1,(depth0 != null ? depth0.rows : depth0),{"name":"list","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </tbody>\n</table>\n";
  },"usePartial":true,"useData":true});

  },{"./tracklist-search-row.hbs":198,"./tracklist/header/album.hbs":202,"./tracklist/header/artists.hbs":203,"./tracklist/header/explicit.hbs":204,"./tracklist/header/local.hbs":205,"./tracklist/header/more.hbs":206,"./tracklist/header/name.hbs":207,"./tracklist/header/play.hbs":208,"./tracklist/header/popularity.hbs":209,"./tracklist/header/premium.hbs":210,"./tracklist/header/save.hbs":211,"./tracklist/header/time.hbs":212,"./tracklist/table-attributes.hbs":220,"./tracklist/table-body-attributes.hbs":221,"hbsfy/runtime":745}],200:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.local : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      var helper;

    return "      "
      + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"data":data}) : helper)))
      + "\n";
  },"4":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.uri : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.program(7, data, 0),"data":data})) != null ? stack1 : "");
  },"5":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "        <a title=\""
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "\" href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" data-uri=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" data-log-click=\"album-name\" data-interaction-target=\"album-name\">"
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "</a>\n";
  },"7":function(container,depth0,helpers,partials,data) {
      var helper;

    return "        "
      + container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"data":data}) : helper)))
      + "\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<td class=\"tl-cell tl-albums\" data-log-context=\"album-cell\">\n"
      + ((stack1 = helpers.blockHelperMissing.call(depth0,container.lambda(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.album : stack1), depth0),{"name":"track.album","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],201:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.local : depth0),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"data":data}) : helper)));
  },"4":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.uri : depth0),"spotify:artist:0LyfQWJT6nXafLPZqxe9Of",{"name":"compare","hash":{},"fn":container.program(5, data, 0),"inverse":container.program(7, data, 0),"data":data})) != null ? stack1 : "");
  },"5":function(container,depth0,helpers,partials,data) {
      return container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),"VariousArtistsCapitalized",{"name":"loc","hash":{},"data":data}));
  },"7":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<a title=\""
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "\" href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" data-uri=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" data-log-click=\"artist-name\" data-interaction-target=\""
      + alias4(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"index","hash":{},"data":data}) : helper)))
      + "\">"
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "</a>";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<td class=\"tl-cell tl-artists\" data-log-context=\"artist-cell\" data-interaction-context=\"artists\">\n  "
      + ((stack1 = (helpers.slice || (depth0 && depth0.slice) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.artists : stack1),", ",{"name":"slice","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],202:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-asc\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-desc\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "data-sort=\"track(album(name),disc,number)\" data-interaction-target=\"header-album\" data-interaction-intent=\"sort-by-album\"";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "<th class=\"tl-albums\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,"track(album(name),disc,number)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\" "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ">"
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Album",{"name":"loc","hash":{},"data":data}))
      + "</th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],203:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-asc\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-desc\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "data-sort=\"track(artists[0:1](name),album(name),disc,number)\" data-interaction-target=\"header-artist\" data-interaction-intent=\"sort-by-artist\"";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "<th class=\"tl-artists\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,"track(artists[0:1](name),album(name),disc,number)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\" "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ">"
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Artist",{"name":"loc","hash":{},"data":data}))
      + "</th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],204:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "data-sort-previous";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<th class=\"tl-explicit\" "
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "></th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],205:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "data-sort-previous";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<th class=\"tl-local\" "
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "></th>";
  },"useData":true});

  },{"hbsfy/runtime":745}],206:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "data-sort-previous";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<th class=\"tl-more\" "
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "></th>\r";
  },"useData":true});

  },{"hbsfy/runtime":745}],207:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-asc\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-desc\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "data-sort=\"track(name)\" data-interaction-target=\"header-name\" data-interaction-intent=\"sort-by-name\"";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing;

    return "<th class=\"tl-name\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,"track(name)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\" "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ">"
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"Title",{"name":"loc","hash":{},"data":data}))
      + "</th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],208:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<th class=\"tl-play\"></th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],209:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-asc\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-desc\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "  data-sort=\"track(negPopularity)\"\n  data-interaction-target=\"header-name\"\n  data-interaction-intent=\"sort-by-popularity\"\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<th class=\"tl-popularity\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(alias1,"track(negPopularity)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\"\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "></th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],210:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "data-sort-previous";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<th class=\"tl-premium\" "
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "></th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],211:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<th class=\"tl-save\"></th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],212:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.sortDirection : depth0),"asc",{"name":"compare","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-asc\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    tl-sort-desc\n";
  },"6":function(container,depth0,helpers,partials,data) {
      return "data-sort=\"track(duration)\" data-interaction-target=\"header-duration\" data-interaction-intent=\"sort-by-duration\"";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<th class=\"tl-time\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(alias1,"track(duration)",(depth0 != null ? depth0.sortQuery : depth0),{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\" "
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.sortable : depth0),{"name":"if","hash":{},"fn":container.program(6, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "></th>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],213:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "  <span class=\"tl-item-local spoticon-localfile-16\" data-tooltip=\""
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),"LocalFile",{"name":"loc","hash":{},"data":data}))
      + "\"></span>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<td class=\"tl-cell tl-local\">\n"
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.local : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],214:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression, alias4="function";

    return "<td class=\"tl-cell tl-more\">\n  <button\n    type=\"button\"\n    data-button=\"contextmenu\"\n    class=\"button button-icon-only button-more\"\n    data-tooltip=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"More",{"name":"loc","hash":{},"data":data}))
      + "\"\n    data-log-click=\"more-button\"\n    data-log-data='{ \"index\": "
      + alias3(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"index","hash":{},"data":data}) : helper)))
      + ", \"target_uri\": \""
      + alias3(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias4 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" }'\n    data-interaction-target=\"context-menu-button\"\n    data-interaction-intent=\"show-options\"></button>\n</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],215:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.premium : stack1),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "    <td class=\"tl-cell tl-name\" colspan=\"1\" data-log-context=\"name-cell\" data-ta-id=\"name-cell\">\n";
  },"4":function(container,depth0,helpers,partials,data) {
      return "    <td class=\"tl-cell tl-name\" colspan=\"2\" data-log-context=\"name-cell\" data-ta-id=\"name-cell\">\n";
  },"6":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.premium : stack1),{"name":"if","hash":{},"fn":container.program(4, data, 0),"inverse":container.program(7, data, 0),"data":data})) != null ? stack1 : "");
  },"7":function(container,depth0,helpers,partials,data) {
      return "    <td class=\"tl-cell tl-name\" colspan=\"3\" data-log-context=\"name-cell\" data-ta-id=\"name-cell\">\n";
  },"9":function(container,depth0,helpers,partials,data) {
      return "    <span class=\"tl-status-indicator tl-status-indicator--in-progress\"></span>\n";
  },"11":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0["new"] : depth0),{"name":"if","hash":{},"fn":container.program(12, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "");
  },"12":function(container,depth0,helpers,partials,data) {
      return "      <span class=\"tl-status-indicator tl-status-indicator--new\"></span>\n";
  },"14":function(container,depth0,helpers,partials,data) {
      return "</td><td class=\"tl-cell tl-premium\"><span class=\"label\" data-log-click=\"premium\">PREMIUM</span>";
  },"16":function(container,depth0,helpers,partials,data) {
      return "</td><td class=\"tl-cell tl-explicit\"><span class=\"label\" data-log-click=\"explicit\">EXPLICIT</span>";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=container.lambda, alias3=helpers.blockHelperMissing;

    return ((stack1 = helpers["if"].call(alias1,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.explicit : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(6, data, 0),"data":data})) != null ? stack1 : "")
      + "<div class=\"tl-highlight\" data-log-click=\"name\">\n"
      + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.inProgress : depth0),{"name":"if","hash":{},"fn":container.program(9, data, 0),"inverse":container.program(11, data, 0),"data":data})) != null ? stack1 : "")
      + "\n  "
      + container.escapeExpression(alias2(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
      + "\n</div>\n"
      + ((stack1 = alias3.call(depth0,alias2(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.premium : stack1), depth0),{"name":"track.premium","hash":{},"fn":container.program(14, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n"
      + ((stack1 = alias3.call(depth0,alias2(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.explicit : stack1), depth0),{"name":"track.explicit","hash":{},"fn":container.program(16, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],216:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<td class=\"tl-cell tl-play\">\n  <button\n    type=\"button\"\n    data-button=\"play\"\n    class=\"button button-icon-with-stroke button-play\"\n    data-ta-id=\"play-button\"\n    data-interaction-target=\"play-pause-button\"\n    data-interaction-intent=\"play\"\n    data-log-click=\"play-button\"></button>\n</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],217:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return " data-tooltip=\""
      + container.escapeExpression((helpers.loc || (depth0 && depth0.loc) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),"ListenCount",((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.listenCount : stack1),{"name":"loc","hash":{},"data":data}))
      + "\" data-tooltip-instant";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<td class=\"tl-cell tl-popularity\""
      + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.listenCount : stack1),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ">\n  <div class=\"pop-meter\">\n    <div class=\"pop-meter-background\"></div>\n    <div class=\"pop-meter-overlay\" style=\"width: "
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.popularity : stack1), depth0))
      + "%\"></div>\n  </div>\n</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],218:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"name","hash":{},"data":data}) : helper)));
  },"3":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.index || (depth0 != null ? depth0.index : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"index","hash":{},"data":data}) : helper)));
  },"5":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.index || (data && data.index)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"index","hash":{},"data":data}) : helper)));
  },"7":function(container,depth0,helpers,partials,data) {
      var helper;

    return container.escapeExpression(((helper = (helper = helpers.contextIndex || (depth0 != null ? depth0.contextIndex : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"contextIndex","hash":{},"data":data}) : helper)));
  },"9":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "");
  },"11":function(container,depth0,helpers,partials,data) {
      var helper;

    return "data-uid=\""
      + container.escapeExpression(((helper = (helper = helpers.uid || (depth0 != null ? depth0.uid : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{"name":"uid","hash":{},"data":data}) : helper)))
      + "\"";
  },"13":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.offlineProgress : stack1),{"name":"if","hash":{},"fn":container.program(14, data, 0),"inverse":container.program(19, data, 0),"data":data})) != null ? stack1 : "");
  },"14":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = (helpers.compare || (depth0 && depth0.compare) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.offlineProgress : stack1),1,{"name":"compare","hash":{},"fn":container.program(15, data, 0),"inverse":container.program(17, data, 0),"data":data})) != null ? stack1 : "");
  },"15":function(container,depth0,helpers,partials,data) {
      return "            offline-downloaded\n";
  },"17":function(container,depth0,helpers,partials,data) {
      return "            offline-downloading\n";
  },"19":function(container,depth0,helpers,partials,data) {
      return "          offline-waiting\n";
  },"21":function(container,depth0,helpers,partials,data) {
      return "playing";
  },"23":function(container,depth0,helpers,partials,data) {
      return "selected";
  },"25":function(container,depth0,helpers,partials,data) {
      return "added";
  },"27":function(container,depth0,helpers,partials,data) {
      return "unavailable";
  },"29":function(container,depth0,helpers,partials,data) {
      return "local";
  },"31":function(container,depth0,helpers,partials,data) {
      return "local-file-available";
  },"33":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "thumbs-"
      + container.escapeExpression(container.lambda(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1), depth0));
  },"35":function(container,depth0,helpers,partials,data) {
      return "thumbs-none";
  },"37":function(container,depth0,helpers,partials,data) {
      return "tl-row--episode";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=container.lambda, alias2=container.escapeExpression, alias3=depth0 != null ? depth0 : (container.nullContext || {}), alias4=helpers.helperMissing;

    return "<tr tabindex=\"0\"\n    aria-label=\""
      + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
      + " "
      + alias2((helpers.loc || (depth0 && depth0.loc) || alias4).call(alias3,"By",{"name":"loc","hash":{},"data":data}))
      + " "
      + ((stack1 = (helpers.slice || (depth0 && depth0.slice) || alias4).call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.artists : stack1),", ",{"name":"slice","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ". "
      + alias2((helpers.loc || (depth0 && depth0.loc) || alias4).call(alias3,"PressEnterToPlay",{"name":"loc","hash":{},"data":data}))
      + ".\"\n    data-list-item=\"true\"\n    data-uri=\""
      + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.uri : stack1), depth0))
      + "\"\n    data-index=\""
      + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n    data-context-index=\""
      + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.contextIndex : depth0),{"name":"if","hash":{},"fn":container.program(7, data, 0),"inverse":container.program(9, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n    "
      + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.uid : depth0),{"name":"if","hash":{},"fn":container.program(11, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    data-scroll-page-item=\""
      + alias2(((helper = (helper = helpers.scrollPageItem || (depth0 != null ? depth0.scrollPageItem : depth0)) != null ? helper : alias4),(typeof helper === "function" ? helper.call(alias3,{"name":"scrollPageItem","hash":{},"data":data}) : helper)))
      + "\" draggable=\"true\"\n    data-interaction-context=\""
      + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
      + "\"\n    data-ta-id=\"tracklist-row\"\n    data-log-data='{\n      \"index\": "
      + ((stack1 = helpers["if"].call(alias3,(depth0 != null ? depth0.index : depth0),{"name":"if","hash":{},"fn":container.program(3, data, 0),"inverse":container.program(5, data, 0),"data":data})) != null ? stack1 : "")
      + ",\n      \"target_uri\": \""
      + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.uri : stack1), depth0))
      + "\",\n      \"name\": \""
      + alias2(alias1(((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.name : stack1), depth0))
      + "\"\n    }'\n    data-contextmenu-spy\n    class=\"tl-row\n"
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.shouldBeOffline : stack1),{"name":"if","hash":{},"fn":container.program(13, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.playing : stack1),{"name":"if","hash":{},"fn":container.program(21, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.selected : stack1),{"name":"if","hash":{},"fn":container.program(23, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.added : stack1),{"name":"if","hash":{},"fn":container.program(25, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.unavailable : stack1),{"name":"if","hash":{},"fn":container.program(27, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.local : stack1),{"name":"if","hash":{},"fn":container.program(29, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.localFileAvailable : stack1),{"name":"if","hash":{},"fn":container.program(31, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1),{"name":"if","hash":{},"fn":container.program(33, data, 0),"inverse":container.program(35, data, 0),"data":data})) != null ? stack1 : "")
      + "\n      "
      + ((stack1 = helpers["if"].call(alias3,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.isEpisode : stack1),{"name":"if","hash":{},"fn":container.program(37, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "\n    \"\n    data-contextmenu>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],219:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.added : stack1),{"name":"if","hash":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"data":data})) != null ? stack1 : "");
  },"2":function(container,depth0,helpers,partials,data) {
      return "";
  },"4":function(container,depth0,helpers,partials,data) {
      return "            disabled\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;

    return "<td class=\"tl-cell tl-save\">\n  <button type=\"button\" data-button=\"add\"\n    class=\"button button-icon-only button-add\"\n"
      + ((stack1 = (helpers.compare || (depth0 && depth0.compare) || alias2).call(alias1,((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.thumb : stack1),"down",{"name":"compare","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    data-tooltip=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"SaveYourMusic",{"name":"loc","hash":{},"data":data}))
      + "\"\n    data-tooltip-add=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"SaveYourMusic",{"name":"loc","hash":{},"data":data}))
      + "\"\n    data-tooltip-remove=\""
      + alias3((helpers.loc || (depth0 && depth0.loc) || alias2).call(alias1,"RemoveYourMusic",{"name":"loc","hash":{},"data":data}))
      + "\"\n    data-log-click=\"save-button\"\n    data-interaction-target=\"save-remove-button\"\n    data-interaction-intent=\"save\"></button>\n</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],220:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "data-insert=\""
      + alias4(((helper = (helper = helpers.insertTracks || (depth0 != null ? depth0.insertTracks : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"insertTracks","hash":{},"data":data}) : helper)))
      + "\"\ndata-remove=\""
      + alias4(((helper = (helper = helpers.removeTracks || (depth0 != null ? depth0.removeTracks : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"removeTracks","hash":{},"data":data}) : helper)))
      + "\"\n";
  },"3":function(container,depth0,helpers,partials,data) {
      return "data-context=\"true\"\n";
  },"5":function(container,depth0,helpers,partials,data) {
      return "data-list-quick-jump=\"true\"\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, options, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=helpers.blockHelperMissing, buffer =
    "data-uri=\""
      + container.escapeExpression(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\ndata-list=\"true\"\n";
    stack1 = ((helper = (helper = helpers.allows || (depth0 != null ? depth0.allows : depth0)) != null ? helper : alias2),(options={"name":"allows","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data}),(typeof helper === alias3 ? helper.call(alias1,options) : helper));
    if (!helpers.allows) { stack1 = alias4.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    stack1 = ((helper = (helper = helpers.noContext || (depth0 != null ? depth0.noContext : depth0)) != null ? helper : alias2),(options={"name":"noContext","hash":{},"fn":container.noop,"inverse":container.program(3, data, 0),"data":data}),(typeof helper === alias3 ? helper.call(alias1,options) : helper));
    if (!helpers.noContext) { stack1 = alias4.call(depth0,stack1,options)}
    if (stack1 != null) { buffer += stack1; }
    return buffer + ((stack1 = helpers["if"].call(alias1,(depth0 != null ? depth0.quickJump : depth0),{"name":"if","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "data-interaction-context=\"tracklist\"\ndata-ta-id=\"tracklist\"\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],221:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "data-list-items=\"true\"\ndata-scroll-container\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],222:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<td class=\"tl-cell tl-time\" data-log-context=\"time-cell\">\n  <span data-log-click=\"duration\">"
      + container.escapeExpression((helpers.duration || (depth0 && depth0.duration) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),((stack1 = (depth0 != null ? depth0.track : depth0)) != null ? stack1.duration : stack1),{"name":"duration","hash":{},"data":data}))
      + "</span>\n</td>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],223:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = spFetch;

  var _getToken = require('./get-token');

  var _getWebgateHeaders = require('./get-webgate-headers');

  function spFetch(input, init = { headers: new Headers() }) {
    return (0, _getToken.getToken)().then(({ accessToken, tokenType }) => {
      const headerdKey = 'Authorization';
      const headerValue = `${tokenType} ${accessToken}`;

      const url = typeof input === 'string' ? input : input.url;

      let webgateHeaders = []; // empty by default

      if (url.indexOf('https://spclient') === 0) {
        webgateHeaders = (0, _getWebgateHeaders.getWebgateHeaders)();
      }

      if (init.headers instanceof Headers) {
        init.headers.append(headerdKey, headerValue);
        webgateHeaders.forEach(function (keyVal) {
          init.headers.append(keyVal[0], keyVal[1]);
        });
      } else {
        // headers got supplied as object literal instead
        init.headers[headerdKey] = headerValue;
        webgateHeaders.forEach(function (keyVal) {
          init.headers[keyVal[0]] = keyVal[1];
        });
      }

      return fetch(input, init);
    });
  }

  },{"./get-token":224,"./get-webgate-headers":225}],224:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getToken = getToken;

  var _spotifyCosmosApi = require('spotify-cosmos-api');

  var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

  var _debug = require('../debug');

  var _debug2 = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const debug = (0, _debug2.default)('http-requests:get-token');

  function getToken() {
    return new Promise((resolve, reject) => {
      _spotifyCosmosApi2.default.resolver.get('sp://webgate/v1/token', (err, response) => {
        if (err) {
          debug('Error retrieving token from keymaster:', err);
          reject(err);
          return;
        }
        const data = response.getJSONBody();
        if (data && data.accessToken && data.tokenType) {
          debug('Retrieved access token, valid until: %s', new Date(data.expiresAtTime));
          resolve({
            accessToken: data.accessToken,
            tokenType: data.tokenType
          });
          return;
        }
        const tokenError = 'Error: missing accessToken or tokenType';
        debug(tokenError, data);
        reject(new Error(tokenError));
      });
    });
  }

  },{"../debug":129,"spotify-cosmos-api":1272}],225:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports._setHeaders = _setHeaders;
  exports.getWebgateHeaders = getWebgateHeaders;
  // Header keys outlined here:
  // https://ghe.spotify.net/messaging/webgate/blob/master/src/main/java/com/spotify/webgate/hermes/UserInfoHeaderDecorator.java#L117-L118
  const SPOTIFY_APP_VERSION_KEY = 'Spotify-App-Version';
  const APP_PLATFORM_KEY = 'App-Platform';

  let SPOTIFY_APP_VERSION = typeof window !== 'undefined' && window.__spotify && window.__spotify.client_version || '';
  const RAW_PLATFORM = typeof window !== 'undefined' && window.navigator && window.navigator.platform || '';
  let APP_PLATFORM = '';

  // These values come from here:
  // https://ghe.spotify.net/messaging/webgate/blob/master/src/main/java/com/spotify/webgate/hermes/UserInfoHeaderDecorator.java#L154
  if (RAW_PLATFORM.indexOf('Mac') !== -1) {
    APP_PLATFORM = 'OSX';
  } else if (RAW_PLATFORM.indexOf('Win') !== -1) {
    APP_PLATFORM = 'Win32';
  } else if (RAW_PLATFORM.indexOf('Linux') !== -1) {
    APP_PLATFORM = 'Linux';
  }

  function getSpotifyAppVersion() {
    if (!SPOTIFY_APP_VERSION) {
      throw new Error('Missing Spotify App Version! Something is wrong: talk to #desktop-squad.');
    }
    return [SPOTIFY_APP_VERSION_KEY, SPOTIFY_APP_VERSION];
  }

  function getAppPlatform() {
    if (!APP_PLATFORM) {
      throw new Error('Missing App Platform! Something is wrong: talk to #desktop-squad.');
    }
    return [APP_PLATFORM_KEY, APP_PLATFORM];
  }

  const DEFAULT_HEADER_VALUE = 'default';
  const DEFAULT_HEADERS = {};
  DEFAULT_HEADERS[SPOTIFY_APP_VERSION_KEY] = DEFAULT_HEADER_VALUE;
  DEFAULT_HEADERS[APP_PLATFORM_KEY] = DEFAULT_HEADER_VALUE;

  /**
   * To only be used by unit tests when window doesnt exist
   */
  function _setHeaders(headers = DEFAULT_HEADERS) {
    SPOTIFY_APP_VERSION = headers[SPOTIFY_APP_VERSION_KEY];
    APP_PLATFORM = headers[APP_PLATFORM_KEY];
  }

  /*
   * @return {Array} - [[key, value]]
   */
  function getWebgateHeaders() {
    return [getSpotifyAppVersion(), getAppPlatform()];
  }

  },{}],226:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.httpMockHelper = exports.addWebgateHeaders = exports.addToken = exports.spFetch = undefined;

  var _fetch = require('./fetch.js');

  var _fetch2 = _interopRequireDefault(_fetch);

  var _xhr = require('./xhr.js');

  var _mockHelper = require('./util/mock-helper.js');

  var httpMockHelper = _interopRequireWildcard(_mockHelper);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.spFetch = _fetch2.default;
  exports.addToken = _xhr.addToken;
  exports.addWebgateHeaders = _xhr.addWebgateHeaders;
  exports.httpMockHelper = httpMockHelper;

  },{"./fetch.js":223,"./util/mock-helper.js":227,"./xhr.js":228}],227:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.mockTokenRequest = mockTokenRequest;
  exports.restoreTokenRequest = restoreTokenRequest;

  var _getToken = require('../get-token');

  var getTokenSingleton = _interopRequireWildcard(_getToken);

  var _getWebgateHeaders = require('../get-webgate-headers');

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  const originalGetToken = getTokenSingleton.getToken;

  const proxiedGetToken = function get() {
    return Promise.resolve({
      accessToken: 'at',
      tokenType: 'tt'
    });
  };

  function mockTokenRequest(get = proxiedGetToken) {
    (0, _getWebgateHeaders._setHeaders)();
    getTokenSingleton.getToken = get;
    getTokenSingleton.restore = restoreTokenRequest;
    return getTokenSingleton;
  }

  function restoreTokenRequest() {
    getTokenSingleton.get = originalGetToken;
  }

  },{"../get-token":224,"../get-webgate-headers":225}],228:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.addToken = addToken;
  exports.addWebgateHeaders = addWebgateHeaders;

  var _getToken = require('./get-token');

  var _getWebgateHeaders = require('./get-webgate-headers');

  function addToken(xhr) {
    if (!xhr || !xhr.setRequestHeader) {
      throw new Error('Expected argument to be an XMLHttpRequest');
    }
    return (0, _getToken.getToken)().then(({ accessToken, tokenType }) => {
      xhr.setRequestHeader('Authorization', `${tokenType} ${accessToken}`);
      return xhr;
    });
  }

  function addWebgateHeaders(xhr) {
    if (!xhr || !xhr.setRequestHeader) {
      throw new Error('Expected argument to be an XMLHttpRequest');
    }
    (0, _getWebgateHeaders.getWebgateHeaders)().forEach(keyVal => {
      xhr.setRequestHeader(keyVal[0], keyVal[1]);
    });
    return xhr;
  }

  },{"./get-token":224,"./get-webgate-headers":225}],229:[function(require,module,exports){
  'use strict';

  module.exports = require('./scripts/index.js');

  },{"./scripts/index.js":248}],230:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Configuration = require('./Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _index = require('./views/index.js');

  var _Environment = require('./Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  var _EventDispatcher = require('./EventDispatcher.js');

  var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

  var _ServiceRouter = require('./ServiceRouter.js');

  var _ServiceRouter2 = _interopRequireDefault(_ServiceRouter);

  var _View = require('./views/View.js');

  var _View2 = _interopRequireDefault(_View);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const PERIODIC_UPDATE_MS = 500;

  /**
   * A class that is responsible for maintaining the view component tree. When the
   * application arguments change, the service router is asked to provide a view
   * component tree for the new arguments but only if the current view tree
   * chooses not to handle the change. This class is also responsible for
   * destroying discarded view component trees.
   */
  class Application {
    constructor(window, containerElement, eventDispatcher, serviceRouter, configuration, environment, eventListenerCreator, viewCreator) {
      _bfsKmTypes2.default.check.type(window, Window);
      _bfsKmTypes2.default.check.type(containerElement, Element);
      _bfsKmTypes2.default.check.type(eventDispatcher, _EventDispatcher2.default);
      _bfsKmTypes2.default.check.type(serviceRouter, _ServiceRouter2.default);
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      _bfsKmTypes2.default.check.type(environment, _Environment2.default);
      _bfsKmTypes2.default.check.function(eventListenerCreator);
      _bfsKmTypes2.default.check.function(viewCreator);
      this._window = window;
      this._containerElement = containerElement;
      this._eventDispatcher = eventDispatcher;
      this._serviceRouter = serviceRouter;
      this._configuration = configuration;
      this._environment = environment;
      this._eventListenerCreator = eventListenerCreator;
      this._viewCreator = viewCreator;
      this._rootView = null;
      this._debugView = null;
      this._expectedDeferredLoads = 0;
      this._receivedDeferredLoads = 0;
      this._window.addEventListener('resize', () => {
        this._eventDispatcher.dispatch('window-resize', {});
      });
      this._window.addEventListener('scroll', () => {
        this._eventDispatcher.dispatch('window-scroll', {});
      });
      this._window.addEventListener('message', event => {
        if (_bfsKmTypes2.default.is.object(event.data)) {
          const json = _bfsKmTypes2.default.clone(event.data);
          this._eventDispatcher.dispatch('window-message', json);
        }
      });
      this._window.setInterval(() => {
        this._eventDispatcher.dispatch('periodic-update', {});
      }, PERIODIC_UPDATE_MS);
      const rv = this._eventListenerCreator('reload-view', json => {
        this._onReloadView(json);
      });
      this._eventDispatcher.register(rv);
      const dcl = this._eventListenerCreator('deferred-content-load', json => {
        this._onDeferredContentLoad(json);
      });
      this._eventDispatcher.register(dcl);
    }

    addDebugView() {
      if (this._debugView === null) {
        this._debugView = this._viewCreator(_index.DebugControls, {});
        this._debugView.attach(this._containerElement);
      }
    }

    onArgumentsChange(args) {
      _bfsKmTypes2.default.check.array(args);
      if (this._rootView === null) {
        this._loadRootViewFromArguments(args);
      } else {
        if (!this._rootView.handlesArgumentsChange(args)) {
          this._loadRootViewFromArguments(args);
        }
      }
    }

    queryApplicationArgumentsAndReload() {
      this._environment.queryApplicationArguments(args => {
        this._loadRootViewFromArguments(args);
      });
    }

    _loadRootViewFromArguments(args) {
      _bfsKmTypes2.default.check.array(args);
      this._setRootView(null);
      this._environment.querySessionOnline(online => {
        if (!online) {
          this._setRootView(this._viewCreator(_index.OfflineScreen, {}));
          return;
        }
        const configurationState = this._configuration.getDefaultState();
        const encodedArgs = args.map(arg => {
          return encodeURIComponent(arg);
        });
        this._serviceRouter.request("spotify:app:bookmark", view => {
          if (view !== null) {
            this._setRootView(view);
          } else {
            this._setRootView(this._viewCreator(_index.ErrorScreen, {}));
          }
        });
      });
    }

    _onDeferredContentLoad(json) {
      _bfsKmTypes2.default.check.object(json);
      this._receivedDeferredLoads++;
      if (this._receivedDeferredLoads >= this._expectedDeferredLoads) {
        this._sendViewLoaded();
      }
    }

    _onReloadView(json) {
      _bfsKmTypes2.default.check.object(json);
      this._configuration.getCurrentState(configurationState => {
        const language = configurationState.getStringOr('user/language', 'en');
        this._environment.registerSpotifyHandlebarsHelpersFor(language);
        this.queryApplicationArgumentsAndReload();
      });
    }

    _sendViewReady(callback) {
      const defaultConfigurationState = this._configuration.getDefaultState();
      const appName = defaultConfigurationState.getString('app/name');
      this._environment.sendViewReady(appName, callback);
    }

    _sendViewLoaded() {
      const defaultConfigurationState = this._configuration.getDefaultState();
      const appName = defaultConfigurationState.getString('app/name');
      this._environment.sendViewLoaded(appName);
    }

    _setRootView(view) {
      this._window.scrollTo(0, 0);
      if (this._rootView !== null) {
        this._rootView.destroy();
        this._rootView = null;
      }
      if (view !== null) {
        _bfsKmTypes2.default.check.type(view, _View2.default);

        this._rootView = view;

        // Send the ready message before attaching, to allow animations to always
        // run even when they happen immediately.
        this._sendViewReady(() => {
          if (this._rootView !== view) {
            return;
          }

          view.attach(this._containerElement);
          this._environment.updateSpotifyEventsIn(this._containerElement);
          this._eventDispatcher.dispatch('root-view-update', {});
          this._expectedDeferredLoads = view.totalNrOfDeferredContentLoads();
          this._receivedDeferredLoads = 0;
          if (this._expectedDeferredLoads === 0) {
            this._sendViewLoaded();
          }
        });
      }
    }
  }

  exports.default = Application;

  },{"./Configuration.js":232,"./Environment.js":235,"./EventDispatcher.js":236,"./ServiceRouter.js":241,"./views/View.js":271,"./views/index.js":323,"bfs-km-types":691}],231:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Application = require('./Application.js');

  var _Application2 = _interopRequireDefault(_Application);

  var _Configuration = require('./Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _Environment = require('./Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for doing the necessary set up required by the
   * Spotify environment and to notify the application about state changes in the
   * environment.
   */
  class ApplicationContext {
    constructor(htmlElement, application, configuration, environment) {
      _bfsKmTypes2.default.check.type(htmlElement, HTMLElement);
      _bfsKmTypes2.default.check.type(application, _Application2.default);
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      _bfsKmTypes2.default.check.type(environment, _Environment2.default);
      this._htmlElement = htmlElement;
      this._application = application;
      this._configuration = configuration;
      this._environment = environment;
    }

    bootstrap() {
      this._environment.registerSpotifyLiveModels();
      this._environment.attachSpotifyEvents();
      this._environment.updateSpotifyEventsIn(this._htmlElement);
      this._environment.listenForOverlayGrid();
      this._configuration.getCurrentState(configurationState => {
        const language = configurationState.getStringOr('user/language', 'en');
        this._environment.registerSpotifyHandlebarsHelpersFor(language);
        if (configurationState.getBooleanOr('user/employee', false)) {
          this._application.addDebugView();
        }
        this._environment.listenForSessionOnlineStatusChanges(online => {
          if (online) {
            this._application.queryApplicationArgumentsAndReload();
          }
        });
      });
    }
  }

  exports.default = ApplicationContext;

  },{"./Application.js":230,"./Configuration.js":232,"./Environment.js":235,"bfs-km-types":691}],232:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Environment = require('./Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const LOCAL_STORAGE_KEY = 'configuration-v1';

  /**
   * A class that is responsible for maintaining the application configuration.
   * The class maintains three layers of configurations which are default, client
   * and preferences. The default layer contains values found in the config such
   * as application name and version. The client layer contains values found in
   * the client such as user attributes while the preferences layer contains
   * overridden values and settings. Each layer is allowed to override the values
   * set by a previous layer.
   */
  class Configuration {
    constructor(environment, configurationStateCreator, configJson) {
      _bfsKmTypes2.default.check.type(environment, _Environment2.default);
      _bfsKmTypes2.default.check.function(configurationStateCreator);
      _bfsKmTypes2.default.check.object(configJson);
      this._environment = environment;
      this._configurationStateCreator = configurationStateCreator;
      this._configJson = _bfsKmTypes2.default.clone(configJson);
    }

    /**
     * A method that returns the current state. The given callback will be called
     * an instance of the current state as the only argument.
     */
    getCurrentState(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const configurationState = this.getDefaultState();
      this._environment.queryClientSessionState((clientVersion, userCatalogue, userCountry, userEmployee, userLanguage, userUsername) => {
        this._copyIntoConfigurationState(configurationState, {
          'client/version': clientVersion,
          'user/catalogue': userCatalogue,
          'user/country': userCountry,
          'user/employee': userEmployee,
          'user/language': userLanguage,
          'user/username': userUsername
        });
        this._fetchFromLocalStorage(json => {
          this._copyIntoConfigurationState(configurationState, json);
          callback(configurationState);
        });
      });
    }

    /**
     * A method that returns the default state. This is usable before the bridge
     * has been initialized.
     */
    getDefaultState() {
      const configurationState = this._configurationStateCreator();
      this._copyIntoConfigurationState(configurationState, this._configJson);
      return configurationState;
    }

    /**
     * A method that removes the stored value for the given key.
     */
    removeValue(key) {
      _bfsKmTypes2.default.check.string(key);
      this._fetchFromLocalStorage(json => {
        delete json[key];
        this._storeInLocalStorage(json);
      });
    }

    /**
     * A method that stores the given value for the given key.
     */
    storeValue(key, value) {
      _bfsKmTypes2.default.check.string(key);
      this._fetchFromLocalStorage(json => {
        json[key] = value;
        this._storeInLocalStorage(json);
      });
    }

    _copyIntoConfigurationState(configurationState, json) {
      for (const key in json) {
        if (_bfsKmTypes2.default.is.boolean(json[key])) {
          configurationState.setBoolean(key, json[key]);
          continue;
        }
        if (_bfsKmTypes2.default.is.number(json[key])) {
          configurationState.setNumber(key, json[key]);
          continue;
        }
        if (_bfsKmTypes2.default.is.string(json[key])) {
          configurationState.setString(key, json[key]);
          continue;
        }
      }
    }

    /**
     * A method that fetches the stored values from local storage. The given
     * callback will be called with the parsed json object as the only argument.
     */
    _fetchFromLocalStorage(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const key = LOCAL_STORAGE_KEY;
      this._environment.fetchFromSpotifyLocalStorage(key, callback);
    }

    /**
     * A method that stores the given json in local storage.
     */
    _storeInLocalStorage(json) {
      _bfsKmTypes2.default.check.object(json);
      const key = LOCAL_STORAGE_KEY;
      this._environment.storeInSpotifyLocalStorage(key, json);
    }
  }

  exports.default = Configuration;

  },{"./Environment.js":235,"bfs-km-types":691}],233:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for storing a snapshot of the configuration.
   * Instances of the class can be produced by the configuration as needed.
   */
  class ConfigurationState {
    constructor() {
      this._values = new Map(); // eslint-disable-line no-undef
    }

    /**
     * A method that returns the stored value for the given key if the value is a
     * boolean. Throws if there is no boolean value stored for the given key.
     */
    getBoolean(key) {
      _bfsKmTypes2.default.check.string(key);
      const value = this._values.get(key);
      if (!_bfsKmTypes2.default.is.boolean(value)) {
        const message = `There is no boolean value stored for the key "${key}"!`;
        throw new Error(message);
      }
      return value;
    }

    /**
     * A method that returns the stored value for the given key if the value is a
     * boolean. If no boolean value is stored, the given fallback will be
     * returned.
     */
    getBooleanOr(key, fallback) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.boolean(fallback);
      const value = this._values.get(key);
      if (_bfsKmTypes2.default.is.boolean(value)) {
        return value;
      }
      return fallback;
    }

    /**
     * A method that returns the stored value for the given key if the value is a
     * number. Throws if there is no number value stored for the given key.
     */
    getNumber(key) {
      _bfsKmTypes2.default.check.string(key);
      const value = this._values.get(key);
      if (!_bfsKmTypes2.default.is.number(value)) {
        const message = `There is no number value stored for the key "${key}"!`;
        throw new Error(message);
      }
      return value;
    }

    /**
     * A method that returns the stored value for the given key if the value is a
     * number. If no number value is stored, the given fallback will be returned.
     */
    getNumberOr(key, fallback) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.number(fallback);
      const value = this._values.get(key);
      if (_bfsKmTypes2.default.is.number(value)) {
        return value;
      }
      return fallback;
    }

    /**
     * A method that returns the stored value for the given key if the value is a
     * string. Throws if there is no string value stored for the given key.
     */
    getString(key) {
      _bfsKmTypes2.default.check.string(key);
      const value = this._values.get(key);
      if (!_bfsKmTypes2.default.is.string(value)) {
        const message = `There is no string value stored for the key "${key}"!`;
        throw new Error(message);
      }
      return value;
    }

    /**
     * A method that returns the stored value for the given key if the value is a
     * string. If no string value is stored, the given fallback will be returned.
     */
    getStringOr(key, fallback) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.string(fallback);
      const value = this._values.get(key);
      if (_bfsKmTypes2.default.is.string(value)) {
        return value;
      }
      return fallback;
    }

    /**
     * A method that checks if there is a boolean value stored for the given key.
     */
    hasBoolean(key) {
      _bfsKmTypes2.default.check.string(key);
      return _bfsKmTypes2.default.is.boolean(this._values.get(key));
    }

    /**
     * A method that checks if there is a number value stored for the given key.
     */
    hasNumber(key) {
      _bfsKmTypes2.default.check.string(key);
      return _bfsKmTypes2.default.is.number(this._values.get(key));
    }

    /**
     * A method that checks if there is a string value stored for the given key.
     */
    hasString(key) {
      _bfsKmTypes2.default.check.string(key);
      return _bfsKmTypes2.default.is.string(this._values.get(key));
    }

    /**
     * A method that stores the given boolean value for the given key.
     */
    setBoolean(key, value) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.boolean(value);
      this._values.set(key, value);
    }

    /**
     * A method that stores the given number value for the given key.
     */
    setNumber(key, value) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.number(value);
      this._values.set(key, value);
    }

    /**
     * A method that stores the given string value for the given key.
     */
    setString(key, value) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.string(value);
      this._values.set(key, value);
    }
  }

  exports.default = ConfigurationState;

  },{"bfs-km-types":691}],234:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _rectIntersect = require('./utils/rectIntersect.js');

  var _rectIntersect2 = _interopRequireDefault(_rectIntersect);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for turning html strings into html document
   * nodes. The class provides methods for locating html elements using css
   * selectors as well as for building html documents.
   */
  class DocumentFragment {
    constructor(document, window, htmlString) {
      _bfsKmTypes2.default.check.type(document, HTMLDocument);
      _bfsKmTypes2.default.check.type(window, Window);
      _bfsKmTypes2.default.check.string(htmlString);
      const storageElement = document.createElement('div');
      storageElement.innerHTML = htmlString;
      this._document = document;
      this._window = window;
      this._containerElement = null;
      this._storageElement = storageElement;
      this._rootElements = Array.from(storageElement.children);
    }

    /**
     * A method that attaches all root nodes to the given container element.
     */
    attach(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      this.detach();
      this._containerElement = containerElement;
      for (let i = 0; i < this._rootElements.length; i++) {
        this._containerElement.appendChild(this._rootElements[i]);
      }
    }

    /**
     * A method that cleans up the instance in a way that should aid the garbage
     * collector.
     */
    destroy() {
      this.detach();
      this._document = null;
      this._window = null;
      this._containerElement = null;
      this._storageElement = null;
      this._rootElements = null;
    }

    /**
     * A method that detaches all root nodes from the container element of the
     * document fragment.
     */
    detach() {
      if (this._containerElement !== null) {
        for (let i = 0; i < this._rootElements.length; i++) {
          this._storageElement.appendChild(this._rootElements[i]);
        }
        this._containerElement = null;
      }
    }

    /**
     * A method that returns an element matching the given selector or null if no
     * element matches. This method only works when the document fragment is in a
     * detached state since the method shouldn't return elements belonging to
     * other views.
     */
    find(selector) {
      _bfsKmTypes2.default.check.string(selector);
      return this._storageElement.querySelector(selector);
    }

    /**
     * A method that determines if the document fragment is attached.
     */
    isAttached() {
      return this._containerElement !== null;
    }

    /**
     * A method that determines if the document fragment is partially visible
     * within the window.
     */
    isPartiallyVisible() {
      const viewportWidth = this._window.innerWidth;
      const viewportHeight = this._window.innerHeight;
      const windowRect = {
        left: 0,
        right: viewportWidth,
        top: 0,
        bottom: viewportHeight
      };
      for (let i = 0; i < this._rootElements.length; i++) {
        const element = this._rootElements[i];
        const elementBCR = element.getBoundingClientRect();
        const elementRect = {
          left: elementBCR.left,
          right: elementBCR.right,
          top: elementBCR.top,
          bottom: elementBCR.bottom
        };
        const elementStyle = this._window.getComputedStyle(element);
        if (this._isInvisible(elementStyle)) {
          return false;
        }
        if (!(0, _rectIntersect2.default)(elementRect, windowRect)) {
          continue;
        }
        const parent = element.parentNode;
        if (this._isVisibleInParent(elementRect, elementStyle, parent)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A method that returns all elements matching the given selector or an empty
     * array if no elements match. This method only works when the document
     * fragment is in a detached state since the method shouldn't return elements
     * belonging to other views.
     */
    query(selector) {
      _bfsKmTypes2.default.check.string(selector);
      const elements = this._storageElement.querySelectorAll(selector);
      return Array.from(elements);
    }

    _isInvisible(style) {
      _bfsKmTypes2.default.check.type(style, CSSStyleDeclaration);
      return style.opacity === '0' || style.visibility === 'hidden';
    }

    _isVisibleInParent(elementRect, elementStyle, parent) {
      _bfsKmTypes2.default.check.object(elementRect);
      _bfsKmTypes2.default.check.type(elementStyle, CSSStyleDeclaration);
      if (!parent) {
        return false;
      }
      _bfsKmTypes2.default.check.type(parent, Element);
      if (parent === this._document.body) {
        return true;
      }
      const parentStyle = this._window.getComputedStyle(parent);
      if (this._isInvisible(parentStyle)) {
        return false;
      }
      const parentBCR = parent.getBoundingClientRect();
      const parentRect = {
        left: parentBCR.left,
        right: parentBCR.right,
        top: parentBCR.top,
        bottom: parentBCR.bottom
      };
      if (parentStyle.overflow === 'hidden') {
        if (!(0, _rectIntersect2.default)(elementRect, parentRect)) {
          return false;
        }
      }
      const ancestor = parent.parentNode;
      return this._isVisibleInParent(elementRect, elementStyle, ancestor);
    }
  }

  exports.default = DocumentFragment;

  },{"./utils/rectIntersect.js":270,"bfs-km-types":691}],235:[function(require,module,exports){
  (function (global){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _getParsedJson = require('./utils/getParsedJson.js');

  var _getParsedJson2 = _interopRequireDefault(_getParsedJson);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for handling interactions with the Spotify
   * environment. This class encapsulates shared Spotify libraries in a way that
   * is very useful for unit testing. The libraries are required in the
   * constructor because importing them as modules is not guaranteed to be free
   * from side-effects.
   */
  class Environment {
    constructor(window, dateCreator) {
      _bfsKmTypes2.default.check.type(window, Window);
      _bfsKmTypes2.default.check.function(dateCreator);
      this._window = window;
      this._dateCreator = dateCreator;
      this._adFormats = require('../../ad-formats');
      this._glue = require('../../glue');
      this._glueStrings = require('../../glue/strings/index.js');
      this._spotifyCosmosApi = require('spotify-cosmos-api');
      this._spotifyEvents = require('../../spotify-events');
      this._spotifyHandlebars = require('../../spotify-handlebars');
      this._spotifyHandlebarsHelpers = require('../../spotify-handlebars/helpers/index.js');
      this._spotifyLive = require('../../live');
      this._spotifyLiveModels = require('../../live-models');
      this._spotifyLocales = require('../../locales');
      this._spotifyLocalStorage = require('../../local-storage');
      this._spotifyNavigationPageIdentifiers = require('../../navigation/page-identifiers.js');
    }

    /**
     * A method that adds any object with a uri to the live cache.
     */
    addToLiveCache(model) {
      _bfsKmTypes2.default.check.object(model);
      this._spotifyLive(model);
    }

    /**
     * A method that attaches the spotify events.
     */
    attachSpotifyEvents() {
      this._spotifyEvents.attach();
    }

    /**
     * A method that creates a hpto and puts it in the given hpto element. The two
     * listeners will be triggered when the hpto is rendered and hidden,
     * respectively.
     */
    createHomePageTakeOverFor(hptoElement, onHptoRendered, onHptoHidden) {
      _bfsKmTypes2.default.check.type(hptoElement, Element);
      _bfsKmTypes2.default.check.function(onHptoRendered);
      _bfsKmTypes2.default.check.function(onHptoHidden);
      this._adFormats.HptoAd.subscribeToRender(onHptoRendered);
      this._adFormats.HptoAd.subscribeToHide(onHptoHidden);
      this._adFormats.HptoAd.init(hptoElement);
    }

    /**
     * A method that destroys the hpto and removes the two listeners.
     */
    destroyHomePageTakeOver(onHptoRendered, onHptoHidden) {
      _bfsKmTypes2.default.check.function(onHptoRendered);
      _bfsKmTypes2.default.check.function(onHptoHidden);
      this._adFormats.HptoAd.unsubscribeToRender(onHptoRendered);
      this._adFormats.HptoAd.unsubscribeToHide(onHptoHidden);
      this._adFormats.HptoAd.destroy();
    }

    /**
     * A method that fetches the json stored in spotify local storage for the
     * given key. The given callback will be called with the stored json.
     */
    fetchFromSpotifyLocalStorage(key, callback) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.function(callback);
      const serialized = this._spotifyLocalStorage.get(key);
      let json = (0, _getParsedJson2.default)(serialized);
      if (!_bfsKmTypes2.default.is.object(json)) {
        json = {};
      }
      callback(json);
    }

    /**
     * A method that checks if the given locale is supported by the
     * locales library.
     */
    isSupportedLocale(locale) {
      _bfsKmTypes2.default.check.string(locale);
      return this._spotifyLocales.all().indexOf(locale) !== -1;
    }

    /**
     * A method that starts to listen for the GLUE grid overlay, that can be
     * triggered from a menu item or keyboard shortcut.
     */
    listenForOverlayGrid() {
      this._glue.gridOverlay.listen();
    }

    /**
     * A method that listens for application arguments changes. When the arguments
     * change, the given callback will be called with an array of application
     * arguments.
     */
    listenForApplicationArgumentsChanges(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const application = this._spotifyLive('spotify:application');
      application.on('update', json => {
        if (_bfsKmTypes2.default.conforms(json, { arguments: '' })) {
          const args = json.arguments.split(':');
          callback(args);
        }
      });
    }

    /**
     * A method that listens the session online status.
     */
    listenForSessionOnlineStatusChanges(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const client = this._spotifyLive('spotify:client');
      client.query('session(online)', () => {
        client.get('session').on('update', json => {
          if (_bfsKmTypes2.default.conforms(json, { online: false })) {
            callback(json.online);
          }
        });
      });
    }

    listenForAppActiveChanges(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const application = this._spotifyLive('spotify:application');
      application.on('update', json => {
        if (_bfsKmTypes2.default.conforms(json, { active: true })) {
          const active = json.active;
          callback(active);
        }
      });
    }

    /**
     * A method that make a tracklist live model from the given model for the
     * given uri.
     */
    makeTracklistLiveModel(uri, model) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.object(model);
      if (!this._spotifyLive.has(uri)) {
        this._spotifyLive(model);
      } else {
        this._spotifyLive(uri).update(model);
      }
    }

    /**
     * A method that queries the application arguments. The given callback will be
     * called with an array of application arguments.
     */
    queryApplicationArguments(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const application = this._spotifyLive('spotify:application');
      application.query('arguments', (error, json) => {
        if (_bfsKmTypes2.default.conforms(json, { arguments: '' })) {
          const args = json.arguments.split(':');
          callback(args);
        }
      });
    }

    /**
     * A method that queries the client session state. The given callback will be
     * called with a clientVersion (nullable), userCatalogue (nullable),
     * userCountry (nullable), userEmployee (nullable), userLanguage (nullable)
     * and userUsername (nullable).
     */
    queryClientSessionState(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const query = 'currentUser(username), session(country, employee, language)';
      const client = this._spotifyLive('spotify:client');
      client.query(query, (error, json) => {
        let clientVersion = null;
        let userCatalogue = null;
        let userCountry = null;
        let userEmployee = null;
        let userLanguage = null;
        let userUsername = null;
        const gsp = global.__spotify;
        if (_bfsKmTypes2.default.conforms(gsp, { client_version: '' })) {
          clientVersion = gsp.client_version;
          clientVersion = clientVersion.split('-').pop(); // Strip out branch.
        }
        if (_bfsKmTypes2.default.conforms(gsp, { product_state: { catalogue: '' } })) {
          userCatalogue = gsp.product_state.catalogue;
        }
        if (_bfsKmTypes2.default.conforms(json, { session: { country: '' } })) {
          userCountry = json.session.country;
        }
        if (_bfsKmTypes2.default.conforms(json, { session: { employee: false } })) {
          userEmployee = json.session.employee;
        }
        if (_bfsKmTypes2.default.conforms(json, { session: { language: '' } })) {
          userLanguage = json.session.language;
        }
        if (_bfsKmTypes2.default.conforms(json, { currentUser: { username: '' } })) {
          userUsername = json.currentUser.username;
        }
        callback(clientVersion, userCatalogue, userCountry, userEmployee, userLanguage, userUsername);
      });
    }

    /**
     * A method that queries the client to know if the application is online.
     */
    querySessionOnline(callback) {
      const client = this._spotifyLive('spotify:client');
      client.query('session(online)', (error, json) => {
        if (_bfsKmTypes2.default.conforms(json, { session: { online: false } })) {
          const online = json.session.online;
          callback(online);
        }
      });
    }

    /**
     * A method that registers the spotify handlebars helpers for the given user
     * language.
     */
    registerSpotifyHandlebarsHelpersFor(language) {
      _bfsKmTypes2.default.check.string(language);
      this._spotifyHandlebarsHelpers.loc.register(this._glueStrings[language]);
      this._spotifyHandlebarsHelpers.loc.setLocale(language);
      this._spotifyHandlebarsHelpers.numeral.setLocale(language);
      this._spotifyHandlebars.register(this._spotifyHandlebarsHelpers);
    }

    /**
     * A method that registers the spotify live models.
     */
    registerSpotifyLiveModels() {
      this._spotifyLiveModels.register();
    }

    /**
     * A method that resolves a cosmos cosmos api get request for the given uri.
     * The given callback will be called with a json response (nullable).
     */
    resolveSpotifyCosmosApiGetRequest(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      this._spotifyCosmosApi.resolver.get(uri, (error, response) => {
        let json;
        if (response) {
          json = response.getJSONBody();
        } else {
          json = null;
        }
        callback(json);
      });
    }

    /**
     * Notifies the outside world that this app is ready to be displayed
     */
    sendViewReady(appName, callback = null) {
      _bfsKmTypes2.default.check.string(appName);

      if (callback) {
        const parentWindow = this._window.parent;
        parentWindow.addEventListener('message', function handler(event) {
          if (event.data.type === 'notify_ready' && event.data.pageId === appName) {
            parentWindow.removeEventListener('message', handler);
            callback();
          }
        });
      }

      this._window.parent.postMessage({
        type: 'notify_ready',
        pageId: appName
      }, '*');
    }

    /**
     * Notifies the outside world that this app is loaded though a cosmos request
     */
    sendViewLoaded(appName) {
      _bfsKmTypes2.default.check.string(appName);
      this.queryApplicationArguments(appArgs => {
        // Send message to assure that View Load metrics are sent
        const pageId = this._getPageId(appName, appArgs);
        this._window.parent.postMessage({
          type: 'notify_loaded',
          pageId: pageId,
          now: this._window.parent.performance.now()
        }, '*');
        // Send message to assure that App Startup metrics are sent
        this._spotifyCosmosApi.resolver.post({
          url: 'sp://messages/v1/container/control',
          body: {
            name: appName,
            type: 'view_loaded'
          }
        });
      });
    }

    /**
     * A method that stores the given json for the given key in spotify local
     * storage.
     */
    storeInSpotifyLocalStorage(key, json) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.object(json);
      const value = JSON.stringify(json);
      this._spotifyLocalStorage.set(key, value);
    }

    /**
     * A method that updates spotify events in the given container element.
     */
    updateSpotifyEventsIn(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      this._spotifyEvents.update(containerElement);
    }

    _getPageId(appName, appArgs) {
      _bfsKmTypes2.default.check.string(appName);
      _bfsKmTypes2.default.check.array(appArgs);
      return this._spotifyNavigationPageIdentifiers.getPageIdFromAppArguments(appName, appArgs);
    }
  }

  exports.default = Environment;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../ad-formats":73,"../../glue":159,"../../glue/strings/index.js":163,"../../live":413,"../../live-models":376,"../../local-storage":418,"../../locales":419,"../../logger/messages/UIInteraction5.js":428,"../../navigation/page-identifiers.js":443,"../../spotify-events":510,"../../spotify-handlebars":559,"../../spotify-handlebars/helpers/index.js":549,"./utils/getParsedJson.js":268,"bfs-km-types":691,"spotify-cosmos-api":1272}],236:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _EventListener = require('./EventListener.js');

  var _EventListener2 = _interopRequireDefault(_EventListener);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for routing events between the different
   * components of the framework in an anonymous fashion. A component may register
   * its interest in any number of different event types. When another component
   * dispatches an event, all components which have registered their interest in
   * the specific event type will get notified. The dispatching component can
   * choose to include event data as json.
   */
  class EventDispatcher {
    constructor() {
      this._eventListeners = new Map(); // eslint-disable-line no-undef
    }

    /**
     * A method that dispatches an event of the given type with the given json.
     */
    dispatch(type, json) {
      _bfsKmTypes2.default.check.string(type);
      _bfsKmTypes2.default.check.object(json);
      if (this._eventListeners.has(type)) {
        const eventListeners = this._eventListeners.get(type).slice();
        for (let i = 0; i < eventListeners.length; i++) {
          eventListeners[i].trigger(json);
        }
      }
    }

    /**
     * A method that registers the given event listener with the event dispatcher.
     */
    register(eventListener) {
      _bfsKmTypes2.default.check.type(eventListener, _EventListener2.default);
      const type = eventListener.getType();
      if (!this._eventListeners.has(type)) {
        this._eventListeners.set(type, []);
      }
      const eventListeners = this._eventListeners.get(type);
      if (eventListeners.indexOf(eventListener) === -1) {
        eventListeners.push(eventListener);
      }
    }

    /**
     * A method that unregisters the given event listener with the event
     * dispatcher.
     */
    unregister(eventListener) {
      _bfsKmTypes2.default.check.type(eventListener, _EventListener2.default);
      const type = eventListener.getType();
      if (this._eventListeners.has(type)) {
        const eventListeners = this._eventListeners.get(type);
        const index = eventListeners.indexOf(eventListener);
        if (index !== -1) {
          eventListeners.splice(index, 1);
        }
        if (eventListeners.length === 0) {
          this._eventListeners.delete(type);
        }
      }
    }
  }

  exports.default = EventDispatcher;

  },{"./EventListener.js":237,"bfs-km-types":691}],237:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for containing the data that comprises an event
   * listener. This class wraps a callback function, a caller and the event type
   * for which to trigger the listener.
   */
  class EventListener {
    constructor(type, callback, caller) {
      _bfsKmTypes2.default.check.string(type);
      _bfsKmTypes2.default.check.function(callback);
      this._type = type;
      this._callback = callback;
      this._caller = caller;
    }

    /**
     * A method that returns the callback of the event listener.
     */
    getCallback() {
      return this._callback;
    }

    /**
     * A method that returns the type of the event listener.
     */
    getType() {
      return this._type;
    }

    /**
     * A method that triggers the event listener with the given json.
     */
    trigger(json) {
      _bfsKmTypes2.default.check.object(json);
      this._callback.call(this._caller, json);
    }
  }

  exports.default = EventListener;

  },{"bfs-km-types":691}],238:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for containing the data that comprises an
   * interaction handler. Interactions are user actions that occur on html
   * elements within a view component. This class wraps a callback function, a
   * caller, the interaction type for which to trigger the handler and the element
   * on which the handler is attached.
   */
  class InteractionHandler {
    constructor(element, type, callback, caller) {
      _bfsKmTypes2.default.check.type(element, Element);
      _bfsKmTypes2.default.check.string(type);
      _bfsKmTypes2.default.check.function(callback);
      this._element = element;
      this._type = type;
      this._handler = () => {
        callback.call(caller, element);
      };
    }

    /**
     * A method that attaches the interaction handler to the element.
     */
    attach() {
      this._element.addEventListener(this._type, this._handler);
    }

    /**
     * A method that detaches the interaction handler from the element.
     */
    detach() {
      this._element.removeEventListener(this._type, this._handler);
    }
  }

  exports.default = InteractionHandler;

  },{"bfs-km-types":691}],239:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A simple class that can be used to temporarily hide any element in the dom by
   * replacing it with a placeholder. This assures that the element retains its
   * position is the dom.
   */
  class Placeholder {
    constructor(document, targetElement) {
      _bfsKmTypes2.default.check.type(document, HTMLDocument);
      _bfsKmTypes2.default.check.type(targetElement, Element);
      this._targetElement = targetElement;
      this._placeholderElement = document.createElement(targetElement.nodeName);
      this._placeholderElement.style.setProperty('display', 'none');
    }

    showPlaceholderElement() {
      const parentNode = this._targetElement.parentNode;
      if (parentNode !== null) {
        parentNode.replaceChild(this._placeholderElement, this._targetElement);
      }
    }

    showTargetElement() {
      const parentNode = this._placeholderElement.parentNode;
      if (parentNode !== null) {
        parentNode.replaceChild(this._targetElement, this._placeholderElement);
      }
    }
  }

  exports.default = Placeholder;

  },{"bfs-km-types":691}],240:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _index = require('./views/index.js');

  var views = _interopRequireWildcard(_index);

  var _Application = require('./Application.js');

  var _Application2 = _interopRequireDefault(_Application);

  var _ApplicationContext = require('./ApplicationContext.js');

  var _ApplicationContext2 = _interopRequireDefault(_ApplicationContext);

  var _Configuration = require('./Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _ConfigurationState = require('./ConfigurationState.js');

  var _ConfigurationState2 = _interopRequireDefault(_ConfigurationState);

  var _CosmosBackend = require('./backends/CosmosBackend.js');

  var _CosmosBackend2 = _interopRequireDefault(_CosmosBackend);

  var _Environment = require('./Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  var _EventDispatcher = require('./EventDispatcher.js');

  var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

  var _EventListener = require('./EventListener.js');

  var _EventListener2 = _interopRequireDefault(_EventListener);

  var _HubviewService = require('./services/HubviewService.js');

  var _HubviewService2 = _interopRequireDefault(_HubviewService);

  var _LocalhostBackend = require('./backends/LocalhostBackend.js');

  var _LocalhostBackend2 = _interopRequireDefault(_LocalhostBackend);

  var _ServiceRouter = require('./ServiceRouter.js');

  var _ServiceRouter2 = _interopRequireDefault(_ServiceRouter);

  var _SwitchableBackend = require('./backends/SwitchableBackend.js');

  var _SwitchableBackend2 = _interopRequireDefault(_SwitchableBackend);

  var _ViewParser = require('./ViewParser.js');

  var _ViewParser2 = _interopRequireDefault(_ViewParser);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for creating instances of other classes required
   * to run the framework. The class creates these instances in the order in which
   * they have to be initialized and connects them together. This is the only
   * class that is required to be created by apps using the framework.
   */
  class Runner {
    constructor(document, window, config) {
      _bfsKmTypes2.default.check.type(document, HTMLDocument);
      _bfsKmTypes2.default.check.type(window, Window);
      _bfsKmTypes2.default.check.object(config);
      this._document = document;
      this._window = window;
      this._config = _bfsKmTypes2.default.clone(config);
    }

    newApplicationContext(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      const environment = new _Environment2.default(this._window, () => new Date());
      const eventDispatcher = new _EventDispatcher2.default();
      const serviceRouter = new _ServiceRouter2.default();
      const configuration = new _Configuration2.default(environment, () => new _ConfigurationState2.default(), this._config);
      const viewCreator = (ViewConstructor, model) => {
        return new ViewConstructor(model, eventDispatcher, serviceRouter, configuration, environment, this._document, this._window);
      };
      const viewParser = this._newViewParser(viewCreator);
      const switchableBackend = this._newSwitchableBackend(environment, configuration);
      const hubviewService = new _HubviewService2.default(switchableBackend, viewParser, configuration, () => new Date());
      serviceRouter.register(hubviewService);
      const application = new _Application2.default(this._window, containerElement, eventDispatcher, serviceRouter, configuration, environment, (type, callback, caller) => new _EventListener2.default(type, callback, caller), viewCreator);
      const htmlElement = this._document.documentElement;
      const applicationContext = new _ApplicationContext2.default(htmlElement, application, configuration, environment);
      return applicationContext;
    }

    _newSwitchableBackend(environment, configuration) {
      _bfsKmTypes2.default.check.type(environment, _Environment2.default);
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      const cosmosBackend = new _CosmosBackend2.default(environment);
      const localhostBackend = new _LocalhostBackend2.default(configuration, () => new XMLHttpRequest());
      const switchableBackend = new _SwitchableBackend2.default(cosmosBackend, localhostBackend, configuration);
      return switchableBackend;
    }

    _newViewParser(viewCreator) {
      _bfsKmTypes2.default.check.function(viewCreator);
      const viewParser = new _ViewParser2.default(viewCreator);
      viewParser.register('bfs-card-album', views.CardAlbum);
      viewParser.register('bfs-card-artist', views.CardArtist);
      viewParser.register('bfs-card-chart', views.CardChart);
      viewParser.register('bfs-card-episode', views.CardEpisode);
      viewParser.register('bfs-card-link', views.CardLink);
      viewParser.register('bfs-card-playlist', views.CardPlaylist);
      viewParser.register('bfs-card-profile', views.CardProfile);
      viewParser.register('bfs-card-show', views.CardShow);
      viewParser.register('bfs-cell', views.Cell);
      viewParser.register('bfs-container', views.Container);
      viewParser.register('bfs-embedded-app', views.EmbeddedApp);
      viewParser.register('bfs-error-screen', views.ErrorScreen);
      viewParser.register('bfs-grid', views.Grid);
      viewParser.register('bfs-header-browse', views.HeaderBrowse);
      viewParser.register('bfs-header-genre', views.HeaderGenre);
      viewParser.register('bfs-item-album', views.ItemAlbum);
      viewParser.register('bfs-item-concert', views.ItemConcert);
      viewParser.register('bfs-list-group', views.ListGroup);
      viewParser.register('bfs-deferred-container', views.DeferredContainer);
      viewParser.register('bfs-puff', views.Puff);
      viewParser.register('bfs-section', views.Section);
      viewParser.register('bfs-section-carousel', views.SectionCarousel);
      viewParser.register('bfs-section-grid', views.SectionGrid);
      viewParser.register('bfs-section-grid-buttons', views.SectionGridButtons);
      viewParser.register('bfs-tab', views.Tab);
      viewParser.register('bfs-tracklist', views.Tracklist);
      return viewParser;
    }
  }

  exports.default = Runner;

  },{"./Application.js":230,"./ApplicationContext.js":231,"./Configuration.js":232,"./ConfigurationState.js":233,"./Environment.js":235,"./EventDispatcher.js":236,"./EventListener.js":237,"./ServiceRouter.js":241,"./ViewParser.js":242,"./backends/CosmosBackend.js":244,"./backends/LocalhostBackend.js":245,"./backends/SwitchableBackend.js":246,"./services/HubviewService.js":262,"./views/index.js":323,"bfs-km-types":691}],241:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Service = require('./services/Service.js');

  var _Service2 = _interopRequireDefault(_Service);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that is responsible for delegating service requests to the services
   * registered with the service router. When a component makes a service request,
   * the service router asks each of the registered services to handle the
   * request. The first service that accepts the request is tasked with handling
   * the request.
   */
  class ServiceRouter {
    constructor() {
      this._services = [];
    }

    /**
     * A method that registers a service with the service router.
     */
    register(service) {
      _bfsKmTypes2.default.check.type(service, _Service2.default);
      if (this._services.indexOf(service) === -1) {
        this._services.push(service);
      }
    }

    /**
     * A method that attempts to find a suitable service providing a view tree for
     * the given uri.
     */
    request(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      for (let i = 0; i < this._services.length; i++) {
        const service = this._services[i];
        if (service.responds(uri)) {
          service.request(uri, callback);
          return;
        }
      }
      callback(null);
    }
  }

  exports.default = ServiceRouter;

  },{"./services/Service.js":263,"bfs-km-types":691}],242:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('./views/View.js');

  var _View2 = _interopRequireDefault(_View);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const SCHEMA = {
    'id': '',
    'model': {},
    'views?': []
  };

  /**
   * A class that is responsible for parsing backend json responses into view
   * component trees. Unknown view components in the json response get discarded
   * (and by that also their children). The same is true if a view component
   * rejects the json model which it may choose to do if required data is missing
   * or malformed.
   */
  class ViewParser {
    constructor(viewCreator) {
      _bfsKmTypes2.default.check.function(viewCreator);
      this._viewCreator = viewCreator;
      this._viewConstructors = new Map(); // eslint-disable-line no-undef
    }

    /**
     * A method that recursively parses the given json into a view tree.
     */
    parse(json) {
      if (_bfsKmTypes2.default.conforms(json, SCHEMA)) {
        const view = this._create(json.id, json.model);
        if (view !== null) {
          if ('views' in json) {
            for (let i = 0; i < json.views.length; i++) {
              const child = this.parse(json.views[i]);
              if (child !== null) {
                view.addChild(child);
              }
            }
          }
        }
        return view;
      }
      return null;
    }

    /**
     * A method that registers a view class for the given id with the view parser.
     */
    register(id, viewConstructor) {
      _bfsKmTypes2.default.check.string(id);
      _bfsKmTypes2.default.check.type(viewConstructor.prototype, _View2.default);
      this._viewConstructors.set(id, viewConstructor);
    }

    /**
     * A method that attempts to create a view from the given id and the given
     * model.
     */
    _create(id, model) {
      _bfsKmTypes2.default.check.string(id);
      _bfsKmTypes2.default.check.object(model);
      if (this._viewConstructors.has(id)) {
        const viewConstructor = this._viewConstructors.get(id);
        try {
          return this._viewCreator(viewConstructor, model);
        } catch (error) {
          console.warn(`Constructor threw error for type "${id}"!`, error);
        }
      } else {
        console.warn(`Constructor not registered for type "${id}"!`);
      }
      return null;
    }
  }

  exports.default = ViewParser;

  },{"./views/View.js":271,"bfs-km-types":691}],243:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An interface that is responsible for providing the data transport of a
   * backend request. Implementations of this interface are required to provide a
   * deserialized json response (or null to indicate an error) and may choose to
   * do so in an asynchronous fashion.
   */
  class Backend {
    constructor() {
      if (this.constructor === Backend) {
        throw new Error('Instances may not be created from interface classes!');
      }
    }

    /**
     * An abstract method that makes a request to the backend. If the request
     * succeeds, the callback will be called with the json response. If the
     * request fails or times out, the callback will be called with null.
     */
    request(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      throw new Error('Abstract method called!');
    }
  }

  exports.default = Backend;

  },{"bfs-km-types":691}],244:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Backend = require('./Backend.js');

  var _Backend2 = _interopRequireDefault(_Backend);

  var _Environment = require('../Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An implementation of the backend interface that uses cosmos for data
   * transport. This is the standard backend implementation that should be used
   * for normal users in production.
   */
  class CosmosBackend extends _Backend2.default {
    constructor(environment) {
      super();
      _bfsKmTypes2.default.check.type(environment, _Environment2.default);
      this._environment = environment;
    }

    /**
     * A method that makes a request to the backend. If the request succeeds, the
     * callback will be called with the json response. If the request fails or
     * times out, the callback will be called with null.
     */
    request(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      this._environment.resolveSpotifyCosmosApiGetRequest(uri, callback);
    }
  }

  exports.default = CosmosBackend;

  },{"../Environment.js":235,"./Backend.js":243,"bfs-km-types":691}],245:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _formatClientVersion = require('../utils/formatClientVersion.js');

  var _formatClientVersion2 = _interopRequireDefault(_formatClientVersion);

  var _getParsedJson = require('../utils/getParsedJson.js');

  var _getParsedJson2 = _interopRequireDefault(_getParsedJson);

  var _Backend = require('./Backend.js');

  var _Backend2 = _interopRequireDefault(_Backend);

  var _Configuration = require('../Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _ConfigurationState = require('../ConfigurationState.js');

  var _ConfigurationState2 = _interopRequireDefault(_ConfigurationState);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An implementation of the backend interface that routes backend requests to
   * the local machine. The implementation uses http for data transport and http
   * headers for user authentication. This is very useful for testing backend
   * changes without deploying a backend service to production but should never be
   * used for normal users. Works in conjunction with a locally running
   * authentication proxy.
   */
  class LocalhostBackend extends _Backend2.default {
    constructor(configuration, xmlHttpRequestCreator) {
      super();
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      _bfsKmTypes2.default.check.function(xmlHttpRequestCreator);
      this._configuration = configuration;
      this._xmlHttpRequestCreator = xmlHttpRequestCreator;
    }

    /**
     * A method that makes a request to the backend. If the request succeeds, the
     * callback will be called with the json response. If the request fails or
     * times out, the callback will be called with null.
     */
    request(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      this._configuration.getCurrentState(configurationState => {
        const xhr = this._xmlHttpRequestCreator();
        xhr.onreadystatechange = () => {
          if (xhr.readyState === XMLHttpRequest.DONE) {
            let json = null;
            if (xhr.status === 200) {
              json = (0, _getParsedJson2.default)(xhr.response);
            }
            callback(json);
          }
        };
        const httpPort = configurationState.getNumberOr('proxy/port', 8081);
        const httpUri = uri.replace(/^hm:\/\//, `http://127.0.0.1:${httpPort}/`);
        xhr.open('GET', httpUri, true);
        this._setRequestHeaders(xhr, configurationState);
        xhr.send(null);
      });
    }

    /**
     * A method that sets the appropriate request headers on the given xhr. The
     * client platform header isn't neccessarily OSX_X86_64 for all requests but
     * most employees are OSX users and this only has to be one of the desktop
     * platforms in order for a/b testing to work properly.
     */
    _setRequestHeaders(xhr, configurationState) {
      _bfsKmTypes2.default.check.type(xhr, XMLHttpRequest);
      _bfsKmTypes2.default.check.type(configurationState, _ConfigurationState2.default);
      xhr.setRequestHeader('x-spotify-client-platform', 'OSX_X86_64');
      if (configurationState.hasString('client/version')) {
        const clientVersion = configurationState.getString('client/version');
        const formattedClientVersion = (0, _formatClientVersion2.default)(clientVersion);
        xhr.setRequestHeader('x-spotify-client-version', formattedClientVersion);
      }
      if (configurationState.hasString('user/catalogue')) {
        const userCatalogue = configurationState.getString('user/catalogue');
        xhr.setRequestHeader('x-spotify-catalogue', userCatalogue);
      }
      if (configurationState.hasString('user/country')) {
        const userCountry = configurationState.getString('user/country');
        xhr.setRequestHeader('x-spotify-country', userCountry);
      }
      if (configurationState.hasBoolean('user/employee')) {
        const userEmployee = configurationState.getBoolean('user/employee');
        xhr.setRequestHeader('x-spotify-employee', `${userEmployee}`);
      }
      if (configurationState.hasString('user/username')) {
        const userUsername = configurationState.getString('user/username');
        xhr.setRequestHeader('x-spotify-username', userUsername);
      }
    }
  }

  exports.default = LocalhostBackend;

  },{"../Configuration.js":232,"../ConfigurationState.js":233,"../utils/formatClientVersion.js":265,"../utils/getParsedJson.js":268,"./Backend.js":243,"bfs-km-types":691}],246:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Backend = require('./Backend.js');

  var _Backend2 = _interopRequireDefault(_Backend);

  var _Configuration = require('../Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _CosmosBackend = require('./CosmosBackend.js');

  var _CosmosBackend2 = _interopRequireDefault(_CosmosBackend);

  var _LocalhostBackend = require('./LocalhostBackend.js');

  var _LocalhostBackend2 = _interopRequireDefault(_LocalhostBackend);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An implementation of the backend interface that uses either the cosmos
   * implementation or the localhost implementation. The decision is made
   * depending on the state of a configuration flag that may be overridden during
   * the application lifecycle.
   */
  class SwitchableBackend extends _Backend2.default {
    constructor(cosmosBackend, localhostBackend, configuration) {
      super();
      _bfsKmTypes2.default.check.type(cosmosBackend, _CosmosBackend2.default);
      _bfsKmTypes2.default.check.type(localhostBackend, _LocalhostBackend2.default);
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      this._cosmosBackend = cosmosBackend;
      this._localhostBackend = localhostBackend;
      this._configuration = configuration;
    }

    /**
     * A method that makes a request to the backend. If the request succeeds, the
     * callback will be called with the json response. If the request fails or
     * times out, the callback will be called with null.
     */
    request(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      this._configuration.getCurrentState(configurationState => {
        if (configurationState.getBooleanOr('proxy/enabled', false)) {
          this._localhostBackend.request(uri, callback);
        } else {
          this._cosmosBackend.request(uri, callback);
        }
      });
    }
  }

  exports.default = SwitchableBackend;

  },{"../Configuration.js":232,"./Backend.js":243,"./CosmosBackend.js":244,"./LocalhostBackend.js":245,"bfs-km-types":691}],247:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SwitchableBackend = exports.LocalhostBackend = exports.CosmosBackend = exports.Backend = undefined;

  var _Backend = require('./Backend.js');

  var _Backend2 = _interopRequireDefault(_Backend);

  var _CosmosBackend = require('./CosmosBackend.js');

  var _CosmosBackend2 = _interopRequireDefault(_CosmosBackend);

  var _LocalhostBackend = require('./LocalhostBackend.js');

  var _LocalhostBackend2 = _interopRequireDefault(_LocalhostBackend);

  var _SwitchableBackend = require('./SwitchableBackend.js');

  var _SwitchableBackend2 = _interopRequireDefault(_SwitchableBackend);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.Backend = _Backend2.default;
  exports.CosmosBackend = _CosmosBackend2.default;
  exports.LocalhostBackend = _LocalhostBackend2.default;
  exports.SwitchableBackend = _SwitchableBackend2.default;

  },{"./Backend.js":243,"./CosmosBackend.js":244,"./LocalhostBackend.js":245,"./SwitchableBackend.js":246}],248:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ViewParser = exports.ServiceRouter = exports.Runner = exports.Placeholder = exports.InteractionHandler = exports.EventListener = exports.EventDispatcher = exports.Environment = exports.DocumentFragment = exports.ConfigurationState = exports.Configuration = exports.ApplicationContext = exports.Application = exports.views = exports.utils = exports.services = exports.modular = exports.backends = undefined;

  var _index = require('./backends/index.js');

  var backends = _interopRequireWildcard(_index);

  var _index2 = require('./modular/index.js');

  var modular = _interopRequireWildcard(_index2);

  var _index3 = require('./services/index.js');

  var services = _interopRequireWildcard(_index3);

  var _index4 = require('./utils/index.js');

  var utils = _interopRequireWildcard(_index4);

  var _index5 = require('./views/index.js');

  var views = _interopRequireWildcard(_index5);

  var _Application = require('./Application.js');

  var _Application2 = _interopRequireDefault(_Application);

  var _ApplicationContext = require('./ApplicationContext.js');

  var _ApplicationContext2 = _interopRequireDefault(_ApplicationContext);

  var _Configuration = require('./Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _ConfigurationState = require('./ConfigurationState.js');

  var _ConfigurationState2 = _interopRequireDefault(_ConfigurationState);

  var _DocumentFragment = require('./DocumentFragment.js');

  var _DocumentFragment2 = _interopRequireDefault(_DocumentFragment);

  var _Environment = require('./Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  var _EventDispatcher = require('./EventDispatcher.js');

  var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

  var _EventListener = require('./EventListener.js');

  var _EventListener2 = _interopRequireDefault(_EventListener);

  var _InteractionHandler = require('./InteractionHandler.js');

  var _InteractionHandler2 = _interopRequireDefault(_InteractionHandler);

  var _Placeholder = require('./Placeholder.js');

  var _Placeholder2 = _interopRequireDefault(_Placeholder);

  var _Runner = require('./Runner.js');

  var _Runner2 = _interopRequireDefault(_Runner);

  var _ServiceRouter = require('./ServiceRouter.js');

  var _ServiceRouter2 = _interopRequireDefault(_ServiceRouter);

  var _ViewParser = require('./ViewParser.js');

  var _ViewParser2 = _interopRequireDefault(_ViewParser);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  exports.backends = backends;
  exports.modular = modular;
  exports.services = services;
  exports.utils = utils;
  exports.views = views;
  exports.Application = _Application2.default;
  exports.ApplicationContext = _ApplicationContext2.default;
  exports.Configuration = _Configuration2.default;
  exports.ConfigurationState = _ConfigurationState2.default;
  exports.DocumentFragment = _DocumentFragment2.default;
  exports.Environment = _Environment2.default;
  exports.EventDispatcher = _EventDispatcher2.default;
  exports.EventListener = _EventListener2.default;
  exports.InteractionHandler = _InteractionHandler2.default;
  exports.Placeholder = _Placeholder2.default;
  exports.Runner = _Runner2.default;
  exports.ServiceRouter = _ServiceRouter2.default;
  exports.ViewParser = _ViewParser2.default;

  },{"./Application.js":230,"./ApplicationContext.js":231,"./Configuration.js":232,"./ConfigurationState.js":233,"./DocumentFragment.js":234,"./Environment.js":235,"./EventDispatcher.js":236,"./EventListener.js":237,"./InteractionHandler.js":238,"./Placeholder.js":239,"./Runner.js":240,"./ServiceRouter.js":241,"./ViewParser.js":242,"./backends/index.js":247,"./modular/index.js":257,"./services/index.js":264,"./utils/index.js":269,"./views/index.js":323}],249:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _index = require('../views/index.js');

  var views = _interopRequireWildcard(_index);

  var _BackendContentProvider = require('./content_providers/BackendContentProvider.js');

  var _BackendContentProvider2 = _interopRequireDefault(_BackendContentProvider);

  var _Configuration = require('../Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _ConfigurationState = require('../ConfigurationState.js');

  var _ConfigurationState2 = _interopRequireDefault(_ConfigurationState);

  var _CosmosBackend = require('../backends/CosmosBackend.js');

  var _CosmosBackend2 = _interopRequireDefault(_CosmosBackend);

  var _Environment = require('../Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  var _EventDispatcher = require('../EventDispatcher.js');

  var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

  var _Scheduler = require('./Scheduler.js');

  var _Scheduler2 = _interopRequireDefault(_Scheduler);

  var _ServiceRouter = require('../ServiceRouter.js');

  var _ServiceRouter2 = _interopRequireDefault(_ServiceRouter);

  var _SurfaceHubApp = require('./hub_apps/SurfaceHubApp.js');

  var _SurfaceHubApp2 = _interopRequireDefault(_SurfaceHubApp);

  var _VanillaUriBuilder = require('./uri_builders/VanillaUriBuilder.js');

  var _VanillaUriBuilder2 = _interopRequireDefault(_VanillaUriBuilder);

  var _ViewParser = require('../ViewParser.js');

  var _ViewParser2 = _interopRequireDefault(_ViewParser);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that makes the dependency injection used in the framework less
   * awkward for the consumer. The factory pattern is especially useful when
   * components need to be shared and the constructor provides a single entry
   * point for injecting external dependencies like configuration.
   */
  class HubFactory {
    constructor(document, window, config) {
      _bfsKmTypes2.default.check.type(document, HTMLDocument);
      _bfsKmTypes2.default.check.type(window, Window);
      _bfsKmTypes2.default.check.object(config);
      this._document = document;
      this._window = window;
      this._config = _bfsKmTypes2.default.clone(config);
    }

    newSurfaceHubApp(uri) {
      _bfsKmTypes2.default.check.string(uri);
      const eventDispatcher = new _EventDispatcher2.default();
      const serviceRouter = new _ServiceRouter2.default();
      const environment = new _Environment2.default(this._window, () => new Date());
      const configuration = new _Configuration2.default(environment, () => new _ConfigurationState2.default(), this._config);
      const viewCreator = (ViewConstructor, model) => {
        return new ViewConstructor(model, eventDispatcher, serviceRouter, configuration, environment, this._document, this._window);
      };
      const viewParser = this._newViewParser(viewCreator);
      const cosmosBackend = new _CosmosBackend2.default(environment);
      const contentProvider = new _BackendContentProvider2.default(cosmosBackend, viewParser, uri);
      const scheduler = new _Scheduler2.default(this._window);
      const surfaceHubApp = new _SurfaceHubApp2.default(contentProvider, environment, scheduler, eventDispatcher);
      return surfaceHubApp;
    }

    newVanillaUriBuilder() {
      const environment = new _Environment2.default(this._window, () => new Date());
      const configuration = new _Configuration2.default(environment, () => new _ConfigurationState2.default(), this._config);
      const vanillaUriBuilder = new _VanillaUriBuilder2.default(configuration, () => new Date());
      return vanillaUriBuilder;
    }

    _newViewParser(viewCreator) {
      _bfsKmTypes2.default.check.function(viewCreator);
      const viewParser = new _ViewParser2.default(viewCreator);
      viewParser.register('bfs-card-album', views.CardAlbum);
      viewParser.register('bfs-card-artist', views.CardArtist);
      viewParser.register('bfs-card-chart', views.CardChart);
      viewParser.register('bfs-card-episode', views.CardEpisode);
      viewParser.register('bfs-card-link', views.CardLink);
      viewParser.register('bfs-card-playlist', views.CardPlaylist);
      viewParser.register('bfs-card-profile', views.CardProfile);
      viewParser.register('bfs-card-show', views.CardShow);
      viewParser.register('bfs-cell', views.Cell);
      viewParser.register('bfs-container', views.Container);
      viewParser.register('bfs-grid', views.Grid);
      viewParser.register('bfs-puff', views.Puff);
      viewParser.register('bfs-section', views.Section);
      viewParser.register('bfs-section-carousel', views.SectionCarousel);
      return viewParser;
    }
  }

  exports.default = HubFactory;

  },{"../Configuration.js":232,"../ConfigurationState.js":233,"../Environment.js":235,"../EventDispatcher.js":236,"../ServiceRouter.js":241,"../ViewParser.js":242,"../backends/CosmosBackend.js":244,"../views/index.js":323,"./Scheduler.js":250,"./content_providers/BackendContentProvider.js":251,"./hub_apps/SurfaceHubApp.js":255,"./uri_builders/VanillaUriBuilder.js":260,"bfs-km-types":691}],250:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that may be used to schedule callbacks. The scheduled callbacks will
   * run on the first animation frame that occurs after the desired amount of time
   * has passed. The class keeps track of scheduled callbacks that haven't fired
   * and supports life-cycle management.
   */
  class Scheduler {
    constructor(window) {
      _bfsKmTypes2.default.check.type(window, Window);
      this._window = window;
      this._setTimeoutTokens = new Set();
      this._requestAnimationFrameTokens = new Set();
    }

    destroy() {
      this._clearPendingSetTimeoutCallbacks();
      this._clearPendingRequestAnimationFrameCallbacks();
      this._window = null;
      this._setTimeoutTokens = null;
      this._requestAnimationFrameTokens = null;
      return null;
    }

    scheduleInAbout(ms, callback) {
      _bfsKmTypes2.default.check.number(ms);
      _bfsKmTypes2.default.check.function(callback);
      const stToken = this._window.setTimeout(() => {
        this._setTimeoutTokens.delete(stToken);
        const rafToken = this._window.requestAnimationFrame(() => {
          this._requestAnimationFrameTokens.delete(rafToken);
          callback();
        });
        this._requestAnimationFrameTokens.add(rafToken);
      }, ms);
      this._setTimeoutTokens.add(stToken);
      return this;
    }

    _clearPendingSetTimeoutCallbacks() {
      for (const stToken of this._setTimeoutTokens) {
        this._window.clearTimeout(stToken);
      }
      this._setTimeoutTokens.clear();
      return this;
    }

    _clearPendingRequestAnimationFrameCallbacks() {
      for (const rafToken of this._requestAnimationFrameTokens) {
        this._window.cancelAnimationFrame(rafToken);
      }
      this._requestAnimationFrameTokens.clear();
      return this;
    }
  }

  exports.default = Scheduler;

  },{"bfs-km-types":691}],251:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Backend = require('../../backends/Backend.js');

  var _Backend2 = _interopRequireDefault(_Backend);

  var _ContentProvider = require('./ContentProvider.js');

  var _ContentProvider2 = _interopRequireDefault(_ContentProvider);

  var _ViewParser = require('../../ViewParser.js');

  var _ViewParser2 = _interopRequireDefault(_ViewParser);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An extension of the ContentProvider class that requests the given uri from
   * the given Backend and lets the given ViewParser parse the returned json into
   * a tree of view components. In the event of an error, null is passed instead
   * of view component tree.
   */
  class BackendContentProvider extends _ContentProvider2.default {
    constructor(backend, viewParser, uri) {
      super();
      _bfsKmTypes2.default.check.type(backend, _Backend2.default);
      _bfsKmTypes2.default.check.type(viewParser, _ViewParser2.default);
      _bfsKmTypes2.default.check.string(uri);
      this._backend = backend;
      this._viewParser = viewParser;
      this._uri = uri;
    }

    getContent(callback) {
      _bfsKmTypes2.default.check.function(callback);
      this._backend.request(this._uri, json => {
        let view;
        if (_bfsKmTypes2.default.conforms(json, { root: {} })) {
          view = this._viewParser.parse(json.root);
        } else {
          view = null;
        }
        callback(view);
      });
      return null;
    }
  }

  exports.default = BackendContentProvider;

  },{"../../ViewParser.js":242,"../../backends/Backend.js":243,"./ContentProvider.js":252,"bfs-km-types":691}],252:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that defines a unified interface for providing view components to the
   * hub app. The purpose of this class is to abstract the underlying
   * implementation of how content is delivered to the hub app. Some content
   * providers may depend on application arguments, some on configuration and some
   * may depend on a combination of these. Classes extending from this class
   * should override all methods as these will throw by default.
   */
  class ContentProvider {
    constructor() {
      if (this.constructor === ContentProvider) {
        throw new Error('Instances may not be created from interface classes!');
      }
    }

    getContent(callback) {
      _bfsKmTypes2.default.check.function(callback);
      throw new Error('Abstract method called!');
    }
  }

  exports.default = ContentProvider;

  },{"bfs-km-types":691}],253:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ContentProvider = exports.BackendContentProvider = undefined;

  var _BackendContentProvider = require('./BackendContentProvider.js');

  var _BackendContentProvider2 = _interopRequireDefault(_BackendContentProvider);

  var _ContentProvider = require('./ContentProvider.js');

  var _ContentProvider2 = _interopRequireDefault(_ContentProvider);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.BackendContentProvider = _BackendContentProvider2.default;
  exports.ContentProvider = _ContentProvider2.default;

  },{"./BackendContentProvider.js":251,"./ContentProvider.js":252}],254:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that defines a unified interface for the life-cycle management of hub
   * apps. Classes extending from this class should override all methods as these
   * will throw by default.
   */
  class HubApp {
    constructor() {
      if (this.constructor === HubApp) {
        throw new Error('Instances may not be created from interface classes!');
      }
    }

    destroy() {
      throw new Error('Abstract method called!');
    }

    loadViewComponentTree(callback) {
      _bfsKmTypes2.default.check.function(callback);
      throw new Error('Abstract method called!');
    }

    mountRootViewIn(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      throw new Error('Abstract method called!');
    }
  }

  exports.default = HubApp;

  },{"bfs-km-types":691}],255:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _ContentProvider = require('../content_providers/ContentProvider.js');

  var _ContentProvider2 = _interopRequireDefault(_ContentProvider);

  var _Environment = require('../../Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  var _EventDispatcher = require('../../EventDispatcher.js');

  var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

  var _HubApp = require('./HubApp.js');

  var _HubApp2 = _interopRequireDefault(_HubApp);

  var _Scheduler = require('../Scheduler.js');

  var _Scheduler2 = _interopRequireDefault(_Scheduler);

  var _View = require('../../views/View.js');

  var _View2 = _interopRequireDefault(_View);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const IMPRESSION_LOGGING_PERIODIC_CHECK_MS = 1000;

  /**
   * An extension of the HubApp class that manages a hub app that may be embedded
   * into surfaces of other apps. This class delegates fetching the view component
   * tree to the given ContentProvider and dispatches impression logging checks
   * through the given Scheduler and EventDispatcher.
   */
  class SurfaceHubApp extends _HubApp2.default {
    constructor(contentProvider, environment, scheduler, eventDispatcher) {
      super();
      _bfsKmTypes2.default.check.type(contentProvider, _ContentProvider2.default);
      _bfsKmTypes2.default.check.type(environment, _Environment2.default);
      _bfsKmTypes2.default.check.type(scheduler, _Scheduler2.default);
      _bfsKmTypes2.default.check.type(eventDispatcher, _EventDispatcher2.default);
      this._contentProvider = contentProvider;
      this._environment = environment;
      this._scheduler = scheduler;
      this._eventDispatcher = eventDispatcher;
      this._rootView = null;
      this._schedulePeriodic();
    }

    destroy() {
      this._scheduler.destroy();
      this._destroyRootView();
      this._contentProvider = null;
      this._environment = null;
      this._rootView = null;
      this._scheduler = null;
      this._eventDispatcher = null;
      return null;
    }

    loadViewComponentTree(callback) {
      _bfsKmTypes2.default.check.function(callback);
      this._contentProvider.getContent(view => {
        this._setRootView(view);
        callback(null, view);
      });
      return null;
    }

    mountRootViewIn(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      if (this._rootView !== null) {
        this._rootView.attach(containerElement);
        this._environment.updateSpotifyEventsIn(containerElement);
      }
      return this;
    }

    _destroyRootView() {
      if (this._rootView !== null) {
        this._rootView.destroy();
        this._rootView = null;
      }
      return this;
    }

    _schedulePeriodic() {
      const timeout = IMPRESSION_LOGGING_PERIODIC_CHECK_MS;
      const scheduledFunction = () => {
        this._eventDispatcher.dispatch('periodic-update', {});
        this._scheduler.scheduleInAbout(timeout, scheduledFunction);
      };
      this._scheduler.scheduleInAbout(timeout, scheduledFunction);
      return null;
    }

    _setRootView(view) {
      this._destroyRootView();
      if (view !== null) {
        _bfsKmTypes2.default.check.type(view, _View2.default);
        this._rootView = view;
      }
      return this;
    }
  }

  exports.default = SurfaceHubApp;

  },{"../../Environment.js":235,"../../EventDispatcher.js":236,"../../views/View.js":271,"../Scheduler.js":250,"../content_providers/ContentProvider.js":252,"./HubApp.js":254,"bfs-km-types":691}],256:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SurfaceHubApp = exports.HubApp = undefined;

  var _HubApp = require('./HubApp.js');

  var _HubApp2 = _interopRequireDefault(_HubApp);

  var _SurfaceHubApp = require('./SurfaceHubApp.js');

  var _SurfaceHubApp2 = _interopRequireDefault(_SurfaceHubApp);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.HubApp = _HubApp2.default;
  exports.SurfaceHubApp = _SurfaceHubApp2.default;

  },{"./HubApp.js":254,"./SurfaceHubApp.js":255}],257:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Scheduler = exports.HubFactory = exports.uriBuilders = exports.hubApps = exports.contentProviders = undefined;

  var _index = require('./content_providers/index.js');

  var contentProviders = _interopRequireWildcard(_index);

  var _index2 = require('./hub_apps/index.js');

  var hubApps = _interopRequireWildcard(_index2);

  var _index3 = require('./uri_builders/index.js');

  var uriBuilders = _interopRequireWildcard(_index3);

  var _HubFactory = require('./HubFactory.js');

  var _HubFactory2 = _interopRequireDefault(_HubFactory);

  var _Scheduler = require('./Scheduler.js');

  var _Scheduler2 = _interopRequireDefault(_Scheduler);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  exports.contentProviders = contentProviders;
  exports.hubApps = hubApps;
  exports.uriBuilders = uriBuilders;
  exports.HubFactory = _HubFactory2.default;
  exports.Scheduler = _Scheduler2.default;

  },{"./HubFactory.js":249,"./Scheduler.js":250,"./content_providers/index.js":253,"./hub_apps/index.js":256,"./uri_builders/index.js":261}],258:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _UriBuilder = require('./UriBuilder.js');

  var _UriBuilder2 = _interopRequireDefault(_UriBuilder);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An extension of the UriBuilder class that builds Hermes uris for any generic
   * service and that handles uri encoding of path components and query
   * parameters. Path component is used interchangeably for both host and path
   * since this implementation does not support the full authority specification
   * as there is currently no need for that.
   */
  class GenericUriBuilder extends _UriBuilder2.default {
    constructor() {
      super();
      this._pathComponents = [];
      this._queryParameters = [];
    }

    addPathComponent(pathComponent) {
      _bfsKmTypes2.default.check.string(pathComponent);
      this._pathComponents.push(pathComponent);
      return this;
    }

    addQueryParameter(key, value) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.string(value);
      const queryParameter = {
        key: key,
        value: value
      };
      this._queryParameters.push(queryParameter);
      return this;
    }

    build(callback) {
      _bfsKmTypes2.default.check.function(callback);
      const pathUriPart = this._getPathUriPart();
      const queryUriPart = this._getQueryUriPart();
      const uri = `hm://${pathUriPart}${queryUriPart}`;
      callback(uri);
      return null;
    }

    _getPathUriPart() {
      const parts = this._pathComponents.map(pathComponent => {
        return encodeURIComponent(pathComponent);
      });
      const joined = parts.join('/');
      return joined;
    }

    _getQueryUriPart() {
      let queryUriPart = '';
      if (this._queryParameters.length > 0) {
        const parts = this._queryParameters.map(queryParameter => {
          const encodedKey = encodeURIComponent(queryParameter.key);
          const encodedValue = encodeURIComponent(queryParameter.value);
          return `${encodedKey}=${encodedValue}`;
        });
        const joined = parts.join('&');
        queryUriPart = `?${joined}`;
      }
      return queryUriPart;
    }
  }

  exports.default = GenericUriBuilder;

  },{"./UriBuilder.js":259,"bfs-km-types":691}],259:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A class that defines a unified interface for building Hermes uris. The
   * purpose of this class is to abstract the underlying implementation of how the
   * Hermes uri is built. Some uri builders may talk with other async libraries
   * while some may build the uri synchronously. Classes extending from this class
   * should override all methods as these will throw by default. This class could
   * eventually be replaced by a Promise.
   */
  class UriBuilder {
    constructor() {
      if (this.constructor === UriBuilder) {
        throw new Error('Instances may not be created from interface classes!');
      }
    }

    build(callback) {
      _bfsKmTypes2.default.check.function(callback);
      throw new Error('Abstract method called!');
    }
  }

  exports.default = UriBuilder;

  },{"bfs-km-types":691}],260:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _getDateTime = require('../../utils/getDateTime.js');

  var _getDateTime2 = _interopRequireDefault(_getDateTime);

  var _Configuration = require('../../Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _ConfigurationState = require('../../ConfigurationState.js');

  var _ConfigurationState2 = _interopRequireDefault(_ConfigurationState);

  var _GenericUriBuilder = require('./GenericUriBuilder.js');

  var _GenericUriBuilder2 = _interopRequireDefault(_GenericUriBuilder);

  var _UriBuilder = require('./UriBuilder.js');

  var _UriBuilder2 = _interopRequireDefault(_UriBuilder);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An extension of the UriBuilder class that builds Hermes uris for the Vanilla
   * service. This class supports sending signals (a special form of query
   * parameters that propagate to upstream services in the programming platform)
   * and will add query parameters with user and client information from the given
   * Configuration. At a minimum, the class requires a space to be specified with
   * the setSpace() method before calling the build() method.
   */
  class VanillaUriBuilder extends _UriBuilder2.default {
    constructor(configuration, dateCreator) {
      super();
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      _bfsKmTypes2.default.check.function(dateCreator);
      this._configuration = configuration;
      this._dateCreator = dateCreator;
      this._space = null;
      this._signals = [];
    }

    addSignal(key, value) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.string(value);
      this._signals.push({
        key: key,
        value: value
      });
      return this;
    }

    build(callback) {
      _bfsKmTypes2.default.check.function(callback);
      this._configuration.getCurrentState(configurationState => {
        const genericUriBuilder = new _GenericUriBuilder2.default();
        this._addPathComponents(genericUriBuilder);
        this._addQueryParameters(genericUriBuilder, configurationState);
        this._addSignals(genericUriBuilder);
        genericUriBuilder.build(callback);
      });
      return null;
    }

    setSpace(space) {
      _bfsKmTypes2.default.check.string(space);
      this._space = space;
      return this;
    }

    _addPathComponents(genericUriBuilder) {
      _bfsKmTypes2.default.check.type(genericUriBuilder, _GenericUriBuilder2.default);
      genericUriBuilder.addPathComponent('vanilla');
      genericUriBuilder.addPathComponent('v1');
      genericUriBuilder.addPathComponent('views');
      genericUriBuilder.addPathComponent('km');
      genericUriBuilder.addPathComponent(this._space);
      return null;
    }

    _addQueryParameters(genericUriBuilder, configurationState) {
      _bfsKmTypes2.default.check.type(genericUriBuilder, _GenericUriBuilder2.default);
      _bfsKmTypes2.default.check.type(configurationState, _ConfigurationState2.default);
      const date = this._dateCreator();
      genericUriBuilder.addQueryParameter('dt', (0, _getDateTime2.default)(date));
      genericUriBuilder.addQueryParameter('platform', 'km');
      if (configurationState.hasString('user/language')) {
        const userLanguage = configurationState.getString('user/language');
        genericUriBuilder.addQueryParameter('locale', userLanguage);
      }
      if (configurationState.hasString('user/catalogue')) {
        const userCatalogue = configurationState.getString('user/catalogue');
        genericUriBuilder.addQueryParameter('product', userCatalogue);
      }
      if (configurationState.hasString('user/country')) {
        const userCountry = configurationState.getString('user/country');
        genericUriBuilder.addQueryParameter('region', userCountry);
      }
      if (configurationState.hasString('user/username')) {
        const userUsername = configurationState.getString('user/username');
        genericUriBuilder.addQueryParameter('username', userUsername);
      }
      if (configurationState.hasString('client/version')) {
        const clientVersion = configurationState.getString('client/version');
        genericUriBuilder.addQueryParameter('version', clientVersion);
      }
      if (!configurationState.getBooleanOr('caching/enabled', true)) {
        const timestamp = date.getTime();
        genericUriBuilder.addQueryParameter('no-cache', `${timestamp}`);
      }
      return null;
    }

    _addSignals(genericUriBuilder) {
      _bfsKmTypes2.default.check.type(genericUriBuilder, _GenericUriBuilder2.default);
      this._signals.forEach(signal => {
        const key = 'signal';
        const value = `${signal.key}:${signal.value}`;
        genericUriBuilder.addQueryParameter(key, value);
      });
      return null;
    }
  }

  exports.default = VanillaUriBuilder;

  },{"../../Configuration.js":232,"../../ConfigurationState.js":233,"../../utils/getDateTime.js":266,"./GenericUriBuilder.js":258,"./UriBuilder.js":259,"bfs-km-types":691}],261:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VanillaUriBuilder = exports.UriBuilder = exports.GenericUriBuilder = undefined;

  var _GenericUriBuilder = require('./GenericUriBuilder.js');

  var _GenericUriBuilder2 = _interopRequireDefault(_GenericUriBuilder);

  var _UriBuilder = require('./UriBuilder.js');

  var _UriBuilder2 = _interopRequireDefault(_UriBuilder);

  var _VanillaUriBuilder = require('./VanillaUriBuilder.js');

  var _VanillaUriBuilder2 = _interopRequireDefault(_VanillaUriBuilder);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.GenericUriBuilder = _GenericUriBuilder2.default;
  exports.UriBuilder = _UriBuilder2.default;
  exports.VanillaUriBuilder = _VanillaUriBuilder2.default;

  },{"./GenericUriBuilder.js":258,"./UriBuilder.js":259,"./VanillaUriBuilder.js":260}],262:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _getDateTime = require('../utils/getDateTime.js');

  var _getDateTime2 = _interopRequireDefault(_getDateTime);

  var _Backend = require('../backends/Backend.js');

  var _Backend2 = _interopRequireDefault(_Backend);

  var _Configuration = require('../Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _Service = require('./Service.js');

  var _Service2 = _interopRequireDefault(_Service);

  var _ViewParser = require('../ViewParser.js');

  var _ViewParser2 = _interopRequireDefault(_ViewParser);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An implementation of the service interface that recognizes and handles
   * service requests to the Hubivew backend service. The implementation adds
   * default query parameters when needed.
   */
  class HubviewService extends _Service2.default {
    constructor(backend, viewParser, configuration, dateCreator) {
      super();
      _bfsKmTypes2.default.check.type(backend, _Backend2.default);
      _bfsKmTypes2.default.check.type(viewParser, _ViewParser2.default);
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      _bfsKmTypes2.default.check.function(dateCreator);
      this._backend = backend;
      this._viewParser = viewParser;
      this._configuration = configuration;
      this._dateCreator = dateCreator;
    }

    /**
     * A method that makes a request to the service. The given callback will be
     * called with the view response if the request succeeds or null if the
     * request fails.
     */
    request(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      if (uri.indexOf('?') === -1) {
        this._requestWithDefaultParameters(uri, callback);
      } else {
        this._requestWithUriParameters(uri, callback);
      }
    }

    /**
     * A method that determines if the service responds for the given uri.
     */
    responds(uri) {
      _bfsKmTypes2.default.check.string(uri);
      return (/^hm:\/\/hubview\//.test(uri)
      );
    }

    /**
     * A method that makes a request to the service using the default parameters.
     */
    _requestWithDefaultParameters(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      this._configuration.getCurrentState(configurationState => {
        const parameters = [];
        const date = this._dateCreator();
        const encodedDateTime = encodeURIComponent((0, _getDateTime2.default)(date));
        parameters.push(`date-time=${encodedDateTime}`);
        if (configurationState.hasString('user/catalogue')) {
          const userCatalogue = configurationState.getString('user/catalogue');
          const encodedUserCatalogue = encodeURIComponent(userCatalogue);
          parameters.push(`catalogue=${encodedUserCatalogue}`);
        }
        if (configurationState.hasString('client/version')) {
          const clientVersion = configurationState.getString('client/version');
          const encodedClientVersion = encodeURIComponent(clientVersion);
          parameters.push(`client-version=${encodedClientVersion}`);
        }
        if (configurationState.hasString('user/country')) {
          const userCountry = configurationState.getString('user/country');
          const encodedUserCountry = encodeURIComponent(userCountry);
          parameters.push(`country=${encodedUserCountry}`);
        }
        if (configurationState.hasString('user/language')) {
          const userLanguage = configurationState.getString('user/language');
          const encodedUserLanguage = encodeURIComponent(userLanguage);
          parameters.push(`locale=${encodedUserLanguage}`);
        }
        if (configurationState.hasString('user/username')) {
          const userUsername = configurationState.getString('user/username');
          const encodedUserUsername = encodeURIComponent(userUsername);
          parameters.push(`username=${encodedUserUsername}`);
        }
        if (!configurationState.getBooleanOr('caching/enabled', true)) {
          const timestamp = date.getTime();
          parameters.push(`no-cache=${timestamp}`);
        }
        const joinedParameters = parameters.join('&');
        const uriWithParameters = `${uri}?${joinedParameters}`;
        this._requestWithUriParameters(uriWithParameters, callback);
      });
    }

    /**
     * A method that makes a request to the service using the uri parameters.
     */
    _requestWithUriParameters(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      this._backend.request(uri, json => {
        let view = null;
        if (_bfsKmTypes2.default.conforms(json, { root: {} })) {
          view = this._viewParser.parse(json.root);
        }
        callback(view);
      });
    }
  }

  exports.default = HubviewService;

  },{"../Configuration.js":232,"../ViewParser.js":242,"../backends/Backend.js":243,"../utils/getDateTime.js":266,"./Service.js":263,"bfs-km-types":691}],263:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An interface that is responsible for handling service requests.
   * Implementations of this interface may choose to only handle certain service
   * requests but must provide a view component tree (or null to indicate an
   * error) if they choose to do so. This may be done in an asynchronous fashion.
   */
  class Service {
    constructor() {
      if (this.constructor === Service) {
        throw new Error('Instances may not be created from interface classes!');
      }
    }

    /**
     * An abstract method that makes a request to the service. The given callback
     * will be called with the view response if the request succeeds or null if
     * the request fails.
     */
    request(uri, callback) {
      _bfsKmTypes2.default.check.string(uri);
      _bfsKmTypes2.default.check.function(callback);
      throw new Error('Abstract method called!');
    }

    /**
     * An abstract method that determines if the service responds for the given
     * uri.
     */
    responds(uri) {
      _bfsKmTypes2.default.check.string(uri);
      throw new Error('Abstract method called!');
    }
  }

  exports.default = Service;

  },{"bfs-km-types":691}],264:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Service = exports.HubviewService = undefined;

  var _HubviewService = require('./HubviewService.js');

  var _HubviewService2 = _interopRequireDefault(_HubviewService);

  var _Service = require('./Service.js');

  var _Service2 = _interopRequireDefault(_Service);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.HubviewService = _HubviewService2.default;
  exports.Service = _Service2.default;

  },{"./HubviewService.js":262,"./Service.js":263}],265:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A method that formats a client version string (like "1.0.46.49.g54412416")
   * into the format for client versions expected by many backend services
   * ("104600049"), including Abba. The format is 1 digit for the major version, 1
   * digit for the minor version, 2 digits for the patch version and 5 digits for
   * the build version. Git revision is ignored.
   */
  const formatClientVersion = clientVersion => {
    _bfsKmTypes2.default.check.string(clientVersion);
    const components = ['0', '0', '00', '00000'];
    const parts = clientVersion.split('.');
    const maxPartsToProcess = Math.min(parts.length, components.length);
    for (let i = 0; i < maxPartsToProcess; i++) {
      const part = parts[i];
      if (part.length > components[i].length) {
        break;
      }
      if (!/^0|(?:[1-9][0-9]*)$/.test(part)) {
        break;
      }
      components[i] = `${components[i]}${part}`.slice(-components[i].length);
    }
    const formattedClientVersion = components.join('');
    return formattedClientVersion;
  };

  exports.default = formatClientVersion;

  },{"bfs-km-types":691}],266:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A method that returns the given date in the format expected by the
   * Programming Platform's services.
   */
  const getDateTime = date => {
    _bfsKmTypes2.default.check.type(date, Date);
    const y = date.getFullYear();
    const m = date.getMonth() + 1;
    const d = date.getDate();
    const h = date.getHours();
    const ys = `0000${y}`.slice(-4);
    const ms = `00${m}`.slice(-2);
    const ds = `00${d}`.slice(-2);
    const hs = `00${h}`.slice(-2);
    return `${ys}-${ms}-${ds}T${hs}:00:00`;
  };

  exports.default = getDateTime;

  },{"bfs-km-types":691}],267:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const getGridBreakPoint = (document, window) => {
    _bfsKmTypes2.default.check.type(document, HTMLDocument);
    _bfsKmTypes2.default.check.type(window, Window);
    const style = window.getComputedStyle(document.body, ':before');
    const value = style.getPropertyValue('content');
    return value.replace(/^"(.*)"$/, '$1');
  };

  exports.default = getGridBreakPoint;

  },{"bfs-km-types":691}],268:[function(require,module,exports){
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const getParsedJson = serialized => {
    try {
      return JSON.parse(serialized);
    } catch (error) {
      return null;
    }
  };

  exports.default = getParsedJson;

  },{}],269:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.rectIntersect = exports.getParsedJson = exports.getGridBreakPoint = exports.getDateTime = exports.formatClientVersion = undefined;

  var _formatClientVersion = require('./formatClientVersion.js');

  var _formatClientVersion2 = _interopRequireDefault(_formatClientVersion);

  var _getDateTime = require('./getDateTime.js');

  var _getDateTime2 = _interopRequireDefault(_getDateTime);

  var _getGridBreakPoint = require('./getGridBreakPoint.js');

  var _getGridBreakPoint2 = _interopRequireDefault(_getGridBreakPoint);

  var _getParsedJson = require('./getParsedJson');

  var _getParsedJson2 = _interopRequireDefault(_getParsedJson);

  var _rectIntersect = require('./rectIntersect.js');

  var _rectIntersect2 = _interopRequireDefault(_rectIntersect);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.formatClientVersion = _formatClientVersion2.default;
  exports.getDateTime = _getDateTime2.default;
  exports.getGridBreakPoint = _getGridBreakPoint2.default;
  exports.getParsedJson = _getParsedJson2.default;
  exports.rectIntersect = _rectIntersect2.default;

  },{"./formatClientVersion.js":265,"./getDateTime.js":266,"./getGridBreakPoint.js":267,"./getParsedJson":268,"./rectIntersect.js":270}],270:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const rectIntersect = (a, b) => {
    _bfsKmTypes2.default.check.object(a);
    _bfsKmTypes2.default.check.object(b);
    if (a.left >= a.right) {
      return false;
    }
    if (a.top >= a.bottom) {
      return false;
    }
    if (b.left >= b.right) {
      return false;
    }
    if (b.top >= b.bottom) {
      return false;
    }
    if (b.right <= a.left) {
      return false;
    }
    if (b.bottom <= a.top) {
      return false;
    }
    if (b.left >= a.right) {
      return false;
    }
    if (b.top >= a.bottom) {
      return false;
    }
    return true;
  };

  exports.default = rectIntersect;

  },{"bfs-km-types":691}],271:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Configuration = require('../Configuration.js');

  var _Configuration2 = _interopRequireDefault(_Configuration);

  var _DocumentFragment = require('../DocumentFragment.js');

  var _DocumentFragment2 = _interopRequireDefault(_DocumentFragment);

  var _Environment = require('../Environment.js');

  var _Environment2 = _interopRequireDefault(_Environment);

  var _EventDispatcher = require('../EventDispatcher.js');

  var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

  var _EventListener = require('../EventListener.js');

  var _EventListener2 = _interopRequireDefault(_EventListener);

  var _InteractionHandler = require('../InteractionHandler.js');

  var _InteractionHandler2 = _interopRequireDefault(_InteractionHandler);

  var _ServiceRouter = require('../ServiceRouter.js');

  var _ServiceRouter2 = _interopRequireDefault(_ServiceRouter);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * An abstract class that is responsible for maintaining a view component node
   * in the view component tree. This class automatically handles html document
   * construction, based on the state of the view component node and updates the
   * html document on state changes such as when a child view component is added
   * or removed.
   */
  class View {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window, schema) {
      if (this.constructor === View) {
        throw new Error('Instances may not be created from abstract classes!');
      }
      _bfsKmTypes2.default.check.object(model);
      _bfsKmTypes2.default.check.type(eventDispatcher, _EventDispatcher2.default);
      _bfsKmTypes2.default.check.type(serviceRouter, _ServiceRouter2.default);
      _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
      _bfsKmTypes2.default.check.type(environment, _Environment2.default);
      _bfsKmTypes2.default.check.type(document, HTMLDocument);
      _bfsKmTypes2.default.check.type(window, Window);
      _bfsKmTypes2.default.check.object(schema);
      if (!_bfsKmTypes2.default.conforms(model, schema, true)) {
        throw new Error();
      }
      this._model = _bfsKmTypes2.default.clone(model);
      this._eventDispatcher = eventDispatcher;
      this._serviceRouter = serviceRouter;
      this._configuration = configuration;
      this._environment = environment;
      this._eventListeners = [];
      this._parentView = null;
      this._childViews = [];
      this._interactionHandlers = [];
      this._documentFragment = new _DocumentFragment2.default(document, window, this._render());
      this._childContainerElement = this._documentFragment.find('[data-child-container]');
    }

    /**
     * A method that adds the given child view as a child to the view. The child
     * view will be attached if the view is already attached to a container
     * element.
     */
    addChild(childView) {
      _bfsKmTypes2.default.check.type(childView, View);
      childView._removeFromParent();
      this._childViews.push(childView);
      childView._parentView = this;
      if (this._documentFragment.isAttached()) {
        if (this._childContainerElement !== null) {
          childView.attach(this._childContainerElement);
        }
      }
      return this;
    }

    /**
     * A method that attaches the document fragment of the view to the given
     * container element. The method begins with each child view recursively and
     * is then applied to the view itself in order to minimise the number of dom
     * mutations reflected in the document.
     */
    attach(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      if (this._childContainerElement !== null) {
        for (let i = 0; i < this._childViews.length; i++) {
          this._childViews[i].attach(this._childContainerElement);
        }
      }
      this._documentFragment.attach(containerElement);
    }

    /**
     * A method that cleans up the instance in a way that should aid the garbage
     * collector.
     */
    destroy() {
      for (let i = 0; i < this._childViews.length; i++) {
        this._childViews[i].destroy();
      }
      for (let i = 0; i < this._eventListeners.length; i++) {
        this._eventDispatcher.unregister(this._eventListeners[i]);
      }
      for (let i = 0; i < this._interactionHandlers.length; i++) {
        this._interactionHandlers[i].detach();
      }
      this._documentFragment.destroy();
      this._model = null;
      this._eventDispatcher = null;
      this._serviceRouter = null;
      this._configuration = null;
      this._environment = null;
      this._eventListeners = null;
      this._parentView = null;
      this._childViews = null;
      this._interactionHandlers = null;
      this._documentFragment = null;
      this._childContainerElement = null;
    }

    /**
     * A method that detaches the document fragment of the view from its container
     * element. The method begins with the view itself and is then called
     * recursively for each child view in order to minimise the number of dom
     * mutations reflected in the document.
     */
    detach() {
      this._documentFragment.detach();
      for (let i = 0; i < this._childViews.length; i++) {
        this._childViews[i].detach();
      }
    }

    /**
     * A method that determines if the view handles a change to the given list of
     * arguments. The method recursively traverses the view component tree so that
     * views overriding this method can claim a certain namespace in the arguments
     * array.
     */
    handlesArgumentsChange(args) {
      _bfsKmTypes2.default.check.array(args);
      for (let i = 0; i < this._childViews.length; i++) {
        if (this._childViews[i].handlesArgumentsChange(args)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A method that determines if the view component has visible children. This
     * is needed since some concrete view component implementations manage their
     * own child views.
     */
    hasVisibleChildren() {
      return this._childViews.length > 0;
    }

    /**
     * Recursively traverses the view component tree and sums up the number of
     * content chunks that are deferred.
     */
    totalNrOfDeferredContentLoads() {
      let total = this._nrOfDeferredContentLoads();
      if (this.hasVisibleChildren()) {
        for (let i = 0; i < this._childViews.length; i++) {
          total += this._childViews[i].totalNrOfDeferredContentLoads();
        }
      }
      return total;
    }

    /**
     * A method that adds an event listener to the view. The given callback will
     * be called with the json data for the event when events of the given type
     * occur. This method automatically captures this so that concrete view
     * component implementations can just pass callback methods from their
     * prototype.
     */
    _addEventListener(type, callback) {
      _bfsKmTypes2.default.check.string(type);
      _bfsKmTypes2.default.check.function(callback);
      const eventListener = new _EventListener2.default(type, callback, this);
      this._eventListeners.push(eventListener);
      this._eventDispatcher.register(eventListener);
      return this;
    }

    /**
     * A method that adds an interaction handler to the view. The given callback
     * will be called with the given element as a parameter when events of the
     * given type occur on the given element. This method automatically captures
     * this so that concrete view component implementations can just pass callback
     * methods from their prototype.
     */
    _addInteractionHandler(element, type, callback) {
      _bfsKmTypes2.default.check.type(element, Element);
      _bfsKmTypes2.default.check.string(type);
      _bfsKmTypes2.default.check.function(callback);
      const interactionHandler = new _InteractionHandler2.default(element, type, callback, this);
      this._interactionHandlers.push(interactionHandler);
      interactionHandler.attach();
    }

    /**
     * A method that logs a UIImpression5 message.
     */
    _logUIImpression5(json) {return;
      _bfsKmTypes2.default.check.object(json);
      this._configuration.getCurrentState(configurationState => {
        const logInConsole = configurationState.getBooleanOr('logging/enabled', false);
        this._environment.logUIImpression5(json, logInConsole);
      });
    }

    /**
     * A method that logs a UIInteraction5 message.
     */
    _logUIInteraction5(json) {return;
      _bfsKmTypes2.default.check.object(json);
      this._configuration.getCurrentState(configurationState => {
        const logInConsole = configurationState.getBooleanOr('logging/enabled', false);
        this._environment.logUIInteraction5(json, logInConsole);
      });
    }

    /**
     * The amount of deferred content loads for this view component. Zero should
     * be the default. This should be overriden by concrete view component
     * implementations that defer loading of content chunks.
     */
    _nrOfDeferredContentLoads() {
      return 0;
    }

    /**
     * A method that removes any event listener that might be registered for the
     * given type and the given callback. This method automatically captures this
     * so that concrete view component implementations can just pass callback
     * methods from their prototype.
     */
    _removeEventListener(type, callback) {
      _bfsKmTypes2.default.check.string(type);
      _bfsKmTypes2.default.check.function(callback);
      for (let i = this._eventListeners.length - 1; i >= 0; i--) {
        const eventListener = this._eventListeners[i];
        if (eventListener.getType() === type) {
          if (eventListener.getCallback() === callback) {
            this._eventDispatcher.unregister(eventListener);
            this._eventListeners.splice(i, 1);
            break;
          }
        }
      }
    }

    /**
     * A method that removes the view component from its parent.
     */
    _removeFromParent() {
      if (this._parentView !== null) {
        this.detach();
        const index = this._parentView._childViews.indexOf(this);
        if (index !== -1) {
          this._parentView._childViews.splice(index, 1);
        }
        this._parentView = null;
      }
    }

    /**
     * An abstract method that creates the html string for the view component.
     */
    _render() {
      throw new Error('Abstract method called!');
    }

    /**
     * A method that sets up standard impression logging to happen when the view
     * component is partially visible on screen if the model has the standard
     * impression log in its model. The event listener will remove itself once it
     * has fired.
     */
    _setUpStandardImpressionLogging() {return;
      if ('logs' in this._model && 'impression' in this._model.logs) {
        this._addEventListener('periodic-update', function callback(json) {
          _bfsKmTypes2.default.check.object(json);
          if (this._documentFragment.isPartiallyVisible()) {
            this._logUIImpression5(this._model.logs.impression);
            this._removeEventListener('periodic-update', callback);
          }
        });
      }
    }
  }

  exports.default = View;

  },{"../Configuration.js":232,"../DocumentFragment.js":234,"../Environment.js":235,"../EventDispatcher.js":236,"../EventListener.js":237,"../InteractionHandler.js":238,"../ServiceRouter.js":241,"bfs-km-types":691}],272:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for an album. The card provides
   * playback overlay controls as long as the "link" attribute is not explicitly
   * set to true. The metadata may be positioned to the right of the card by
   * explicitly setting the "horizontal" attribute to true. If the "image"
   * attribute is absent, a placeholder image is shown.
   */
  class CardAlbum extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._environment.addToLiveCache(this._model);
    }

    _render() {
      const configurationState = this._configuration.getDefaultState();
      const data = {};
      if ('artists' in this._model) {
        data.subtitleLinks = this._model.artists.map(artist => {
          return {
            name: artist.name,
            uri: artist.uri
          };
        });
      }
      if ('horizontal' in this._model) {
        data.horizontal = this._model.horizontal;
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      data.title = this._model.name;
      data.uri = this._model.uri;
      if (configurationState.getBooleanOr('style/small-cards', false)) {
        data.playButtonOnly = true;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = CardAlbum;

  },{"../View.js":271,"./schema.json":273,"./template.hbs":274,"bfs-km-types":691}],273:[function(require,module,exports){
  module.exports={
    "artists?":
    [
      {
        "name": "",
        "uri": ""
      }
    ],
    "horizontal?": false,
    "image?": "",
    "link?": false,
    "logs?":
    {
      "addToCollection?": {},
      "impression?": {},
      "navigateToAlbum?": {},
      "navigateToArtist?": {},
      "openContextMenu?": {},
      "removeFromCollection?": {},
      "startPlayback?": {},
      "stopPlayback?": {}
    },
    "name": "",
    "uri": ""
  }

  },{}],274:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/cards/card-horizontal.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/card-horizontal.hbs', partial$0);
  var partial$1 = require('../../../../glue/templates/cards/card.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/card.hbs', partial$1);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["../../../../glue/templates/cards/card-horizontal.hbs"],depth0,{"name":"../../../../glue/templates/cards/card-horizontal.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"3":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["../../../../glue/templates/cards/card.hbs"],depth0,{"name":"../../../../glue/templates/cards/card.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.horizontal : depth0),{"name":"if","hash":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"data":data})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"../../../../glue/templates/cards/card.hbs":168,"hbsfy/runtime":745}],275:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for an artist. The card provides
   * playback overlay controls as long as the "link" attribute is not explicitly
   * set to true. The metadata may be positioned to the right of the card by
   * explicitly setting the "horizontal" attribute to true. If the "image"
   * attribute is absent, a placeholder image is shown.
   */
  class CardArtist extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._environment.addToLiveCache(this._model);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const configurationState = this._configuration.getDefaultState();
      const data = {};
      if ('horizontal' in this._model) {
        data.horizontal = this._model.horizontal;
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      data.title = this._model.name;
      data.uri = this._model.uri;
      if (configurationState.getBooleanOr('style/small-cards', false)) {
        data.playButtonOnly = true;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = CardArtist;

  },{"../View.js":271,"./schema.json":276,"./template.hbs":277,"bfs-km-types":691}],276:[function(require,module,exports){
  module.exports={
    "horizontal?": false,
    "image?": "",
    "link?": false,
    "logs?":
    {
      "impression?": {},
      "navigateToArtist?": {},
      "startPlayback?": {},
      "stopPlayback?": {}
    },
    "name": "",
    "uri": ""
  }

  },{}],277:[function(require,module,exports){
  arguments[4][274][0].apply(exports,arguments)
  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"../../../../glue/templates/cards/card.hbs":168,"dup":274,"hbsfy/runtime":745}],278:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for a chart.
   * The metadata may be positioned to the right of the card by
   * explicitly setting the "horizontal" attribute to true. If the "image"
   * attribute is absent, a placeholder image is shown.
   */
  class CardChart extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._environment.addToLiveCache(this._model);
    }

    /**
     * A method that creates the html string for the view. The backend sends empty
     * strings to indicate that info fields should be shown. Glue templates
     * interpret info fields with empty strings as being absent so we output zero
     * width spaces for info fields with empty strings.
     */
    _render() {
      const configurationState = this._configuration.getDefaultState();
      const data = {};
      if ('description' in this._model) {
        if (this._model.description === '') {
          data.description = '\u200B';
        } else {
          data.description = this._model.description;
        }
      }
      if ('horizontal' in this._model) {
        data.horizontal = this._model.horizontal;
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      if ('meta' in this._model) {
        if (this._model.meta === '') {
          data.metadata = '\u200B';
        } else {
          data.metadata = this._model.meta;
        }
      }
      data.title = this._model.name;
      data.uri = this._model.uri;
      if (configurationState.getBooleanOr('style/small-cards', false)) {
        data.playButtonOnly = true;
        delete data.description;
        delete data.metadata;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = CardChart;

  },{"../View.js":271,"./schema.json":279,"./template.hbs":280,"bfs-km-types":691}],279:[function(require,module,exports){
  module.exports={
    "description?": "",
    "horizontal?": false,
    "image?": "",
    "link?": false,
    "logs?":
    {
      "impression?": {},
      "navigateToChart?": {}
    },
    "meta?": "",
    "name": "",
    "uri": ""
  }

  },{}],280:[function(require,module,exports){
  arguments[4][274][0].apply(exports,arguments)
  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"../../../../glue/templates/cards/card.hbs":168,"dup":274,"hbsfy/runtime":745}],281:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for an episode. The card provides
   * playback overlay controls as long as the "link" attribute is not explicitly
   * set to true. The metadata may be positioned to the right of the card by
   * explicitly setting the "horizontal" attribute to true. If the "image"
   * attribute is absent, a placeholder image is shown. The cover image will be
   * square as long as the "wideImage" attribute is not explicitly set to true.
   */
  class CardEpisode extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._environment.addToLiveCache(this._model);
    }

    /**
     * A method that creates the html string for the view. The backend sends empty
     * strings to indicate that info fields should be shown. Glue templates
     * interpret info fields with empty strings as being absent so we output zero
     * width spaces for info fields with empty strings.
     */
    _render() {
      const configurationState = this._configuration.getDefaultState();
      const data = {};
      if ('horizontal' in this._model) {
        data.horizontal = this._model.horizontal;
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      if ('meta' in this._model) {
        if (this._model.meta === '') {
          data.metadata = '\u200B';
        } else {
          data.metadata = this._model.meta;
        }
      }
      if (this._model.wideImage) {
        data.isVideo = true;
      }
      data.title = this._model.name;
      data.uri = this._model.uri;
      data.description = this._model.description;
      if (configurationState.getBooleanOr('style/small-cards', false)) {
        data.playButtonOnly = true;
        delete data.title;
        delete data.metadata;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = CardEpisode;

  },{"../View.js":271,"./schema.json":282,"./template.hbs":283,"bfs-km-types":691}],282:[function(require,module,exports){
  module.exports={
    "horizontal?": false,
    "image?": "",
    "link?": false,
    "logs?":
    {
      "impression?": {},
      "startPlayback?": {}
    },
    "meta?": "",
    "name": "",
    "uri": "",
    "description?": "",
    "wideImage?": false
  }

  },{}],283:[function(require,module,exports){
  arguments[4][274][0].apply(exports,arguments)
  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"../../../../glue/templates/cards/card.hbs":168,"dup":274,"hbsfy/runtime":745}],284:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for a link. In difference to the other
   * cards, this view component positions the "title" attribute over the image. If
   * the "cols" attribute is present, the height of the view component is computed
   * from the width with respect to the value of the "cols" attribute. If the
   * attribute is absent, the component uses a fixed height.
   */
  class CardLink extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      if ('cols' in this._model) {
        data.cols = this._model.cols;
      }
      data.imageUrl = this._model.image;
      data.title = this._model.title;
      data.uri = this._model.uri;
      return (0, _template2.default)(data);
    }
  }

  exports.default = CardLink;

  },{"../View.js":271,"./schema.json":285,"./template.hbs":286,"bfs-km-types":691}],285:[function(require,module,exports){
  module.exports={
    "cols?" : 0,
    "image": "",
    "logs?":
    {
      "impression?": {},
      "navigateToLink?": {}
    },
    "title": "",
    "uri": ""
  }

  },{}],286:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/genre-card.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/genre-card.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["../../../../glue/templates/genre-card.hbs"],depth0,{"name":"../../../../glue/templates/genre-card.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/genre-card.hbs":179,"hbsfy/runtime":745}],287:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for a playlist. The card provides
   * playback overlay controls as long as the "link" attribute is not explicitly
   * set to true. The metadata may be positioned to the right of the card by
   * explicitly setting the "horizontal" attribute to true. If the "image"
   * attribute is absent, a placeholder image is shown.
   */
  class CardPlaylist extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._environment.addToLiveCache(this._model);
    }

    /**
     * A method that creates the html string for the view. The backend sends empty
     * strings to indicate that info fields should be shown. Glue templates
     * interpret info fields with empty strings as being absent so we output zero
     * width spaces for info fields with empty strings.
     */
    _render() {
      const configurationState = this._configuration.getDefaultState();
      const data = {};
      if ('description' in this._model) {
        if (this._model.description === '') {
          data.description = '\u200B';
        } else {
          data.description = this._model.description;
        }
      }
      if ('horizontal' in this._model) {
        data.horizontal = this._model.horizontal;
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      if ('meta' in this._model) {
        if (this._model.meta === '') {
          data.metadata = '\u200B';
        } else {
          data.metadata = this._model.meta;
        }
      }
      data.title = this._model.name;
      data.uri = this._model.uri;
      if (configurationState.getBooleanOr('style/small-cards', false)) {
        data.playButtonOnly = true;
        delete data.description;
        delete data.metadata;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = CardPlaylist;

  },{"../View.js":271,"./schema.json":288,"./template.hbs":289,"bfs-km-types":691}],288:[function(require,module,exports){
  module.exports={
    "description?": "",
    "horizontal?": false,
    "image?": "",
    "link?": false,
    "logs?":
    {
      "followPlaylist?": {},
      "impression?": {},
      "navigateToPlaylist?": {},
      "openContextMenu?": {},
      "startPlayback?": {},
      "stopPlayback?": {},
      "unfollowPlaylist?": {}
    },
    "meta?": "",
    "name": "",
    "uri": ""
  }

  },{}],289:[function(require,module,exports){
  arguments[4][274][0].apply(exports,arguments)
  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"../../../../glue/templates/cards/card.hbs":168,"dup":274,"hbsfy/runtime":745}],290:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for a profile. The metadata may be
   * positioned to the right of the card by explicitly setting the "horizontal"
   * attribute to true. If the "image" attribute is absent, a placeholder image is
   * shown.
   */
  class CardProfile extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._environment.addToLiveCache(this._model);
    }

    /**
     * A method that creates the html string for the view. The backend sends empty
     * strings to indicate that info fields should be shown. Glue templates
     * interpret info fields with empty strings as being absent so we output zero
     * width spaces for info fields with empty strings.
     */
    _render() {
      const configurationState = this._configuration.getDefaultState();
      const data = {};
      if ('horizontal' in this._model) {
        data.horizontal = this._model.horizontal;
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      if ('meta' in this._model) {
        if (this._model.meta === '') {
          data.metadata = '\u200B';
        } else {
          data.metadata = this._model.meta;
        }
      }
      data.title = this._model.name;
      data.uri = this._model.uri;
      if (configurationState.getBooleanOr('style/small-cards', false)) {
        data.playButtonOnly = true;
        delete data.metadata;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = CardProfile;

  },{"../View.js":271,"./schema.json":291,"./template.hbs":292,"bfs-km-types":691}],291:[function(require,module,exports){
  module.exports={
    "horizontal?": false,
    "image?": "",
    "logs?":
    {
      "impression?": {},
      "navigateToProfile?": {}
    },
    "meta?": "",
    "name": "",
    "uri": ""
  }

  },{}],292:[function(require,module,exports){
  arguments[4][274][0].apply(exports,arguments)
  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"../../../../glue/templates/cards/card.hbs":168,"dup":274,"hbsfy/runtime":745}],293:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a card for a show. The metadata may be
   * positioned to the right of the card by explicitly setting the "horizontal"
   * attribute to true. If the "image" attribute is absent, a placeholder image is
   * shown.
   */
  class CardShow extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._environment.addToLiveCache(this._model);
    }

    /**
     * A method that creates the html string for the view. The backend sends empty
     * strings to indicate that info fields should be shown. Glue templates
     * interpret info fields with empty strings as being absent so we output zero
     * width spaces for info fields with empty strings.
     */
    _render() {
      const configurationState = this._configuration.getDefaultState();
      const data = {};
      if ('description' in this._model) {
        if (this._model.description === '') {
          data.description = '\u200B';
        } else {
          data.description = this._model.description;
        }
      }
      if ('horizontal' in this._model) {
        data.horizontal = this._model.horizontal;
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      if ('meta' in this._model) {
        if (this._model.meta === '') {
          data.metadata = '\u200B';
        } else {
          data.metadata = this._model.meta;
        }
      }
      data.playButtonOnly = false;
      data.title = this._model.name;
      data.uri = this._model.uri;

      if (configurationState.getBooleanOr('style/small-cards', false)) {
        delete data.description;
        delete data.metadata;
      }

      return (0, _template2.default)(data);
    }
  }

  exports.default = CardShow;

  },{"../View.js":271,"./schema.json":294,"./template.hbs":295,"bfs-km-types":691}],294:[function(require,module,exports){
  module.exports={
    "description?": "",
    "horizontal?": false,
    "image?": "",
    "logs?":
    {
      "impression?": {},
      "navigateToShow?": {},
      "startPlayback?": {},
      "stopPlayback?": {}
    },
    "meta?": "",
    "name": "",
    "uri": ""
  }

  },{}],295:[function(require,module,exports){
  arguments[4][274][0].apply(exports,arguments)
  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"../../../../glue/templates/cards/card.hbs":168,"dup":274,"hbsfy/runtime":745}],296:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a grid cell. The "large", "medium", "small"
   * and "xSmall" attributes control how many of the 12 columns in the glue grid
   * that should be spanned by the view component for different window sizes.
   */
  class Cell extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view. The "xSmall" size was
     * added after the other sizes, so if the model doesn't have it, the "small"
     * value is used instead.
     */
    _render() {
      const data = {};
      data.large = this._model.large;
      data.medium = this._model.medium;
      data.small = this._model.small;
      if ('xSmall' in this._model) {
        data.xSmall = this._model.xSmall;
      } else {
        data.xSmall = this._model.small;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = Cell;

  },{"../View.js":271,"./schema.json":297,"./template.hbs":298}],297:[function(require,module,exports){
  module.exports={
    "large": 0,
    "medium": 0,
    "small": 0,
    "xSmall?": 0
  }

  },{}],298:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<div class=\"crsl-item col-xs-"
      + alias4(((helper = (helper = helpers.xSmall || (depth0 != null ? depth0.xSmall : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"xSmall","hash":{},"data":data}) : helper)))
      + " col-sm-"
      + alias4(((helper = (helper = helpers.small || (depth0 != null ? depth0.small : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"small","hash":{},"data":data}) : helper)))
      + " col-md-"
      + alias4(((helper = (helper = helpers.medium || (depth0 != null ? depth0.medium : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"medium","hash":{},"data":data}) : helper)))
      + " col-lg-"
      + alias4(((helper = (helper = helpers.large || (depth0 != null ? depth0.large : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"large","hash":{},"data":data}) : helper)))
      + "\" data-child-container>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],299:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a container. The container component adds the
   * left and right gutters and should be the parent component of layout
   * controlling cells.
   */
  class Container extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      return (0, _template2.default)(data);
    }
  }

  exports.default = Container;

  },{"../View.js":271,"./schema.json":300,"./template.hbs":301}],300:[function(require,module,exports){
  module.exports={
    "logs?":
    {
      "impression?": {}
    }
  }

  },{}],301:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<div class=\"container bfs-container\">\n  <div class=\"row\" data-child-container>\n  </div>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],302:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a debug control panel. The view component is
   * positioned over any other content and provides tools, switches and overrides
   * that can aid development.
   */
  class DebugControls extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._overlayElement = this._documentFragment.find('[data-node="overlay"]');
      this._toggleElement = this._documentFragment.find('[data-node="toggle"]');
      this._reloadElement = this._documentFragment.find('[data-node="reload"]');
      this._controlsElement = this._documentFragment.find('[data-node="controls"]');
      this._appInfoElement = this._documentFragment.find('[data-node="appInfo"]');
      this._proxyEnabledSliderElement = this._documentFragment.find('[data-slider="proxyEnabledSlider"]');
      this._proxyPortCheckboxElement = this._documentFragment.find('[data-node="proxyPortCheckbox"]');
      this._proxyPortInputElement = this._documentFragment.find('[data-node="proxyPortInput"]');
      this._loggingEnabledSliderElement = this._documentFragment.find('[data-slider="loggingEnabledSlider"]');
      this._userCountryCheckboxElement = this._documentFragment.find('[data-node="userCountryCheckbox"]');
      this._userCountryInputElement = this._documentFragment.find('[data-node="userCountryInput"]');
      this._userLanguageCheckboxElement = this._documentFragment.find('[data-node="userLanguageCheckbox"]');
      this._userLanguageInputElement = this._documentFragment.find('[data-node="userLanguageInput"]');
      this._cachingEnabledSliderElement = this._documentFragment.find('[data-slider="cachingEnabledSlider"]');
      this._updateFormFromConfiguration();
      this._setUpEventRoutes();
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickCachingEnabledSliderElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      if (this._cachingEnabledSliderElement.classList.toggle('enabled')) {
        this._configuration.removeValue('caching/enabled');
      } else {
        this._configuration.storeValue('caching/enabled', false);
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickLoggingEnabledSliderElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      if (this._loggingEnabledSliderElement.classList.toggle('enabled')) {
        this._configuration.storeValue('logging/enabled', true);
      } else {
        this._configuration.removeValue('logging/enabled');
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickProxyEnabledSliderElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      if (this._proxyEnabledSliderElement.classList.toggle('enabled')) {
        this._configuration.storeValue('proxy/enabled', true);
      } else {
        this._configuration.removeValue('proxy/enabled');
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickProxyPortCheckboxElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      if (this._proxyPortCheckboxElement.checked) {
        this._proxyPortInputElement.disabled = false;
        this._configuration.storeValue('debug-controls/port-enabled', true);
        this._updateProxyPortFromInput();
      } else {
        this._proxyPortInputElement.disabled = true;
        this._configuration.removeValue('proxy/port');
        this._configuration.removeValue('debug-controls/port-enabled');
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickReloadElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      this._eventDispatcher.dispatch('reload-view', {});
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickToggleElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      if (this._controlsElement.classList.contains('hide')) {
        this._controlsElement.classList.remove('hide');
        this._configuration.storeValue('debug-controls/controls-visible', true);
      } else {
        this._controlsElement.classList.add('hide');
        this._configuration.removeValue('debug-controls/controls-visible');
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickUserCountryCheckboxElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      if (this._userCountryCheckboxElement.checked) {
        this._userCountryInputElement.disabled = false;
        this._configuration.storeValue('debug-controls/country-enabled', true);
        this._updateUserCountryFromInput();
      } else {
        this._userCountryInputElement.disabled = true;
        this._configuration.removeValue('user/country');
        this._configuration.removeValue('debug-controls/country-enabled');
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickUserLanguageCheckboxElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      if (this._userLanguageCheckboxElement.checked) {
        this._userLanguageInputElement.disabled = false;
        this._configuration.storeValue('debug-controls/language-enabled', true);
        this._updateUserLanguageFromInput();
      } else {
        this._userLanguageInputElement.disabled = true;
        this._configuration.removeValue('user/language');
        this._configuration.removeValue('debug-controls/language-enabled');
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onInputProxyPortInputElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      this._updateProxyPortFromInput();
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onInputUserCountryInputElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      this._updateUserCountryFromInput();
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onInputUserLanguageInputElement(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      this._updateUserLanguageFromInput();
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {
        caching: {
          id: 'cachingEnabledSlider'
        },
        logging: {
          id: 'loggingEnabledSlider'
        },
        proxy: {
          id: 'proxyEnabledSlider'
        }
      };
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      this._addInteractionHandler(this._toggleElement, 'click', this._onClickToggleElement);
      this._addInteractionHandler(this._reloadElement, 'click', this._onClickReloadElement);
      this._addInteractionHandler(this._proxyEnabledSliderElement, 'click', this._onClickProxyEnabledSliderElement);
      this._addInteractionHandler(this._proxyPortCheckboxElement, 'click', this._onClickProxyPortCheckboxElement);
      this._addInteractionHandler(this._proxyPortInputElement, 'input', this._onInputProxyPortInputElement);
      this._addInteractionHandler(this._loggingEnabledSliderElement, 'click', this._onClickLoggingEnabledSliderElement);
      this._addInteractionHandler(this._userCountryCheckboxElement, 'click', this._onClickUserCountryCheckboxElement);
      this._addInteractionHandler(this._userCountryInputElement, 'input', this._onInputUserCountryInputElement);
      this._addInteractionHandler(this._userLanguageCheckboxElement, 'click', this._onClickUserLanguageCheckboxElement);
      this._addInteractionHandler(this._userLanguageInputElement, 'input', this._onInputUserLanguageInputElement);
      this._addInteractionHandler(this._cachingEnabledSliderElement, 'click', this._onClickCachingEnabledSliderElement);
    }

    /**
     * A method that queries the configuration for its current state and updates
     * the form with the returned values.
     */
    _updateFormFromConfiguration() {
      this._appInfoElement.textContent = `Bookmark 0.0`;
      this._configuration.getCurrentState(state => {
        if (state.getBooleanOr('proxy/enabled', false)) {
          this._proxyEnabledSliderElement.classList.add('enabled');
        }
        if (state.hasNumber('proxy/port')) {
          const proxyPort = state.getNumber('proxy/port');
          this._proxyPortInputElement.value = `${proxyPort}`;
        }
        if (state.getBooleanOr('logging/enabled', false)) {
          this._loggingEnabledSliderElement.classList.add('enabled');
        }
        if (state.hasString('user/country')) {
          const userCountry = state.getString('user/country');
          this._userCountryInputElement.value = userCountry;
        }
        if (state.hasString('user/language')) {
          const userLanguage = state.getString('user/language');
          this._userLanguageInputElement.value = userLanguage;
        }
        if (state.getBooleanOr('debug-controls/port-enabled', false)) {
          this._proxyPortCheckboxElement.checked = true;
          this._proxyPortInputElement.disabled = false;
        }
        if (state.getBooleanOr('debug-controls/country-enabled', false)) {
          this._userCountryCheckboxElement.checked = true;
          this._userCountryInputElement.disabled = false;
        }
        if (state.getBooleanOr('debug-controls/language-enabled', false)) {
          this._userLanguageCheckboxElement.checked = true;
          this._userLanguageInputElement.disabled = false;
        }
        if (state.getBooleanOr('debug-controls/controls-visible', false)) {
          this._controlsElement.classList.remove('hide');
        }
        if (state.getBooleanOr('caching/enabled', true)) {
          this._cachingEnabledSliderElement.classList.add('enabled');
        }
      });
    }

    /**
     * A method that updates the proxy/port override from the value in the input
     * field.
     */
    _updateProxyPortFromInput() {
      const proxyPort = parseInt(this._proxyPortInputElement.value, 10);
      this._configuration.storeValue('proxy/port', proxyPort);
    }

    /**
     * A method that updates the user/country override from the value in the input
     * field.
     */
    _updateUserCountryFromInput() {
      const userCountry = this._userCountryInputElement.value;
      this._configuration.storeValue('user/country', userCountry);
    }

    /**
     * A method that updates the user/language override from the value in the
     * input field.
     */
    _updateUserLanguageFromInput() {
      const userLanguage = this._userLanguageInputElement.value;
      if (this._environment.isSupportedLocale(userLanguage)) {
        this._userLanguageInputElement.classList.remove('invalid');
        this._configuration.storeValue('user/language', userLanguage);
      } else {
        this._userLanguageInputElement.classList.add('invalid');
      }
    }
  }

  exports.default = DebugControls;

  },{"../View.js":271,"./schema.json":303,"./template.hbs":304,"bfs-km-types":691}],303:[function(require,module,exports){
  module.exports={

  }

  },{}],304:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/slider.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/slider.hbs', partial$0);
  var partial$1 = require('../../../../glue/templates/slider.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/slider.hbs', partial$1);
  var partial$2 = require('../../../../glue/templates/slider.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/slider.hbs', partial$2);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["../../../../glue/templates/slider.hbs"],depth0,{"name":"../../../../glue/templates/slider.hbs","data":data,"indent":"          ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<div class=\"bfs-debug-controls-overlay\" data-node=\"overlay\">\n  <div class=\"bfs-debug-controls-buttons\">\n    <span class=\"bfs-debug-controls-button spoticon-refresh-32\" data-node=\"reload\"></span>\n    <span class=\"bfs-debug-controls-button spoticon-gears-32\" data-node=\"toggle\"></span>\n  </div>\n  <div class=\"bfs-debug-controls-controls hide\" data-node=\"controls\">\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\" data-node=\"appInfo\"></h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Proxy</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Enable backend development on your local machine using the HTTP proxy.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.proxy : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input data-node=\"proxyPortCheckbox\" type=\"checkbox\" />\n      </div>\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Port:</p>\n      </div>\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input class=\"bfs-debug-controls-input\" data-node=\"proxyPortInput\" disabled=\"disabled\" type=\"text\" />\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Logging</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Log messages to the console instead of the logging endpoint.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.logging : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Caching</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Use the native response cache for Hermes requests. Disabling this will add a new cache entry for each request.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.caching : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Overrides</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Override certain user attributes to test regionalized content programming. The overrides are only active in this app.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input data-node=\"userCountryCheckbox\" type=\"checkbox\" />\n      </div>\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Country:</p>\n      </div>\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input class=\"bfs-debug-controls-input\" data-node=\"userCountryInput\" disabled=\"disabled\" type=\"text\" />\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input data-node=\"userLanguageCheckbox\" type=\"checkbox\" />\n      </div>\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Language:</p>\n      </div>\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input class=\"bfs-debug-controls-input\" data-node=\"userLanguageInput\" disabled=\"disabled\" type=\"text\" />\n      </div>\n    </div>\n\n  </div>\n</div>\n";
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/slider.hbs":197,"hbsfy/runtime":745}],305:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that can load data to display in its container only after
   * the view component is rendered.
   */
  class DeferredContainer extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._contentLoaded = false;
      this._pendingPageRequest = false;
    }

    /**
     * Extends attach method from View and loads content of the view if it was not
     * not loaded yet.
     */
    attach(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      super.attach(containerElement);
      this._loadContent();
    }

    /**
     * A method that loads the content of the view component.
     */
    _loadContent() {
      if (this._contentLoaded || this._pendingPageRequest) {
        return;
      }
      this._pendingPageRequest = true;
      this._serviceRouter.request(this._model.uri, view => {
        if (view === null) {
          this._contentLoaded = true;
          this._pendingPageRequest = false;
          return;
        }
        const childViews = view._childViews.slice();
        for (let i = 0; i < childViews.length; i++) {
          super.addChild(childViews[i]);
        }
        view.destroy();
        this._contentLoaded = true;
        this._pendingPageRequest = false;
        this._environment.updateSpotifyEventsIn(this._childContainerElement);
        this._eventDispatcher.dispatch('deferred-content-load', {});
      });
    }

    /**
     * The amount of deferred content loads for this single view
     */
    _nrOfDeferredContentLoads() {
      return 1;
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      return (0, _template2.default)(data);
    }
  }

  exports.default = DeferredContainer;

  },{"../View.js":271,"./schema.json":306,"./template.hbs":307,"bfs-km-types":691}],306:[function(require,module,exports){
  module.exports={
    "uri": ""
  }

  },{}],307:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<div data-child-container data-interaction-list>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],308:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const POST_MESSAGE_NAME = 'hub-embedded-resize';

  /**
   * A view component that renders an iframe.
   */
  class EmbeddedApp extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._mainContainerElement = this._documentFragment.find('div');
      this._iframeElement = this._documentFragment.find('iframe');
      this._origin = window.location.origin;
      this._hasBeenAttached = false;
      this._setUpEventRoutes();
    }

    /**
     * Extends attach method from View. It shows the view if it has been hidden
     * (when "detach" is called).
     */
    attach(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      if (!this._hasBeenAttached) {
        super.attach(containerElement);
        this._hasBeenAttached = true;
      }
      this._mainContainerElement.classList.remove('hide');
    }

    /**
     * A method that detaches the document fragment of the view from its container
     * element.
     */
    detach() {
      this._mainContainerElement.classList.add('hide');
    }

    /**
     * A method that is triggered when a message is sent to the window.
     */
    _onWindowMessage(data) {
      if (!_bfsKmTypes2.default.conforms(data, {
        height: 0,
        name: '',
        uri: ''
      })) {
        return;
      }
      if (data.name !== POST_MESSAGE_NAME) {
        return;
      }
      if (data.uri !== this._model.uri) {
        return;
      }
      const height = `${data.height}px`;
      this._iframeElement.height = height;
      this._iframeElement.style.height = height;
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.origin = this._origin;
      data.postMessageName = POST_MESSAGE_NAME;
      data.uri = this._model.uri;
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      this._addEventListener('window-message', this._onWindowMessage);
    }
  }

  exports.default = EmbeddedApp;

  },{"../View.js":271,"./schema.json":309,"./template.hbs":310,"bfs-km-types":691}],309:[function(require,module,exports){
  arguments[4][306][0].apply(exports,arguments)
  },{"dup":306}],310:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<div class=\"embedded-app-row hide\">\n  <iframe\n    src=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\"\n    class=\"embedded-app-iframe\"\n    data-embedded=\"true\"\n    data-origin=\""
      + alias4(((helper = (helper = helpers.origin || (depth0 != null ? depth0.origin : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"origin","hash":{},"data":data}) : helper)))
      + "\"\n    data-post-message-name=\""
      + alias4(((helper = (helper = helpers.postMessageName || (depth0 != null ? depth0.postMessageName : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"postMessageName","hash":{},"data":data}) : helper)))
      + "\">\n  </iframe>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],311:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a Glue error screen. The view component is
   * positioned over any other content and may be used to indicate that an error
   * occured. A default message is used when neither the "title" nor the
   * "subtitle" attributes are present in the model. The view component also
   * supports an optional call-to-action button.
   */
  class ErrorScreen extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.useDefaultError = true;
      if ('title' in this._model) {
        data.errorTitle = this._model.title;
        data.useDefaultError = false;
      }
      if ('subtitle' in this._model) {
        data.errorMessage = this._model.subtitle;
        data.useDefaultError = false;
      }
      if ('button' in this._model) {
        data.errorEscapeUrl = this._model.button.uri;
        data.errorEscapeMessage = this._model.button.title;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = ErrorScreen;

  },{"../View.js":271,"./schema.json":312,"./template.hbs":313}],312:[function(require,module,exports){
  module.exports={
    "button?":
    {
      "title": "",
      "uri": ""
    },
    "subtitle?": "",
    "title?": ""
  }

  },{}],313:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/error-and-offline.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/error-and-offline.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<div class=\"show-error-screen\">\n"
      + ((stack1 = container.invokePartial(partials["../../../../glue/templates/error-and-offline.hbs"],depth0,{"name":"../../../../glue/templates/error-and-offline.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</div>\n";
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/error-and-offline.hbs":176,"hbsfy/runtime":745}],314:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  var _getGridBreakPoint = require('../../utils/getGridBreakPoint.js');

  var _getGridBreakPoint2 = _interopRequireDefault(_getGridBreakPoint);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const INFINI_LOADING_THRESHOLD_PX = 800;

  /**
   * A view component that presents a grid of cells. The number of visible cells
   * may be controlled by the "layout" attribute in the model. The view component
   * also supports infini-loading when the "nextPage" attribute is present in the
   * model.
   */
  class Grid extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._getPixelsToBottomBelowScreen = () => {
        return document.body.scrollHeight - (window.scrollY + window.innerHeight);
      };
      this._getGridBreakPoint = () => {
        return (0, _getGridBreakPoint2.default)(document, window);
      };
      this._numberOfVisibleChildren = null;
      this._timesGridExpanded = 0;
      this._currentRows = this._getDefaultNumberOfVisibleRows();
      this._pendingPageRequest = false;
      this._setUpEventRoutes();
    }

    /**
     * Overridden because the number of visible children might be controlled by
     * the grid.
     */
    attach(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      if ('layout' in this._model) {
        this._updateVisibility();
        for (let i = 0; i < this._numberOfVisibleChildren; i++) {
          this._childViews[i].attach(this._childContainerElement);
        }
        this._documentFragment.attach(containerElement);
      } else {
        super.attach(containerElement);
      }
    }

    _getColsForCurrentBreakPoint() {
      if ('layout' in this._model) {
        const breakPoint = this._getGridBreakPoint();
        if (breakPoint === 'lg') {
          return this._model.layout.cols.large;
        }
        if (breakPoint === 'md') {
          return this._model.layout.cols.medium;
        }
        if (breakPoint === 'sm') {
          return this._model.layout.cols.small;
        }
        if ('xSmall' in this._model.layout.cols) {
          return this._model.layout.cols.xSmall;
        }
        return this._model.layout.cols.small;
      }
      return Infinity;
    }

    _getDefaultNumberOfVisibleRows() {
      if ('layout' in this._model) {
        return this._model.layout.rows;
      }
      return Infinity;
    }

    /**
     * A method that returns the maximum number of visible children.
     */
    _getMaximumNumberOfVisibleChildren() {
      return this._getColsForCurrentBreakPoint() * this._currentRows;
    }

    /**
     * A method that loads the next page for the grid.
     */
    _loadNextPage() {
      if ('nextPage' in this._model) {
        this._pendingPageRequest = true;
        this._serviceRouter.request(this._model.nextPage, view => {
          if (view !== null) {
            if (_bfsKmTypes2.default.is.type(view, Grid)) {
              const childViews = view._childViews.slice();
              for (let i = 0; i < childViews.length; i++) {
                this.addChild(childViews[i]);
              }
              if ('nextPage' in view._model && childViews.length > 0) {
                this._model.nextPage = view._model.nextPage;
              } else {
                delete this._model.nextPage;
              }
              view.destroy();
              this._pendingPageRequest = false;
              this._environment.updateSpotifyEventsIn(this._childContainerElement);
              this._maybeLoadNextPage();
            } else {
              view.destroy();
              delete this._model.nextPage;
              this._pendingPageRequest = false;
            }
          } else {
            delete this._model.nextPage;
            this._pendingPageRequest = false;
          }
        });
      }
    }

    /**
     * A method that loads the next page for the grid if the next page should be
     * loaded.
     */
    _maybeLoadNextPage() {
      if (this._documentFragment.isAttached()) {
        if (!this._pendingPageRequest) {
          const pixelsToBottomBelowScreen = this._getPixelsToBottomBelowScreen();
          if (pixelsToBottomBelowScreen < INFINI_LOADING_THRESHOLD_PX) {
            this._loadNextPage();
          }
        }
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onClickAll(json) {
      _bfsKmTypes2.default.check.object(json);
      if (json.id === this._model.id) {
        this._timesGridExpanded++;
        this._currentRows = Infinity;
        this._updateVisibility();
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onClickLess(json) {
      _bfsKmTypes2.default.check.object(json);
      if (json.id === this._model.id) {
        this._timesGridExpanded = 0;
        this._currentRows = this._getDefaultNumberOfVisibleRows();
        this._updateVisibility();
        this._eventDispatcher.dispatch('set-button-position', json);
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onClickMore(json) {
      _bfsKmTypes2.default.check.object(json);
      if (json.id === this._model.id) {
        this._timesGridExpanded++;
        this._currentRows += this._getDefaultNumberOfVisibleRows();
        this._updateVisibility();
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onRootViewUpdateLayout(json) {
      _bfsKmTypes2.default.check.object(json);
      this._updateVisibility();
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onRootViewUpdateLoad(json) {
      _bfsKmTypes2.default.check.object(json);
      this._maybeLoadNextPage();
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onWindowResize(json) {
      _bfsKmTypes2.default.check.object(json);
      this._updateVisibility();
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onWindowScroll(json) {
      _bfsKmTypes2.default.check.object(json);
      this._maybeLoadNextPage();
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      if ('layout' in this._model) {
        this._addEventListener('click-all', this._onClickAll);
        this._addEventListener('click-less', this._onClickLess);
        this._addEventListener('click-more', this._onClickMore);
        this._addEventListener('root-view-update', this._onRootViewUpdateLayout);
        this._addEventListener('window-resize', this._onWindowResize);
      }
      if ('nextPage' in this._model) {
        this._addEventListener('window-scroll', this._onWindowScroll);
        this._addEventListener('root-view-update', this._onRootViewUpdateLoad);
      }
    }

    /**
     * A method that updates the visibility of the grid cells based on the current
     * layout settings.
     */
    _updateVisibility() {
      const visible = Math.min(this._getMaximumNumberOfVisibleChildren(), this._childViews.length);
      if (this._numberOfVisibleChildren !== visible) {
        const hidden = this._childViews.length - visible;
        for (let i = 0; i < visible; i++) {
          this._childViews[i].attach(this._childContainerElement);
        }
        for (let i = visible; i < this._childViews.length; i++) {
          this._childViews[i].detach();
        }
        this._environment.updateSpotifyEventsIn(this._childContainerElement);
        this._numberOfVisibleChildren = visible;
        this._eventDispatcher.dispatch('grid-update', {
          id: this._model.id,
          expansions: this._timesGridExpanded,
          hidden: hidden,
          visible: visible
        });
      }
    }
  }

  exports.default = Grid;

  },{"../../utils/getGridBreakPoint.js":267,"../View.js":271,"./schema.json":315,"./template.hbs":316,"bfs-km-types":691}],315:[function(require,module,exports){
  module.exports={
    "id": "",
    "layout?":
    {
      "cols":
      {
        "large": 0,
        "medium": 0,
        "small": 0,
        "xSmall?": 0
      },
      "rows": 0
    },
    "nextPage?": ""
  }

  },{}],316:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<div class=\"row standard-grid\" data-child-container data-interaction-list data-interaction-context=\"grid\">\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],317:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _Placeholder = require('../../Placeholder.js');

  var _Placeholder2 = _interopRequireDefault(_Placeholder);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a header for the browse view. The view
   * component provides a container for the home page take over and creates a tab
   * bar from the "tabs" attribute in the model. Spotify events doesn't support
   * having mutliple navbars in the document and the glue header doesn't support
   * the home page take over. For these reasons, we use placeholders to switch out
   * one of the navbars from the document.
   */
  class HeaderBrowse extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._hptoElement = this._documentFragment.find('[data-node="hpto"]');
      this._hptoWrapperElement = this._documentFragment.find('[data-node="hpto-wrapper"]');
      this._headerElement = this._documentFragment.find('[data-node="header"]');
      this._navbarElement = this._documentFragment.find('[data-node="navbar"]');
      this._navbarPlaceholder = new _Placeholder2.default(document, this._navbarElement);
      this._headerPlaceholder = new _Placeholder2.default(document, this._headerElement);
      this._onHptoRendered = () => {
        this._hptoWrapperElement.classList.remove('hide');
        this._headerPlaceholder.showPlaceholderElement();
        this._navbarPlaceholder.showTargetElement();
        this._environment.updateSpotifyEventsIn(this._navbarElement);
        this._environment.updateSpotifyEventsIn(this._hptoElement);
      };
      this._onHptoHidden = () => {
        this._hptoWrapperElement.classList.add('hide');
        this._headerPlaceholder.showTargetElement();
        this._navbarPlaceholder.showPlaceholderElement();
        this._environment.updateSpotifyEventsIn(this._headerElement);
      };
      this._environment.createHomePageTakeOverFor(this._hptoElement, this._onHptoRendered, this._onHptoHidden);
      this._setUpEventRoutes();
      this._window = window;
    }

    /**
     * A method that cleans up the instance in a way that should aid the garbage
     * collector.
     */
    destroy() {
      this._environment.destroyHomePageTakeOver(this._onHptoRendered, this._onHptoHidden);
      super.destroy();
    }

    /**
     * A method that determines if the view handles a change to the given list of
     * arguments.
     */
    handlesArgumentsChange(argumentsList) {
      _bfsKmTypes2.default.check.array(argumentsList);
      if (argumentsList.length > 0) {
        let tabIdToShow = this._model.tabs[0].id;
        for (let i = 1; i < this._model.tabs.length; i++) {
          if (this._model.tabs[i].id === argumentsList[0]) {
            tabIdToShow = this._model.tabs[i].id;
            break;
          }
        }
        this._eventDispatcher.dispatch('show-tab', {
          id: tabIdToShow
        });
        this._window.scrollTo(0, 0);
        return true;
      }
      return false;
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onRootViewUpdate(json) {
      _bfsKmTypes2.default.check.object(json);
      this._eventDispatcher.dispatch('show-tab', {
        id: this._model.tab
      });
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      const navBar = {
        'nav-items': this._model.tabs.map(tab => {
          return {
            id: tab.uri,
            name: tab.title,
            url: tab.uri
          };
        })
      };
      data.pageHeader = {
        background: {
          type: 'color'
        },
        navBar: navBar,
        title: this._model.title
      };
      data.navBar = navBar;
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      this._addEventListener('root-view-update', this._onRootViewUpdate);
    }
  }

  exports.default = HeaderBrowse;

  },{"../../Placeholder.js":239,"../View.js":271,"./schema.json":318,"./template.hbs":319,"bfs-km-types":691}],318:[function(require,module,exports){
  module.exports={
    "logs?":
    {
      "impression?": {}
    },
    "tab": "",
    "tabs":
    [
      {
        "id": "",
        "title": "",
        "uri": ""
      }
    ],
    "title": ""
  }

  },{}],319:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/headers/page-header.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/headers/page-header.hbs', partial$0);
  var partial$1 = require('../../../../glue/templates/navbar.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/navbar.hbs', partial$1);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<header class=\"app-header\" data-interaction-context=\"header\">\n  <div data-node=\"hpto-wrapper\" class=\"hide\">\n    <div class=\"hpto-top-bar\"></div>\n    <div data-node=\"hpto\" class=\"hpto-container\"></div>\n  </div>\n  <div data-node=\"header\">\n"
      + ((stack1 = container.invokePartial(partials["../../../../glue/templates/headers/page-header.hbs"],(depth0 != null ? depth0.pageHeader : depth0),{"name":"../../../../glue/templates/headers/page-header.hbs","data":data,"indent":"      ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "  </div>\n  <div data-node=\"navbar\" data-interaction-context=\"navbar\">\n"
      + ((stack1 = container.invokePartial(partials["../../../../glue/templates/navbar.hbs"],(depth0 != null ? depth0.navBar : depth0),{"name":"../../../../glue/templates/navbar.hbs","data":data,"indent":"    ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "  </div>\n</header>\n<div class=\"app-content container bfs-container\" data-interaction-context=\"body\">\n  <div class=\"row\" data-child-container>\n  </div>\n</div>\n";
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/headers/page-header.hbs":194,"../../../../glue/templates/navbar.hbs":196,"hbsfy/runtime":745}],320:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a header for the genre view. The view
   * component will show a cover image when the "image" attribute is present in
   * the model and supports showing a subtitle when the "subtitle" attribute is
   * present in the model.
   */
  class HeaderGenre extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._setUpEventRoutes();
    }

    _render() {
      const data = {};
      const pageHeader = {
        title: this._model.title
      };
      if ('image' in this._model) {
        pageHeader.background = {
          imageUrl: this._model.image,
          type: 'image'
        };
        pageHeader.useResponsiveHeightLarge = true;
      } else {
        pageHeader.background = {
          type: 'color'
        };
      }
      if ('subtitle' in this._model) {
        pageHeader.description = this._model.subtitle;
      }
      data.pageHeader = pageHeader;
      return (0, _template2.default)(data);
    }

    _setUpEventRoutes() {
      this._setUpStandardImpressionLogging();
    }
  }

  exports.default = HeaderGenre;

  },{"../View.js":271,"./schema.json":321,"./template.hbs":322}],321:[function(require,module,exports){
  module.exports={
    "image?": "",
    "logs?":
    {
      "impression?": {}
    },
    "subtitle?": "",
    "title": ""
  }

  },{}],322:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/headers/page-header.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/headers/page-header.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<div class=\"app-header\" data-node=\"header\">\n"
      + ((stack1 = container.invokePartial(partials["../../../../glue/templates/headers/page-header.hbs"],(depth0 != null ? depth0.pageHeader : depth0),{"name":"../../../../glue/templates/headers/page-header.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</div>\n<div class=\"app-content container\">\n  <div class=\"row\" data-child-container>\n  </div>\n</div>\n";
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/headers/page-header.hbs":194,"hbsfy/runtime":745}],323:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.View = exports.Tracklist = exports.Tab = exports.SectionGridButtons = exports.SectionGrid = exports.SectionCarousel = exports.Section = exports.Puff = exports.OfflineScreen = exports.ListGroup = exports.ItemConcert = exports.ItemAlbum = exports.HeaderGenre = exports.HeaderBrowse = exports.Grid = exports.ErrorScreen = exports.EmbeddedApp = exports.DeferredContainer = exports.DebugControls = exports.Container = exports.Cell = exports.CardShow = exports.CardProfile = exports.CardPlaylist = exports.CardLink = exports.CardEpisode = exports.CardChart = exports.CardArtist = exports.CardAlbum = undefined;

  var _CardAlbum = require('./card-album/CardAlbum.js');

  var _CardAlbum2 = _interopRequireDefault(_CardAlbum);

  var _CardArtist = require('./card-artist/CardArtist.js');

  var _CardArtist2 = _interopRequireDefault(_CardArtist);

  var _CardChart = require('./card-chart/CardChart.js');

  var _CardChart2 = _interopRequireDefault(_CardChart);

  var _CardEpisode = require('./card-episode/CardEpisode.js');

  var _CardEpisode2 = _interopRequireDefault(_CardEpisode);

  var _CardLink = require('./card-link/CardLink.js');

  var _CardLink2 = _interopRequireDefault(_CardLink);

  var _CardPlaylist = require('./card-playlist/CardPlaylist.js');

  var _CardPlaylist2 = _interopRequireDefault(_CardPlaylist);

  var _CardProfile = require('./card-profile/CardProfile.js');

  var _CardProfile2 = _interopRequireDefault(_CardProfile);

  var _CardShow = require('./card-show/CardShow.js');

  var _CardShow2 = _interopRequireDefault(_CardShow);

  var _Cell = require('./cell/Cell.js');

  var _Cell2 = _interopRequireDefault(_Cell);

  var _Container = require('./container/Container.js');

  var _Container2 = _interopRequireDefault(_Container);

  var _DebugControls = require('./debug-controls/DebugControls.js');

  var _DebugControls2 = _interopRequireDefault(_DebugControls);

  var _DeferredContainer = require('./deferred-container/DeferredContainer.js');

  var _DeferredContainer2 = _interopRequireDefault(_DeferredContainer);

  var _EmbeddedApp = require('./embedded-app/EmbeddedApp.js');

  var _EmbeddedApp2 = _interopRequireDefault(_EmbeddedApp);

  var _ErrorScreen = require('./error-screen/ErrorScreen.js');

  var _ErrorScreen2 = _interopRequireDefault(_ErrorScreen);

  var _Grid = require('./grid/Grid.js');

  var _Grid2 = _interopRequireDefault(_Grid);

  var _HeaderBrowse = require('./header-browse/HeaderBrowse.js');

  var _HeaderBrowse2 = _interopRequireDefault(_HeaderBrowse);

  var _HeaderGenre = require('./header-genre/HeaderGenre.js');

  var _HeaderGenre2 = _interopRequireDefault(_HeaderGenre);

  var _ItemAlbum = require('./item-album/ItemAlbum.js');

  var _ItemAlbum2 = _interopRequireDefault(_ItemAlbum);

  var _ItemConcert = require('./item-concert/ItemConcert.js');

  var _ItemConcert2 = _interopRequireDefault(_ItemConcert);

  var _ListGroup = require('./list-group/ListGroup.js');

  var _ListGroup2 = _interopRequireDefault(_ListGroup);

  var _OfflineScreen = require('./offline-screen/OfflineScreen.js');

  var _OfflineScreen2 = _interopRequireDefault(_OfflineScreen);

  var _Puff = require('./puff/Puff.js');

  var _Puff2 = _interopRequireDefault(_Puff);

  var _Section = require('./section/Section.js');

  var _Section2 = _interopRequireDefault(_Section);

  var _SectionCarousel = require('./section-carousel/SectionCarousel.js');

  var _SectionCarousel2 = _interopRequireDefault(_SectionCarousel);

  var _SectionGrid = require('./section-grid/SectionGrid.js');

  var _SectionGrid2 = _interopRequireDefault(_SectionGrid);

  var _SectionGridButtons = require('./section-grid-buttons/SectionGridButtons.js');

  var _SectionGridButtons2 = _interopRequireDefault(_SectionGridButtons);

  var _Tab = require('./tab/Tab.js');

  var _Tab2 = _interopRequireDefault(_Tab);

  var _Tracklist = require('./tracklist/Tracklist.js');

  var _Tracklist2 = _interopRequireDefault(_Tracklist);

  var _View = require('./View.js');

  var _View2 = _interopRequireDefault(_View);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.CardAlbum = _CardAlbum2.default;
  exports.CardArtist = _CardArtist2.default;
  exports.CardChart = _CardChart2.default;
  exports.CardEpisode = _CardEpisode2.default;
  exports.CardLink = _CardLink2.default;
  exports.CardPlaylist = _CardPlaylist2.default;
  exports.CardProfile = _CardProfile2.default;
  exports.CardShow = _CardShow2.default;
  exports.Cell = _Cell2.default;
  exports.Container = _Container2.default;
  exports.DebugControls = _DebugControls2.default;
  exports.DeferredContainer = _DeferredContainer2.default;
  exports.EmbeddedApp = _EmbeddedApp2.default;
  exports.ErrorScreen = _ErrorScreen2.default;
  exports.Grid = _Grid2.default;
  exports.HeaderBrowse = _HeaderBrowse2.default;
  exports.HeaderGenre = _HeaderGenre2.default;
  exports.ItemAlbum = _ItemAlbum2.default;
  exports.ItemConcert = _ItemConcert2.default;
  exports.ListGroup = _ListGroup2.default;
  exports.OfflineScreen = _OfflineScreen2.default;
  exports.Puff = _Puff2.default;
  exports.Section = _Section2.default;
  exports.SectionCarousel = _SectionCarousel2.default;
  exports.SectionGrid = _SectionGrid2.default;
  exports.SectionGridButtons = _SectionGridButtons2.default;
  exports.Tab = _Tab2.default;
  exports.Tracklist = _Tracklist2.default;
  exports.View = _View2.default;

  },{"./View.js":271,"./card-album/CardAlbum.js":272,"./card-artist/CardArtist.js":275,"./card-chart/CardChart.js":278,"./card-episode/CardEpisode.js":281,"./card-link/CardLink.js":284,"./card-playlist/CardPlaylist.js":287,"./card-profile/CardProfile.js":290,"./card-show/CardShow.js":293,"./cell/Cell.js":296,"./container/Container.js":299,"./debug-controls/DebugControls.js":302,"./deferred-container/DeferredContainer.js":305,"./embedded-app/EmbeddedApp.js":308,"./error-screen/ErrorScreen.js":311,"./grid/Grid.js":314,"./header-browse/HeaderBrowse.js":317,"./header-genre/HeaderGenre.js":320,"./item-album/ItemAlbum.js":324,"./item-concert/ItemConcert.js":327,"./list-group/ListGroup.js":330,"./offline-screen/OfflineScreen.js":333,"./puff/Puff.js":336,"./section-carousel/SectionCarousel.js":339,"./section-grid-buttons/SectionGridButtons.js":342,"./section-grid/SectionGrid.js":345,"./section/Section.js":348,"./tab/Tab.js":351,"./tracklist/Tracklist.js":354}],324:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a small horizontal album card that provides
   * playback overlay controls. If the "image" attribute is absent in the model, a
   * placeholder image is shown.
   */
  class ItemAlbum extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      if ('artists' in this._model) {
        data.subtitleLinks = this._model.artists.map(artist => {
          return {
            name: artist.name,
            uri: artist.uri
          };
        });
      }
      if ('image' in this._model) {
        data.imageUrl = this._model.image;
      }
      data.title = this._model.name;
      data.uri = this._model.uri;
      return (0, _template2.default)(data);
    }
  }

  exports.default = ItemAlbum;

  },{"../View.js":271,"./schema.json":325,"./template.hbs":326}],325:[function(require,module,exports){
  module.exports={
    "artists?":
    [
      {
        "name": "",
        "uri": ""
      }
    ],
    "image?": "",
    "name": "",
    "uri": ""
  }

  },{}],326:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/cards/card-horizontal.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/card-horizontal.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["../../../../glue/templates/cards/card-horizontal.hbs"],depth0,{"name":"../../../../glue/templates/cards/card-horizontal.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/cards/card-horizontal.hbs":166,"hbsfy/runtime":745}],327:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents an item for a concert. The view component
   * requires most of the attributes to be present and has no special behaviour.
   */
  class ItemConcert extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.date = {
        day: this._model.date.day,
        month: this._model.date.month
      };
      data.name = this._model.name;
      data.uri = this._model.uri;
      data.venue = {
        city: this._model.venue.city,
        name: this._model.venue.name
      };
      return (0, _template2.default)(data);
    }
  }

  exports.default = ItemConcert;

  },{"../View.js":271,"./schema.json":328,"./template.hbs":329,"bfs-km-types":691}],328:[function(require,module,exports){
  module.exports={
    "date":
    {
      "day": "",
      "month": ""
    },
    "logs?":
    {
      "impression?": {},
      "navigateToConcert?": {}
    },
    "name": "",
    "uri": "",
    "venue":
    {
      "city": "",
      "name": ""
    }
  }

  },{}],329:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "      <div class=\"bfs-calendar-icon\">\n        <div class=\"bfs-calendar-month\">"
      + alias4(((helper = (helper = helpers.month || (depth0 != null ? depth0.month : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"month","hash":{},"data":data}) : helper)))
      + "</div>\n        <div class=\"bfs-calendar-day\">"
      + alias4(((helper = (helper = helpers.day || (depth0 != null ? depth0.day : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"day","hash":{},"data":data}) : helper)))
      + "</div>\n      </div>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "      <div class=\"bfs-concert-info-venue\">"
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + " &#x2022; "
      + alias4(((helper = (helper = helpers.city || (depth0 != null ? depth0.city : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"city","hash":{},"data":data}) : helper)))
      + "</div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<div class=\"bfs-concert\">\n  <div class=\"bfs-concert-date\">\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.date : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n  <div class=\"bfs-concert-info\">\n    <div class=\"bfs-concert-info-name\">\n      <a class=\"bfs-concert-info-link\" href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" data-log-click=\"concert-name\">"
      + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"name","hash":{},"data":data}) : helper)))
      + "</a>\n    </div>\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.venue : depth0),{"name":"with","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],330:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a list of links. The view component requires
   * most of the attributes to be present and has no special behaviour.
   */
  class ListGroup extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.items = this._model.items.map(item => {
        return {
          title: item.title,
          uri: item.uri
        };
      });
      data.title = this._model.title;
      return (0, _template2.default)(data);
    }
  }

  exports.default = ListGroup;

  },{"../View.js":271,"./schema.json":331,"./template.hbs":332}],331:[function(require,module,exports){
  module.exports={
    "items":
    [
      {
        "title": "",
        "uri": ""
      }
    ],
    "title": ""
  }

  },{}],332:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "    <div class=\"list-group-item list-group-item-media\">\n      <a class=\"item-link\" href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\">\n        <div class=\"item-data\">"
      + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "</div>\n      </a>\n    </div>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<div class=\"bfs-list-group\" data-node=\"list-group\">\n  <div class=\"section-divider section-divider-borderless\">\n    <div>\n      <h2 class=\"section-divider-title\">"
      + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "</h2>\n    </div>\n  </div>\n"
      + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.items : depth0),{"name":"each","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],333:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a Glue offline screen. The view component is
   * positioned over any other content and may be used to indicate that the
   * application is offline. A default message is used when neither the "title"
   * nor the "subtitle" attributes are present in the model. The view component
   * also supports an optional call-to-action button.
   */
  class OfflineScreen extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.useDefaultOffline = true;
      if ('title' in this._model) {
        data.offlineTitle = this._model.title;
        data.useDefaultOffline = false;
      }
      if ('subtitle' in this._model) {
        data.offlineMessage = this._model.subtitle;
        data.useDefaultOffline = false;
      }
      if ('button' in this._model) {
        data.offlineEscapeUrl = this._model.button.uri;
        data.offlineEscapeMessage = this._model.button.title;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = OfflineScreen;

  },{"../View.js":271,"./schema.json":334,"./template.hbs":335}],334:[function(require,module,exports){
  arguments[4][312][0].apply(exports,arguments)
  },{"dup":312}],335:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/error-and-offline.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/error-and-offline.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<div class=\"show-offline-screen\">\n"
      + ((stack1 = container.invokePartial(partials["../../../../glue/templates/error-and-offline.hbs"],depth0,{"name":"../../../../glue/templates/error-and-offline.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</div>\n";
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/error-and-offline.hbs":176,"hbsfy/runtime":745}],336:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a Glue puff with three cover images. The view
   * component requires most of the attributes to be present and has no special
   * behaviour.
   */
  class Puff extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.images = [{
        imageUrl: this._model.images.right
      }, {
        imageUrl: this._model.images.left
      }, {
        imageUrl: this._model.images.middle
      }];
      data.subtitle = this._model.subtitle;
      data.title = this._model.title;
      data.uri = this._model.uri;
      return (0, _template2.default)(data);
    }
  }

  exports.default = Puff;
  },{"../View.js":271,"./schema.json":337,"./template.hbs":338,"bfs-km-types":691}],337:[function(require,module,exports){
  module.exports={
    "images":
    {
      "left": "",
      "middle": "",
      "right": ""
    },
    "logs?":
    {
      "impression?": {},
      "navigateToLink?": {}
    },
    "subtitle": "",
    "title": "",
    "uri": ""
  }

  },{}],338:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/cards/puff.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/puff.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return ((stack1 = container.invokePartial(partials["../../../../glue/templates/cards/puff.hbs"],depth0,{"name":"../../../../glue/templates/cards/puff.hbs","data":data,"helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "");
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/cards/puff.hbs":175,"hbsfy/runtime":745}],339:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a carousel in a section. The section header
   * will show a title and has support for showing an optional description. The
   * header will also contain chevron buttons that control the carousel through
   * spotify events. The chevron buttons and the carousel are linked through the
   * "id" property in the model.
   */
  class SectionCarousel extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      if ('description' in this._model) {
        data.description = this._model.description;
      }
      data.id = this._model.id;
      data.title = this._model.title;
      return (0, _template2.default)(data);
    }
  }

  exports.default = SectionCarousel;

  },{"../View.js":271,"./schema.json":340,"./template.hbs":341}],340:[function(require,module,exports){
  module.exports={
    "description?": "",
    "id": "",
    "title": ""
  }

  },{}],341:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "        <p class=\"section-divider-description\">"
      + container.escapeExpression(container.lambda(depth0, depth0))
      + "</p>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "<section>\n  <div>\n    <div class=\"section-divider\">\n      <h2 class=\"section-divider-title\">"
      + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "</h2>\n      <div class=\"section-auxiliary\" data-interaction-context=\"carousel-controls\">\n        <button class=\"button button-icon-only spoticon-chevron-left-16\" data-carousel=\""
      + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
      + "\" data-button=\"carousel-left\" data-interaction-target=\"left-button\" data-interaction-intent=\"slide-left\"></button>\n        <button class=\"button button-icon-only spoticon-chevron-right-16\" data-carousel=\""
      + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
      + "\" data-button=\"carousel-right\" data-interaction-target=\"right-button\" data-interaction-intent=\"slide-right\"></button>\n      </div>\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.description : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    </div>\n  </div>\n  <div class=\"carousel\" data-carousel=\""
      + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"id","hash":{},"data":data}) : helper)))
      + "\" data-carousel-main>\n    <div class=\"row standard-grid\">\n      <div class=\"crsl-inner\" data-carousel-inner data-child-container data-interaction-context=\"carousel\" data-interaction-list>\n      </div>\n    </div>\n  </div>\n</section>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],342:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a button for pagination control that may be
   * used in conjunction with the grids to load in more content.
   */
  class SectionGridButtons extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._allElement = this._documentFragment.find('[data-node="all"]');
      this._containerElement = this._documentFragment.find('[data-node="container"]');
      this._lessElement = this._documentFragment.find('[data-node="less"]');
      this._moreElement = this._documentFragment.find('[data-node="more"]');
      this._scrollBy = (x, y) => {
        window.scrollBy(x, y);
      };
      this._setUpEventRoutes();
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickAll(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      this._eventDispatcher.dispatch('click-all', {
        id: this._model.id
      });
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickLess(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      const rect = element.getBoundingClientRect();
      this._eventDispatcher.dispatch('click-less', {
        id: this._model.id,
        top: rect.top
      });
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickMore(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      this._eventDispatcher.dispatch('click-more', {
        id: this._model.id
      });
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onGridUpdate(json) {
      _bfsKmTypes2.default.check.object(json);
      const dataSchema = {
        id: '',
        expansions: 0,
        hidden: 0,
        visible: 0
      };
      if (_bfsKmTypes2.default.conforms(json, dataSchema)) {
        if (json.id === this._model.id) {
          const expansions = json.expansions;
          const hidden = json.hidden;
          const visible = json.visible;
          this._allElement.classList.add('hide');
          if (expansions === 0 && hidden > 0 && hidden <= visible) {
            this._allElement.classList.remove('hide');
          }
          if (expansions === 1 && hidden > 0) {
            this._allElement.classList.remove('hide');
          }
          this._lessElement.classList.add('hide');
          if (expansions > 0 && hidden === 0) {
            this._lessElement.classList.remove('hide');
          }
          this._moreElement.classList.add('hide');
          if (expansions === 0 && hidden > visible) {
            this._moreElement.classList.remove('hide');
          }
        }
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onSetButtonPosition(json) {
      _bfsKmTypes2.default.check.object(json);
      if (_bfsKmTypes2.default.conforms(json, { id: '', top: 0 })) {
        if (json.id === this._model.id) {
          const rect = this._containerElement.getBoundingClientRect();
          this._scrollBy(0, rect.top - json.top);
        }
      }
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.titles = {
        all: this._model.titles.all,
        less: this._model.titles.less,
        more: this._model.titles.more
      };
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      this._addEventListener('grid-update', this._onGridUpdate);
      this._addEventListener('set-button-position', this._onSetButtonPosition);
      this._addInteractionHandler(this._allElement, 'click', this._onClickAll);
      this._addInteractionHandler(this._lessElement, 'click', this._onClickLess);
      this._addInteractionHandler(this._moreElement, 'click', this._onClickMore);
    }
  }

  exports.default = SectionGridButtons;

  },{"../View.js":271,"./schema.json":343,"./template.hbs":344,"bfs-km-types":691}],343:[function(require,module,exports){
  module.exports={
    "id": "",
    "titles":
    {
      "all": "",
      "less": "",
      "more": ""
    }
  }

  },{}],344:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"all\">\n      "
      + alias4(((helper = (helper = helpers.all || (depth0 != null ? depth0.all : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"all","hash":{},"data":data}) : helper)))
      + "\n    </button>\n    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"less\">\n      "
      + alias4(((helper = (helper = helpers.less || (depth0 != null ? depth0.less : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"less","hash":{},"data":data}) : helper)))
      + "\n    </button>\n    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"more\">\n      "
      + alias4(((helper = (helper = helpers.more || (depth0 != null ? depth0.more : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"more","hash":{},"data":data}) : helper)))
      + "\n    </button>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<div class=\"text-center\" data-node=\"container\">\n"
      + ((stack1 = helpers["with"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.titles : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],345:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  var _getGridBreakPoint = require('../../utils/getGridBreakPoint.js');

  var _getGridBreakPoint2 = _interopRequireDefault(_getGridBreakPoint);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a grid in a section. The section header will
   * show a title and has support for showing an optional description. The number
   * of visible cells may be controlled by the "layout" attribute in the model.
   */
  class SectionGrid extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._getGridBreakPoint = () => {
        return (0, _getGridBreakPoint2.default)(document, window);
      };
      this._numberOfVisibleChildren = null;
      this._timesGridExpanded = 0;
      this._currentRows = this._getDefaultNumberOfVisibleRows();
      this._setUpEventRoutes();
    }

    /**
     * Overridden because the number of visible children might be controlled by
     * the grid.
     */
    attach(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      if ('layout' in this._model) {
        this._updateVisibility();
        for (let i = 0; i < this._numberOfVisibleChildren; i++) {
          this._childViews[i].attach(this._childContainerElement);
        }
        this._documentFragment.attach(containerElement);
      } else {
        super.attach(containerElement);
      }
    }

    _getColsForCurrentBreakPoint() {
      if ('layout' in this._model) {
        const breakPoint = this._getGridBreakPoint();
        if (breakPoint === 'lg') {
          return this._model.layout.cols.large;
        }
        if (breakPoint === 'md') {
          return this._model.layout.cols.medium;
        }
        if (breakPoint === 'sm') {
          return this._model.layout.cols.small;
        }
        if ('xSmall' in this._model.layout.cols) {
          return this._model.layout.cols.xSmall;
        }
        return this._model.layout.cols.small;
      }
      return Infinity;
    }

    _getDefaultNumberOfVisibleRows() {
      if ('layout' in this._model) {
        return this._model.layout.rows;
      }
      return Infinity;
    }

    /**
     * A method that returns the maximum number of visible children.
     */
    _getMaximumNumberOfVisibleChildren() {
      return this._getColsForCurrentBreakPoint() * this._currentRows;
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onClickAll(json) {
      _bfsKmTypes2.default.check.object(json);
      if (json.id === this._model.id) {
        this._timesGridExpanded++;
        this._currentRows = Infinity;
        this._updateVisibility();
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onClickLess(json) {
      _bfsKmTypes2.default.check.object(json);
      if (json.id === this._model.id) {
        this._timesGridExpanded = 0;
        this._currentRows = this._getDefaultNumberOfVisibleRows();
        this._updateVisibility();
        this._eventDispatcher.dispatch('set-button-position', json);
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onClickMore(json) {
      _bfsKmTypes2.default.check.object(json);
      if (json.id === this._model.id) {
        this._timesGridExpanded++;
        this._currentRows += this._getDefaultNumberOfVisibleRows();
        this._updateVisibility();
      }
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onRootViewUpdate(json) {
      _bfsKmTypes2.default.check.object(json);
      this._updateVisibility();
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onWindowResize(json) {
      _bfsKmTypes2.default.check.object(json);
      this._updateVisibility();
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      if ('description' in this._model) {
        data.description = this._model.description;
      }
      data.title = this._model.title;
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      if ('layout' in this._model) {
        this._addEventListener('click-all', this._onClickAll);
        this._addEventListener('click-less', this._onClickLess);
        this._addEventListener('click-more', this._onClickMore);
        this._addEventListener('root-view-update', this._onRootViewUpdate);
        this._addEventListener('window-resize', this._onWindowResize);
      }
    }

    /**
     * A method that updates the visibility of the grid cells based on the current
     * layout settings.
     */
    _updateVisibility() {
      const visible = Math.min(this._getMaximumNumberOfVisibleChildren(), this._childViews.length);
      if (this._numberOfVisibleChildren !== visible) {
        const hidden = this._childViews.length - visible;
        for (let i = 0; i < visible; i++) {
          this._childViews[i].attach(this._childContainerElement);
        }
        for (let i = visible; i < this._childViews.length; i++) {
          this._childViews[i].detach();
        }
        this._environment.updateSpotifyEventsIn(this._childContainerElement);
        this._numberOfVisibleChildren = visible;
        this._eventDispatcher.dispatch('grid-update', {
          id: this._model.id,
          expansions: this._timesGridExpanded,
          hidden: hidden,
          visible: visible
        });
      }
    }
  }

  exports.default = SectionGrid;

  },{"../../utils/getGridBreakPoint.js":267,"../View.js":271,"./schema.json":346,"./template.hbs":347,"bfs-km-types":691}],346:[function(require,module,exports){
  module.exports={
    "description?": "",
    "id": "",
    "layout?":
    {
      "cols":
      {
        "large": 0,
        "medium": 0,
        "small": 0,
        "xSmall?": 0
      },
      "rows": 0
    },
    "title": ""
  }

  },{}],347:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "      <p class=\"section-divider-description\">"
      + container.escapeExpression(container.lambda(depth0, depth0))
      + "</p>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<section>\n  <div class=\"section-divider\">\n    <h2 class=\"section-divider-title\">"
      + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "</h2>\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.description : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "  </div>\n  <div class=\"row standard-grid\" data-child-container data-interaction-context=\"grid\" data-interaction-list>\n  </div>\n</section>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],348:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a section. The view component can display an
   * optional title and/or description and may show link to a drilldown view.
   */
  class Section extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      if ('description' in this._model) {
        data.description = this._model.description;
      }
      if ('link' in this._model) {
        data.link = {
          title: this._model.link.title,
          uri: this._model.link.uri
        };
      }
      if ('title' in this._model) {
        data.title = this._model.title;
      }
      return (0, _template2.default)(data);
    }
  }

  exports.default = Section;

  },{"../View.js":271,"./schema.json":349,"./template.hbs":350,"bfs-km-types":691}],349:[function(require,module,exports){
  module.exports={
    "description?": "",
    "id?": "",
    "link?":
    {
      "title": "",
      "uri": ""
    },
    "logs?":
    {
      "navigateToShowAll?": {}
    },
    "title?": ""
  }

  },{}],350:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      return "        <h2 class=\"section-divider-title\">"
      + container.escapeExpression(container.lambda(depth0, depth0))
      + "</h2>\n";
  },"3":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "        <div class=\"section-auxiliary\" data-node=\"show-all\">\n          <a href=\""
      + alias4(((helper = (helper = helpers.uri || (depth0 != null ? depth0.uri : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"uri","hash":{},"data":data}) : helper)))
      + "\" data-log-click=\"show-all\" data-interaction-target=\"show-all-button\" data-interaction-intent=\"show-all\">"
      + alias4(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"title","hash":{},"data":data}) : helper)))
      + "</a>\n        </div>\n";
  },"5":function(container,depth0,helpers,partials,data) {
      return "        <p class=\"section-divider-description\" data-description>"
      + container.escapeExpression(container.lambda(depth0, depth0))
      + "</p>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});

    return "<section>\n  <div class=\"section-divider-sticky-wrapper\">\n    <div class=\"section-divider\">\n"
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.title : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.link : depth0),{"name":"with","hash":{},"fn":container.program(3, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + ((stack1 = helpers["with"].call(alias1,(depth0 != null ? depth0.description : depth0),{"name":"with","hash":{},"fn":container.program(5, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "    </div>\n  </div>\n  <div class=\"section-divider-section-content\" data-child-container></div>\n</section>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],351:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a tab. The view component may be used in
   * conjunction with headers supporting tab bars to switch the currently
   * displayed content.
   */
  class Tab extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);
      this._areChildrenShown = false;
      this._setUpEventRoutes();
    }

    /**
     * A method that attaches the document fragment of the view to the given
     * container element. This method is overridden since this view component
     * manages its tree of child view components by itself.
     */
    attach(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, Element);
      this._documentFragment.attach(containerElement);
    }

    /**
     * Used to deduce if the children of this view component should be used in the
     * calculation of deferred content loads. This method is overridden since this
     * view component manages its tree of child view components by itself.
     */
    hasVisibleChildren() {
      return this._areChildrenShown && super.hasVisibleChildren();
    }

    /**
     * A method that is triggered by an event listener.
     */
    _onShowTab(json) {
      _bfsKmTypes2.default.check.object(json);
      if ('id' in this._model) {
        if (_bfsKmTypes2.default.conforms(json, { id: '' })) {
          if (json.id === this._model.id) {
            this._areChildrenShown = true;
            for (let i = 0; i < this._childViews.length; i++) {
              this._childViews[i].attach(this._childContainerElement);
            }
            this._environment.updateSpotifyEventsIn(this._childContainerElement);

            const defaultConfigurationState = this._configuration.getDefaultState();
            const appName = defaultConfigurationState.getString('app/name');
            this._environment.sendViewReady(appName);
          } else {
            this._areChildrenShown = false;
            for (let i = 0; i < this._childViews.length; i++) {
              this._childViews[i].detach();
            }
          }
        }
      }
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      if ('id' in this._model) {
        this._addEventListener('show-tab', this._onShowTab);
      }
    }
  }

  exports.default = Tab;

  },{"../View.js":271,"./schema.json":352,"./template.hbs":353,"bfs-km-types":691}],352:[function(require,module,exports){
  module.exports={
    "id?": ""
  }

  },{}],353:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  module.exports = HandlebarsCompiler.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      return "<div data-child-container>\n</div>\n";
  },"useData":true});

  },{"hbsfy/runtime":745}],354:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _bfsKmTypes = require('bfs-km-types');

  var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

  var _View = require('../View.js');

  var _View2 = _interopRequireDefault(_View);

  var _schema = require('./schema.json');

  var _schema2 = _interopRequireDefault(_schema);

  var _template = require('./template.hbs');

  var _template2 = _interopRequireDefault(_template);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A view component that presents a list of tracks. The tracklist is playable
   * and shows the five first tracks until the button at the bottom is clicked.
   */
  class Tracklist extends _View2.default {
    constructor(model, eventDispatcher, serviceRouter, configuration, environment, document, window) {
      super(model, eventDispatcher, serviceRouter, configuration, environment, document, window, _schema2.default);

      this._scrollBy = (x, y) => {
        window.scrollBy(x, y);
      };
      this._lessElement = this._documentFragment.find('[data-node="less"]');
      this._moreElement = this._documentFragment.find('[data-node="more"]');
      this._tracklistElement = this._documentFragment.find('[data-node="tracklist"]');
      this._makePlayableLiveModel();
      this._setUpEventRoutes();
    }

    /**
     * A method that makes the tracklist playable by creating a playable live
     * model from the given model.
     */
    _makePlayableLiveModel() {
      const model = {};
      model.rows = this._model.tracks.map(track => {
        return {
          track: _bfsKmTypes2.default.clone(track)
        };
      });
      model.uri = this._model.uri;
      this._environment.makeTracklistLiveModel(model.uri, model);
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickLess(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      const rectBefore = this._lessElement.getBoundingClientRect();
      this._lessElement.classList.add('hide');
      this._moreElement.classList.remove('hide');
      this._tracklistElement.classList.add('summary');
      const rectAfter = this._moreElement.getBoundingClientRect();
      const tracklistRect = this._tracklistElement.getBoundingClientRect();
      if (tracklistRect.top < 0) {
        this._scrollBy(0, rectAfter.top - rectBefore.top);
      }
    }

    /**
     * A method that is triggered by an interaction handler.
     */
    _onClickMore(element) {
      _bfsKmTypes2.default.check.type(element, Element);
      this._lessElement.classList.remove('hide');
      this._moreElement.classList.add('hide');
      this._tracklistElement.classList.remove('summary');
    }

    /**
     * A method that creates the html string for the view.
     */
    _render() {
      const data = {};
      data.titles = {
        less: this._model.titles.less,
        more: this._model.titles.more
      };
      data.rows = this._model.tracks.map(track => {
        return {
          track: _bfsKmTypes2.default.clone(track)
        };
      });
      data.uri = this._model.uri;
      return (0, _template2.default)(data);
    }

    /**
     * A method that registers the event routing for the view.
     */
    _setUpEventRoutes() {
      this._addInteractionHandler(this._lessElement, 'click', this._onClickLess);
      this._addInteractionHandler(this._moreElement, 'click', this._onClickMore);
    }
  }

  exports.default = Tracklist;

  },{"../View.js":271,"./schema.json":355,"./template.hbs":356,"bfs-km-types":691}],355:[function(require,module,exports){
  module.exports={
    "titles":
    {
      "less": "",
      "more": ""
    },
    "tracks":
    [
      {
        "album":
        {
          "name": "",
          "uri": ""
        },
        "artists":
        [
          {
            "name": "",
            "uri": ""
          }
        ],
        "duration": 0,
        "explicit?": false,
        "name": "",
        "popularity": 0,
        "unavailable?": false,
        "uri": ""
      }
    ],
    "uri": ""
  }

  },{}],356:[function(require,module,exports){
  // hbsfy compiled Handlebars template
  var HandlebarsCompiler = require('hbsfy/runtime');
  var partial$0 = require('../../../../glue/templates/tracklist-search.hbs');
  HandlebarsCompiler.registerPartial('../../../../glue/templates/tracklist-search.hbs', partial$0);
  module.exports = HandlebarsCompiler.template({"1":function(container,depth0,helpers,partials,data) {
      var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3="function", alias4=container.escapeExpression;

    return "    <button type=\"button\" class=\"button button-with-stroke grid-button hide\" data-node=\"less\">\n      "
      + alias4(((helper = (helper = helpers.less || (depth0 != null ? depth0.less : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"less","hash":{},"data":data}) : helper)))
      + "\n    </button>\n    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"more\">\n      "
      + alias4(((helper = (helper = helpers.more || (depth0 != null ? depth0.more : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{"name":"more","hash":{},"data":data}) : helper)))
      + "\n    </button>\n";
  },"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
      var stack1;

    return "<div class=\"bfs-tracklist summary\" data-node=\"tracklist\">\n"
      + ((stack1 = container.invokePartial(partials["../../../../glue/templates/tracklist-search.hbs"],depth0,{"name":"../../../../glue/templates/tracklist-search.hbs","data":data,"indent":"  ","helpers":helpers,"partials":partials,"decorators":container.decorators})) != null ? stack1 : "")
      + "</div>\n<div class=\"text-center\">\n"
      + ((stack1 = helpers["with"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.titles : depth0),{"name":"with","hash":{},"fn":container.program(1, data, 0),"inverse":container.noop,"data":data})) != null ? stack1 : "")
      + "</div>\n";
  },"usePartial":true,"useData":true});

  },{"../../../../glue/templates/tracklist-search.hbs":199,"hbsfy/runtime":745}],357:[function(require,module,exports){
  'use strict';

  const base = 'spotify:internal:filterlist';
  const regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

  /**
   * Create a URI representing a filtered variant of a list.
   *
   * @param {string} originUri The original list URI.
   * @param {string} query The query string (compatible with Core). Filter
   *     implementations might not look at all values.
   *
   * @return {string} URI of the filtered variant of the list. The URI will have
   *     the query string URL encoded.
   */
  exports.create = function (originUri, query) {
    const newOriginUri = originUri.replace(/^spotify:/, '');

    const newQuery = encodeURIComponent(query);

    return [base, newQuery, newOriginUri].join(':');
  };

  /**
   * Get the query string from a filter URI.
   *
   * @param {string} filterUri The URI of the filtered list.
   *
   * @return {string} The query string, URL decoded. If URI is
   *     invalid, this returns an empty string.
   */
  exports.getQuery = function (filterUri) {
    const matches = filterUri.match(regExp);
    if (!matches) return '';

    return decodeURIComponent(matches[1]);
  };

  /**
   * Get the URI of the original list.
   *
   * @param {string} filterUri The URI of the filtered list.
   *
   * @return {string} The URI of the original list. If the filter URI is invalid,
   *     this returns an empty string.
   */
  exports.getOriginUri = function (filterUri) {
    const matches = filterUri.match(regExp);
    if (!matches) return '';

    return `spotify:${matches[2]}`;
  };

  /**
   * Parse and return all parts of the filter URI.
   *
   * @param {string} filterUri The URI of the filtered list.
   *
   * @return {Object?} An object with properties `direction`, `query` and `originUri`,
   *     or null if the URI is not valid.
   */
  exports.parse = function (filterUri) {
    const matches = filterUri.match(regExp);
    if (!matches) return null;

    return {
      query: decodeURIComponent(matches[1]),
      originUri: `spotify:${matches[2]}`
    };
  };

  /**
   * Test if the provided URI is a valid filter URI.
   *
   * @param {string} filterUri The URI of the filtered list.
   *
   * @return {boolean} True if it's valid, false otherwise.
   */
  exports.isValid = function (filterUri) {
    return regExp.test(filterUri);
  };

  /**
   * The regular expression that matches filter URIs.
   */
  exports.regExp = regExp;

  },{}],358:[function(require,module,exports){
  'use strict';

  const Range = require('../range2');

  /**
   * Get the needed operations for inserting items at a specific index.
   *
   * @param {Array} items Array of items to insert.
   * @param {number} index Index to insert the items at, relative to the list
   *     before the operations.
   *
   * @return {Array.<Object>} Array of operation objects.
   */
  function getInsertOperations(items, index) {
    return [{ type: 'insert', index: index, values: items }];
  }

  /**
   * Get the needed operations for removing items from the specified indices.
   *
   * @param {Array.<number>} indices Array of indices relative to the list before
   *     the operations.
   *
   * @return {Array.<Object>} Array of operation objects.
   */
  function getRemoveOperations(indices) {
    const ranges = Range.fromIndices(indices);

    let removed = 0;
    const operations = [];

    for (let r = 0, range; ranges[r]; r++) {
      range = ranges[r];
      operations.push({
        type: 'remove',
        index: range.start - removed,
        length: range.length
      });
      removed += range.length;
    }

    return operations;
  }

  /**
   * Get the needed operations for moving items from a set of indices to a
   * target index.
   *
   * @param {Array.<number>} fromIndices Array of indices relative to the list
   *     before the operations.
   * @param {number} toIndex Index to move the items to, relative to the list
   *     before the operations.
   *
   * @return {Array.<Object>} Array of operation objects.
   */
  function getMoveOperations(fromIndices, toIndex) {
    // We're going through one range at a time, and when a range is moved down,
    // we need to decrease the start of the next range to account for the
    // range we moved down (since each operation is based on the result of
    // the previous operation).
    let movedAbove = 0;

    // The maximum index starts at the index we want to move to.
    // When operations are created to move ranges, this maximum index
    // is increased to always point to the bottom index of the moved
    // items. If five items are moved from far down up to the 'to' index,
    // the new maxIndex will be toIndex + 5.
    let maxIndex = toIndex;

    const ranges = Range.fromIndices(fromIndices);
    let r;
    let range;
    let toRange;

    // Find any range that intersects with the 'to' index. Referred below as
    // the 'to' range. This range can't be split, so we need to move items to
    // positions above or below this range if it exists.
    for (r = 0; ranges[r]; r++) {
      range = ranges[r];
      if (range.start <= toIndex && range.end >= toIndex) {
        toRange = range;
        break;
      }
    }

    const operations = [];

    for (r = 0; ranges[r]; r++) {
      range = ranges[r];
      const length = range.length;
      let to;
      let from = range.start - movedAbove;

      // If the 'to' index is inside a range
      if (toRange) {
        // Range is above the 'to' range, so move it to right above that range.
        if (range.end < toRange.start) {
          from = range.start - movedAbove;
          to = toRange.start - length;
          movedAbove += length;

          // Range is the 'to' range, which means it will not move anywhere.
        } else if (range === toRange) {
          maxIndex = Math.max(maxIndex, range.end);
          continue;

          // Range is below the 'to' range, so move it to the maximum index
          // we've reached so far.
        } else {
          from = range.start;
          to = maxIndex;
          maxIndex = Math.max(maxIndex, to + length);
        }
        // If the 'to' index is not inside a range
      } else {
        // Range is above the 'to' index, so move it to right above the maximum index.
        if (range.end < toIndex) {
          from = range.start - movedAbove;
          to = maxIndex - length;
          movedAbove += length;

          // Range is below the 'to' index, so move it to the maximum index we've
          // reached so far.
        } else {
          from = range.start;
          to = maxIndex;
          maxIndex = Math.max(maxIndex, to + length);
        }
      }

      operations.push({ type: 'move', from: from, length: length, to: to });
    }

    return operations;
  }

  exports.getInsertOperations = getInsertOperations;
  exports.getRemoveOperations = getRemoveOperations;
  exports.getMoveOperations = getMoveOperations;

  },{"../range2":454}],359:[function(require,module,exports){
  (function (global){
  'use strict';

  const live = require('../../live');
  const cosmos = require('../util/cosmos');
  const Collection = require('./collection');
  const liburi = require('spotify-liburi');

  const endpoints = {
    isInCollection: 'sp://core-collection/v1/contains',
    updateIsInCollection: 'sp://core-collection/v1/items',
    broadcast: 'sp://messages/v1/collectionstate',
    pubsub: 'hm://collection/collection/@/json'
  };

  const onCollectionPublish = function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    live(response.body.items.filter(({ type = '' }) => type.toUpperCase() === 'ALBUM').map(({ identifier, removed }) => ({
      uri: liburi.albumURI(identifier).toURI(),
      added: !removed
    })));
  };

  let albumCollection;
  let broadcastSubscription;
  let collectionSubscription;

  const regExp = exports.matches = /^spotify:album:[^:]+$/;
  let registered = false;
  exports.register = function () {
    if (registered) return;
    registered = true;

    albumCollection = new Collection(endpoints);

    live.subscribe(regExp, 'publish', albumCollection.onPublish);
    live.subscribe(regExp, 'wait', albumCollection.onWait);

    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
    collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'publish', albumCollection.onPublish);
    live.unsubscribe(regExp, 'wait', albumCollection.onWait);

    albumCollection = null;

    if (broadcastSubscription) {
      broadcastSubscription.cancel();
      broadcastSubscription = null;
    }

    if (collectionSubscription) {
      collectionSubscription.cancel();
      collectionSubscription = null;
    }
  };

  exports._endpoints = endpoints;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live":413,"../util/cosmos":408,"./collection":361,"spotify-liburi":1282}],360:[function(require,module,exports){
  'use strict';

  const profile = require('./profile');

  const regExp = exports.matches = /^spotify:artist:/;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    profile.register(regExp);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    profile.unregister(regExp);
  };

  },{"./profile":365}],361:[function(require,module,exports){
  (function (global){
  'use strict';

  // This model will take a URI and create a live model for that URI.
  //
  //
  // It will listen for publish events on the live model. The publish
  // events are only triggered when someone actually wants to update
  // something on the backend.
  // When a publish event is detected, it will:
  //
  // * If the changed property was "added", it will contact
  //   the backend to update the stored collection state. If this
  //   fails, it will set it to the opposite of what was pusblished.
  //
  // * On success, broadcast the changes to the rest of the client via
  //   cosmos, as "isInCollection" / "isFollowing" and as "added".
  //
  // This model will also listen for update events on the live model.
  // The update event will be triggered when someone changes the data
  // on the live model, without an intention to update the backend.
  // When an update event is detected, it will:
  //
  // This model will also listen for broadcast events from the rest
  // of the client. When a broadcast event is received, this happens:
  //
  // * If the URI for the broadcast message does not match this model,
  //   do nothing.
  //
  // * It will then update the live model with the data it received
  //   from the broadcast event. This will trigger the update listener
  //   described above, but it won't run the code because all properties
  //   are there.

  const prime = require('../../../libs/prime');
  const defer = require('../../../libs/prime/defer');

  const live = require('../../live');
  const contains = require('mout/array/contains');

  const cosmos = require('../util/cosmos');

  const INSUFFICIENT_STORAGE = 507;

  // COLLECTION

  const Collection = prime({
    constructor: function (endpoints) {
      this.endpoints = endpoints;
      this.onPublish = this.onPublish.bind(this);
      this.waitQueue = [];
      this.onWait = this.onWait.bind(this);
      this.fetch = this.fetch.bind(this);
    },

    onPublish: function (model, data) {
      // If the property is "added", update the backend with the new value
      // If the update fails, revert the state
      // If the update does not fail, broadcast the new state, as "isInCollection" and "added"
      if ('added' in data) {
        const endpoints = this.endpoints;
        const state = !!data.added;

        // optimistic
        model.update({ added: state });

        const method = state ? 'post' : 'delete';
        this._publish(method, [model], function (error, publishData) {
          if (error) {
            // that's what being optimistic gets you
            model.update({ added: !state });
            if (error.response && error.response.getStatusCode() === INSUFFICIENT_STORAGE) {
              cosmos.post({
                url: 'sp://messages/v1/container/user-message',
                body: { id: 'collection-limit-exceeded' }
              });
            }
          } else {
            cosmos.post({
              url: endpoints.broadcast,
              body: { uri: model.uri, isInCollection: state, added: state }
            });
            if (publishData && publishData.items) {
              publishData.items.forEach(function (item) {
                // Patch items to contain added
                item.added = item.isInCollection;
                cosmos.post({ url: endpoints.broadcast, body: item });
              });
            }
          }
        });
      }
    },

    onWait: function (model, properties) {
      if (contains(properties, 'added')) {
        this.fetch(model);
      }
    },

    fetch: function (model) {
      const queue = this.waitQueue;

      queue.push(model);

      // The first thing that gets added to the queue should defer a batch fetch
      // for the next tick. On the next tick, it will batch fetch status for all
      // models added to the queue.
      if (queue.length === 1) {
        defer.immediate(this._fetchBatch, this);
      }
    },

    _fetchBatch: function () {
      const queue = this.waitQueue;
      if (queue.length === 0) return;

      // Create a new queue for requests coming after this
      this.waitQueue = [];

      this._contains(queue, function (error, result) {
        // Collection returns 404 for a user without a collection. This is sent as an error,
        // but we will just interpret that as `isInCollection` is false. All other errors
        // we just throw.
        if (error && (!error.response || error.response && error.response.getStatusCode() !== 404)) {
          if (global.console) console.error(error);
          return;
        }

        queue.forEach(function (model, i) {
          let added = false;
          if (!error) added = result[i];
          model.update({ added: added });
        });
      });
    },

    _contains: function (models, callback) {
      const url = this.endpoints.isInCollection;
      const body = this._getRequestBody(models);

      cosmos.post({ url: url, body: body }, function (error, result) {
        callback(error, result && result.body && result.body.found);
      });
    },

    _publish: function (method, models, callback) {
      const url = this.endpoints.updateIsInCollection;
      const body = this._getRequestBody(models);

      cosmos[method]({ url: url, body: body }, function (error, result) {
        callback(error, result && result.body);
      });
    },

    _getRequestBody: function (models) {
      return {
        items: models.map(function (model) {
          return model.uri;
        }),
        source: global.__spotify && global.__spotify.app_uri || null
      };
    }
  });

  // ----------------------

  Collection.onBroadcast = function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    let value;
    if ('added' in response.body) value = response.body.added;else if ('isInCollection' in response.body) {
      // Deal with older versions of this package that send isInCollection / isFollowing
      value = response.body.isInCollection;
    }

    live(response.body.uri).update({
      added: value
    });
  };

  module.exports = Collection;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../../libs/prime":452,"../../../libs/prime/defer":450,"../../live":413,"../util/cosmos":408,"mout/array/contains":776}],362:[function(require,module,exports){
  'use strict';

  const album = require('./album');
  const artist = require('./artist');
  const playlist = require('./playlist');
  const track = require('./track');
  const user = require('./user');
  const local = require('./local');
  const show = require('./show');

  exports.register = function () {
    album.register();
    artist.register();
    playlist.register();
    track.register();
    user.register();
    local.register();
    show.register();
  };

  exports.unregister = function () {
    album.unregister();
    artist.unregister();
    playlist.unregister();
    track.unregister();
    user.unregister();
    local.unregister();
    show.unregister();
  };

  },{"./album":359,"./artist":360,"./local":363,"./playlist":364,"./show":366,"./track":367,"./user":368}],363:[function(require,module,exports){
  'use strict';

  const live = require('../../live');
  const contains = require('mout/array/contains');

  const onWait = function (model, properties) {
    if (contains(properties, 'added')) {
      // Neither tracks nor albums or artists can ever be added to YM.
      model.update({ added: false });
    }
  };

  // Matches local track, albums and artists.
  const regExp = exports.matches = /^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;
  let registered = false;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);
  };

  },{"../../live":413,"mout/array/contains":776}],364:[function(require,module,exports){
  (function (global){
  'use strict';

  // The 'playlist' function will be called when a new live object is
  // created for the pattern in playlist.matches. We use this function
  // to automatically add data to the live model when requested, and to
  // push any needed updates to the backend.
  //
  //
  // It will listen for publish events on the live model. The publish
  // events are only triggered when someone actually wants to update
  // something on the backend.
  // When a publish event is detected, it will:
  //
  // * Broadcast the changes to the rest of the client via cosmos.
  //
  // * If the changed property was `added`, it will contact
  //   the backend to update the stored collection state for the
  //   currently logged in user. If this fails, it will revert the
  //   state for the live model and broadcast the reverted state.
  //
  // This function will also listen for update events on the live model.
  // The update event will be triggered when someone changes the data
  // on the live model, without an intention to update the backend.
  // When an update event is detected, it will:
  //
  // This function will also listen for broadcast events from the rest
  // of the client. When a broadcast event is received, this happens:
  //
  // * If the URI for the broadcast message does not match this model,
  //   do nothing.
  //
  // * It will then update the live model with the data it received
  //   from the broadcast event. This will trigger the update listener
  //   described above, but it won't run the code because all properties
  //   are there.

  var _playlistUtils = require('../../../libs/playlist-utils');

  const contains = require('mout/array/contains');

  const live = require('../../live');

  const cosmos = require('../util/cosmos');


  const endpoints = {
    broadcast: 'sp://messages/v1/followstate'
  };

  function onPublish(model, data) {
    // If the property is "added", update the backend with the new
    // value. If the update fails somewhere along the way, revert the state
    // and broadcast the reverted state to the rest of the client.
    if ('added' in data) {
      model.update({ added: data.added });

      if (model.get('followersCount') !== null) {
        model.update({
          followersCount: model.get('followersCount') + (data.added ? 1 : -1)
        });
      }

      const fn = data.added ? _playlistUtils.followPlaylist : _playlistUtils.removePlaylist;
      fn(model.uri, error => {
        if (error) {
          // Revert optimistic change
          model.update({ added: !data.added });

          if (model.get('followersCount') !== null) {
            model.update({
              followersCount: model.get('followersCount') + (!data.added ? 1 : -1)
            });
          }
        }
      });
    }
  }

  function onBroadcast(error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    let value;
    if ('added' in response.body) {
      value = response.body.added;
    } else if ('isFollowing' in response.body) {
      value = response.body.isFollowing;
    }

    if (value !== undefined) {
      live(response.body.uri).update({
        added: value
      });
    }
  }

  function fetchAdded(model) {
    cosmos.get({
      url: `sp://core-playlist/v1/playlist/${encodeURIComponent(model.uri)}/metadata`,
      body: {
        policy: {
          followed: true
        }
      }
    }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        added: response.body.metadata.followed
      });
    });
  }

  function fetchFollowersCount(model) {
    cosmos.get({
      url: `sp://core-playlist/v1/playlist/${encodeURIComponent(model.uri)}/metadata`,
      body: {
        policy: {
          followers: true
        }
      }
    }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        followersCount: response.body.metadata.followers
      });
    });
  }

  const onWait = function (model, properties) {
    const needsAdded = contains(properties, 'added');
    const needsFollowersCount = contains(properties, 'followersCount');
    if (needsAdded) {
      const subscribed = model.get('subscribed');
      if (subscribed !== undefined) {
        model.update({ added: subscribed });
      } else {
        fetchAdded(model);
      }
    }
    if (needsFollowersCount) {
      fetchFollowersCount(model);
    }
  };

  const regExp = exports.matches = /^spotify:(user:[^:]+:)?playlist:[^:]+$/;

  let broadcastSubscription;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'publish', onPublish);
    live.subscribe(regExp, 'wait', onWait);
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'publish', onPublish);
    live.unsubscribe(regExp, 'wait', onWait);

    broadcastSubscription.cancel();
    broadcastSubscription = null;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../../libs/playlist-utils":445,"../../live":413,"../util/cosmos":408,"mout/array/contains":776}],365:[function(require,module,exports){
  (function (global){
  'use strict';

  // This model will, when registered to live, listen for publish
  // events on the live model. The publish events are only triggered
  // when someone actually wants to update something on the backend.
  // When a publish event is detected, it will:
  //
  // * Broadcast the changes to the rest of the client via cosmos.
  //
  // * If the changed property was isFollowing, it will contact
  //   the backend to update the stored following state for the
  //   currently logged in user. If this fails, it will revert the
  //   state for the live model and broadcast the reverted state.
  //
  // This function will also listen for update events on the live model.
  // The update event will be triggered when someone changes the data
  // on the live model, without an intention to update the backend.
  // When an update event is detected, it will:
  //
  // * If the changed property was isFollowing, it will automatically
  //   update followersCount on the live model.
  //
  // This function will also listen for broadcast events from the rest
  // of the client. When a broadcast event is received, this happens:
  //
  // * If the URI for the broadcast message does not match this model,
  //   do nothing.
  //
  // * It will then update the live model with the data it received
  //   from the broadcast event. This will trigger the update listener
  //   described above, but it won't run the code because all properties
  //   are there.
  //

  const intersection = require('mout/array/intersection');
  const live = require('../../live');
  const cosmos = require('../util/cosmos');
  let requestsInProgress = {};

  const endpoints = {
    isFollowing: 'hm://socialgraph/v2/is_following?format=json',
    followCounts: 'hm://socialgraph/v2/counts?format=json',
    updateIsFollowing: 'hm://socialgraph/v2/following?format=json',
    broadcast: 'sp://messages/v1/followstate'
  };

  function onUpdate(model, data) {
    // Only update followers count if that data was not present in the changed data
    if ('added' in data && !('followersCount' in data)) {
      const followersCount = model.get('followersCount');
      if (followersCount !== undefined) {
        const newFollowersCount = followersCount + (data.added ? 1 : -1);
        model.update({ followersCount: newFollowersCount });
      }
    }
  }

  function onPublish(model, data) {
    // If the property is added, update the backend with the new value.
    // If the update fails, revert the model state.
    // If the update is successful, broadcast the state to the client.
    if ('added' in data) {
      // if there is a request in course, do not launch a new request
      // as this can mess up with the Backend
      if (requestsInProgress[model.uri]) {
        return;
      }
      requestsInProgress[model.uri] = true;

      // we're optimistic this will work
      model.update({ added: data.added });

      updateBackend(model, !!data.added, function (error) {
        // request finished, we can accept more requests now
        delete requestsInProgress[model.uri];
        if (error) {
          // such is life.
          model.update({ added: !data.added });
        } else {
          model.update({ added: data.added });
          broadcast(model);
        }
      });
    }
  }

  function onBroadcast(error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    const body = response.body;
    const data = {};

    if ('added' in body) data.added = body.added;else if ('isFollowing' in body) {
      // Also accept broadcast from older versions that only send "isFollowing"
      data.added = body.isFollowing;
    }

    if ('followersCount' in body) data.followersCount = body.followersCount;
    if ('followingCount' in body) data.followingCount = body.followingCount;

    live(body.uri).update(data);
  }

  const followProperties = ['added', 'followersCount', 'followingCount'];

  function onWait(model, properties) {
    if (intersection(properties, followProperties).length) {
      getRequestData(model, function (error, data) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        updateIsFollowing(model, data);
        updateCounts(model, data);
      });
    }
  }

  function updateIsFollowing(model, requestData, callback) {
    const options = {
      url: endpoints.isFollowing,
      body: requestData
    };
    cosmos.get(options, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        if (callback) {
          callback(error);
        }
      } else {
        const value = response.body[0].is_following;
        model.update({ added: value });

        if (callback) callback();
      }
    });
  }

  function updateCounts(model, requestData, callback) {
    const options = {
      url: endpoints.followCounts,
      body: requestData
    };
    cosmos.get(options, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        if (callback) {
          callback(error);
        }
      } else {
        const body = response.body[0];

        model.update({
          followersCount: body.followers_count,
          followingCount: body.following_count
        });

        if (callback) callback();
      }
    });
  }

  function getRequestData(model, callback) {
    // Assumes that the client live object either already has the data about the current user,
    // or that there is code included for getting this data on request.
    live('spotify:client').query('currentUser(uri)', function (error, data) {
      if (error) {
        callback(error);
      } else {
        callback(null, {
          // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
          // rather than spotify:user:someone%21). `currentUser(uri)` returns a
          // uri-encoded user name.
          source_uri: decodeURIComponent(data.currentUser.uri),
          target_uris: [decodeURIComponent(model.uri)]
        });
      }
    });
  }

  function updateBackend(model, isFollowing, callback) {
    getRequestData(model, function (error, data) {
      if (error) {
        callback(error);
      } else {
        const requestMethod = isFollowing ? 'post' : 'delete';
        cosmos[requestMethod]({ url: endpoints.updateIsFollowing, body: data }, function (cosmosError) {
          if (cosmosError) {
            callback(cosmosError);
          } else {
            callback(null);
          }
        });
      }
    });
  }

  function broadcast(model) {
    const added = model.get('added');
    cosmos.post({
      url: endpoints.broadcast,
      body: {
        uri: model.uri,
        isFollowing: added,
        added: added,
        followersCount: model.get('followersCount'),
        followingCount: model.get('followingCount')
      }
    });
  }

  let broadcastSubscription;

  exports.register = function (regExp) {
    live.subscribe(regExp, 'wait', onWait);
    live.subscribe(regExp, 'update', onUpdate);
    live.subscribe(regExp, 'publish', onPublish);

    // reset the requestsInProgress variable
    requestsInProgress = {};

    if (!broadcastSubscription) {
      broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
    }
  };

  exports.unregister = function (regExp) {
    live.unsubscribe(regExp, 'wait', onWait);
    live.unsubscribe(regExp, 'update', onUpdate);
    live.unsubscribe(regExp, 'publish', onPublish);

    if (broadcastSubscription) {
      broadcastSubscription.cancel();
      broadcastSubscription = null;
    }
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live":413,"../util/cosmos":408,"mout/array/intersection":783}],366:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.register = register;
  exports.unregister = unregister;

  var _live = require('../../live');

  var _live2 = _interopRequireDefault(_live);

  var _collection = require('./collection');

  var _collection2 = _interopRequireDefault(_collection);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const regExp = /^spotify:show:[^:]+$/;
  let showCollection;
  let registered = false;

  function register() {
    if (registered) return;
    registered = true;

    showCollection = new _collection2.default({
      isInCollection: 'sp://core-collection/v1/contains',
      updateIsInCollection: 'sp://core-collection/v1/items',
      broadcast: 'sp://messages/v1/collectionstate',
      pubsub: 'hm://collection/collection/@/json'
    });

    _live2.default.subscribe(regExp, 'publish', showCollection.onPublish);
    _live2.default.subscribe(regExp, 'wait', showCollection.onWait);
  }

  function unregister() {
    if (!registered) return;
    registered = false;

    _live2.default.unsubscribe(regExp, 'publish', showCollection.onPublish);
    _live2.default.unsubscribe(regExp, 'wait', showCollection.onWait);
  }

  },{"../../live":413,"./collection":361}],367:[function(require,module,exports){
  (function (global){
  'use strict';

  const live = require('../../live');
  const cosmos = require('../util/cosmos');
  const Collection = require('./collection');
  const liburi = require('spotify-liburi');

  const endpoints = {
    isInCollection: 'sp://core-collection/v1/contains',
    updateIsInCollection: 'sp://core-collection/v1/items',
    broadcast: 'sp://messages/v1/collectionstate',
    pubsub: 'hm://collection/collection/@/json'
  };

  const onCollectionPublish = function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    live(response.body.items.filter(({ type = '' }) => type.toUpperCase() === 'TRACK').map(({ identifier, removed }) => ({
      uri: liburi.trackURI(identifier).toURI(),
      added: !removed
    })));
  };

  let trackCollection;
  let broadcastSubscription;
  let collectionSubscription;

  const regExp = exports.matches = /^spotify:track:[^:]+$/;
  let registered = false;
  exports.register = function () {
    if (registered) return;
    registered = true;

    trackCollection = new Collection(endpoints);

    live.subscribe(regExp, 'publish', trackCollection.onPublish);
    live.subscribe(regExp, 'wait', trackCollection.onWait);

    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
    collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'publish', trackCollection.onPublish);
    live.unsubscribe(regExp, 'wait', trackCollection.onWait);

    trackCollection = null;

    if (broadcastSubscription) {
      broadcastSubscription.cancel();
      broadcastSubscription = null;
    }

    if (collectionSubscription) {
      collectionSubscription.cancel();
      collectionSubscription = null;
    }
  };

  exports._endpoints = endpoints;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live":413,"../util/cosmos":408,"./collection":361,"spotify-liburi":1282}],368:[function(require,module,exports){
  'use strict';

  const profile = require('./profile');

  const regExp = exports.matches = /^spotify:user:[^:]+$/;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    profile.register(regExp);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    profile.unregister(regExp);
  };

  },{"./profile":365}],369:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/album
   */
  'use strict';

  const live = require('../live');

  const liburi = require('spotify-liburi');

  const intersection = require('mout/array/intersection');
  const contains = require('mout/array/contains');
  const mixIn = require('mout/object/mixIn');

  const bridge = require('./util/bridge').request;

  function isLocalAlbum(uri) {
    return liburi.from(uri).type === liburi.Type.LOCAL_ALBUM;
  }

  function isLocalArtist(uri) {
    return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
  }

  function updateMetadata(model) {
    if (isLocalAlbum(model.uri)) {
      const uriObject = liburi.from(model.uri);
      if (uriObject) {
        const data = {
          local: true,
          name: uriObject.album,
          artists: [{
            uri: 'spotify:local:',
            name: '',
            local: true
          }]
        };
        if (uriObject.artist) {
          data.artists[0].uri = liburi.localArtistURI(uriObject.artist).toURI();
          data.artists[0].name = uriObject.artist;
          data.artists[0].local = true;
        }
        model.update(data);
      }
    } else {
      bridge('album_metadata', [model.uri], function (error, payload) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update(payload);
      });
    }
  }

  function updateLocal(model) {
    model.update({
      local: isLocalAlbum(model.uri)
    });
  }

  let idCounter = 1000;

  function getRowUri(trackUri) {
    return trackUri.replace('spotify:', `spotify:row:${(++idCounter).toString(36)}:`);
  }

  function updateRows(model) {
    const descriptor = { type: 'list', uri: model.uri };

    bridge('album_tracks_snapshot', [descriptor, 0, 0, false], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      bridge('album_tracks_snapshot', [descriptor, 0, payload.length, false], function (bridgeError, bridgePayload) {
        if (bridgeError) {
          if (global.console) console.error(bridgeError);
        } else {
          const discs = [];
          const uriId = liburi.from(model.uri).id;

          const rows = bridgePayload.metadata && bridgePayload.metadata.map(function (trackdata, i) {
            const track = mixIn({ uri: bridgePayload.array[i] }, trackdata);
            const discNum = track.disc ? track.disc - 1 : 0;
            track.unavailable = !track.playable;
            setLocalProperty(track);
            if (!discs[discNum]) {
              discs[discNum] = {
                rows: [],
                uri: uriId ? liburi.albumURI(uriId, discNum + 1).toURI() : ''
              };
            }
            const uri = getRowUri(track.uri);
            const trackObject = {
              track: track,
              uri: uri
            };
            discs[discNum].rows.push(trackObject);
            return trackObject;
          });

          model.update({ rows: rows, discs: discs });
        }
      });
    });
  }

  function setLocalProperty(track) {
    if (track.album && track.album.uri) {
      track.album.local = isLocalAlbum(track.album.uri);
    }
    if (track.artists) {
      for (let i = 0, l = track.artists.length; i < l; i++) {
        const artist = track.artists[i];
        if (artist.uri) {
          artist.local = isLocalArtist(artist.uri);
        }
      }
    }
  }

  function onWait(model, properties) {
    const hasLocal = contains(properties, 'local');
    const hasRows = contains(properties, 'rows');
    const hasDiscs = contains(properties, 'discs');

    const metaFields = ['artists', 'image', 'images', 'name', 'playable', 'type', 'availability', 'date', 'label', 'copyrights'];

    const hasMetadata = !!intersection(properties, metaFields).length;

    if (hasMetadata) updateMetadata(model);
    if (hasRows || hasDiscs) updateRows(model);
    if (hasLocal) updateLocal(model);
  }

  const regExp = exports.matches = /^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"./util/bridge":406,"mout/array/contains":776,"mout/array/intersection":783,"mout/object/mixIn":813,"spotify-liburi":1282}],370:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/application
   */
  'use strict';

  var _getLocationHref = require('./util/get-location-href');

  var _getLocationHref2 = _interopRequireDefault(_getLocationHref);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const live = require('../live');
  const AppState = require('../navigation/app-state');


  function onMessage(message) {
    if (message.data && message.data.name) {
      if (message.data.name === 'set_active') {
        live('spotify:application').update({
          active: message.data.active
        });
      } else if (message.data.name === 'set_arguments') {
        // Arguments come as an array of un-encoded values, but we need to
        // concatenate them to a single colon-separated string for the
        // current design of the API. This is incorrect, as arguments should
        // be encoded if they are joined in a string. We should fix this, but
        // not without a breaking change.
        // https://jira.spotify.net/browse/KM-2353
        live('spotify:application').update({
          arguments: message.data.arguments.join(':')
        });
      } else if (message.data.name === 'set_state') {
        live('spotify:application').update({
          state: AppState.unserialize(message.data.state)
        });
      }
    }
  }

  function onRegister(model) {
    model.update({
      version: global.__spotify && global.__spotify.app_version || '0.0.0'
    });

    // Get the initial application state from the URL.
    const url = new URL((0, _getLocationHref2.default)());
    if (url.hostname.length > 0) {
      const pattern = /^([a-zA-Z-]+)\.app\.spotify\.com$/;
      const matches = url.hostname.match(pattern);
      if (matches.length === 2) {
        model.update({
          appURI: `spotify:app:${matches[1]}`,
          arguments: url.searchParams.get('param') || '',
          active: true
        });
      }
    }
  }

  exports.matches = /^spotify:application$/;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    global.addEventListener('message', onMessage);
    onRegister(live('spotify:application'));
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    global.removeEventListener('message', onMessage);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"../navigation/app-state":439,"./util/get-location-href":409}],371:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/artist
   */
  'use strict';

  const liburi = require('spotify-liburi');
  const contains = require('mout/array/contains');
  const live = require('../live');
  const bridge = require('./util/bridge').request;

  function isLocalArtist(uri) {
    return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
  }

  function updateMetadata(model) {
    if (isLocalArtist(model.uri)) {
      const uriObject = liburi.from(model.uri);
      if (uriObject) {
        model.update({
          local: true,
          name: uriObject.artist
        });
      }
    } else {
      bridge('artist_metadata', [model.uri], function (error, payload) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        if (!payload.image && !model.get('image')) payload.image = '';
        if (!payload.images && !model.get('images')) payload.images = [];
        model.update(payload);
      });
    }
  }

  function updateLocal(model) {
    model.update({
      local: isLocalArtist(model.uri)
    });
  }

  function onWait(model, properties) {
    const hasLocal = contains(properties, 'local');
    let hasMetadata = false;
    const metaFields = ['image', 'images', 'name'];
    for (let i = 0, l = properties.length; i < l; i++) {
      if (contains(metaFields, properties[i])) {
        hasMetadata = true;
        break;
      }
    }

    if (hasMetadata) updateMetadata(model);
    if (hasLocal) updateLocal(model);
  }

  const regExp = exports.matches = /^spotify:artist:|^spotify:local:[^:]*$/;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"./util/bridge":406,"mout/array/contains":776,"spotify-liburi":1282}],372:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/client-storage
   */
  'use strict';

  const forOwn = require('mout/object/forOwn');
  const combine = require('mout/array/combine');
  const remove = require('mout/array/remove');
  const contains = require('mout/array/contains');

  const URI = 'spotify:client-storage';
  const live = require('../live');
  const cosmos = require('./util/cosmos');
  const endpoints = {
    broadcast: 'sp://messages/v1/client-storage'
  };

  let waiting = [];

  function onInit(model) {
    // Set a flag for showing that the model has been implemented and
    // registered. This is so that we can check this in player without
    // making a breaking change. Would be great with a future live API
    // to see if someone has implemented a specific model.
    model.update({ implemented: true });
  }

  function onWait(model, properties) {
    // Ask the top frame to broadcast the properties.
    // Values will be null when they weren't stored.
    waiting = combine(waiting, properties);
    global.top.postMessage({
      type: 'client_storage',
      name: 'broadcast_client_storage',
      data: properties
    }, '*');
  }

  function onPublish(model, properties) {
    // Tell the top frame to persist and broadcast
    global.top.postMessage({
      type: 'client_storage',
      name: 'set_client_storage',
      data: properties
    }, '*');

    // Optimistic update
    model.update(properties);
  }

  function onBroadcast(error, event) {
    if (error) {
      console.error('Broadcast Error', error);
      return;
    }
    const update = {};
    const model = live(URI);
    forOwn(event.body, function (value, key) {
      // Update model if this instance of storage knows that the model waits for it
      const isWaiting = contains(waiting, key);

      // Or if the model has a potentially outdated value in the live cache
      const hasKey = model.get(key) !== undefined;

      if (isWaiting || hasKey) update[key] = value;
      if (isWaiting) remove(waiting, key);
    });
    model.update(update);
  }

  let broadcastSubscription;
  const regExp = exports.matches = new RegExp(`^${URI}$`);
  let registered;

  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'init', onInit);
    live.subscribe(regExp, 'wait', onWait);
    live.subscribe(regExp, 'publish', onPublish);
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'init', onInit);
    live.unsubscribe(regExp, 'wait', onWait);
    live.unsubscribe(regExp, 'publish', onPublish);

    if (broadcastSubscription) {
      broadcastSubscription.cancel();
      broadcastSubscription = null;
    }
    waiting.length = 0;
  };

  exports._endpoints = endpoints;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"./util/cosmos":408,"mout/array/combine":775,"mout/array/contains":776,"mout/array/remove":785,"mout/object/forOwn":810}],373:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/client
   */
  'use strict';

  const live = require('../live');
  const bridge = require('./util/bridge').request;
  const liburi = require('spotify-liburi');

  const BACKOFF = 100;

  function updateCurrentUser(model) {
    model.update({
      currentUser: {
        uri: "spotify:app:bookmark",
        name: "Bookmark",
        username: "bookmark"
      }
    });
  }

  function updateSessionData(model) {
    bridge('session_query', [], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // Not all the clients expose employee property so it needs to be set if it does not exist
      if (payload.employee === undefined) {
        if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
          // For Zelda
          payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
        } else {
          // Clients older than 0.9.16 do not expose employee flag.
          payload.employee = false;
        }
      }

      model.update({ session: payload });

      // Initiate session subscription since data has been requested once.
      bridgeWaitSession(model);
    });
  }

  let registered;

  function bridgeWaitSession(model) {
    bridge('session_event_wait', [], function (error, event) {
      if (!registered) return;
      if (error) {
        setTimeout(function () {
          bridgeWaitSession(model);
        }, BACKOFF);
        if (global.console) console.error(error);
        return;
      }

      if (event.type === 'change') {
        model.get('session').update(event.data);
      }

      bridgeWaitSession(model);
    });
  }

  function showContextMenu(model, data) {
    if (global === window && window.top && window.top.postMessage) {
      window.top.postMessage({
        type: 'client_show_context_ui',
        data: data
      }, '*');
    }
  }

  function onWait(model, properties) {
    if (properties.indexOf('currentUser') > -1) {
      updateCurrentUser(model);
    }

    if (properties.indexOf('session') > -1) {
      updateSessionData(model);
    }
  }

  function onInit(model) {
    // Get container_features and put it into it's own place on the client model.
    const __spotify = global.__spotify || {};
    const containerFeatures = live(__spotify.container_features || {});
    containerFeatures.on('wait', function (properties) {
      const update = {};
      for (let i = 0; i < properties.length; i++) {
        const property = properties[i];
        update[property] = false;
      }
      containerFeatures.update(update);
    });

    model.update({
      containerFeatures: containerFeatures
    });

    // Grab the username from __spotify where available
    const username = "Bookmark";
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });

    // Async fetch from bridge to complete currentUser to a user model
    // while we don't have all the info available elsewhere.
    updateCurrentUser(model);
  }

  const regExp = exports.matches = /^spotify:client$/;

  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'wait', onWait);
    live.subscribe(regExp, 'init', onInit);
    live.subscribe(regExp, 'show-context-menu', showContextMenu);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);
    live.unsubscribe(regExp, 'init', onInit);
    live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"./util/bridge":406,"spotify-liburi":1282}],374:[function(require,module,exports){
  'use strict';

  const live = require('../live');
  const cosmos = require('./util/cosmos');

  function onWait(model) {
    cosmos.get({
      url: 'sp://core-show/unstable/decorate',
      body: { items: [model.uri] }
    }, function (error, data) {
      if (error) throw error;

      const items = data.body.items[model.uri];
      items.show.uri = items.show.link;
      model.update(items);
    });
  }

  const regExp = exports.matches = /^spotify:episode:[^:]+$/;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);
  };

  },{"../live":413,"./util/cosmos":408}],375:[function(require,module,exports){
  'use strict';

  var _live = require('../live');

  var _live2 = _interopRequireDefault(_live);

  var _bridge = require('../bridge');

  var _playlistUtils = require('../playlist-utils');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const CORE_FEEDBACK_ENDPOINT = 'sp://feedback/v1/feedback';
  let feedbackSubscriptionCancel;

  function onFeedbackSuccess(err, data) {
    if (err || !data) return;

    const feedbackUri = _playlistUtils.formatListUtils.makeFeedbackUri(data.context_uri, data.uri);

    let thumb = null;
    switch (data.type) {
      case 'like':
        thumb = 'up';
        break;
      case 'dislike':
        thumb = 'down';
        break;
      case 'delete':
      default:
        break;
    }
    (0, _live2.default)(feedbackUri).update({
      thumb
    });
  }

  exports.register = function () {
    feedbackSubscriptionCancel = (0, _bridge.cosmosJSON)({ method: 'SUB', uri: CORE_FEEDBACK_ENDPOINT }, onFeedbackSuccess);
  };

  exports.unregister = function () {
    feedbackSubscriptionCancel();
    feedbackSubscriptionCancel = null;
  };

  },{"../bridge":121,"../live":413,"../playlist-utils":445}],376:[function(require,module,exports){
  'use strict';

  const album = require('./album');
  const application = require('./application');
  const artist = require('./artist');
  const client = require('./client');
  const clientStorage = require('./client-storage');
  const sessionStorage = require('./session-storage');
  const player = require('./player');
  const playlist = require('./playlist');
  const sortlist = require('./sortlist');
  const track = require('./track');
  const user = require('./user');
  const add = require('./add');
  const localFiles = require('./local-files');
  const listVariant = require('./list-variant');
  const episode = require('./episode');
  const show = require('./show');
  const feedback = require('./feedback');

  exports.register = function () {
    album.register();
    application.register();
    artist.register();
    client.register();
    clientStorage.register();
    sessionStorage.register();
    player.register();
    playlist.register();
    sortlist.register();
    track.register();
    user.register();
    add.register();
    localFiles.register();
    listVariant.register();
    episode.register();
    show.register();
    feedback.register();
  };

  exports.unregister = function () {
    album.unregister();
    application.unregister();
    artist.unregister();
    client.unregister();
    clientStorage.unregister();
    sessionStorage.unregister();
    player.unregister();
    playlist.unregister();
    sortlist.unregister();
    track.unregister();
    user.unregister();
    add.unregister();
    localFiles.unregister();
    listVariant.unregister();
    episode.unregister();
    show.unregister();
    feedback.unregister();
  };

  },{"./add":362,"./album":369,"./application":370,"./artist":371,"./client":373,"./client-storage":372,"./episode":374,"./feedback":375,"./list-variant":377,"./local-files":378,"./player":383,"./playlist":387,"./session-storage":388,"./show":389,"./sortlist":397,"./track":404,"./user":405}],377:[function(require,module,exports){
  /**
   * @module live-models/list-variant
   */
  'use strict';

  var _contains = require('mout/array/contains');

  var _contains2 = _interopRequireDefault(_contains);

  var _unplayableTracksPlaylistSetting = require('./util/unplayable-tracks-playlist-setting.js');

  var _unplayableTracksPlaylistSetting2 = _interopRequireDefault(_unplayableTracksPlaylistSetting);

  var _legacySortUris = require('./sorting/legacy-sort-uris');

  var _legacySortUris2 = _interopRequireDefault(_legacySortUris);

  var _live = require('../live');

  var _live2 = _interopRequireDefault(_live);

  var _liveSortUri = require('../live-sort-uri');

  var _liveSortUri2 = _interopRequireDefault(_liveSortUri);

  var _liveFilterUri = require('../live-filter-uri');

  var _liveFilterUri2 = _interopRequireDefault(_liveFilterUri);

  var _playlistUtils = require('../playlist-utils');

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const SESSION_STORAGE = 'spotify:session-storage';
  const CLIENT_STORAGE = 'spotify:client-storage';
  const SORT_VARIANT_KEY = 'list-variant-';
  const STRING_FILTER_KEY = 'list-filter-string-';

  function onWait(model, properties) {
    if (!(0, _contains2.default)(properties, 'listVariant')) {
      return;
    }

    const uri = getOriginUri(model.uri);

    // listVariant objects are shared amongst all variants.
    let listVariant = (0, _live2.default)(uri).get('listVariant');
    if (!listVariant) {
      listVariant = (0, _live2.default)({
        origin: {
          uri: uri
        }
      });
      listVariant.on('wait', onVariantWait.bind(null, listVariant));
    }

    model.update({ listVariant: listVariant });

    // If the model is a variant, set that list variant on the origin too
    // so it can be accessed there for the next variant to ask.
    if (uri !== model.uri) {
      (0, _live2.default)(uri).update({ listVariant: listVariant });
    }
  }

  function onVariantWait(model, properties) {
    if ((0, _contains2.default)(properties, 'currentUri')) {
      addAndWatchCurrentUri(model);
      // This will fulfill and watch all other properties
      return;
    }

    if ((0, _contains2.default)(properties, 'filterString')) {
      addAndWatchFilterString(model);
    }
    if ((0, _contains2.default)(properties, 'sortQuery') || (0, _contains2.default)(properties, 'sortDirection') || (0, _contains2.default)(properties, 'sortUri')) {
      addAndWatchSortQuery(model);
    }
    if ((0, _contains2.default)(properties, 'showUnplayable')) {
      addAndWatchUnplayable(model);
    }
  }

  function addAndWatchCurrentUri(model) {
    model.on('update', update);
    update();

    function update() {
      const props = 'filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)';
      model.query(props, function (error, data) {
        if (error) {
          console.error('Error when getting', props, ':', Error);
          return;
        }

        let result = data.origin.uri;
        const filters = [];

        if (data.filterString) {
          filters.push(`text contains ${encodeURIComponent(data.filterString)}`);
        }

        if (!data.showUnplayable) {
          filters.push('playable eq true');
        }

        if (filters.length) {
          result = _liveFilterUri2.default.create(result, filters.join(','));
        }

        const sortUriParams = data.sortUri && _liveSortUri2.default.parse(data.sortUri);

        if (sortUriParams) {
          result = _liveSortUri2.default.create(result, sortUriParams.direction, sortUriParams.query);
        }

        model.update({
          currentUri: result
        });
      });
    }
  }

  function addAndWatchUnplayable(model) {
    const uri = model.get('origin').uri;

    if (!_spotifyLiburi2.default.isPlaylistV1OrV2(uri)) {
      model.update({ showUnplayable: true });
      return;
    }

    (0, _live2.default)(uri).get('formatListType', function (error, formatListType) {
      if (error || formatListType !== 'chart') {
        subscribeToUnplayablePref(model);
      } else {
        model.update({ showUnplayable: true });
      }
    });
  }

  let showUnplayablePref;
  let updateUnavailablePrefOn = [];

  function subscribeToUnplayablePref(model) {
    updateUnavailablePrefOn.push(model);
    if (showUnplayablePref) {
      model.update({ showUnplayable: showUnplayablePref });
      return;
    }

    _unplayableTracksPlaylistSetting2.default.subscribe(function (error, showUnplayable) {
      let newShowUnplayable = showUnplayable;

      // Cache this globally as we will never cancel this subscribe here.
      // The same setting is valid for all models.
      if (error) {
        console.error(error);
        newShowUnplayable = false; // Should default to hide unplayable.
      }

      showUnplayablePref = newShowUnplayable;
      for (let i = 0; i < updateUnavailablePrefOn.length; i++) {
        updateUnavailablePrefOn[i].update({ showUnplayable: newShowUnplayable });
      }
    });
  }

  exports.getSortVariantKey = function (uri) {
    return SORT_VARIANT_KEY + uri;
  };

  function fetchSortVariantByUri(uri) {
    return new Promise((resolve, reject) => (0, _live2.default)(CLIENT_STORAGE).get(exports.getSortVariantKey(uri), (error, variant) => {
      if (error) reject(error);else resolve(variant);
    }));
  }

  async function addAndWatchSortQuery(model) {
    const uri = model.get('origin').uri;
    const clientStorage = (0, _live2.default)(CLIENT_STORAGE);
    const key = exports.getSortVariantKey(uri);

    if (clientStorage.get('implemented')) {
      if (_spotifyLiburi2.default.isPlaylistV2(uri)) {
        const variant = await fetchSortVariantByUri(uri);
        if (!variant) {
          // This Playlist V2 URI didn't have any variant saved – let's check if
          // its V1 equivalent has!
          const oldVariant = await fetchSortVariantByUri((await (0, _playlistUtils.fetchPlaylistV1UriFromPlaylist)(uri)));
          if (oldVariant) {
            // Oh, its V1 equivalent had a saved variant – let's port it over to
            // the V2 URI
            clientStorage.publish({
              [key]: oldVariant
            });
          }
        }
      }

      updateSortParams(model, uri, key);
      clientStorage.on('update', function (changed) {
        if (changed.hasOwnProperty(key)) {
          updateSortParams(model, uri, key);
        }
      });
    } else {
      // There is no clientStorage. Update the model with defaults.
      const update = getDefaultQueryParams(uri);
      model.update(update);
    }
  }

  function updateSortParams(model, uri, key) {
    const clientStorage = (0, _live2.default)(CLIENT_STORAGE);

    clientStorage.get(key, function (error, variant) {
      // Respond with the sort variant if it's a valid sort URI
      const sortParams = variant && _liveSortUri2.default.parse(variant);
      if (!error && sortParams) {
        // Check for legacy sort URIs and convert them by publishing
        // the updated version on client-storage
        const convertedFromLegacy = _legacySortUris2.default.legacyQueries[sortParams.query];

        if (convertedFromLegacy && convertedFromLegacy !== sortParams.query) {
          // Fix the legacy query on storage
          const fixedUri = _liveSortUri2.default.create(uri, sortParams.direction, convertedFromLegacy);
          const publish = {};
          publish[key] = fixedUri;
          clientStorage.publish(publish);
          // This will trigger another update which will then set the sort params.
          return;
        }

        model.update({
          sortQuery: sortParams.query,
          sortDirection: sortParams.direction, // this is 'asc' or 'desc'
          sortUri: variant
        });
      } else if (variant === uri) {
        // This was unsorted.
        model.update({
          sortQuery: null,
          sortDirection: null,
          sortUri: null
        });
      } else {
        // There was nothing valid in store. Update the model with defaults.
        const update = getDefaultQueryParams(uri);
        model.update(update);
      }
    });
  }

  function getDefaultQueryParams(uri) {
    let sortQuery = null;
    let sortDirection = null;
    let sortUri = null;

    const isLocalFiles = uri === 'spotify:internal:local-files';
    if (isLocalFiles) {
      // Local files should be sorted by trackname by default
      sortQuery = 'track(name)';
      sortDirection = 'asc';
      sortUri = _liveSortUri2.default.create(uri, sortDirection, sortQuery);
    }

    return {
      sortQuery: sortQuery,
      sortDirection: sortDirection,
      sortUri: sortUri
    };
  }

  function addAndWatchFilterString(model) {
    const uri = model.get('origin').uri; // The variant object itself doesn't have a uri, this is the one for the list it's about
    const sessionStorage = (0, _live2.default)(SESSION_STORAGE);
    const key = STRING_FILTER_KEY + uri;

    if (sessionStorage.get('implemented')) {
      updateFilterString(model, uri, key);
      sessionStorage.on('update', function (changed) {
        if (changed.hasOwnProperty(key)) {
          updateFilterString(model, uri, key);
        }
      });
    } else {
      model.update({ filterString: '' });
    }
  }

  function updateFilterString(model, uri, key) {
    const sessionStorage = (0, _live2.default)(SESSION_STORAGE);

    sessionStorage.get(key, function (error, value) {
      model.update({ filterString: value || '' });
    }, _live2.default.ASAP);
  }

  function getOriginUri(uri) {
    let newUri = uri;
    const sorted = _liveSortUri2.default.parse(newUri);
    if (sorted) newUri = sorted.originUri;

    const filtered = _liveFilterUri2.default.parse(newUri);
    if (filtered) newUri = filtered.originUri;

    return newUri;
  }

  let registered;

  function updateRegisteredStatus(status) {
    registered = status;
    (0, _live2.default)('spotify:list-variant').update({ implemented: status });
  }

  const regExp = exports.matches = /^spotify:/;
  exports.register = function () {
    if (registered) return;

    _live2.default.subscribe(regExp, 'wait', onWait);
    updateRegisteredStatus(true);
  };

  exports.unregister = function () {
    if (!registered) return;

    updateUnavailablePrefOn = [];
    showUnplayablePref = null;

    _live2.default.unsubscribe(regExp, 'wait', onWait);
    updateRegisteredStatus(false);
  };

  },{"../live":413,"../live-filter-uri":357,"../live-sort-uri":411,"../playlist-utils":445,"./sorting/legacy-sort-uris":391,"./util/unplayable-tracks-playlist-setting.js":410,"mout/array/contains":776,"spotify-liburi":1282}],378:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/local-files
   */
  'use strict';

  const contains = require('mout/array/contains');

  const live = require('../live');
  const listOperations = require('../live-list-operations');
  const liburi = require('spotify-liburi');
  const Range = require('../range2');
  const cosmos = require('./util/cosmos');

  const regExp = /^spotify:internal:local-files$/;

  function onWait(model, properties) {
    if (contains(properties, 'allows')) getAllows(model);
    if (contains(properties, 'rows')) getRows(model);
  }

  function getAllows(model) {
    model.update({
      allows: {
        insertTracks: false,
        removeTracks: false
      }
    });
  }

  function createRows(data) {
    const rows = new Array(data.length);

    for (let i = 0, l = data.length; i < l; i++) {
      const track = data[i];

      setLocalProperty(track);

      // We want timestamp in milliseconds, but the client gives it in seconds.
      const dateAdded = track.dateAdded * 1000;

      const row = {
        uri: getRowUri(track.uri),
        track: track,
        dateAdded: dateAdded
      };

      rows[i] = row;

      delete track.dateAdded;
      delete track.addedBy;
    }

    return rows;
  }

  function setLocalProperty(track) {
    if (track.album && track.album.uri) {
      const albumType = liburi.from(track.album.uri).type;
      track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
    }
    if (track.artists) {
      for (let i = 0, l = track.artists.length; i < l; i++) {
        const artist = track.artists[i];
        if (artist.uri) {
          const artistType = liburi.from(artist.uri).type;
          artist.local = artistType === liburi.Type.LOCAL_ARTIST;
        }
      }
    }
  }

  function getRows(model) {
    cosmos.get({ url: 'sp://local-files/v1/tracks' }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      model.update({
        rows: createRows(response.body)
      });

      cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (subError, subResponse) {
        if (subError) {
          if (global.console) console.error(subError);
        } else {
          onChange(model, subResponse.body);
        }
      });
    });
  }

  function onChange(model, event) {
    switch (event.type) {
      case 'removed':
        onTracksRemoved(model, event.data);
        break;
      case 'added':
        onTracksAdded(model, event.data);
        break;
      case 'moved':
        onTracksMoved(model, event.data);
        break;
      case 'changed':
        onMetadataChanged(model, event.data);
        break;
      default:
        console.error('Unexpected event type', event.type);
        break;
    }
  }

  function onMetadataChanged(model, data) {
    // The positions we get could in some cases be for multiple ranges.
    //
    // We need to remove each range individually, so that we can re-add
    // the same range with updated data right after removing the range.
    // The reason we can't just update rows with new data is that the
    // metadata might cause the row to get a new URI (since local files
    // contain the metadata in the URI).

    const ranges = Range.fromIndices(data.positions);

    let startOfRangeInChangeset = 0;

    for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {
      const range = ranges[rangeIndex];
      const indices = range.toIndices();
      const rangeLength = range.length;
      const tracks = new Array(indices.length);

      for (let i = 0; i < rangeLength; i++) {
        tracks[i] = data.tracks[startOfRangeInChangeset + i];
      }

      // Remove range and re-add it with new data
      const removeOperations = listOperations.getRemoveOperations(indices);
      model.get('rows').update(removeOperations);
      addTracksToList(model, tracks, indices[0]);

      startOfRangeInChangeset += rangeLength;
    }
  }

  function onTracksMoved(model, data) {
    const moveOperations = listOperations.getMoveOperations(data.positions, data.position);
    model.get('rows').update(moveOperations);
  }

  function onTracksRemoved(model, data) {
    const removeOperations = listOperations.getRemoveOperations(data.positions);
    model.get('rows').update(removeOperations);
  }

  function onTracksAdded(model, data) {
    addTracksToList(model, data.tracks, data.position);
  }

  function addTracksToList(model, tracks, index) {
    const rows = createRows(tracks);

    const insertOperations = listOperations.getInsertOperations(rows, index);
    model.get('rows').update(insertOperations);
  }

  let idCounter = 1000;
  function getRowUri(trackUri) {
    return trackUri.replace('spotify:', `spotify:row:${(++idCounter).toString(36)}:`);
  }

  let registered = false;

  exports.register = function () {
    if (registered) return;
    registered = true;
    live.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;
    live.unsubscribe(regExp, 'wait', onWait);
  };

  exports.matches = regExp;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"../live-list-operations":358,"../range2":454,"./util/cosmos":408,"mout/array/contains":776,"spotify-liburi":1282}],379:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.play = play;
  const cosmos = require('../util/cosmos');
  const liburi = require('spotify-liburi');

  function play(contextUri, options, callback) {
    const uriObject = liburi.from(contextUri);

    const type = {
      [liburi.Type.COLLECTION_ALBUM]: 'album',
      [liburi.Type.COLLECTION_ARTIST]: 'artist'
    }[uriObject.type];

    const id = uriObject.getBase62Id();

    const sort = {
      [liburi.Type.COLLECTION_ALBUM]: 'discNumber,trackNumber',
      [liburi.Type.COLLECTION_ARTIST]: 'addTime DESC,discNumber,trackNumber'
    }[uriObject.type];

    const resolverUrl = `sp://core-collection/unstable/@/list/tracks/${type}/${id}/play?sort=${sort}`;
    const postObject = { url: resolverUrl };
    if (options) {
      postObject.body = options;
    }

    cosmos.post(postObject, callback);
  }

  },{"../util/cosmos":408,"spotify-liburi":1282}],380:[function(require,module,exports){
  (function (global){
  'use strict';

  var _liveWrappedUri = require('../../live-wrapped-uri');

  var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

  var _cosmosPlayer = require('./cosmos-player');

  var _cosmosPlayer2 = _interopRequireDefault(_cosmosPlayer);

  var _playerApi = require('./player-api');

  var _playerApi2 = _interopRequireDefault(_playerApi);

  var _playlistResolver = require('./playlist-resolver');

  var playlistResolver = _interopRequireWildcard(_playlistResolver);

  var _collectionResolver = require('./collection-resolver');

  var collectionResolver = _interopRequireWildcard(_collectionResolver);

  var _data = require('./data');

  var _data2 = _interopRequireDefault(_data);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Request to play a list of track URIs.
   *
   * @param {Array.<string>} trackUris Array of track URIs.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Callback function.
   */
  /**
   * @module live-models/player/control
   * @private
   */
  function playTrackUris(tracks, playOptions, callback) {
    _playerApi2.default.play(tracks, playOptions, callback);
  }

  /**
   * Request to play a context through the cosmos track resolver.
   *
   * @param {string} contextUri Context URI.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Optional callback function.
   */
  function playFromResolver(contextUri, playOptions, callback) {
    _playerApi2.default.playFromResolver(contextUri, playOptions, callback);
  }

  /**
   * Play a context directly, only supported on context player
   *
   * @param {Object} context Context object that CP can deal with.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Optional callback function.
   */
  function playContext(context, playOptions, callback) {
    _playerApi2.default.playContext(context, playOptions, callback);
  }

  /**
   * Update the player with a new context without changing what is currently
   * playing.
   *
   * @param {Object} context Context object that CP can deal with.
   * @param {Function=} callback Optional callback function.
   */
  function updateContext(context, callback) {
    _playerApi2.default.updateContext(context, callback);
  }

  /**
   * Request to play a context through the playlist resolver.
   *
   * @param {string} contextUri Context URI.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Optional callback function.
   */
  function playFromPlaylistResolver(contextUri, playOptions, callback) {
    // For playlist playback we don't need to support ranges, so we'll
    // always just pick the first.
    const skipToIndex = {};

    // Todo: This should be cleaned up, we don't need a list of uids because we
    // never need ranges now. We do that stuff using pages.
    if (playOptions.uids) {
      skipToIndex.track_uid = playOptions.uids[0];
    } else if (playOptions.uid) {
      skipToIndex.track_uid = playOptions.uid;
    }

    // Todo: This should be cleaned up, we don't need a list of uids because we
    // never need ranges now. We do that stuff using pages.
    if (playOptions.uris) {
      skipToIndex.track_uri = playOptions.uris[0];
    } else if (playOptions.trackUri) {
      skipToIndex.track_uri = playOptions.trackUri;
    }

    const preparePlayOptions = {};
    if (Object.keys(skipToIndex).length) {
      preparePlayOptions.skip_to_index = skipToIndex;
    }

    const playOrigin = {
      view_uri: _liveWrappedUri2.default.getOriginUri(playOptions.context) || playOptions.context,

      // fills in source_start & source_end
      // example values: browse, playlist-owned-by-self-non-collaborative
      feature_identifier: playOptions.source,

      // fills in referer
      // example values: spotify:app:browse
      referrer_identifier: playOptions.referrerId,

      // fills in referrer version
      feature_version: playOptions.referrerVersion
    };

    const options = {
      prepare_play_options: preparePlayOptions,
      play_origin: playOrigin
    };

    playlistResolver.play(contextUri, options, callback);
  }

  /**
   * Request to play a context through the collection resolver.
   *
   * @param {string} contextUri Context URI.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Optional callback function.
   */
  function playFromCollectionResolver(contextUri, playOptions, callback) {
    const playOrigin = {
      view_uri: _liveWrappedUri2.default.getOriginUri(playOptions.context) || playOptions.context,

      // fills in source_start & source_end
      // example values: browse, playlist-owned-by-self-non-collaborative
      feature_identifier: playOptions.source,

      // fills in referer
      // example values: spotify:app:browse
      referrer_identifier: playOptions.referrerId,

      // fills in referrer version
      feature_version: playOptions.referrerVersion
    };

    const preparePlayOptions = {};
    if (playOptions.index !== null) {
      preparePlayOptions.skip_to = {
        track_index: playOptions.index
      };
    }

    const options = {
      prepare_play_options: preparePlayOptions,
      play_origin: playOrigin
    };

    collectionResolver.play(contextUri, options, callback);
  }

  /**
   * Request to play a single track.
   *
   * @param {string} uri The track URI.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Optional callback function.
   */
  function playTrack(uri, playOptions, callback) {
    playOptions.context = uri;
    playOptions.track = uri;
    playOptions.index = 0;

    playTrackUris([{ uri }], playOptions, callback);
  }

  /**
   * Request to play tracks found in the list of rows.
   *
   * @param {LiveList} rows A live list of rows with tracks.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Optional callback function.
   */
  function playRows(rows, playOptions, callback) {
    const { index, range } = playOptions;

    if (index === null && range) {
      _data2.default.getFirstPlayableRow(rows, range, (error, rowIndex) => {
        if (error) {
          if (global.console) console.error(error);
          if (callback) {
            callback(error);
          }
        } else {
          const tracks = _data2.default.getTracksFromRows(rows);
          playOptions.index = rowIndex;

          playTrackUris(tracks, playOptions, callback);
        }
      });
    } else {
      const tracks = _data2.default.getTracksFromRows(rows);
      playTrackUris(tracks, playOptions, callback);
    }
  }

  /**
   * Request to play artist context.
   *
   * @param {string} contextUri Context URI.
   * @param {Function=} callback Optional callback function.
   */
  function playFromArtist(uri, playOptions, callback) {
    playFromResolver(uri, playOptions, callback);
  }

  /**
   * Request to update the player with tracks from the provided rows list.
   * This will update the player silently without interrupting playback.
   *
   * @param {LiveList} rows A live list of rows with tracks.
   * @param {Object} playOptions An object with play options.
   * @param {Function=} callback Optional callback function.
   */
  function updateWithRows(rows, playOptions, callback) {
    const tracks = _data2.default.getTracksFromRows(rows);

    // Context Player matches on UIDs so let's not provide index
    delete playOptions.index;
    _playerApi2.default.update(tracks, playOptions, callback);
  }

  /**
   * Request to pause the playback.
   *
   * @param {Function=} callback Optional callback function.
   */
  function pause(callback) {
    _playerApi2.default.pause(callback);
  }

  /**
   * Request to resume the playback.
   *
   * @param {Function=} callback Optional callback function.
   */
  function resume(callback) {
    _playerApi2.default.resume(callback);
  }

  /**
   * Request to skip to the previous track.
   *
   * @param {Function=} callback Optional callback function.
   */
  function skipPrev(callback) {
    _cosmosPlayer2.default.skipPrev(callback);
  }

  /**
   * Request to skip to the next track.
   *
   * @param {Function=} callback Optional callback function.
   */
  function skipNext(callback) {
    _cosmosPlayer2.default.skipNext(callback);
  }

  exports.playTrack = playTrack;
  exports.playRows = playRows;
  exports.playFromResolver = playFromResolver;
  exports.playContext = playContext;
  exports.playFromArtist = playFromArtist;
  exports.updateContext = updateContext;
  exports.updateWithRows = updateWithRows;
  exports.pause = pause;
  exports.resume = resume;
  exports.skipPrev = skipPrev;
  exports.skipNext = skipNext;
  exports.playFromPlaylistResolver = playFromPlaylistResolver;
  exports.playFromCollectionResolver = playFromCollectionResolver;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live-wrapped-uri":412,"./collection-resolver":379,"./cosmos-player":381,"./data":382,"./player-api":384,"./playlist-resolver":385}],381:[function(require,module,exports){
  /**
   * @module live-models/player/cosmos-player
   * @private
   */
  'use strict';

  const cosmos = require('../util/cosmos');

  const PLAYER_URI = 'sp://player/v2/main';

  const ACTIONS = {
    PLAY: 'play',
    PAUSE: 'pause',
    RESUME: 'resume',
    UPDATE: 'update',
    SKIP_PREV: 'skip_prev',
    SKIP_NEXT: 'skip_next'
  };

  /**
   * Request to pause the playback.
   *
   * @param {Function=} callback Optional callback function.
   */
  function pause(callback) {
    cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.PAUSE } }, callback);
  }

  /**
   * Request to resume the playback.
   *
   * @param {Function=} callback Optional callback function.
   */
  function resume(callback) {
    cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.RESUME } }, callback);
  }

  /**
   * Request to skip playback back.
   *
   * @param {Function=} callback Optional callback function.
   */
  function skipPrev(callback) {
    cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_PREV } }, callback);
  }

  /**
   * Request to skip playback forward.
   *
   * @param {Function=} callback Optional callback function.
   */
  function skipNext(callback) {
    cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_NEXT } }, callback);
  }

  /**
   * Request to get the current state of the cosmos player.
   *
   * @param {Function} callback Callback function.
   */
  function getState(callback) {
    cosmos.get({ url: PLAYER_URI }, function (error, response) {
      if (error) {
        callback(error);
      } else {
        callback(null, response.body);
      }
    });
  }

  /**
   * Request to get the current state of the cosmos player whenever the player
   * changes.
   *
   * @param {Function} callback Callback function.
   *
   * @return {Object} An object with a method to unsubscribe.
   */
  function subscribe(callback) {
    let subscription = cosmos.subscribe({ url: PLAYER_URI }, function (error, response) {
      if (error) {
        callback(error);
      } else {
        callback(null, response.body);
      }
    });

    return {
      unsubscribe: function () {
        if (!subscription) return;
        subscription.cancel();
        subscription = null;
      }
    };
  }

  exports.pause = pause;
  exports.resume = resume;
  exports.skipPrev = skipPrev;
  exports.skipNext = skipNext;
  exports.getState = getState;
  exports.subscribe = subscribe;

  },{"../util/cosmos":408}],382:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/player/data
   * @private
   */
  'use strict';

  const live = require('../../live');
  const Range = require('../../range2');

  const playerApi = require('./player-api');

  /**
   * Default values for play options.
   */
  const PLAY_OPTIONS_DEFAULTS = {
    page: null,
    uid: null,
    trackUri: null,
    index: null,
    source: 'unknown',
    reason: 'unknown'
  };

  /**
   * Get the first playable row from range in a list of rows.
   *
   * @param {LiveList} rows A live list of rows.
   * @param {Range} range A range object.
   * @param {Function} callback A callback where the second argument is the
   *     index of the first playable row. If no playable track is found, the
   *     index will be the first index in the range.
   */
  function getFirstPlayableRow(rows, range, callback) {
    let index = range.start;

    isRowPlayable(rows.get(index), function playableCallback(error, playable) {
      if (playable) {
        callback(null, index);
      } else {
        if (index === range.end - 1) {
          callback(null, range.start);
        } else {
          isRowPlayable(rows.get(++index), playableCallback);
        }
      }
    });
  }

  /**
   * Check if the row is playable.
   *
   * @param {LiveObject?} row A row live object. If this is falsy, the callback
   *     is returned with false immediately.
   * @param {Function} callback A callback where the second argument is the
   *     boolean flag for playable. The callback may run synchronously or
   *     asynchronously.
   */
  function isRowPlayable(row, callback) {
    if (!row) {
      callback(null, false);
    } else {
      row.query('track(playable)', function (error, data) {
        if (error) {
          callback(error);
        } else {
          callback(null, data.track.playable);
        }
      }, live.ASAP);
    }
  }

  /**
   * Get options for play actions based on a data object and other state
   * like referrer set on the player or application object.
   *
   * @param {Object} data A data object.
   * @param {Function} callback A callback, where the second argument is a data
   *     object with the options.
   */
  function getPlayOptions(data, callback) {
    getReferrer(data, function (error, viewUri, referrerId, featureId) {
      if (error) {
        callback(error);
      } else {
        Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function (key) {
          if (data[key] === undefined) {
            data[key] = PLAY_OPTIONS_DEFAULTS[key];
          }
        });

        if (data.range) {
          data.range = new Range(data.range[0], data.range[1]);
        }

        data.viewUri = viewUri;
        data.referrerId = referrerId;
        data.referrerVersion = getReferrerVersion();
        data.featureId = featureId;

        callback(null, data);
      }
    });
  }

  /**
   * Get a list of track objects from a live list of rows.
   *
   * @param {LiveList} rows A live list of rows.
   *
   * @return {Array.<Object>} Array of track objects. If a row is not set in the
   *     list, or if the row doesn't have a track object with a URI, an
   *     null value will be put in that position in the output array.
   */
  function getTracksFromRows(rows) {
    return rows.map((row, index) => {
      const trackLiveObject = row && row.get('track');
      if (trackLiveObject) {
        const trackData = trackLiveObject.serialize(1);

        const metadata = {};

        if (trackData.manifestId) {
          metadata['media.manifest_id'] = trackData.manifestId;
        }

        if (trackData.mediaTypeEnum) {
          metadata['media.type'] = trackData.mediaTypeEnum === 2 ? 'video' : 'audio';
        }

        return {
          uri: trackData.uri,
          uid: rows.keys[index],
          metadata: metadata
        };
      }

      return null;
    });
  }

  /**
   * Get the latest player state, in the format of the player live model.
   *
   * @param {Function} callback Callback function.
   */
  function getPlayerState(callback) {
    playerApi.getState(callback);
  }

  /**
   * Subscribe to the cosmos player to get the latest player state,
   * in the format of the player live model.
   *
   * @param {Function} callback Callback function.
   * @return {Object} An object with a method to unsubscribe.
   */
  function subscribeForPlayerState(callback) {
    return playerApi.subscribe(callback);
  }

  /**
   * Get the referrer for the player. This is usually the path back to the app in
   * the state where the playback started. It can be set by the user in the `referrer`
   * property of the player live object. If nothing is set there, it will generate
   * the referrer by combining the app URI with the app arguments.
   *
   * @param {Object} data An object with optional data for referrer.
   * @param {Function} callback A callback where the second argument is the referrer.
   */
  function getReferrer(data, callback) {
    const referrer = live('spotify:player').get('referrer');
    const referrerBaseUri = live('spotify:player').get('referrerBaseUri');
    if (referrer) {
      if (!referrerBaseUri) {
        console.warn(`referrer field is set on the player model (${referrer}), but referrerBaseUri isn't`);
      }
      callback(null, referrer, referrerBaseUri || '', '');
    } else {
      if (!data.viewUri || !data.referrerId) {
        live('spotify:application').get('appURI', 'arguments', function (error, appUri, args) {
          if (error) {
            callback(error);
          } else {
            const viewUri = data.viewUri || (args ? `${appUri}:${args}` : appUri);
            const referrerId = appUri;
            const featureId = '';
            callback(null, viewUri, referrerId, featureId);
          }
        });
      } else {
        callback(null, data.viewUri, data.referrerId, data.featureId);
      }
    }
  }

  /**
   * Get the referrer version. This is usually the version of the app. It can be set
   * by the user in the `version` property of the application live object. If nothing
   * is set there, it will use the default version '0.0.0'.
   *
   * @return {string} The version string.
   */
  function getReferrerVersion() {
    return '0.0.0';
  }

  exports.getReferrer = getReferrer;
  exports.getReferrerVersion = getReferrerVersion;
  exports.getFirstPlayableRow = getFirstPlayableRow;
  exports.isRowPlayable = isRowPlayable;
  exports.getPlayOptions = getPlayOptions;
  exports.getTracksFromRows = getTracksFromRows;
  exports.getPlayerState = getPlayerState;
  exports.subscribeForPlayerState = subscribeForPlayerState;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live":413,"../../range2":454,"./player-api":384}],383:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/player
   */
  'use strict';

  var _messageProxy = require('../../../libs/message-proxy');

  const live = require('../../live');
  const URI = require('spotify-liburi');
  const CancellationTokenSource = require('../../../libs/cancellation-token-source').default;

  const playerApi = require('./player-api');
  const playbackControl = require('./control');
  const dataUtils = require('./data');
  const updatesUtils = require('./updates');
  const sortUriUtils = require('../../live-sort-uri');
  const filterUriUtils = require('../../live-filter-uri');
  const createStationPlayContext = require('../station/create-play-context');
  const createStationPlayOptions = require('../station/create-play-options');
  const isStationUri = require('../station').isStationUri;

  const TYPE_TRACK = 'track';
  const TYPE_ROWS = 'rows';
  const TYPE_CP_RESOLVER_PLAYLIST = 'context-player-resolver-playlist';
  const TYPE_CP_RESOLVER_COLLECTION = 'context-player-resolver-collection';
  const TYPE_CP_CONTEXT = 'context-player-context';
  const TYPE_CONTEXT_OBJECT = 'context-object';
  const TYPE_STATION_CONTEXT = 'context-station-context';
  const TYPE_CP_ARTIST_CONTEXT = 'context-player-artist';
  const TYPE_CP_ALBUM_CONTEXT = 'context-player-album';
  const TYPE_CONTEXT_EPISODE = 'context-episode';
  const TYPE_CONTEXT_SHOW = 'context-show';

  const cancellationTokenSource = new CancellationTokenSource();

  // This data store will keep context objects keyed by context URI. The values
  // are context objects in the format of spotify-player Context:
  // https://ghe.spotify.net/spotify-sdk/spotify-player/blob/master/lib/v2/types.js#L164
  const contextDataStore = {};

  /**
   * Handler for when properties are requested from the model.
   *
   * @param {LiveObject} model The player live object.
   */
  function onWait(model) {
    updateState(model);
  }

  /**
   * Handler for when the model needs to be updated by polling the player.
   *
   * @param {LiveObject} model The player live object.
   */
  function onSync(model) {
    updateState(model);
  }

  /**
   * Handler for when the real player is updated.
   *
   * @param {Error?} error An error object, or null.
   * @param {Object} data Data object in the format of this live model.
   */
  function onPlayerStateUpdate(error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    const model = live('spotify:player');
    if (model.get('pending')) return;
    model.update(data);
  }

  /**
   * Handler for when the model receives the 'update' event.
   *
   * @param {LiveObject} model The player live object.
   */
  function onUpdate(model) {
    const index = model.get('index') && model.get('index').get('track');
    if (index !== null) {
      updatesUtils.setPlayingIndex(index);
    }

    updatesUtils.clean(model);
  }

  /**
   * Handler for when the model receives the 'play' event.
   *
   * @param {LiveObject} model The player live object.
   * @param {Object} event The event object with data about what to play.
   *     Can contain the following properties:
   *       `context` (string, context URI)
   *       `index` (number, index within context to play)
   *       `uid` (string, uid within context to play)
   *       `page` (number, index for the context player page)
   *       `range` (array of two values, start and end index)
   *       `uids` (array of uids representing an index or a range)
   *       `uris` (array of uris connected to the uids)
   *       `source` (string)
   *       `reason` (string)
   */
  function onPlay(model, event) {
    const context = event.context;
    if (!context) return;

    // The `index` property might be `null`, which should mean that no specific
    // index should be played.
    if (typeof event.index !== 'number') {
      delete event.index;
    }

    // Cancel all previous play/update context requests
    cancellationTokenSource.cancel();
    const cancellationToken = cancellationTokenSource.token();

    // Update the model optimistically
    model.update(playerApi.addContext({
      isPlaying: true,
      isPaused: false,
      index: event.index === undefined ? null : { page: 0, track: event.index },
      track: event.trackUri === undefined ? null : { uri: event.trackUri },
      contextUpdatedCrossFrame: false
    }, context));

    // Get options for the play action based on event data and other state
    // Todo: getPlayOptions creates options that fit the cosmos/v1 implementation.
    // We could probably do this a bit later from cosmos-player.js
    dataUtils.getPlayOptions(event, function (error, options) {
      if (error || !options.context) {
        updateState(model); // Revert state
      } else {
        // Canonical contexts can have sorted and/or filtered state that needs
        // to be respected client-wide. We therefore query for the correct variant
        // to be played.
        // For spotify:internal uris on the other hand, we don't look for variants.
        // This would also be the case for contexts that already represent variants.
        // Please see docs for details.
        if (/^spotify:internal:/.test(options.context)) {
          playWithOptions(model, cancellationToken, options);
        } else {
          if (live('spotify:list-variant').get('implemented')) {
            live(options.context).query('listVariant(currentUri, sortUri)', function (queryError, data) {
              if (queryError) {
                updateState(model); // Revert state
              } else {
                // Abort if a new play request has happened since this request started
                if (!cancellationToken.isCanceled()) {
                  options.context = data.listVariant.currentUri;
                  playWithOptions(model, cancellationToken, options);
                }
              }
            });
          } else {
            playWithOptions(model, cancellationToken, options);
          }
        }
      }
    });
  }

  /**
   * Handler for when the model receives the 'pause' event.
   *
   * @param {LiveObject} model The player live object.
   */
  function onPause(model) {
    if (model.get('isPlaying') === false || model.get('isPaused') === true) {
      return;
    }

    model.update({ isPaused: true });

    playbackControl.pause(function (error) {
      if (error) {
        model.update({ isPaused: false });
      }
    });
  }

  /**
   * Handler for when the model receives the 'resume' event.
   *
   * @param {LiveObject} model The player live object.
   */
  function onResume(model) {
    if (model.get('isPlaying') === true && model.get('isPaused') === false) {
      return;
    }

    model.update({ isPaused: false });

    playbackControl.resume(function (error) {
      if (error) {
        model.update({ isPaused: true });
      }
    });
  }

  /**
   * Handler for when the model receives the 'skip-previous' event.
   *
   * @param {LiveObject} model The player live object.
   */
  function onSkipPrev() {
    // Skip prev often starts playback, but not when you're on the first track.
    // Therefor no optimistic update of 'playing' here.
    playbackControl.skipPrev();
  }

  /**
   * Handler for when the model receives the 'skip-next' event.
   *
   * @param {LiveObject} model The player live object.
   */
  function onSkipNext() {
    // Skip next often starts playback, but not when you're on the last track.
    // Therefor no optimistic update of 'playing' here.
    playbackControl.skipNext();
  }

  /**
   * Handler for when the model receives the 'update-context' event.
   *
   * @param {LiveObject} model The player live object.
   * @param {Object} event An event object with a `context` property (string).
   */
  function onUpdateContext(model, event) {
    const contextUri = event.context;
    if (!contextUri) return;

    // Cancel all previous play/update context requests
    cancellationTokenSource.cancel();
    const cancellationToken = cancellationTokenSource.token();

    const currentIndex = model.get('index') && model.get('index').get('track');
    const currentContext = model.get('variant');

    // Update player model optimistically with context and no index.
    // We can't know the index yet, so we must set it to nothing to
    // not get wrong highlights.
    model.update(playerApi.addContext({
      index: null,
      pending: true,
      contextUpdatedCrossFrame: false
    }, contextUri));

    // We need the rows list to be able to get the index and play the list.
    live(contextUri).get('rows', function (error, rowsList) {
      if (error) {
        model.update({ pending: false });
        if (global.console) console.error(error);
        return;
      }

      const options = { context: contextUri };
      dataUtils.getPlayOptions(options, function (playOptionsError, playOptions) {
        // Abort if a new play request has happened since this request started
        if (cancellationToken.isCanceled()) {
          return;
        }

        // Store which row is currently playing, so that we can get the index
        // of the playing row in another list.
        updatesUtils.setPlayingIndex(currentIndex, currentContext.get('rows'));

        // Find the index of the currently playing track in new list, to do an
        // optimistic update. This is not optional, since the actual player only appends
        // the next context and will not send an update until the next skip.
        // (If it does, because of play/pause for example, it will still report the old
        // list that we're not showing in the UI)

        // At the same time, find the index that we will use to actually update the playback
        const updateIndices = updatesUtils.getPlayingAndUpdateIndicesInList(rowsList);
        playOptions.index = updateIndices.update;
        if (updateIndices.playing !== null) {
          model.update({ index: { page: 0, track: updateIndices.playing } });
        }

        if (model.get('playOrigin') && model.get('playOrigin').get('referrerIdentifier') !== playOptions.referrerId) {
          model.update({ contextUpdatedCrossFrame: true });
        }

        playbackControl.updateWithRows(rowsList, playOptions, function () {
          model.update({ pending: false });
          // The state is updated both for success and error cases.
          updateState(model);
        });

        updatesUtils.listen(rowsList, playOptions, function (updateOptions) {
          playbackControl.updateWithRows(rowsList, updateOptions, function (updateError) {
            if (updateError) {
              updateState(model); // Revert state
            }
          });
        });
      });
    });
  }

  /**
   * Handler for when the model receives the 'update-show-context' event.
   *
   * @param {LiveObject} model The player live object.
   * @param {Object} event An event object with a `context` property (string).
   */
  function onUpdateShowContext(model, event) {
    const contextUri = event.context;
    if (!contextUri) return;

    // Cancel all previous play/update context requests
    cancellationTokenSource.cancel();
    const cancellationToken = cancellationTokenSource.token();

    // Update player model optimistically with context and no index.
    // We can't know the index yet, so we must set it to nothing to
    // not get wrong highlights.
    model.update(playerApi.addContext({}, contextUri));

    const showQueryTimeout = 3000;
    live(contextUri).query('show(name, uri), rows(track(uri, name, mediaTypeEnum))', (error, data) => {
      // Abort if a new play request has happened since this request started
      if (cancellationToken.isCanceled()) {
        return;
      } else if (error) {
        updateState(model); // Revert state
      } else {
        const context = {
          uri: data.show.uri,
          pages: [{
            tracks: data.rows.map(({ track }) => ({
              uri: track.uri,
              uid: track.uri,
              metadata: {
                'title': track.name,
                'album_title': data.show.name,
                'media.type': track.mediaTypeEnum === 1 ? 'audio' : 'video',
                // manifestId is not specifically queried above, since audio
                // tracks don't have that property, so it would then just stall on
                // that query. Querying for anything for the show will request all
                // the show data, so it should be available anyway.
                'media.manifest_id': live(track.uri).get('manifestId') || ''
              }
            }))
          }],
          metadata: {
            'zelda.context_uri': contextUri
          }
        };

        playbackControl.updateContext(context, updateContextError => {
          if (updateContextError) {
            updateState(model); // Revert state
          }
        });
      }
    }, showQueryTimeout);
  }

  /**
   * Request to start playback based on passed options.
   * If the request fails, it will revert the player model to the latest
   * state.
   *
   * @param {LiveObject} model The player live object.
   * @param {CancellationToken} cancellationToken
   * @param {Object} options Object with options and data of what to play.
   */
  function playWithOptions(model, cancellationToken, options) {
    const contextUri = options.context;
    const resolverType = getPlaybackResolverType(contextUri);

    if (resolverType === TYPE_TRACK) {
      playbackControl.playTrack(contextUri, options, function (error) {
        if (error) {
          updateState(model); // Revert state
        }
      });
    } else if (resolverType === TYPE_CP_ALBUM_CONTEXT) {
      playbackControl.playFromResolver(contextUri, options, function (error) {
        if (error) {
          updateState(model); // Revert state
        }
      });
    } else if (resolverType === TYPE_ROWS) {
      const isSortedList = sortUriUtils.isValid(contextUri);

      // If it's a sorted list that is played by rows, we want to request all the track
      // URIs of the sorted list and then play that list of tracks. We will wait for all
      // tracks to be fetched and sorted, to allow clicking play on a media object in
      // Browse for example and have it play the stored sorted variant of the playlist.
      if (isSortedList) {
        getSortedRows(contextUri, function (error, rowsList) {
          if (error) {
            updateState(model); // Revert state
          } else {
            // Abort if a new play request has happened since this request started
            if (!cancellationToken.isCanceled()) {
              playRows(model, rowsList, options);
            }
          }
        });

        // Play any other context from the rows list
      } else {
        live(contextUri).query('rows(track(uri))', function (err) {
          if (!err && !cancellationToken.isCanceled()) {
            playRows(model, live(contextUri).get('rows'), options);
          }
        });
      }
    } else if (resolverType === TYPE_CP_RESOLVER_PLAYLIST) {
      playbackControl.playFromPlaylistResolver(contextUri, options, function (error) {
        if (error) {
          updateState(model); // Revert state
        }
      });
    } else if (resolverType === TYPE_CP_RESOLVER_COLLECTION) {
      playbackControl.playFromCollectionResolver(contextUri, options, function (error) {
        if (error) {
          updateState(model); // Revert state
        }
      });
    } else if (resolverType === TYPE_CONTEXT_OBJECT) {
      const context = contextDataStore[contextUri];
      playbackControl.playContext(context, options, function (error) {
        if (error) {
          updateState(model); // Revert state
        }
      });
    } else if (resolverType === TYPE_CP_CONTEXT) {
      const context = {
        url: `context://${contextUri}`,
        entity_uri: contextUri
      };

      playbackControl.playContext(context, options, function (error) {
        if (error) {
          updateState(model); // Revert state
        }
      });
    } else if (resolverType === TYPE_STATION_CONTEXT) {
      const station = live(contextUri);
      station.query('rows', function (err) {
        if (!err) {
          playbackControl.playContext(createStationPlayContext(station), createStationPlayOptions(station, options), function (error) {
            if (error) {
              updateState(model); // Revert state
            }
          });
          // Post message to create station in zlink
          (0, _messageProxy.messageProxy)({
            method: 'POST',
            uri: 'station-create',
            target: 'top',
            body: { stationUri: contextUri }
          });
        }
      });
    } else if (resolverType === TYPE_CP_ARTIST_CONTEXT) {
      playbackControl.playFromArtist(contextUri, options, function (error) {
        if (error) {
          updateState(model); // Revert state
        }
      });
    } else if (resolverType === TYPE_CONTEXT_EPISODE) {
      const episodeQueryTimeout = 3000;

      live(contextUri).query('name, mediaTypeEnum, show(name)', function (error, data) {
        if (error) {
          updateState(model); // Revert state
        } else {
          const context = {
            uri: contextUri,
            pages: [{
              tracks: [{
                uri: contextUri,
                metadata: {
                  'title': data.name,
                  'album_title': data.show.name,
                  'media.type': data.mediaTypeEnum === 1 ? 'audio' : 'video',
                  'media.manifest_id': live(contextUri).get('manifestId') || ''
                }
              }]
            }],
            restrictions: {
              disallow_toggling_repeat_context_reasons: ['disallow-video'],
              disallow_toggling_repeat_track_reasons: ['disallow-video'],
              disallow_toggling_shuffle_reasons: ['disallow-video']
            }
          };

          if (!options.player_options_override) {
            options.player_options_override = {};
          }
          // Avoid repeating context when playing episode
          // This might be removed in future when we have proper shows support
          options.player_options_override.repeating_context = false;
          options.player_options_override.repeating_track = false;

          playbackControl.playContext(context, options, function (playContextError) {
            if (playContextError) {
              updateState(model); // Revert state
            }
          });
        }
      }, episodeQueryTimeout);
    } else if (resolverType === TYPE_CONTEXT_SHOW) {
      const showQueryTimeout = 3000;
      live(contextUri).query('show(name, uri), rows(track(uri, name, mediaTypeEnum))', (error, data) => {
        if (error) {
          updateState(model); // Revert state
        } else {
          const context = {
            uri: data.show.uri,
            pages: [{
              tracks: data.rows.map(({ track }) => ({
                uri: track.uri,
                uid: track.uri,
                metadata: {
                  'title': track.name,
                  'album_title': data.show.name,
                  'media.type': track.mediaTypeEnum === 1 ? 'audio' : 'video',

                  // manifestId is not specifically queried above, since audio
                  // tracks don't have that property, so it would then just stall on
                  // that query. Querying for anything for the show will request all
                  // the show data, so it should be available anyway.
                  'media.manifest_id': live(track.uri).get('manifestId') || ''
                }
              }))
            }],
            restrictions: {
              disallow_toggling_repeat_context_reasons: ['disallow-show'],
              disallow_toggling_repeat_track_reasons: ['disallow-show'],
              disallow_toggling_shuffle_reasons: ['disallow-show']
            },
            metadata: {
              'zelda.context_uri': contextUri
            }
          };

          if (!options.player_options_override) {
            options.player_options_override = {};
          }

          options.player_options_override.repeating_context = false;
          options.player_options_override.repeating_track = false;
          options.player_options_override.shuffling_context = false;

          playbackControl.playContext(context, options, playContextError => {
            if (playContextError) {
              updateState(model); // Revert state
            }
          });
        }
      }, showQueryTimeout);
    }
  }

  /**
   * Request to start playback based on passed rows list and options.
   * If the request fails, it will revert the player model to the latest
   * state.
   *
   * @param {LiveObject} model The player live object.
   * @param {LiveList} rowsList The rows live list.
   * @param {Object} options Object with options and data of what to play.
   */
  function playRows(model, rowsList, options) {
    playbackControl.playRows(rowsList, options, function (error) {
      if (error) {
        updateState(model); // Revert state
      }

      updatesUtils.listen(rowsList, options, function (updateOptions) {
        playbackControl.updateWithRows(rowsList, updateOptions, function (updateError) {
          if (updateError) {
            updateState(model); // Revert state
          }
        });
      });
    });
  }

  /**
   * Get the type of playback resolver to use for a certain context URI.
   *
   * @param {string} contextUri Context URI.
   *
   * @return {string} A resolver type.
   */
  function getPlaybackResolverType(contextUri) {
    const contextType = URI.from(contextUri).type;

    const isTrack = contextType === URI.Type.TRACK;
    const isLocal = contextType === URI.Type.LOCAL;
    const isPlaylist = contextType === URI.Type.PLAYLIST || contextType === URI.Type.PLAYLIST_V2;
    const isCollectionAlbum = contextType === URI.Type.COLLECTION_ALBUM;
    const isCollectionArtist = contextType === URI.Type.COLLECTION_ARTIST;
    const isPlaylistFolder = contextType === URI.Type.FOLDER;
    const isArtist = contextType === URI.Type.ARTIST;
    const isAlbum = contextType === URI.Type.ALBUM;
    const isSortedList = sortUriUtils.isValid(contextUri);
    const isFilteredList = filterUriUtils.isValid(contextUri);
    const isStation = isStationUri(contextUri);
    const isEpisode = contextType === URI.Type.EPISODE;
    const isShow = contextType === URI.Type.SHOW;

    if (isTrack || isLocal) {
      return TYPE_TRACK;
    }

    if (isPlaylist) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    if (isCollectionAlbum || isCollectionArtist) {
      return TYPE_CP_RESOLVER_COLLECTION;
    }

    if (isPlaylistFolder) {
      return TYPE_CP_CONTEXT;
    }

    if (isStation) return TYPE_STATION_CONTEXT;

    let originUri;

    if (isSortedList) {
      originUri = sortUriUtils.parse(contextUri).originUri;

      // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
      // needs to be taken into account when judging the origin context type.
      if (filterUriUtils.isValid(originUri)) {
        originUri = filterUriUtils.parse(originUri).originUri;
      }

      if (URI.isPlaylistV1OrV2(originUri)) {
        return TYPE_CP_RESOLVER_PLAYLIST;
      }

      if (URI.isShow(originUri)) {
        return TYPE_CONTEXT_SHOW;
      }

      return TYPE_ROWS;
    }

    if (isFilteredList) {
      // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
      // needs to be taken into account when judging the origin context type.
      originUri = filterUriUtils.parse(contextUri).originUri;

      if (URI.isPlaylistV1OrV2(originUri)) {
        return TYPE_CP_RESOLVER_PLAYLIST;
      }

      return TYPE_ROWS;
    }

    if (isEpisode) {
      return TYPE_CONTEXT_EPISODE;
    }

    if (isShow) {
      return TYPE_CONTEXT_SHOW;
    }

    const contextData = contextDataStore[contextUri];
    if (contextData) {
      return TYPE_CONTEXT_OBJECT;
    }

    // If it's a different URI, check if we have rows
    const rowsList = live(contextUri).get('rows');
    if (rowsList && rowsList.length) {
      return TYPE_ROWS;
    }

    // If it's an artist context but context object or rows were not defined
    if (isArtist) {
      return TYPE_CP_ARTIST_CONTEXT;
    }

    if (isAlbum) {
      return TYPE_CP_ALBUM_CONTEXT;
    }

    // This should not happen ;)
    return null;
  }

  /**
   * Get the live list for the rows of the sorted URI.
   *
   * @param {string} sortUri The URI of the sorted list.
   * @param {Function} callback Callback function where second argument is the
   *     sorted live list.
   */
  function getSortedRows(sortUri, callback) {
    const playlistUri = sortUriUtils.getOriginUri(sortUri);

    // Get the rows list for the regular playlist.
    // We could have queried for the track of every row, but by not querying we
    // avoid the conversions from live objects to plain objects.
    live(playlistUri).get('rows', function (error, rows) {
      if (error) {
        callback(error);
      } else {
        // Get the live models for all rows.
        rows.get(0, rows.length, function (rowError) {
          if (rowError) {
            callback(error);
          } else {
            // When we know we have the rows, we can safely sort the list
            live(sortUri).get('rows', function (liveError, rowsList) {
              if (liveError) {
                callback(liveError);
              } else {
                // Finally return the sorted rows list
                callback(null, rowsList);
              }
            });
          }
        });
      }
    });
  }

  /**
   * Update the player model with the current data of the cosmos player model.
   *
   * @param {LiveObject} model The player live object.
   */
  function updateState(model) {
    dataUtils.getPlayerState(function (error, data) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update(data);
    });
  }

  const regExp = exports.matches = /^spotify:player$/;
  let registered;
  let playerSubscription;
  let cancelPlayerErrorSubscription;

  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'play', onPlay);
    live.subscribe(regExp, 'pause', onPause);
    live.subscribe(regExp, 'resume', onResume);
    live.subscribe(regExp, 'skip-previous', onSkipPrev);
    live.subscribe(regExp, 'skip-next', onSkipNext);
    live.subscribe(regExp, 'update-context', onUpdateContext);
    live.subscribe(regExp, 'update-show-context', onUpdateShowContext);
    live.subscribe(regExp, 'update', onUpdate);
    live.subscribe(regExp, 'wait', onWait);
    live.subscribe(regExp, 'sync-position', onSync);

    playerSubscription = dataUtils.subscribeForPlayerState(onPlayerStateUpdate);

    // This is a workaround the fact that some errors aren't reported to the
    // callbacks passed to Player API when we intereact normally with it.
    //
    // Here we observe all errors. If we know, by means of observation, that an
    // error is not being handled properly elsewhere, we revert the live-model
    // state when the error is reported here.
    cancelPlayerErrorSubscription = playerApi.onError(function (error, response) {
      if (error) {
        console.error(error);
        return;
      }
      const body = response.getJSONBody();
      switch (body.error) {
        case 'one_track_unplayable':
        case 'one_track_unplayable_auto_stopped':
        case 'all_tracks_unplayable_auto_stopped':
          // Revert state
          exports._syncPlayerModelState();
          break;
        default:
          break;
      }
    });
  };

  exports._syncPlayerModelState = function () {
    const model = live('spotify:player');
    updateState(model);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'play', onPlay);
    live.unsubscribe(regExp, 'pause', onPause);
    live.unsubscribe(regExp, 'resume', onResume);
    live.unsubscribe(regExp, 'skip-previous', onSkipPrev);
    live.unsubscribe(regExp, 'skip-next', onSkipNext);
    live.unsubscribe(regExp, 'update-context', onUpdateContext);
    live.unsubscribe(regExp, 'update-show-context', onUpdateShowContext);
    live.unsubscribe(regExp, 'update', onUpdate);
    live.unsubscribe(regExp, 'wait', onWait);
    live.unsubscribe(regExp, 'sync-position', onSync);

    playerSubscription.unsubscribe();
    if (cancelPlayerErrorSubscription) {
      cancelPlayerErrorSubscription();
    }
    playerSubscription = null;
  };

  exports.setContextData = function (contextUri, contextData) {
    contextDataStore[contextUri] = contextData;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../../libs/cancellation-token-source":122,"../../../libs/message-proxy":437,"../../live":413,"../../live-filter-uri":357,"../../live-sort-uri":411,"../station":398,"../station/create-play-context":399,"../station/create-play-options":400,"./control":380,"./data":382,"./player-api":384,"./updates":386,"spotify-liburi":1282}],384:[function(require,module,exports){
  (function (global){
  'use strict';

  var _data = require('./data');

  var _data2 = _interopRequireDefault(_data);

  var _cosmos = require('../util/cosmos');

  var _cosmos2 = _interopRequireDefault(_cosmos);

  var _liveSortUri = require('../../live-sort-uri');

  var _liveSortUri2 = _interopRequireDefault(_liveSortUri);

  var _liveFilterUri = require('../../live-filter-uri');

  var _liveFilterUri2 = _interopRequireDefault(_liveFilterUri);

  var _v = require('spotify-player/lib/v2');

  var _v2 = _interopRequireDefault(_v);

  var _spotifyCosmosApi = require('spotify-cosmos-api');

  var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * @module live-models/player/player-api
   * @private
   */
  function getPlayer(optionalPlayOptions, callback) {
    const playOptions = optionalPlayOptions || {};

    _data2.default.getReferrer(playOptions, (error, viewUri, referrerId, featureId) => {
      if (error) {
        callback(error);
        return;
      }

      let featureIdentifier = "bookmark";

      const featureVersion = "0.0.0";

      const options = referrerId ? { referrerIdentifier: referrerId } : null;
      const player = new _v2.default.Player(_spotifyCosmosApi2.default.resolver, viewUri, featureIdentifier, featureVersion, options);
      callback(player);
    });
  }

  function play(tracks, playOptions, callback) {
    getPlayer(playOptions, function (p) {
      const context = {
        pages: [{ tracks }],
        metadata: {
          'zelda.context_uri': playOptions.context
        },
        entity_uri: getOriginUri(playOptions.context)
      };

      const options = {};
      if (typeof playOptions.index === 'number') {
        options.skip_to_index = {
          page: 0,
          track: playOptions.index
        };
      } else if (playOptions.uid || playOptions.uri) {
        options.skip_to = {};
        if (playOptions.uid) {
          options.skip_to.track_uid = playOptions.uid;
        } else if (playOptions.uri) {
          options.skip_to.track_uri = playOptions.uri;
        }
      }

      if (typeof playOptions.seekTo === 'number') {
        options.seek_to = playOptions.seekTo;
      }
      p.play(context, options, callback);
    });
  }

  function playContext(context, playOptions, callback) {
    if (playOptions.uid || playOptions.uri || playOptions.page) {
      playOptions.skip_to = {};
      if (playOptions.uid) {
        playOptions.skip_to.track_uid = playOptions.uid;
      } else if (playOptions.uri) {
        playOptions.skip_to.track_uri = playOptions.uri;
      }

      // Together with UID send page_index property, so Connect can
      // figure out where to look for a track that needs to
      // be played. (Connect doesn't support UIDs at the moment).
      if (playOptions.page) {
        playOptions.skip_to.page_index = playOptions.page;
      }
    } else if (playOptions.range) {
      playOptions.skip_to_index = {
        page: 0,
        track: playOptions.range.start
      };
    } else if (typeof playOptions.index === 'number') {
      playOptions.skip_to_index = {
        page: 0,
        track: playOptions.index
      };
    }

    getPlayer(playOptions, function (p) {
      p.play(context, playOptions || {}, callback);
    });
  }

  function updateContext(context, callback) {
    getPlayer(null, function (p) {
      p.update(context, callback);
    });
  }

  function update(tracks, playOptions, callback) {
    getPlayer(playOptions, function (p) {
      // Todo: When currently playing from the new playlist and folder resolver,
      // uids provided by the core resolver need to be used.

      const context = {
        pages: [{ tracks }],
        metadata: {
          'zelda.context_uri': playOptions.context
        },
        entity_uri: getOriginUri(playOptions.context)
      };

      p.update(context, callback);
    });
  }

  function playFromResolver(contextUri, playOptions, callback) {
    getPlayer(playOptions, player => {
      _cosmos2.default.sanitizeURL(contextUri, (error, uri) => {
        if (error) {
          if (callback) callback(error);
          return;
        }

        const context = {
          uri,
          url: `context://${encodeURI(uri)}`
        };

        let options = null;
        if (typeof playOptions.index === 'number') {
          options = {
            skip_to_index: {
              page: 0,
              track: playOptions.index
            }
          };
        } else if (playOptions.trackUri) {
          options = {
            skip_to_index: {
              track_uri: playOptions.trackUri
            }
          };
        }

        if (typeof playOptions.seekTo === 'number') {
          options.seek_to = playOptions.seekTo;
        }

        player.play(context, options, callback);
      });
    });
  }

  let cancelSubscribe;

  function subscribe(callback, options = {}) {
    cancelSubscribe = false;

    let subscription;
    getPlayer(null, p => {
      if (cancelSubscribe) return;
      subscription = p.subscribe((error, response) => {
        if (error) {
          callback(error);
        } else {
          callback(null, addContext(response.getJSONBody()));
        }
      }, options);
    });

    return {
      unsubscribe: () => {
        cancelSubscribe = true;
        if (!subscription) return;
        subscription.cancel();
        subscription = null;
      }
    };
  }

  let onErrorSubscription;

  function onError(callback) {
    getPlayer(null, p => {
      onErrorSubscription = p.onError(callback);
    });

    return () => {
      if (onErrorSubscription) {
        onErrorSubscription.cancel();
        onErrorSubscription = null;
      }
    };
  }

  function getState(callback) {
    getPlayer(null, p => {
      p.getState((error, response) => {
        if (error) {
          callback(error, null);
        } else {
          callback(null, addContext(response.getJSONBody()));
        }
      });
    });
  }

  function pause(callback) {
    getPlayer(null, p => {
      p.pause(callback);
    });
  }

  function resume(callback) {
    getPlayer(null, p => {
      p.resume(callback);
    });
  }

  /**
   * Adds the context to a given player state.
   *
   * @param {Object} data Input data in the format of the cosmos player live model (v2).
   * @param {string?} optUri Optional URI to be used in first place.
   * @return {Object} Data object.
   */
  function addContext(data, optUri) {
    const uri = optUri || // We provide the URI of the context.
    data.context_metadata['zelda.context_uri'] || // Best case scenario.
    data.context_uri || // No special context, use the standard one.
    data.track && data.track.uri || // If a track is present, use it.
    null; // Nothing found; there's nothing being played.

    const context = getOriginUri(uri);

    // Avoid writing it into the context. People should always use the context object.
    delete data.context_uri;

    if (uri) {
      data.variant = { uri };
      data.context = { uri: context };
    } else {
      data.variant = null;
      data.context = null;
    }

    // Track and index are flagged as "optional", meaning that when the player is stopped
    // will not be returned. Because of the way "live" works (waiting for properties until
    // they're set), it could happen that we wait forever for "track" and "index". For
    // aoviding this, we set them both to "null".
    data.track = data.track || null;
    data.index = data.index || null;

    if (data.track) {
      data.uid = data.track.uid;
      delete data.track.uid;
    } else {
      data.uid = null;
    }

    return removeUnderscores(data);
  }

  /**
   * Returns the original URI from a given filtered & sorted URI. For example, given
   * this URL:
   *
   * spotify:internal:sortlist:desc:track(name):internal:filterlist:playable%20eq%20true:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
   *
   * This method would return:
   *
   * spotify:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
   *
   * @param {string} uri An internal URI format with sort and/or query parts.
   * @return {string} The original URI.
   */
  function getOriginUri(uri) {
    if (!uri) {
      return uri;
    }

    const sorted = _liveSortUri2.default.parse(uri);
    let newUri = uri;
    if (sorted) {
      newUri = sorted.originUri;
    }

    const filtered = _liveFilterUri2.default.parse(newUri);
    if (filtered) {
      newUri = filtered.originUri;
    }

    return newUri;
  }

  /**
   * Transforms C++ syntax for variable names and keys (underscore_names) to the JS format
   * (camelCase).
   */
  function removeUnderscores(data) {
    let transformedKey;

    for (const key in data) {
      if (!data.hasOwnProperty(key)) continue;

      transformedKey = key.replace(/_(.)/g, (str, chr) => chr.toUpperCase());

      if (data[key] instanceof Object) {
        data[transformedKey] = removeUnderscores(data[key]);
      } else {
        data[transformedKey] = data[key];
      }

      if (transformedKey !== key) {
        delete data[key];
      }
    }

    return data;
  }

  exports.play = play;
  exports.playFromResolver = playFromResolver;
  exports.playContext = playContext;
  exports.pause = pause;
  exports.resume = resume;
  exports.update = update;
  exports.subscribe = subscribe;
  exports.onError = onError;
  exports.getState = getState;
  exports.addContext = addContext;
  exports.updateContext = updateContext;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live-filter-uri":357,"../../live-sort-uri":411,"../util/cosmos":408,"./data":382,"spotify-cosmos-api":1272,"spotify-player/lib/v2":1284}],385:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.play = play;
  const playlistUtils = require('../../../libs/playlist-utils');
  const isPlaylist2Shows = require('../../../libs/playlist-utils').isPlaylist2Shows;
  const live = require('../../../libs/live');
  const wrappedUri = require('../../../libs/live-wrapped-uri');

  function play(contextUri, options, callback) {
    checkIfPlaylistsToShowsContext(contextUri).then(includeEpisodes => {
      playlistUtils.playlistRequest(contextUri, {
        method: 'POST',
        includeEpisodes,
        type: 'play',
        body: options
      }, callback);
    });
  }

  function checkIfPlaylistsToShowsContext(contextUri) {
    return new Promise(resolve => {
      const parsedUri = wrappedUri.parse(contextUri);
      const originUri = parsedUri ? parsedUri.originUri : contextUri;
      live(originUri).get('formatListType', (error, formatListType) => {
        resolve(isPlaylist2Shows(formatListType));
      }, live.ASAP);
    });
  }

  },{"../../../libs/live":413,"../../../libs/live-wrapped-uri":412,"../../../libs/playlist-utils":445}],386:[function(require,module,exports){
  /**
   * @module live-models/player/updates
   * @private
   */
  'use strict';

  let lastRowsList;
  let lastRowsListUri;
  let lastRowsListHandler;
  let lastRowsListReferrer;
  let playerRowKey;
  let playerKeys;

  /**
   * Listen for updates on a rows list and update the player when
   * changes happen.
   *
   * @param {LiveList} rowsList A live list of rows.
   * @param {Object} options Object with options and data of what to play.
   * @param {Function} handler A handler function that gets called whenever
   *     the list is updated. Gets called with one argument: an options object.
   */
  function listen(rowsList, options, handler) {
    if (lastRowsList) {
      removeRowsListener();
    }

    lastRowsList = rowsList;
    lastRowsListUri = options.context;
    lastRowsListReferrer = options.referrerId;

    lastRowsListHandler = function () {
      // Todo: Only add this for TPM.
      options.index = getPlayingAndUpdateIndicesInList(rowsList).update;
      handler(options);
    };

    rowsList.on('update', lastRowsListHandler);
  }

  /**
   * Check if the last added rows listener is still valid for the current
   * player state, and clean up the update handler if it's not valid.
   *
   * @param {LiveObject} model The player live object.
   */
  function clean(model) {
    if (!lastRowsListHandler) return;

    const context = model.get('variant');

    // Remove listener if the player context is no longer the same
    if ((context && context.uri) !== lastRowsListUri) {
      removeRowsListener();

      // Remove listener if the player referrer is no longer the same
    } else {
      const origin = model.get('playOrigin');
      const playerReferrer = origin && origin.get('referrerIdentifier');

      if (playerReferrer !== lastRowsListReferrer && !model.get('contextUpdatedCrossFrame')) {
        removeRowsListener();
      }
    }
  }

  /**
   * Save which item is currently playing.
   *
   * @param {number} index The index for the playing row.
   */
  function setPlayingIndex(index, optRowsList) {
    if (!lastRowsList && !optRowsList) {
      return;
    }

    // If the index is out of bounds (e.g. is -1 because the track is not found),
    // then just keep the old playerRowKey.
    if (index < 0) {
      return;
    }

    const list = optRowsList || lastRowsList;

    playerRowKey = list.keys[index] || null;
    playerKeys = list.keys.slice();
  }

  /**
   * Remove the saved rows listener data.
   */
  function removeRowsListener() {
    if (lastRowsList) {
      lastRowsList.off('update', lastRowsListHandler);
    }

    lastRowsList = null;
    lastRowsListUri = '';
    lastRowsListHandler = null;
    lastRowsListReferrer = '';
  }

  /**
   * Get the index of the playing row in the provided list.
   *
   * @param {LiveList} rowsList A live list of rows.
   *
   * @return {number} The index of the playing row, or -1 if not found.
   */
  function getPlayingAndUpdateIndicesInList(rowsList) {
    if (!playerRowKey) return { update: -1, playing: -1 };

    // Find the currently playing row in the new list
    const playingIndexInNewList = rowsList.keys.indexOf(playerRowKey);
    let updateIndex = playingIndexInNewList;

    // If the playing row was not found in the new list, loop through the row
    // keys of the list that the player is currently playing from, and try to
    // find the next row key that exist both in the currently playing list and
    // the new list.
    if (playingIndexInNewList === -1) {
      const indexInPlayerList = playerKeys.indexOf(playerRowKey);
      for (let i = indexInPlayerList, l = playerKeys.length; i < l; i++) {
        updateIndex = rowsList.keys.indexOf(playerKeys[i]);
        if (updateIndex > -1) {
          // Index must be -1 since we've moved down several rows. The cosmos
          // player wants the index of the next row, so before passing it to
          // cosmos, the index will be incremented again.
          updateIndex--;

          break;
        }
      }
    }

    return {
      update: updateIndex,
      playing: playingIndexInNewList
    };
  }

  /**
   * Check if the player is currently playing from a rows list.
   *
   * @param {string} uri Context URI. If passed, it checks for that specific URI.
   *
   * @return {boolean} True if it is playing from a rows list, false otherwise.
   */
  function isPlayingFromRowsContext(uri) {
    if (uri) return lastRowsListUri === uri;

    return !!lastRowsList;
  }

  exports.setPlayingIndex = setPlayingIndex;
  exports.listen = listen;
  exports.clean = clean;
  exports.getPlayingAndUpdateIndicesInList = getPlayingAndUpdateIndicesInList;
  exports.isPlayingFromRowsContext = isPlayingFromRowsContext;

  },{}],387:[function(require,module,exports){
  (function (global){
  'use strict';

  var _live = require('../live');

  var _live2 = _interopRequireDefault(_live);

  var _offlineStatus = require('../playlist-utils/offline-status');

  var _bridge = require('../bridge');

  var _playlistUtils = require('../playlist-utils');

  var _messageProxy = require('../message-proxy');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function onBroadcast(error, body) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    (0, _live2.default)(body.uri).update(body);
  }

  function onWait(model, properties) {
    const policy = {};
    if (properties.includes('name')) policy.name = true;
    if (properties.includes('description')) policy.description = true;
    if (properties.includes('image') || properties.includes('annotatedImage')) {
      policy.picture = true;
    }
    if (properties.includes('added')) policy.followed = true;
    if (properties.includes('formatListType')) policy.formatListType = true;
    if (properties.includes('annotatedImage')) policy.pictureFromAnnotate = true;
    if (properties.includes('owner')) {
      policy.owner = { link: true, username: true, name: true };
      policy.ownedBySelf = true;
    }
    if (properties.includes('published')) policy.published = true;
    if (properties.includes('collaborative')) policy.collaborative = true;
    if (properties.includes('allows')) {
      policy.allows = { insert: true, remove: true };
    }
    if (Object.keys(policy).length === 0) return;

    (0, _playlistUtils.subscribeToMetadata)(model.uri, policy, (error, data = {}) => {
      if (error) {
        console.error(error);
        return;
      }

      if (data && 'picture' in data) {
        data.image = data.picture;
        delete data.picture;
      }

      if (data && 'pictureFromAnnotate' in data) {
        data.annotatedImage = data.pictureFromAnnotate && data.image || null;
        delete data.pictureFromAnnotate;
      }

      if (data && 'offline' in data) {
        data.offlineStatus = data.offline;
        data.shouldBeOffline = (0, _offlineStatus.shouldBeOffline)(data.offline);
        delete data.offline;
      }

      if (properties.includes('formatListType')) {
        data.formatListType = data.formatListType || 'playlist';
      }

      if ('owner' in data && 'link' in data.owner) {
        data.owner.uri = data.owner.link;
      }

      if ('ownedBySelf' in data && 'owner' in data) {
        data.owner.currentUser = data.ownedBySelf;
      }

      if (data && 'allows' in data) {
        data.allows = {
          insertTracks: data.allows.insert,
          removeTracks: data.allows.remove
        };
      }

      model.update(data);
    });
  }

  function onHeart(model, trackUri) {
    const entityUri = _playlistUtils.formatListUtils.originalPlaylistUri(model.get('uri'));
    (0, _live2.default)(entityUri).get('formatListAttributes', function (err, res) {
      if (err) {
        console.error(err);
        return;
      }

      if (res.get('like-feedback-available') === '1') {
        (0, _messageProxy.messageProxy)({
          method: 'POST',
          uri: 'format-list-heart',
          body: {
            entityUri,
            trackUri
          }
        });
      }

      const feedbackUri = _playlistUtils.formatListUtils.makeFeedbackUri(entityUri, trackUri);
      (0, _live2.default)(feedbackUri).update({ thumb: 'up' });
    });
  }

  function onUndoFeedback(model, trackUri) {
    const entityUri = _playlistUtils.formatListUtils.originalPlaylistUri(model.get('uri'));
    (0, _live2.default)(entityUri).get('formatListAttributes', function (err, res) {
      if (err) {
        console.error(err);
        return;
      }

      if (res.get('like-feedback-available') === '1') {
        (0, _messageProxy.messageProxy)({
          method: 'POST',
          uri: 'format-list-undo-feedback',
          body: {
            entityUri,
            trackUri
          }
        });

        const feedbackUri = _playlistUtils.formatListUtils.makeFeedbackUri(entityUri, trackUri);
        (0, _live2.default)(feedbackUri).update({ thumb: null });
      }
    });
  }

  const matches = exports.matches = /^spotify:(user:[^:]+:)?playlist:[^:]+$/;

  let broadcastSubscriptionCancel;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    _live2.default.subscribe(matches, 'wait', onWait);
    _live2.default.subscribe(matches, 'heart', onHeart);
    _live2.default.subscribe(matches, 'undo-heart', onUndoFeedback);
    _live2.default.subscribe(matches, 'undo-ban', onUndoFeedback);

    broadcastSubscriptionCancel = (0, _bridge.cosmosJSON)({ method: 'SUB', uri: 'sp://messages/v1/playliststate' }, onBroadcast);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    _live2.default.unsubscribe(matches, 'wait', onWait);

    broadcastSubscriptionCancel();
    broadcastSubscriptionCancel = null;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../bridge":121,"../live":413,"../message-proxy":437,"../playlist-utils":445,"../playlist-utils/offline-status":446}],388:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/session-storage
   */
  'use strict';

  const forOwn = require('mout/object/forOwn');
  const combine = require('mout/array/combine');
  const remove = require('mout/array/remove');
  const contains = require('mout/array/contains');

  const URI = 'spotify:session-storage';
  const live = require('../live');
  const cosmos = require('./util/cosmos');
  const endpoints = {
    broadcast: 'sp://messages/v1/session-storage'
  };

  let waiting = [];

  function onInit(model) {
    // Set a flag for showing that the model has been implemented and
    // registered. This is so that we can check this in player without
    // making a breaking change.
    model.update({ implemented: true });
  }

  function onWait(model, properties) {
    // Ask the top frame to broadcast the properties.
    // Values will be null when they weren't stored.
    waiting = combine(waiting, properties);
    global.top.postMessage({
      type: 'session_storage',
      name: 'broadcast_session_storage',
      data: properties
    }, '*');
  }

  function onPublish(model, properties) {
    // Tell the top frame to persist and broadcast
    global.top.postMessage({
      type: 'session_storage',
      name: 'set_session_storage',
      data: properties
    }, '*');

    // Optimistic update
    model.update(properties);
  }

  function onBroadcast(error, event) {
    const update = {};
    const model = live(URI);

    forOwn(event.body, function (value, key) {
      // Update model if this instance of storage knows that the model waits for it
      const isWaiting = contains(waiting, key);

      // Or if the model has a potentially outdated value in the live cache
      const hasKey = model.get(key) !== undefined;

      if (isWaiting || hasKey) update[key] = value;
      if (isWaiting) remove(waiting, key);
    });
    model.update(update);
  }

  let broadcastSubscription;
  const regExp = exports.matches = new RegExp(`^${URI}$`);
  let registered;

  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'init', onInit);
    live.subscribe(regExp, 'wait', onWait);
    live.subscribe(regExp, 'publish', onPublish);
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'init', onInit);
    live.unsubscribe(regExp, 'wait', onWait);
    live.unsubscribe(regExp, 'publish', onPublish);

    if (broadcastSubscription) {
      broadcastSubscription.cancel();
      broadcastSubscription = null;
    }
    waiting.length = 0;
  };

  exports._endpoints = endpoints;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"./util/cosmos":408,"mout/array/combine":775,"mout/array/contains":776,"mout/array/remove":785,"mout/object/forOwn":810}],389:[function(require,module,exports){
  'use strict';

  var _live = require('../live');

  var _live2 = _interopRequireDefault(_live);

  var _cosmos = require('./util/cosmos');

  var _cosmos2 = _interopRequireDefault(_cosmos);

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  var _liveWrappedUri = require('../live-wrapped-uri');

  var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const regExp = exports.matches = /^spotify:((internal:sortlist:(asc|desc):([^:]*):(internal:filterlist:[^:]*):)|(internal:sortlist:(asc|desc):([^:]*):)|(internal:filterlist:[^:]*):)?show:[^:]+$/;
  let registered;
  const subscribingForUris = [];

  exports.register = () => {
    if (registered) return;
    registered = true;

    subscribingForUris.length = 0;

    _live2.default.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = () => {
    if (!registered) return;
    registered = false;

    subscribingForUris.length = 0;

    _live2.default.unsubscribe(regExp, 'wait', onWait);
  };

  function onWait(model, properties) {
    if (!properties.includes('show') && !properties.includes('rows')) {
      return;
    }

    if (subscribingForUris.includes(model.uri)) {
      return;
    }

    subscribingForUris.push(model.uri);

    let showUri = model.uri;
    let additionalFilter = '';
    let sort = 'number,publishDate,name';

    const parsed = _liveWrappedUri2.default.parse(model.uri);

    if (parsed) {
      showUri = parsed.originUri;

      if (parsed.sort && parsed.sort.query) {
        sort = sortToString(parsed.sort);
      }

      if (parsed.filter && parsed.filter.query) {
        additionalFilter = filterQueryToString(parsed.filter.query);
      }
    }

    const showId = _spotifyLiburi2.default.from(showUri).getBase62Id();

    _cosmos2.default.subscribe({
      url: `sp://core-show/unstable/show/${showId}?filter=available eq true${additionalFilter}&sort=${sort}`
    }, (error, data) => {
      if (error) throw error;
      const { show, items } = data.body;

      // Add a URI property so the data is put into the live cache
      show.uri = show.link;
      items.forEach(item => {
        item.uri = item.link;
        item.show.uri = item.show.link;
      });

      // we have to map the items array this way to enable row selection
      model.update({
        show,
        rows: items.map(item => ({ track: item })),

        // This timestamp will cause an 'update' event to be sent out even when
        // the real diff was just something nested.
        lastUpdateTimestamp: Date.now()
      });
    });
  }

  /**
   * @param  {Object} parsedSort Object with .direction and .query
   * @return {String}
   */
  function sortToString(parsedSort) {
    const direction = parsedSort.direction.toUpperCase();
    let sort = 'number,publishDate,name';

    switch (parsedSort.query) {
      case 'track(name)':
        sort = `name ${direction}`;
        break;
      case 'track(duration)':
        sort = `length ${direction}`;
        break;
      case 'track(timeLeft)':
        {
          sort = `progress ${direction}`;
          break;
        }
      case 'timeSinceAdded,track(album(name),disc,number)':
        sort = `number ${direction},publishDate ${direction},name ${direction}`;
        break;
      default:
        console.error('Invalid query', parsedSort.query);
        break;
    }

    return sort;
  }

  /**
   * @param  {String} parsedFilterQuery
   * @return {String}
   */
  function filterQueryToString(parsedFilterQuery) {
    if (parsedFilterQuery.length > 0) {
      return `,${parsedFilterQuery}`;
    }
    return '';
  }

  },{"../live":413,"../live-wrapped-uri":412,"./util/cosmos":408,"spotify-liburi":1282}],390:[function(require,module,exports){
  "use strict";

  /**
   * This module splits up a list into many chunks.
   *
   * @module live-models/sorting/chunker
   * @private
   */

  /**
   * Splits up an array of data into smaller chunks.
   *
   * @param {Array} list The array to be split up.
   * @param {number=} size Optional size of each chunk.
   *
   * @return {Array} Array of chunks, where each chunk is an array of data.
   */
  module.exports = function (list, size = 50) {
    function split(array, segments = 2) {
      const results = [];
      if (array === null) {
        return results;
      }

      const minLength = Math.floor(array.length / segments);
      const remainder = array.length % segments;
      let i = 0;
      const len = array.length;
      let segmentIndex = 0;
      let segmentLength;

      while (i < len) {
        segmentLength = minLength;
        if (segmentIndex < remainder) {
          segmentLength++;
        }

        results.push(array.slice(i, i + segmentLength));

        segmentIndex++;
        i += segmentLength;
      }

      return results;
    }

    const chunkCount = Math.ceil(list.length / size);
    const chunks = split(list, chunkCount);

    return chunks;
  };

  },{}],391:[function(require,module,exports){
  /**
   * This file contains transformations from legacy sort queries to new sort
   * queries. We need this because when a user sorts by a certain column, we store
   * the full URI for that list and the sort query is part of the URI. Whenever
   * we change the sort query of a column, we will break sorting for users who
   * have a stored sort state with the old query. That's why we need to maintain
   * this conversion from old to new to make the right list load for all users.
   *
   * When to remove a conversion needs to be weighed case by case I guess. If a
   * user sorts by a certain column and doesn't launch the client for three months
   * and we change the query during that time, it's expected to still work for
   * that user when logging in the next time.
   *
   * History of this file is in the play-desktop app,
   * https://ghe.spotify.net/zelda/client-zelda-js/blob/master/apps/playlist/src/legacy-sort-uris.js
   */
  'use strict';

  exports.legacyQueries = {
    // Change date: 2015-03-16
    'track(album(name))': 'track(album(name),disc,number)',
    // Change date: 2015-03-16
    'track(artists(name))': 'track(artists[0:1](name),album(name),disc,number)',
    // Change date: 2015-03-17, value changed 2015-07-14 because we introduced the conversion below.
    'track(addedBy)': 'addedBy(name)',
    // Change date: 2015-07-14
    'track(addedBy(name))': 'addedBy(name)',
    // Change date: 2015-06-26
    'timeSinceAdded': 'timeSinceAdded,track(album(name),disc,number)'
  };

  },{}],392:[function(require,module,exports){
  'use strict';

  /**
   * This module helps posting chunked data to/from a worker.
   *
   * @module live-models/sorting/poster
   * @private
   */

  /**
   * Posts data from/to a worker.
   *
   * @param {Object} worker A web worker.
   * @param {Array} chunks Array of split up data.
   * @param {number} index Index of the current chunk to post. Initiate the
   *     poster with 0, and it posts all data sequentially until all data
   *     is posted.
   * @param {string} id An ID for the full payload.
   */
  module.exports = function poster(worker, chunks, index, id) {
    'use strict';

    const data = {
      items: chunks[index],
      id: id
    };

    if (index === chunks.length - 1) {
      data.last = true;
    }

    worker.postMessage(data);

    if (!data.last) {
      poster(worker, chunks, index + 1, id);
    }
  };

  },{}],393:[function(require,module,exports){
  (function (global){
  'use strict';

  /**
   * This module sorts an array of data in the best possible way.
   * If Web Workers are supported, it will spawn new workers and
   * sort on different threads to speed it up.
   *
   * @module live-models/sorting/sort
   * @private
   */

  const chunker = require('./chunker');
  const poster = require('./poster');
  const sorter = require('./sorter');
  const sortWorker = require('./sortworker');
  const defer = require('../../../libs/prime/defer');

  let workerFile;
  const workers = {};
  const callbacks = {};
  const waitingForReset = {};

  // A generated ID will be stored here for each sorted list. Whenever a sorted
  // list is asked to resort, a new ID will be generated and set here for that
  // list. That allows us to cancel a previous sort if a newer one has started
  // before the old one finished.
  let idCounter = 0;
  const lastIds = {};

  /**
   * The local sorter that sorts on the main thread.
   *
   * @param {string} sortUri URI of the sorted list.
   * @param {Array.<Object>} items Array of items to sort. Each item is
   *     an object with the properties `data` and `key`. The `data`
   *     property is an array of values to sort on. The `key` property
   *     is a string for the row ID.
   * @param {Function} callback Async callback where the data is the array of
   *     sorted items.
   */
  function localSorter(sortUri, items, callback) {
    const sortedItems = sorter(items);

    // Saving the callback as the latest callback for this sorted list
    // will allow us to only respond with the latest sorted values (if
    // multiple sort calls were made at the same time).
    callbacks[sortUri] = callback;

    // Make the callback async
    defer.immediate(function () {
      // Only allow the latest callback to run
      if (callback === callbacks[sortUri]) {
        delete callbacks[sortUri];

        callback(null, sortedItems);
      }
    });
  }

  /**
   * The Web Worker sorter.
   *
   * @param {string} sortUri URI of the sorted list.
   * @param {Array.<Object>} items Array of items to sort. Each item is
   *     an object with the properties `data` and `key`. The `data`
   *     property is an array of values to sort on. The `key` property
   *     is a string for the row ID.
   * @param {Function} callback Async callback where the data is the array of
   *     sorted items.
   */
  function workerSorter(sortUri, items, callback) {
    let worker = workers[sortUri];

    // If we already have a worker for this sorted list, reset that worker
    // and tell it to sort the new data. By saving the callback we make sure
    // that the original worker event handler will run the latest callback
    // when the sorting is done.
    if (worker) {
      callbacks[sortUri] = callback;
      waitingForReset[sortUri] = (waitingForReset[sortUri] || 0) + 1;
      const id = (++idCounter).toString(36);
      lastIds[sortUri] = id;
      worker.postMessage({ reset: true, newId: id });
      sendItemsToWorker(items, worker, id);
      return;
    }

    worker = new Worker(workerFile);
    workers[sortUri] = worker;
    callbacks[sortUri] = callback;

    const id = (++idCounter).toString(36);
    lastIds[sortUri] = id;
    sendItemsToWorker(items, worker, id);

    const result = { items: [] };

    worker.addEventListener('message', function (event) {
      onWorkerMessage(event, result, sortUri);
    }, false);
  }

  /**
   * Event handler for receiving a message from a worker.
   * This will handle collecting all chunks of data and post it to the latest
   * callback when all chunks have been received.
   *
   * @param {Event} event An event object from the worker 'message' event.
   * @param {Object} result An object with a property `items` for the sorted items.
   * @param {string} sortUri The sort URI for the current sort.
   */
  function onWorkerMessage(event, result, sortUri) {
    // When the main thread tells the worker to reset, the worker will respond with
    // a message to reset the array of already sorted items.
    if (event.data.reset) {
      waitingForReset[sortUri]--;
      result.items.length = 0;
      return;
    }

    // Skip messages that don't belong to the latest sort
    if (event.data.id !== lastIds[sortUri]) {
      return;
    }

    // If we are still waiting for reset messages, don't continue to add more items
    // to the list of sorted items.
    if (waitingForReset[sortUri]) {
      return;
    }

    // If we are not waiting for any resets, just save the chunk of sorted items.
    result.items = result.items.concat(event.data.items);

    // When all data has been passed over from the worker, kill the worker and run
    // the latest registered callback for this sorted list.
    if (event.data.last) {
      workers[sortUri].terminate();

      const callback = callbacks[sortUri];
      delete callbacks[sortUri];
      delete workers[sortUri];

      callback(null, result.items);
    }
  }

  /**
   * Create the Web Worker file path.
   * Since the worker can't share objects with the main thead, we can't share
   * dependencies. To solve this, we convert the dependencies to strings and pass
   * them as arguments to the worker file.
   * To circumvent the need of a separate file for the worker, we make the worker
   * itself and the passed dependencies a single string and make a blob out of it.
   * From the blob we can get a URL that we can pass to the worker constructor.
   *
   * @return {string} Blob URL that can be passed to the worker.
   */
  function createWorkerFile() {
    const workerStr = sortWorker.toString();
    const sortStr = sorter.toString();
    const chunkerStr = chunker.toString();
    const posterStr = poster.toString();
    const argsStr = [sortStr, chunkerStr, posterStr].join(', ');
    const stringWorker = `(${workerStr})(${argsStr})`;

    const blob = new Blob([stringWorker], { type: 'text/javascript' });
    const url = URL.createObjectURL(blob);

    return url;
  }

  /**
   * Send the provided items to the provided worker. It will do this by splitting
   * the items into chunks and sending the chunks.
   *
   * @param {Array} items An array of items.
   * @param {Worker} worker A worker instance.
   * @param {string} id The ID for the payload.
   */
  function sendItemsToWorker(data, worker, id) {
    const chunks = chunker(data);
    poster(worker, chunks, 0, id);
  }

  /**
   * Get the sort function to use.
   * If Web Workers are supported, it will use that, otherwise it will use the
   * default sorter on the main thread.
   * Having the code in a function allows for testing where worker support can
   * be removed and added while running the tests.
   *
   * @return {Function} The sorter function.
   */
  function getSorter() {
    if (global.Worker && global.Blob && global.URL) {
      if (!workerFile) {
        workerFile = createWorkerFile();
      }
      return workerSorter;
    }
    return localSorter;
  }

  /**
   * Sort the data using the best supported method.
   *
   * @param {string} sortUri URI of the sorted list.
   * @param {Array.<Object>} items Array of items to sort. Each item is
   *     an object with the properties `data` and `key`. The `data`
   *     property is an array of values to sort on. The `key` property
   *     is a string for the row ID.
   * @param {Function} callback Async callback where the data is the array of
   *     sorted items.
   */
  module.exports = function (sortUri, items, callback) {
    const sort = getSorter();
    sort(sortUri, items, callback);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../../libs/prime/defer":450,"./chunker":390,"./poster":392,"./sorter":394,"./sortworker":395}],394:[function(require,module,exports){
  'use strict';

  /**
   * Sorts an array of data. Supports multiple levels of values
   * (if two items are the same, it tests the values in the next level).
   *
   * @param {Array.<Object>} data Array of items to sort. Each item is
   *     an object with the properties `data` and `key`. The `data`
   *     property is an array of values to sort on. The `key` property
   *     is a string for the row ID.
   *
   * @return {Array.<Object>} A new array of the same objects that were
   *     passed in, but sorted.
   */
  module.exports = function (data) {
    'use strict';

    data.sort(function (a, b) {
      const length = a.data.length;

      for (let i = 0; i < length; i++) {
        const aValue = a.data[i];
        const bValue = b.data[i];

        const aNumber = parseInt(aValue, 10);
        const bNumber = parseInt(bValue, 10);

        const aStartsWithNumber = !isNaN(aNumber);
        const bStartsWithNumber = !isNaN(bNumber);

        if (aStartsWithNumber && bStartsWithNumber) {
          if (aNumber < bNumber) return -1;
          if (aNumber > bNumber) return 1;
        } else if (aStartsWithNumber) {
          return -1;
        } else if (bStartsWithNumber) {
          return 1;
        }

        if (aValue.localeCompare) {
          const value = aValue.localeCompare(bValue);
          if (value !== 0) return value;
        } else {
          if (aValue < bValue) return -1;
          if (aValue > bValue) return 1;
        }
      }

      return -1;
    });

    return data;
  };

  },{}],395:[function(require,module,exports){
  'use strict';

  /**
   * This is the Web Worker file that sorts the data and passes it back again.
   * The file cannot be passed directly to new Worker(), as it needs some
   * dependencies. These dependencies are required before creating the worker,
   * and then serialized together with this file into a single blob, which is
   * used to create the worker.
   *
   * @module live-models/sorting/sortworker
   * @private
   */

  /**
   * Sort worker.
   *
   * @param {Function} sort Function that sorts an array of data based on a
   *     property.
   * @param {Function} chunk Function that splits up data into chunks.
   * @param {Function} post Function that posts chunks of data back to main
   *     thread.
   * @param {Object} optWorker Optional worker instance (mainly for testability).
   */
  module.exports = function (sort, chunk, post, optWorker) {
    'use strict';

    const worker = optWorker || self;

    let itemsToSort = [];
    let id = null;

    worker.addEventListener('message', function (event) {
      // When the main thread tells the worker to reset, the worker will respond with
      // a message to reset the array of already sorted items.
      if (event.data.reset) {
        itemsToSort.length = 0;
        id = event.data.newId;
        worker.postMessage({ reset: true, newId: id });
        return;
      }

      // Only set the stored id for the first message
      if (id === null) {
        id = event.data.id;
      }

      // If the event id does not match the stored id, don't do anything.
      // This allows a sort to be aborted in the middle.
      if (id !== event.data.id) {
        return;
      }

      itemsToSort = itemsToSort.concat(event.data.items);

      if (event.data.last) {
        const sortedItems = sort(itemsToSort);
        const chunks = chunk(sortedItems);
        post(worker, chunks, 0, id);
      }
    }, false);
  };

  },{}],396:[function(require,module,exports){
  'use strict';

  /**
   * Get the row values used for sorting.
   *
   * @module live-models/sorting/values
   * @private
   */

  /**
   * Get the values from the row based on the passed mask.
   * String values will be sanitized (lowercase, removing articles like 'the' etc).
   * The values can then be used for sorting.
   *
   * @param {Object} mask A mask object from the query parser.
   * @param {Object} row Row data object.
   *
   * @return {Array>} Array of values to sort on.
   *
   * @example
   * var parse = require('../../live/util/parser');
   * var mask = parse('track(name), track(artists(name))').mask;
   * var row = {track: {name: 'Track', artists: [{name: 'Artist'}]}};
   * var values = getValues(mask, row);
   * console.log(values);
   * // ['track', 'artist']
   */
  function getValues(mask, row) {
    let result = [];
    mask.forEach(function (m) {
      const k = m.key;
      const value = row[k];

      // If the value is an array, we will concatenate all the
      // values with a comma in between, so that sorting takes
      // all values into account. An example is sorting tracks
      // based on 'artists(name)', where there can be many
      // artists for a track. We will in that case concatenate
      // all artists with comma in between and use a string with
      // all the artists when we compare in the sort function.
      if (Array.isArray(value)) {
        if (m.mask) {
          let values = [];
          for (let i = 0, l = value.length; i < l; i++) {
            values = values.concat(getValues(m.mask, value[i]));
          }
          result.push(values.join(', '));
        } else {
          result.push(value.join(', '));
        }
      } else {
        if (m.mask) result.push.apply(result, getValues(m.mask, value));else result.push(value);
      }
    });

    result = sanitizeStrings(result);

    return result;
  }

  /**
   * Sanitize string values. This includes trimming whitespace, converting
   * the string to lower case and removing common articles like 'the'.
   *
   * @param {Array} values Array of values.
   *
   * @return {Array} A new array of sanitized values.
   */
  function sanitizeStrings(values) {
    const numberRe = /\b[0-9]+\b/g;
    const pad = '000000';

    return values.map(function (value) {
      if (typeof value !== 'string') return value;

      let newValue = value.toLowerCase();

      // Remove the first article
      const articles = ['the ', '(the) '];
      for (let i = 0; i < articles.length; i++) {
        const article = articles[i];

        if (newValue.indexOf(article) === 0) {
          newValue = newValue.replace(article, '');
          break;
        }
      }

      // Zero-pad numbers for natural numeric sorting (i.e. 2 before 10)
      newValue = newValue.replace(numberRe, function (match) {
        if (match.length >= pad.length) return match;
        return pad.substr(0, pad.length - match.length) + match;
      });

      return newValue.trim();
    });
  }

  module.exports = getValues;

  },{}],397:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/sortlist
   */
  'use strict';

  const live = require('../live');
  const mixIn = require('mout/object/mixIn');

  const parse = require('../live/util/parser');
  const sortUriUtils = require('../live-sort-uri');
  const listOperations = require('../live-list-operations');

  const sort = require('./sorting/sort');
  const getValues = require('./sorting/values');

  // A generated ID will be stored here for each sorted list. Whenever a sorted
  // list is asked to resort, a new ID will be generated and set here for that
  // list. That allows us to cancel a previous sort if a newer one has started
  // before the old one finished.
  let idCounter = 0;
  const lastIds = {};

  /**
   * Event handler for the live 'init' event on sorted models. Keeps sorted model
   * and tracking model in sync (properties, not rows).
   *
   * This will set up an update listener for the tracking model, so that any
   * changes to the tracking model are also applied to the sort model.
   *
   * This also sets up a publish listener for the sorted model, so that anything
   * that is published on the sorted model gets published on the tracking model,
   * which can then update backend with the data and then update the tracking
   * model with the correct data, which will then trickle back down to the
   * sorted model.
   *
   * @param {LiveObject} sortModel The sorted live model.
   */
  function onInit(sortModel) {
    const trackingModel = getTrackingModel(sortModel.uri);

    lastIds[sortModel.uri] = (++idCounter).toString(36);

    // Update the sorted model when any property on the tracking model changes (except rows)
    trackingModel.on('update', function (properties) {
      const updateObject = mixIn({}, properties);
      delete updateObject.rows;
      sortModel.update(updateObject);
    });

    // Update the tracking model when any property on the sort model changes (except rows)
    sortModel.on('publish', function (properties) {
      const updateObject = mixIn({}, properties);
      delete updateObject.rows;
      trackingModel.publish(updateObject);
    });
  }

  /**
   * Event handler for the live 'wait' event on sorted models.
   * This will fetch any requested property from the tracking model, or if
   * rows are requested, it will perform a sort of the rows from the tracking
   * model.
   *
   * It will also listen for changes. If a change is published on the sorted list,
   * it will be republished on the tracking list. When the tracking list is updated
   * with the new data (maybe after a save on the backend), the sorted list will be
   * updated and resorted if needed.
   *
   * @param {LiveObject} sortModel The sorted live model.
   * @param {Array} properties Array of properties that the model is waiting for.
   */
  function onWait(sortModel, properties) {
    const trackingModel = getTrackingModel(sortModel.uri);

    properties.forEach(function (key) {
      // Requesting rows will create a live list of rows, perform sorting,
      // fill the list with the sorted items and also start to listen for changes.
      if (key === 'rows') {
        setRowsProperty(sortModel, trackingModel);

        // Requesting any other property than rows will just get that property from
        // the tracking model.
      } else {
        trackingModel.get(key, function (error, value) {
          if (error) {
            if (global.console) console.error(error);
            return;
          }
          const obj = {};
          obj[key] = value;
          sortModel.update(obj);
        });
      }
    });
  }

  /**
   * Set the `rows` property on the sort model. It will create a new live list
   * and perform sorting based on the rows of the tracking model. It will also
   * set up listeners for any changes to the lists to automatically keep
   * everything in sync.
   *
   * @param {LiveObject} sortModel The live object for the sorted list.
   * @param {LiveObject} trackingModel The live object for the list the sorted
   *     list is tracking.
   */
  function setRowsProperty(sortModel, trackingModel) {
    const sortParams = sortUriUtils.parse(sortModel.uri);
    const direction = sortParams.direction;
    const query = sortParams.query;

    // Start the first sort
    performRowSorting(trackingModel, sortModel, query, direction);

    // Whenever a publish call happens on the sorted list, publish it to the
    // tracking list.
    sortModel.get('rows', function (error, sortList) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      sortList.on('publish', function (operations) {
        const trackingList = trackingModel.get('rows');
        if (!trackingList) return;
        syncRows(trackingList, operations, 'publish');
      });
    });

    // We need to get the rows list of the tracking model to be able to know the
    // length of the list, so that we can create the rows list for the sorted list.
    trackingModel.get('rows', function (error, trackingList) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // Listen for updates on the tracking list and apply the changes (and
      // maybe resort if needed) on the sorted list.
      trackingList.on('update', function (operations) {
        const sortList = sortModel.get('rows');
        if (!sortList) return;
        const mustSort = syncRows(sortList, operations, 'update');
        if (mustSort) {
          performRowSorting(trackingModel, sortModel, query, direction);
        }
      });
    });
  }

  /**
   * Get the tracking model for a sort URI.
   * For an ascending sort URI, the tracking model would be the original list.
   * For a descending sort URI, the tracking model would be the ascending sort list.
   *
   * @param {string} sortUri The sort URI.
   *
   * @return {LiveObject} The live object for the tracking model.
   */
  function getTrackingModel(sortUri) {
    const parsed = sortUriUtils.parse(sortUri);
    const direction = parsed.direction;
    const originUri = parsed.originUri;
    const query = parsed.query;

    // We can use the sorting from the ascending list when requesting the
    // descending list, by just depending on the ascending list. Asking for
    // data from the ascending list will make that list ask for the data
    // from the original list and then sort it, and then the descending list
    // will reverse that.
    if (direction === 'desc') {
      return live(sortUriUtils.create(originUri, 'asc', query));
    }
    return live(originUri);
  }

  /**
   * Get data that is needed for performing a sort.
   *
   * @param {Array.<Object>} rows Array of objects of metadata about the rows.
   * @param {Object} mask A mask object from the query parser.
   * @param {LiveList} trackingList The live list for the list the sorted
   *     list is tracking.
   *
   * @return {Array.<Object>} A new array of items used for sorting. Each item is
   *     an object with the properties `data` and `key`. The `data`
   *     property is an array of values to sort on. The `key` property
   *     is a string for the row ID.
   *
   * @example
   * {
   *   data: ['Name of Song', 'Whatever', 100, 0],
   *   key: '0'
   * }
   */
  function getSortData(rows, mask, trackingList) {
    return rows.map(function (row, i) {
      const array = getValues(mask, row);
      array.push(i);
      return { data: array, key: trackingList.keys[i] };
    });
  }

  /**
   * Perform sorting of all rows in a list.
   *
   * @param {LiveObject} trackingModel The model that the sort model is tracking.
   *     For ascending lists, this is the original model. For descending lists,
   *     this is the ascending sort model.
   * @param {LiveObject} sortModel The model to perform the sort on.
   * @param {string} sortQuery The sort query (live compatible query).
   * @param {string} sortDirection The sort direction ('asc' or 'desc').
   */
  function performRowSorting(trackingModel, sortModel, sortQuery, sortDirection) {
    lastIds[sortModel.uri] = (++idCounter).toString(36);
    const sortId = lastIds[sortModel.uri];

    // Querying the rows of the tracking model might perform a sort. An example is when
    // getting the sort for a descending list, it will query the rows from the ascending
    // list, which will in turn query the rows from the original list and then perform a
    // sort. When the ascending sort is done, the query will be done and the descending
    // list can just use the ascending list and reverse it.
    trackingModel.get('rows', function (error, rows) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // Create a list of loaded rows. This allows partial loading of a list,
      // and the sorted version will only contain the loaded rows.
      const rowsToSort = [];
      const keys = [];
      for (let i = 0, l = rows.length; i < l; i++) {
        if (rows.get(i)) {
          rowsToSort.push(rows.get(i));
          keys.push(rows.keys[i]);
        }
      }

      // Empty lists won't sort anyway, so quit here, but empty the sorted list
      // to make it up to date.
      if (rowsToSort.length === 0) {
        const sortList = sortModel.get('rows');
        if (sortList) {
          sortList.update([{
            type: 'remove',
            index: 0,
            length: sortList.length
          }]);
        } else {
          sortModel.update({ rows: [] });
        }
        return;
      }

      const partialTrackingList = live([]);

      partialTrackingList.update([{
        type: 'insert',
        index: 0,
        values: rowsToSort,
        keys: keys
      }]);

      // Now we have a list containing only the loaded rows
      partialTrackingList.query(sortQuery, function (queryError, queryRows) {
        if (queryError) {
          if (global.console) console.error(queryError);
        } else {
          // If direction is descending, the tracking model is ascending. Simply reverse that.
          if (sortDirection === 'desc') {
            updateListWithReversedData(sortModel, partialTrackingList);

            // For an ascending sort, perform a real sort.
          } else {
            const mask = parse(sortQuery).mask;
            const sortData = getSortData(queryRows, mask, partialTrackingList);

            sort(sortModel.uri, sortData, function (sortError, sortedData) {
              if (sortError) {
                if (global.console) console.error(sortError);
                return;
              }
              if (lastIds[sortModel.uri] !== sortId) return;
              updateListWithSortedData(sortModel, partialTrackingList, sortedData);
            });
          }
        }
      });
    });
  }

  /**
   * Update the sorted live list with the right data after a sort.
   *
   * @param {LiveObject} sortModel The live object for the sorted list.
   * @param {LiveList} trackingList The live list for the list the sorted
   *     list is tracking.
   * @param {Array.<Object>} sortedItems Array of sorted items. Each item is
   *     an object with a property `key`, which is a string for the row ID.
   */
  function updateListWithSortedData(sortModel, trackingList, sortedItems) {
    let sortList = sortModel.get('rows');

    // Copy the rows from the list that the sorted list is tracking,
    // if the sorted list has no tracks yet. Only for the first time.
    if (!sortList) {
      sortList = new live.List();
      sortModel.update({ rows: sortList });
    }

    const length = sortedItems.length;
    const keys = new Array(length);
    const values = new Array(length);

    for (let i = 0, l = sortedItems.length; i < l; i++) {
      keys[i] = sortedItems[i].key;
      values[i] = trackingList.valueOf(keys[i]);
    }

    sortList.update([{
      type: 'remove',
      index: 0,
      length: sortList.length
    }, {
      type: 'insert',
      index: 0,
      keys: keys,
      values: values
    }]);
  }

  /**
   * Update the sorted live list with the data of the list it is tracking,
   * but reversed.
   *
   * @param {LiveObject} sortModel The live object for the sorted list.
   * @param {LiveList} trackingList The live list for the list the sorted
   *     list is tracking.
   */
  function updateListWithReversedData(sortModel, trackingList) {
    let sortList = sortModel.get('rows');

    if (!sortList) {
      sortList = new live.List();
      sortModel.update({ rows: sortList });
    }

    sortList.update([{
      type: 'remove',
      index: 0,
      length: sortList.length
    }, {
      type: 'insert',
      index: 0,
      length: trackingList.length,
      values: trackingList.values.slice().reverse(),
      keys: trackingList.keys.slice().reverse()
    }]);
  }

  /**
   * Converting the passed in operations to be relative to the list that was
   * passed in. Passing operations for a sorted list can convert the operations
   * to be used for the original list. This also updates (or publishes) the list
   * with the converted operations.
   *
   * @param {LiveList} rows The list to sync operations to.
   * @param {Array.<Object>} operations Array of operation objects.
   * @param {string} mode The mode for updates. 'update' or 'publish'.
   *
   * @return {boolean} True if a resort must happen after applying the operations.
   */
  function syncRows(rows, operations, mode) {
    let mustSort = false;

    operations.forEach(function (operation) {
      let newOperations = [];

      switch (operation.type) {
        // If rows are removed from the tracking list, we can "simply" remove
        // the same rows from the sorted model.
        case 'remove':
          newOperations = convertRemoveOperationForList(rows, operation);
          break;

        // If rows are inserted in the tracking list, we must add the rows to
        // the sorted list and resort. Where we insert doesn't matter as we will
        // perform a new sort anyway.
        case 'insert':
          newOperations = [{
            type: 'insert',
            index: 0,
            values: operation.values,
            keys: operation.keys
          }];
          mustSort = true;
          break;

        // If rows are moved in the tracking list, we don't need to perform any
        // new moves directly, but we will need to perform a resort, as sorting
        // uses stable sort (falls back on index in original list if compared
        // values are the same).
        case 'move':
          mustSort = true;
          break;

        default:
          console.error('Invalid operation type', operation.type);
          break;
      }

      if (mode === 'publish') {
        rows.publish(newOperations);
      } else if (mode === 'update') {
        rows.update(newOperations);
      }
    });

    return mustSort;
  }

  /**
   * Convert a remove operation from one list to an operation that can
   * be used in another list. An example is when we have an operation that
   * happened in the original list, we need to convert that to operations
   * that can be applied to the sorted list.
   *
   * @param {LiveList} list The live list to create the operations for.
   * @param {Object} operation The input 'remove' operation.
   *
   * @return {Array.<Object>} Array of remove operation objects.
   */
  function convertRemoveOperationForList(list, operation) {
    const indices = [];
    const operationKeys = operation.keys;

    list.keys.forEach(function (key, i) {
      if (operationKeys.indexOf(key) > -1) indices.push(i);
    });

    return listOperations.getRemoveOperations(indices);
  }

  const regExp = exports.matches = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

  let registered = false;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'init', onInit);
    live.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'init', onInit);
    live.unsubscribe(regExp, 'wait', onWait);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"../live-list-operations":358,"../live-sort-uri":411,"../live/util/parser":416,"./sorting/sort":393,"./sorting/values":396,"mout/object/mixIn":813}],398:[function(require,module,exports){
  'use strict';

  var _messageProxy = require('../../libs/message-proxy');

  /**
   * @module live-models/station
   */

  const live = require('../live');

  // Utilities
  const trackToRow = require('./station/track-to-row');
  const contains = require('mout/array/contains');
  const spotifyURI = require('spotify-liburi');
  const thumbActions = require('./station/thumb-actions');

  const URI = exports.URI = 'spotify:station:';
  const regExp = exports.matches = new RegExp(`^${URI}(` + '((artist:|album:|track:)[a-zA-Z0-9]{22})' + '|' + '(user:[^:]+:' + '(playlist:[a-zA-Z0-9]{22}|top:tracks|toplist))' + '|' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + '|' + '(genre:[a-zA-Z0-9]*)' + ')');
  const isStationUri = exports.isStationUri = regExp.test.bind(regExp);

  const clusterRegExp = new RegExp(`^${URI}(` + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + ')');
  exports.isClusterStationUri = regExp.test.bind(clusterRegExp);

  const DEFAULT_FETCH_COUNT = 15;

  // Station Types
  const PLAYLIST = 'playlist';
  const TRACK = 'track';
  const ALBUM = 'album';
  const ARTIST = 'artist';
  const GENRE = 'genre';
  const CLUSTER = 'cluster';
  const UNKNOWN = 'unknown';

  let registered = false;
  let metadataUpdateUnsubscribe;

  let trackingRows = []; // A list of stations that need row updates.
  let trackingMetadata = []; // A list of stations that need metadata updates.

  /**
   * Get the station's base seed from the live model uri
   * @param {Object} model
   * @return {String}
   */
  function getBaseSeedFromUri(model) {
    const seed = model.uri.replace(/^spotify:station:/, 'spotify:');
    return decodeURIComponent(seed);
  }

  /**
   * Get the station type
   * @param {String} seed
   * @return {String}
   */
  function getType(seed) {
    const uri = spotifyURI.from(seed);
    if (!uri) {
      return UNKNOWN;
    }
    const contextType = uri.type;
    if (spotifyURI.isPlaylistV1OrV2(uri)) {
      return PLAYLIST;
    } else if (contextType === spotifyURI.Type.ARTIST) {
      return ARTIST;
    } else if (contextType === spotifyURI.Type.ALBUM) {
      return ALBUM;
    } else if (contextType === spotifyURI.Type.TRACK) {
      return TRACK;
    } else if (seed.indexOf('spotify:genre:') === 0) {
      return GENRE;
    } else if (seed.indexOf(':cluster:') > 0) {
      return CLUSTER;
    }
    return UNKNOWN;
  }

  /**
   * Thumb up a track
   * @param {Object} model
   * @param {String} trackUID
   */
  function onThumbUp(model, trackUri) {
    (0, _messageProxy.messageProxy)({
      method: 'POST',
      uri: 'station-thumb',
      body: {
        stationUri: model.get('uri'),
        trackUri: trackUri,
        thumb: thumbActions.UP
      }
    });
  }

  /**
   * Thumb down a track
   * @param {Object} model
   * @param {String} trackUID
   */
  function onThumbDown(model, trackUri) {
    (0, _messageProxy.messageProxy)({
      method: 'POST',
      uri: 'station-thumb',
      body: {
        stationUri: model.get('uri'),
        trackUri: trackUri,
        thumb: thumbActions.DOWN
      }
    });
  }

  /**
   * Heart a track
   * @param {Object} model
   * @param {String} trackUID
   */
  function onHeart(model, trackUri) {
    if (!isStationUri(model.get('uri'))) {
      return;
    }

    (0, _messageProxy.messageProxy)({
      method: 'POST',
      uri: 'station-heart',
      body: {
        stationUri: model.get('uri'),
        trackUri: trackUri
      }
    });
  }

  function onUndoHeart(model, trackUri) {
    if (!isStationUri(model.get('uri'))) {
      return;
    }

    (0, _messageProxy.messageProxy)({
      method: 'POST',
      uri: 'station-undo-feedback',
      body: {
        stationUri: model.get('uri'),
        trackUri: trackUri,
        thumbAction: thumbActions.UNDO_HEART
      }
    });
  }

  /**
   * Post a request for data from the container (station-manager in zlink).
   * @param {Object} model
   * @param {Array} properties
   * @param {Boolean} needsRows
   * @param {Integer} fetchCount
   */
  function requestStationData(model, properties, needsRows, fetchCount) {
    const count = needsRows ? fetchCount || model.get('fetchCount') : false;
    (0, _messageProxy.messageProxy)({
      method: 'GET',
      uri: 'station',
      target: 'top',
      body: {
        stationUri: model.get('uri'),
        metadata: properties,
        trackCount: count
      }
    }, function onStationGet(err, opts) {
      if (err) {
        (0, _messageProxy.messageProxy)({
          method: 'POST',
          uri: 'station-error',
          body: { stationUri: model.get('uri'), message: err }
        });
        return;
      }
      const stationUri = opts.stationUri;
      const station = opts.station;
      if (station.hasOwnProperty('tracks')) {
        if (trackingRows.indexOf(stationUri) !== -1) {
          const timeStamp = new Date().getTime();
          station.rows = station.tracks.map(trackToRow.bind(null, timeStamp));
        }
        // Never keep a tracks object in the station (needs to be rows).
        delete station.tracks;
      }
      live(stationUri).update(station);
    });
  }

  /**
   * Callback for rows wait event.
   * @param {Object} model
   * @param {Array} ranges
   */
  function onRowsWait(model, ranges) {
    if (ranges && ranges.length > 0) {
      let fetchCount = 0;
      let largestTrack = 0;
      ranges.forEach(function (a) {
        if (a.end > largestTrack) {
          largestTrack = a.end;
        }
      });
      fetchCount = largestTrack - model.get('rows').length;
      requestStationData(model, [], true, fetchCount);
    }
  }

  /**
   * Subscriber for updateMetadata messages
   * @param {Object} opts
   */
  function onUpdateMetadata(opts) {
    const stationUri = opts.stationUri;
    const metadata = opts.metadata;
    if (trackingMetadata.indexOf(stationUri) === -1) {
      return;
    }
    if (metadata.hasOwnProperty('tracks')) {
      if (trackingRows.indexOf(stationUri) !== -1) {
        const timeStamp = new Date().getTime();
        metadata.rows = metadata.tracks.map(trackToRow.bind(null, timeStamp));
      }
      // Never keep a tracks object in the station (needs to be rows).
      delete metadata.tracks;
    }
    live(stationUri).update(metadata);
  }

  /**
   * When the model intializes
   * @param {Object} model
   */
  function onInit(model) {
    const baseSeed = getBaseSeedFromUri(model);
    if (!baseSeed) {
      return;
    }
    model.update({
      baseSeed: baseSeed,
      type: getType(baseSeed),
      fetchCount: DEFAULT_FETCH_COUNT
    });
    model.on('update', function onModelUpdate(properties) {
      if (properties.hasOwnProperty('rows')) {
        model.get('rows').on('wait', onRowsWait.bind(null, model));
        model.off('update', onModelUpdate);
      }
    });
    trackingMetadata.push(model.get('uri'));
  }

  /**
   * Model publish listener
   * @param {Object} model station
   * @param {Object} properties
   */
  function onPublish(model, properties) {
    if (properties.hasOwnProperty('added')) {
      const added = properties.added;
      if (typeof added === 'boolean') {
        model.update({ added: added });
        (0, _messageProxy.messageProxy)({
          method: 'POST',
          uri: 'station-add',
          body: {
            stationUri: model.get('uri'),
            add: added
          }
        });
      } else {
        console.error('Added can only be a boolean');
      }
    }
  }

  /**
   * Unset props listener
   * @param {Object} model station
   * @param {Object} properties
   */
  function onWait(model, properties) {
    let rowsIndex = -1;
    let needsMetadata;
    const metaFields = ['added', 'name', 'subtitles', 'relatedArtists', 'image', 'nextPageUrl'];

    properties.forEach(function (key, index) {
      if (key === 'rows') {
        rowsIndex = index;
      }
      if (!needsMetadata && contains(metaFields, key)) {
        needsMetadata = true;
      }
    });

    if (rowsIndex !== -1) {
      trackingRows.push(model.get('uri'));
      properties.splice(rowsIndex, 1);
      requestStationData(model, properties, true);
    } else if (needsMetadata) {
      requestStationData(model, properties);
    }
  }

  exports.register = function () {
    if (registered) {
      return;
    }
    registered = true;

    live.subscribe(regExp, 'wait', onWait);
    live.subscribe(regExp, 'init', onInit);
    live.subscribe(regExp, 'thumb-up', onThumbUp);
    live.subscribe(regExp, 'thumb-down', onThumbDown);
    live.subscribe(regExp, 'heart', onHeart);
    live.subscribe(regExp, 'undo-heart', onUndoHeart);
    live.subscribe(regExp, 'publish', onPublish);
    metadataUpdateUnsubscribe = (0, _messageProxy.messageProxy)({
      method: 'SUB',
      uri: 'station-metadata'
    }, onUpdateMetadata);
  };

  exports.unregister = function () {
    if (!registered) {
      return;
    }
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);
    live.unsubscribe(regExp, 'init', onInit);
    live.unsubscribe(regExp, 'thumb-up', onThumbUp);
    live.unsubscribe(regExp, 'thumb-down', onThumbDown);
    live.unsubscribe(regExp, 'heart', onHeart);
    live.unsubscribe(regExp, 'publish', onPublish);
    metadataUpdateUnsubscribe();
    trackingRows = [];
    trackingMetadata = [];
  };

  },{"../../libs/message-proxy":437,"../live":413,"./station/thumb-actions":402,"./station/track-to-row":403,"mout/array/contains":776,"spotify-liburi":1282}],399:[function(require,module,exports){
  'use strict';

  const rowToPlayerTrack = require('./row-to-player-track');

  const PLAYER_RESTRICTIONS = {
    disallow_toggling_repeat_context_reasons: ['disallow-radio'],
    disallow_toggling_repeat_track_reasons: ['disallow-radio'],
    disallow_toggling_shuffle_reasons: ['disallow-radio']
  };

  /**
   * Create an array of tracks formatted for the context player
   * @param {Object} model
   * @return {Array} tracks array
   */
  function createPlayerTracks(model) {
    const rows = model.get('rows');
    if (!rows) {
      return [];
    }
    return rows.values.map(rowToPlayerTrack);
  }

  /**
   * Construct a context object for context-player
   * @param {Object} model station live model
   * @return {Object} context
   */
  module.exports = function createPlayContext(model) {
    return {
      entity_uri: model.get('uri'),
      pages: [{
        tracks: createPlayerTracks(model),
        next_page_url: model.get('nextPageUrl')
      }],
      metadata: {
        context_description: model.get('name')
      },
      restrictions: PLAYER_RESTRICTIONS
    };
  };

  },{"./row-to-player-track":401}],400:[function(require,module,exports){
  'use strict';

  const PLAYER_OPTIONS = {
    shuffling_context: false,
    repeating_context: false,
    repeating_track: false
  };

  /**
   * This is neccesary because you dont get pages back from the context-player.
   * So if you want to resume a station with a set of rows (not pages)
   * you have to know the index of the last played row,
   * which you can get by comparing currentTrackUid with the row's Uid.
   * @param {Object} model station live model
   * @return {Int} index
   */
  function getLastIndex(model) {
    const rows = model.get('rows');
    const currentTrackUid = model.get('currentTrackUid');

    if (!rows || !currentTrackUid) {
      return 0;
    }

    let currentIndex;

    const foundRow = rows.values.some(function (row, index) {
      if (row.get('uid') === currentTrackUid) {
        currentIndex = index;
        return true;
      }
      return false;
    });

    return foundRow ? currentIndex : 0;
  }

  /**
   * Creates the context-player options for a station context
   * @param {Object} model station model
   * @param {Object} options optional
   * @return {Object} playOptions
   */
  module.exports = function createPlayOptions(model, options) {
    let trackIndex;
    if (options && (options.index || options.index === 0)) {
      trackIndex = options.index;
    } else {
      trackIndex = getLastIndex(model);
    }
    const playOptions = {
      skip_to_index: {
        page: 0,
        track: trackIndex
      },
      player_options_override: PLAYER_OPTIONS
    };
    if (options && options.uid) {
      playOptions.uid = options.uid;
    }
    return playOptions;
  };

  },{}],401:[function(require,module,exports){
  'use strict';

  /**
   * Converts a station row into a track for the context-player
   * @param {Object} row station row
   * @return {Object} track
   */

  module.exports = function rowToPlayerTrack(row) {
    return {
      uid: row.get('uid'),
      uri: row.get('track').get('uri'),
      album_uri: row.get('track').get('albumUri'),
      artist_uri: row.get('track').get('artistUri'),
      metadata: {
        'image_url': row.get('track').get('image'),
        'radio.thumb': row.get('track').get('thumb')
      }
    };
  };

  },{}],402:[function(require,module,exports){
  'use strict';

  module.exports = {
    UP: 'ups',
    DOWN: 'downs',
    UNDO_HEART: 'undo-heart',
    UNDO_BAN_ARTIST: 'undo-ban-artist',
    UNDO_BAN_TRACK: 'undo-ban-track'
  };

  },{}],403:[function(require,module,exports){
  'use strict';

  /**
   * Convert track objects coming from station-manager into a row.
   * @param {Object} track
   * @return {Object} row
   */

  module.exports = function trackToRow(timeStamp, track, index) {
    const metadata = track.metadata || {};
    const albumUri = track.album_uri || metadata.album_uri;
    let uid = track.uid;

    if (!track.uid) {
      const id = track.uri.replace('spotify:track:', '');
      uid = timeStamp + id + index;
    }

    return {
      uid: uid,
      uri: uid,
      track: {
        uri: track.uri,
        name: metadata.title,
        image: metadata.image_url,
        albumUri: albumUri,
        artists: transformArtists(track.metadata),
        album: { name: metadata.album_title, uri: albumUri },
        thumb: metadata['radio.thumb'] || ''
      }
    };
  };

  function transformArtists(metadata) {
    const artists = [];

    for (let i = 0;; i++) {
      const suffix = i > 0 ? `:${i}` : '';
      const uri = metadata[`artist_uri${suffix}`];
      const name = metadata[`artist_name${suffix}`];
      if (uri && name) {
        artists.push({ uri: uri, name: name });
      } else {
        break;
      }
    }

    return artists;
  }

  },{}],404:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/track
   */
  'use strict';

  const live = require('../live');
  const liburi = require('spotify-liburi');
  const intersection = require('mout/array/intersection');
  const contains = require('mout/array/contains');
  const bridge = require('./util/bridge').request;
  const cosmos = require('./util/cosmos');
  const util = require('./util/common');

  const BACKOFF = 100;
  let localFilesRequest = null;

  const metaFields = ['album', 'artists', 'availability', 'disc', 'duration', 'explicit', 'image', 'local', 'name', 'number', 'placeholder', 'playable', 'linkedTrack'];

  function onWait(model, properties) {
    // Set the 'unavailable' property based on the 'playable' property
    if (contains(properties, 'unavailable')) {
      model.get('playable', function (error, playable) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({ unavailable: !playable });
      });
    }

    const hasMetadata = !!intersection(properties, metaFields).length;

    if (hasMetadata) updateMetadata(model);

    const needsShouldBeOffline = contains(properties, 'shouldBeOffline');
    const needsOfflineProgress = contains(properties, 'offlineProgress');
    if (needsShouldBeOffline || needsOfflineProgress) {
      updateOffline(model);
    }
  }

  function updateMetadata(model) {
    bridge('track_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      util.setLocalProperties(payload);
      payload.image = largestImage(payload);

      // The linkedTrack is not available everywhere, so do fallback
      if (payload.linkedTrack) {
        payload.linkedTrack = { uri: payload.linkedTrack };
      } else {
        payload.linkedTrack = null;
      }

      model.update(payload);
    });
  }

  function largestImage(trackMetadata) {
    let imageURI = trackMetadata.image;
    let largestSize;

    if (trackMetadata.images) {
      for (let i = 0; i < trackMetadata.images.length; i++) {
        const currentImage = trackMetadata.images[i];
        if (!largestSize || currentImage[0] > largestSize) {
          largestSize = currentImage[0];
          imageURI = currentImage[1];
        }
      }
    }

    return imageURI;
  }

  function updateOffline(model) {
    // Local tracks are available offline if they are playable
    if (liburi.fromString(model.uri).type === liburi.Type.LOCAL) {
      model.get('playable', function (error, playable) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({
          shouldBeOffline: playable,
          offlineProgress: playable ? 1 : 0
        });
      });
      return;
    }

    cosmos.subscribe({ url: `sp://offline/v1/resources?uri=${model.uri}` }, function (error, response) {
      if (!error) {
        const resource = response.body.resources;
        updateModelWithOfflineData(model, resource);
      } else {
        // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
        // If that's the case, we handle it like the client doesn't support offline.
        const statusCode = error.response && error.response.getStatusCode();
        if (statusCode === -104 || statusCode === 404) {
          updateModelWithOfflineData(model, { offline_availability: 'no' });
        } else {
          if (global.console) console.error(error);
          return;
        }
      }
    });
  }

  function updateModelWithOfflineData(model, resource) {
    let shouldBeOffline = false;
    let offlineProgress = 0;

    switch (resource.offline_availability) {
      case 'waiting':
        shouldBeOffline = true;
        offlineProgress = 0;
        break;
      case 'downloading':
        shouldBeOffline = true;
        offlineProgress = 0.5;
        break;
      case 'yes':
        shouldBeOffline = true;
        offlineProgress = 1;
        break;
      case 'no':
        shouldBeOffline = false;
        offlineProgress = 0;
        break;
      default:
        console.error('Unexpected resource.offline_availability', resource.offline_availability);
        break;
    }

    model.update({
      shouldBeOffline: shouldBeOffline,
      offlineProgress: offlineProgress
    });
  }

  let registered;

  function waitForLocalFilesChange() {
    localFilesRequest = cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
      if (!registered) return;

      if (error) {
        // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
        // If that's the case, we bail out and don't do anything.
        const statusCode = error.response && error.response.getStatusCode();
        if (statusCode === -104 || statusCode === 404) {
          return;
        }
        if (global.console) console.error(error);
        return;
      }

      const event = response.body;
      const data = event.data;
      const type = event.type;
      const isAdded = type === 'added';
      const isRemoved = type === 'removed';

      if (isAdded || isRemoved) {
        data.tracks.forEach(function (track) {
          live(track.uri).update({
            shouldBeOffline: isAdded,
            offlineProgress: isAdded ? 1 : 0,
            playable: isAdded
          });
        });
      }
    });
  }

  function waitForTrackChange() {
    bridge('track_event_wait_any', [], function (error, event) {
      if (!registered) return;

      if (error) {
        setTimeout(function () {
          waitForTrackChange();
        }, BACKOFF);
        if (global.console) console.error(error);
        return;
      }

      waitForTrackChange();

      if (event.type === 'change') {
        if (event.data.playable !== undefined) {
          event.data.unavailable = !event.data.playable;
        }
        live(event.data.uri).update(event.data);
      }
    });
  }

  const regExp = exports.matches = /^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'wait', onWait);

    waitForLocalFilesChange();

    // Only desktop has support for track relinking
    if (global._getSpotifyModule) {
      waitForTrackChange();
    }
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);

    if (localFilesRequest) {
      localFilesRequest.cancel();
      localFilesRequest = null;
    }
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"./util/bridge":406,"./util/common":407,"./util/cosmos":408,"mout/array/contains":776,"mout/array/intersection":783,"spotify-liburi":1282}],405:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/user
   */
  'use strict';

  const live = require('../live');
  const liburi = require('spotify-liburi');
  const contains = require('mout/array/contains');
  const intersection = require('mout/array/intersection');
  const bridge = require('./util/bridge').request;

  function updateMetadata(model) {
    bridge('user_metadata', [model.uri], function (error, payload = {}) {
      if (error && global.console) console.error(error);

      payload.username = payload.username || liburi.from(model.uri).username;
      payload.name = payload.name || payload.username;
      payload.image = payload.image || '';
      payload.images = payload.images || [];

      // Has to be truthy check
      // because can be undefined or null
      if (!payload.subscribed) {
        payload.subscribed = false;
      }

      // Has to be truthy check
      // because can be undefined or null
      if (!payload.currentUser) {
        live('spotify:client').query('currentUser(uri)', function (innerError, data) {
          if (innerError) {
            if (global.console) console.error(innerError);
          } else {
            model.update({ currentUser: model.uri === data.currentUser.uri });
          }
        });
      }

      model.update(payload);
    });
  }

  function updateArtist(model) {
    bridge('user_associated_artist', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      const artist = payload.artist ? { uri: payload.artist } : null;
      model.update({ artist: artist });
    });
  }

  function onWait(model, properties) {
    const hasArtist = contains(properties, 'artist');
    const metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
    const hasMetadata = !!intersection(properties, metaFields).length;

    if (hasMetadata) updateMetadata(model);
    if (hasArtist) updateArtist(model);
  }

  const regExp = exports.matches = /^spotify:user:[^:]+$/;
  let registered;
  exports.register = function () {
    if (registered) return;
    registered = true;

    live.subscribe(regExp, 'wait', onWait);
  };

  exports.unregister = function () {
    if (!registered) return;
    registered = false;

    live.unsubscribe(regExp, 'wait', onWait);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"./util/bridge":406,"mout/array/contains":776,"mout/array/intersection":783,"spotify-liburi":1282}],406:[function(require,module,exports){
  /**
   * @module live-models/util/bridge
   * @private
   */

  'use strict';

  const bridge = require('../../bridge');

  module.exports = {
    request: bridge.request
  };

  },{"../../bridge":121}],407:[function(require,module,exports){
  'use strict';

  const liburi = require('spotify-liburi');

  function setLocalProperties(track) {
    if (track.album && track.album.uri) {
      const albumType = liburi.from(track.album.uri).type;
      track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
    }
    if (track.artists) {
      for (let i = 0, l = track.artists.length; i < l; i++) {
        const artist = track.artists[i];
        if (artist.uri) {
          const artistType = liburi.from(artist.uri).type;
          artist.local = artistType === liburi.Type.LOCAL_ARTIST;
        }
      }
    }
  }

  module.exports = {
    setLocalProperties: setLocalProperties
  };

  },{"spotify-liburi":1282}],408:[function(require,module,exports){
  (function (global){
  /**
   * @module live-models/util/cosmos
   * @private
   */

  'use strict';

  const cosmos = require('spotify-cosmos-api');

  function DELETE(options, callback) {
    options.method = exports.cosmos.Action.DELETE;
    return request(options, callback);
  }

  function GET(options, callback) {
    options.method = exports.cosmos.Action.GET;
    return request(options, callback);
  }

  function SUB(options, callback) {
    options.method = exports.cosmos.Action.SUB;
    return request(options, callback);
  }

  function POST(options, callback) {
    options.method = exports.cosmos.Action.POST;
    return request(options, callback);
  }

  function PUT(options, callback) {
    options.method = exports.cosmos.Action.PUT;
    return request(options, callback);
  }

  function HEAD(options, callback) {
    options.method = exports.cosmos.Action.HEAD;
    return request(options, callback);
  }

  function request(options, callback) {
    const method = options.method;
    delete options.method;

    let subscription;
    let canceled;

    sanitizeURL(options.url, function (error, url) {
      if (error) {
        if (callback) {
          callback(error);
        }
      } else {
        // if you don't cancel before the userName is replaced.
        if (!canceled) {
          const innerRequest = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
          subscription = exports.cosmos.resolver.resolve(innerRequest, function (innerError, response) {
            if (!callback) return;
            if (callback && innerError) {
              callback(innerError);
            } else {
              try {
                callback(null, {
                  body: JSON.parse(response.getBody() || '{}'),
                  headers: response.getHeaders(),
                  status: response.getStatusCode()
                });
              } catch (parseError) {
                parseError.response = response;
                callback(parseError);
              }
            }
          });
        }
      }
    });

    return {
      cancel: function () {
        if (subscription && subscription.cancel) {
          // we already subscribed, cancel it.
          subscription.cancel();
          subscription = null;
        } else if (!canceled) {
          // not subscribed yet, don't even subscribe.
          canceled = true;
        }
        return null;
      }
    };
  }

  function sanitizeURL(url, callback) {
    if (url.indexOf('@') > -1) {
      callback(null, url.replace('@', "Bookmark"));
    } else {
      callback(null, url);
    }
  }

  exports.request = request;
  exports.get = GET;
  exports.post = POST;
  exports.subscribe = SUB;
  exports.delete = DELETE;
  exports.put = PUT;
  exports.head = HEAD;
  exports.cosmos = cosmos;

  exports.sanitizeURL = sanitizeURL;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"spotify-cosmos-api":1272}],409:[function(require,module,exports){
  (function (global){
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = () => global.location.href;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],410:[function(require,module,exports){
  'use strict';

  const Preferences = require('../../preferences');

  /**
   * Subscribe for changes of the 'Show Unplayable Tracks' preference.
   *
   * @param {Function} callback Callback function that gets called for
   *                            each change.
   *
   * @return {Object} An object with a `cancel` method.
   */
  function subscribe(callback) {
    const preferences = new Preferences('ui');

    return preferences.subscribe('show_unplayable_tracks', function (error, value) {
      if (error) {
        callback(error);
      } else {
        callback(null, !!value);
      }
    });
  }

  exports.subscribe = subscribe;

  },{"../../preferences":449}],411:[function(require,module,exports){
  'use strict';

  const base = 'spotify:internal:sortlist';
  const regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

  /**
   * Create a URI representing a sorted variant of a list.
   *
   * @param {string} originUri The original list URI.
   * @param {string} direction The direction of the sorted list ('asc' or 'desc').
   * @param {string} query The query string (compatible with live). Sorting
   *     implementations might not look at all values. The list of produced values
   *     from the query will be tried in order from left to right. If two items have
   *     the same value, it will look at the next produced value from this query.
   *     Any spaces in the query will be removed.
   *
   * @return {string} URI of the sorted variant of the list. The URI will have
   *     the query string URL encoded.
   */
  exports.create = function (originUri, direction, query) {
    const newOriginUri = originUri.replace(/^spotify:/, '');

    const newQuery = encodeURIComponent(query).replace(/%20/g, '');

    return [base, direction, newQuery, newOriginUri].join(':');
  };

  /**
   * Get the direction of the sorted list.
   *
   * @param {string} sortUri The URI of the sorted list.
   *
   * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
   *     invalid, this returns an empty string.
   */
  exports.getDirection = function (sortUri) {
    const matches = sortUri.match(regExp);
    if (!matches) return '';

    return matches[1];
  };

  /**
   * Get the query string from a sort URI.
   *
   * @param {string} sortUri The URI of the sorted list.
   *
   * @return {string} The query string, URL decoded. If URI is
   *     invalid, this returns an empty string.
   */
  exports.getQuery = function (sortUri) {
    const matches = sortUri.match(regExp);
    if (!matches) return '';

    return decodeURIComponent(matches[2]);
  };

  /**
   * Get the URI of the original list.
   *
   * @param {string} sortUri The URI of the sorted list.
   *
   * @return {string} The URI of the original list. If the sort URI is invalid,
   *     this returns an empty string.
   */
  exports.getOriginUri = function (sortUri) {
    const matches = sortUri.match(regExp);
    if (!matches) return '';

    return `spotify:${matches[3]}`;
  };

  /**
   * Parse and return all parts of the sort URI.
   *
   * @param {string} sortUri The URI of the sorted list.
   *
   * @return {Object?} An object with properties `direction`, `query` and `originUri`,
   *     or null if the URI is not valid.
   */
  exports.parse = function (sortUri) {
    const matches = sortUri.match(regExp);
    if (!matches) return null;

    return {
      direction: matches[1],
      query: decodeURIComponent(matches[2]),
      originUri: `spotify:${matches[3]}`
    };
  };

  /**
   * Test if the provided URI is a valid sort URI.
   *
   * @param {string} sortUri The URI of the sorted list.
   *
   * @return {boolean} True if it's valid, false otherwise.
   */
  exports.isValid = function (sortUri) {
    return regExp.test(sortUri);
  };

  /**
   * The regular expression that matches sort URIs.
   */
  exports.regExp = regExp;

  },{}],412:[function(require,module,exports){
  'use strict';

  const sortUriUtils = require('../live-sort-uri');
  const filterUriUtils = require('../live-filter-uri');

  /**
   * Create a URI representing a wrapped variant of a list.
   *
   * @param {object} opts The options.
   * @param {string} opts.originUri The origin uri.
   * @param {object?} opts.filter The filter, if any
   * @param {object?} opts.sort The sorting, if any
   *
   * @return {string} URI of the wrapped variant of the list.
   */
  exports.create = function (opts) {
    let uri = opts.originUri;
    if (opts.filter) {
      uri = filterUriUtils.create(uri, opts.filter.query);
    }
    if (opts.sort) {
      uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
    }
    return uri;
  };

  /**
   * Get the URI of the original list.
   *
   * @param {string} sortUri The URI of the wrapped list.
   *
   * @return {string} The URI of the original list. If the wrapped URI is invalid,
   *     this returns an empty string.
   */
  exports.getOriginUri = function (wrappedUri) {
    const parsed = exports.parse(wrappedUri);
    return parsed && parsed.originUri || '';
  };

  /**
   * Parse and return all parts of the wrapped URI.
   *
   * @param {string} wrappedUri The URI of the wrapped list.
   *
   * @return {object} An object with properties `originUri`, `sort` and `filter`.
   */
  exports.parse = function (wrappedUri) {
    const sort = sortUriUtils.parse(wrappedUri);
    const filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
    if (!(sort || filter)) return null;

    return {
      originUri: filter && filter.originUri || sort && sort.originUri,
      sort: sort,
      filter: filter
    };
  };

  /**
   * Test if the provided URI is a valid wrapped URI.
   *
   * @param {string} wrappedUri The URI of the wrapped list.
   *
   * @return {boolean} True if it's valid, false otherwise.
   */
  exports.isValid = function (wrappedUri) {
    return !!exports.parse(wrappedUri);
  };

  },{"../live-filter-uri":357,"../live-sort-uri":411}],413:[function(require,module,exports){
  (function (global){
  /* eslint-disable no-use-before-define */

  /**
   * @module live
   */'use strict';

  // prime

  const prime = require('../../libs/prime');
  const defer = require('../../libs/prime/defer');
  const Emitter = require('../../libs/prime/emitter');

  // mout
  const isPlainObject = require('mout/lang/isPlainObject');
  const isRegExp = require('mout/lang/isRegExp');
  const isNumber = function (n) {
    return typeof n === 'number';
  };
  const isString = function (s) {
    return typeof s === 'string';
  };

  const escapeRegExp = require('mout/string/escapeRegExp');

  const _difference = require('mout/array/difference');
  const filter = require('mout/array/filter');
  const combine = require('mout/array/combine');
  const map = require('mout/array/map');

  const deepMixIn = require('mout/object/deepMixIn');
  const pick = require('mout/object/pick');

  function parallel(tasks, cb) {
    const results = [];
    let pending = tasks.length;

    if (!pending) cb(null, results);else {
      tasks.forEach((task, i) => {
        task((err, result) => {
          results[i] = result;
          if (--pending === 0 || err) cb(err, results);
        });
      });
    }
  }

  // util
  const OrderedSet = require('./util/ordered-set');
  const Range = require('../range2');
  const parse = require('./util/parser');
  const throttle = require('./util/throttle');

  // debugging
  const debug = require('../debug')('live');

  // methods

  const isLiveList = function (item) {
    return item instanceof LiveList;
  };

  const isLiveObject = function (item) {
    return item instanceof LiveObject;
  };

  const simpleClone = function (object) {
    return Object.assign({}, object);
  };

  const difference = function (a, b) {
    return a.length === 0 ? [] : _difference.call(this, a, b);
  };

  const values = function (object, keys) {
    const newValues = [];
    let key;
    for (let i = 0, len = keys.length; i < len; i++) {
      key = keys[i];
      if (key in object) newValues.push(object[key]);else newValues.length++;
    }
    return newValues;
  };

  // subtract ranges2 from ranges1
  const rdifference = function (ranges1, ranges2) {
    if (!ranges1.length) return [];

    let resultingRanges = [];

    for (let i = 0, len = ranges1.length; i < len; i++) {
      const range = ranges1[i];
      resultingRanges = resultingRanges.concat(range.subtract(ranges2));
    }

    // Make sure we don't have overlapping ranges
    resultingRanges = new Range(0, 0).merge(resultingRanges);

    // Remove any empty ranges
    resultingRanges = filter(resultingRanges, function (range) {
      return !!range.length;
    });

    return resultingRanges;
  };

  // merge ranges1 into ranges2
  const rcombine = function (ranges1, ranges2) {
    let newRanges2 = ranges2;
    for (let i = 0, len = ranges1.length; i < len; i++) {
      const range = ranges1[i];
      newRanges2 = range.merge(newRanges2);
    }
    return newRanges2;
  };

  // util
  let IDX = 0;

  const slice_ = Array.prototype.slice;

  const transform = function (item, method) {
    if (isPlainObject(item)) {
      // plain objects need to be liveified
      if ('operations' in item) return new LiveList().update(item.operations);
      return live(item.uri)._update(item, method);
    }

    if (Array.isArray(item)) {
      // arrays need to be liveified
      return new LiveList()._update([{
        type: 'insert',
        index: 0,
        length: item.length,
        values: item
      }], method);
    }
    return item;
  };

  // Creates a callback with a timeout.
  function createTimedCallback(callback, timeout) {
    let called;
    const timeoutId = setTimeout(function () {
      called = true;
      callback(new Error(`Timeout Expired: ${timeout} milliseconds`));
    }, timeout);
    return function () {
      if (!called) {
        clearTimeout(timeoutId);
        callback.apply(this, arguments);
      }
    };
  }

  const LiveList = prime(
  /** @lends LiveList.prototype */{
    mixin: Emitter,

    /**
     * A representation of an array which may be observed for changes
     * @constructs
     * @mixes Emitter
     * @param {Number} [length] - A number representing the length of the liveList.
     */
    constructor: function LiveList(length) {
      this._data = new OrderedSet(length);
      this._mergeThrottled = throttle(this._merge, this);
      this._waiting = [];

      let lastWait = '';

      if (live.debug) {
        setInterval(() => {
          const thisWait = this._waiting.toString();
          if (lastWait === thisWait) return;
          lastWait = thisWait;

          if (this._waiting.length) {
            debug(this, 'waiting for', this._waiting);
          } else {
            debug(this, 'all done');
          }
        }, 2000);
      }
    },

    get index() {
      return this._data.index;
    },

    get length() {
      return this._data.length;
    },

    get keys() {
      return this._data.keys;
    },

    get values() {
      return this._data.values;
    },

    indexOf: function (key) {
      return this._data.indexOf(key);
    },

    indexOfMany: function (keys) {
      return this._data.indexOfMany(keys);
    },

    valueOf: function (key) {
      return this._data.valueOf(key);
    },

    hasKey: function (key) {
      return this._data.hasKey(key);
    },

    forEach: function (fn, ctx) {
      this._data.forEach(fn, ctx);
      return this;
    },

    map: function (fn, ctx) {
      return this._data.map(fn, ctx);
    },

    _merge: function () {
      const data = this._data; // actual data
      const publish = this._publish; // new items on top of a copy of data || null
      const before = this._before; // an old copy of data || null

      if (publish) {
        delete this._publish;
        if (this._listeners && this._listeners.publish) {
          const publishDiff = data.diff(publish);
          if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
        }
      } else if (before) {
        delete this._before;
        if (this._listeners && this._listeners.update) {
          const updateDiff = before.diff(data);
          if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
        }
      }
      return this;
    },

    _update: function (operations, method) {
      let branch;
      if (method === PUBLISH) {
        // it was receiving, cannot publish.
        if (this._before) return this;
        branch = this._publish || (this._publish = this._data.clone());
      } else if (method === UPDATE) {
        // it was publishing, delete it.
        if (this._publish) delete this._publish;
        if (!this._before) this._before = this._data.clone();
        branch = this._data;
      }

      let op;
      for (let opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
        op = operations[opIndex];
        const newValues = [];
        const keys = op.keys || [];

        switch (op.type) {
          case 'length':
            branch.length = op.length;
            break;
          case 'sort':
            branch.sort(op.compareFunction);
            break;
          case 'move':
            branch.move(op.from, op.to, op.length);
            break;
          case 'remove':
            branch.remove(op.index, op.length);
            break;
          case 'insert':
            for (let i = 0, len = op.values.length; i < len; i++) {
              if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
              newValues[i] = transform(op.values[i], method);
            }
            branch.insert(op.index, keys, newValues);
            break;
          default:
            console.error('Invalid operation type', op.type);
            break;
        }
      }

      if (method === UPDATE) {
        this._waiting = rdifference(this._waiting, this.index);
      }

      this._mergeThrottled();
      return this;
    },

    publish: function (operations) {
      return this._update(operations, PUBLISH);
    },

    update: function (operations) {
      return this._update(operations, UPDATE);
    },

    /**
     * Serialize the data in this list into a plain object.
     *
     * @param {number=} limit Optional limit parameter. Controls how many levels
     *     deep to serialize.
     *
     * @return {Array} The data array.
     */
    serialize: function (limit) {
      if (limit === 0) return [];

      const array = [];
      const nextLimit = limit === undefined ? undefined : limit - 1;

      for (let i = 0; i < this.length; i++) {
        const value = this.values[i];
        let serializedValue = value;
        if (value && value.serialize) {
          serializedValue = value.serialize(nextLimit);
        }
        array.push(serializedValue);
      }

      return array;
    },

    _getDataFromMask: function (mask) {
      const items = [];

      if (mask.length > 0) {
        // The provided mask to a list is the mask for each list item, so we need
        // to loop through all the items and get the data from each item based on
        // the mask.
        for (let i = 0, l = this.length; i < l; i++) {
          const item = this.get(i);
          let parsedItem;
          const isObjectOrList = item && item._getDataFromMask;
          if (isObjectOrList) {
            parsedItem = item._getDataFromMask(mask);
          }
          items.push(parsedItem);
        }
      }

      return items;
    },

    _query: function (selector, callback, mode) {
      const query = () => {
        queryList(this, selector, (error, data, wasSync) => {
          if (error) {
            callback(error);
          } else {
            if (!wasSync) {
              this._query(selector, callback, mode);
            } else {
              callback(null, data);
            }
          }
        });
      };

      if (mode === ASYNC) defer.immediate(query);else query();
    },

    /**
     * Query properties in this list.
     * This can be called in two different ways: with a callback or without. When
     * calling it with a callback, it will wait for any missing data and always
     * return the data you queried for. When calling it without a callback, it
     * will return an array structure with only the data that was found in the
     * object at the moment. It will not kick off any events for waiting for
     * properties.
     *
     * @param {String} selector - The query selector. Only selectors without
     *     filters are supported when not providing a callback.
     * @param {Array} params - The query replace parameters.
     * @param {LiveList~queryCallback} callback - The callback that handles the response.
     * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
     * @param {Number} timeout - optional timeout in milliseconds
     *
     * @return {LiveList|Array} If no callback is passed it returns an array with
     *                             the data matching the query, that was found at
     *                             the moment in the list.
     *                             If a callback is passed it returns the instance.
     */
    query: function (selector, params, callback, mode, timeout) {
      let newParams = params;
      let newCallback = callback;
      let newMode = mode;
      let newTimeout = timeout;

      /**
       * @callback LiveList~queryCallback
       * @param {Error|Null} error - An error that you can throw, or null.
       * @param {Array} [data] - The response as an array.
       */
      if (typeof newParams === 'function') {
        // shift for empty params
        newTimeout = newMode;
        newMode = newCallback;
        newCallback = newParams;
        newParams = [];
      }

      if (!newCallback) {
        return this._getDataFromMask(parse(selector, newParams).mask);
      }

      if (!newMode) {
        newMode = ASYNC;
      } else if (isNumber(newMode)) {
        // shift once again
        newTimeout = newMode;
        newMode = ASYNC;
      }

      if (newTimeout) {
        newCallback = createTimedCallback(newCallback, newTimeout);
      }

      this._query(parse(selector, newParams), newCallback, newMode);
      return this;
    },

    _wait: function (ranges) {
      if (!this._required) {
        // if _required is set, it was deferred already
        this._required = [];
        defer.immediate(function () {
          const missingFromIndex = this.missing(this._required);
          const missingFromWaiting = rdifference(missingFromIndex, this._waiting);
          this._waiting = rcombine(this._waiting, missingFromWaiting);
          delete this._required;
          if (missingFromWaiting.length) {
            this.emit('wait', missingFromWaiting, EMIT_SYNC);
          }
        }, this);
      }
      this._required = rcombine(this._required, ranges);
    },

    missing: function (ranges) {
      return rdifference(ranges, this.index);
    },

    // the raw, unbeautified get
    // this can callback sync or async
    _get: function (ranges, callback) {
      if (this.missing(ranges).length) {
        // has missing stuff (no matter what)
        this._wait(ranges);

        const check = function () {
          const needed = this.missing(ranges);
          if (!needed.length) {
            this.off('update', check);
            callback.call(this);
          }
        };

        this.on('update', check);
      } else {
        // the callback is called with 'true' when syncronous.
        callback.call(this, null, true);
      }
    },

    /**
     * Checks if the range has been set with values in the list.
     *
     * @param {number} fromIndex The index to start from.
     * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
     *     toIndex is specified, it will default to the index after fromIndex, to
     *     check for the single item at fromIndex.
     *
     * @return {Boolean} True if the range has been set.
     */
    has: function (fromIndex, toIndex) {
      const hasToIndex = toIndex !== undefined;
      let range;
      if (!hasToIndex) {
        range = new Range(fromIndex, fromIndex + 1);
      } else {
        range = new Range(fromIndex, toIndex);
      }

      return range.contained(this.index);
    },

    /**
     * Gets items from the list between the specified indices.
     * @param {Number} what - The index to start from.
     * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
     * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
     *     is specified, the callback can be placed as the second argument.
     * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
     * @param {Number} timeout - optional timeout in milliseconds
     * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
     *                          If a callback is specified, the method returns the instance.
     */
    get: function (fromIndex, toIndex) {
      /**
       * @callback LiveList~getCallback
       * @param {Error|Null} error - An error that you can throw, or null.
       * @param {Array|*} [data] - The response as an array.
       *                           If toIndex is not specified a single item on the list is passed.
       */

      // fast, get one
      if (arguments.length === 1) {
        if (isNumber(fromIndex)) return this.values[fromIndex];
        if (isString(fromIndex)) return this.valueOf(fromIndex);
      }

      const args = slice_.call(arguments);
      let callback;
      let mode;
      let requested;

      for (let i = 0, len = args.length; i < len; i++) {
        const arg = args[i];
        if (typeof arg === 'function') {
          const split = args.splice(i, 3);
          len = args.length;
          callback = split[0];
          if (split[1]) {
            if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
              mode = split[1];
            } else {
              // assume this arg is a timeout
              mode = ASYNC;
              callback = createTimedCallback(callback, split[1]);
              break;
            }
            // is there a timeout ?
            if (split[2] && mode !== SYNC) {
              callback = createTimedCallback(callback, split[2]);
            }
          } else {
            mode = ASYNC;
          }
          break;
        }
      }

      let asArray = false;
      let asSingleValue = false;

      if (fromIndex instanceof Range) {
        // one range
        requested = args;
        asArray = !callback && requested.length > 1;
      } else if (Array.isArray(fromIndex)) {
        // array of ranges
        asArray = true;
        requested = fromIndex;
      } else {
        // numbers ?
        const hasToIndex = !isNaN(toIndex);
        if (!hasToIndex) {
          requested = [new Range(fromIndex, fromIndex + 1)];
        } else {
          requested = [new Range(fromIndex, toIndex)];
        }
        asSingleValue = !hasToIndex;
      }

      const result = () => {
        return map(requested, range => {
          return this.values.slice(range.start, range.end);
        });
      };

      const done = () => {
        if (asArray) callback.call(this, null, result());else if (asSingleValue) {
          callback.call(this, null, this.values[fromIndex]);
        } else callback.apply(this, [null].concat(result()));
      };

      if (!callback) {
        if (asArray) return result();
        return result()[0];
      } else if (mode === SYNC) {
        done();
      } else {
        if (mode === ASYNC && !this.missing(requested).length) {
          // it has all the data but needs to be ASYNC
          defer.immediate(function () {
            this._get(requested, done);
          }, this);
        } else {
          this._get(requested, done);
        }
      }
      return this;
    }
  });

  const LiveObject = prime(
  /** @lends LiveObject.prototype */{
    mixin: Emitter,

    /**
     * A representation of an object which may be observed for changes
     * @constructs
     * @mixes Emitter
     */
    constructor: function LiveObject(_uri) {
      this.uri = _uri;
      this._data = { uri: _uri };
      this._mergeThrottled = throttle(this._merge, this);
      this.index = [];
      this._waiting = [];
      this.emit('init', EMIT_SYNC);

      let lastWait = '';

      if (live.debug) {
        setInterval(() => {
          const thisWait = this._waiting.toString();
          if (lastWait === thisWait) return;
          lastWait = thisWait;

          if (this._waiting.length) {
            debug(this, this._waiting);
          } else {
            debug(this, 'all done');
          }
        }, 2000);
      }
    },

    emit: function () {
      const uri = this.uri;
      if (uri) {
        const keys = emitters.keys;
        const innerValues = emitters.values;
        let key;
        let args;

        for (let i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          if (uri.match(key)) {
            if (!args) {
              args = new Array(arguments.length);
              for (let j = 0; j < arguments.length; ++j) {
                args[j] = arguments[j];
              }
              args.splice(1, 0, this);
            }
            const emitter = innerValues[i];
            emitter.emit.apply(emitter, args);
          }
        }
      }

      Emitter.prototype.emit.apply(this, arguments);
    },

    _merge: function () {
      const data = this._data; // the data
      const before = this._before; // an old copy of data
      const publish = this._publish; // published data
      let value;
      let key;

      // published changes
      if (publish) {
        delete this._publish;

        // emit change events if the object has a uri that can be subscribed too,
        // or the object in itself has listeners
        if (this.uri || this._listeners && this._listeners.publish) {
          const publishEvent = {};

          for (key in publish) {
            if (!publish.hasOwnProperty(key)) continue;
            value = publish[key];
            if (data[key] !== value) publishEvent[key] = value;
          }

          if (Object.keys(publishEvent).length) {
            this.emit('publish', publishEvent, EMIT_SYNC);
          }
        }
      }

      // if there are changes
      if (before) {
        delete this._before;

        const updateEvent = {};

        // emit change events if the object has a uri that can be subscribed too,
        // or the object in itself has listeners
        if (this.uri || this._listeners && this._listeners.update) {
          // check changed and added keys
          for (key in data) {
            if (!data.hasOwnProperty(key)) continue;
            value = data[key];
            // there was no key, or value is different
            if (!(key in before) || before[key] !== value) {
              updateEvent[key] = value;
            }
          }

          // check deleted keys
          for (key in before) {
            if (!before.hasOwnProperty(key)) continue;
            value = before[key];
            // there is no key so it was deleted
            if (!(key in data)) updateEvent[key] = undefined;
          }

          if (Object.keys(updateEvent).length) {
            this.emit('update', updateEvent, EMIT_SYNC);
          }
        }
      }

      return this;
    },

    _update: function (object, method) {
      let branch;

      if (method === PUBLISH) {
        branch = this._publish || (this._publish = simpleClone(this._data));
      } else if (method === UPDATE) {
        if (!this._before) this._before = simpleClone(this._data);
        branch = this._data;
      }

      let value;
      for (const key in object) {
        if (!object.hasOwnProperty(key)) continue;
        value = object[key];
        const previous = !(key in branch) ? undefined : branch[key];

        if (isLiveList(previous)) {
          // updating lists with an array will keep the reference but replace every item.
          if (Array.isArray(value)) {
            previous._update([{
              type: 'remove',
              index: 0,
              length: previous.length
            }, {
              type: 'insert',
              index: 0,
              values: value
            }], method);
            continue;
          } else if (isPlainObject(value) && 'operations' in value) {
            previous._update(value.operations, method);
            continue;
          }
        }

        if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
      }

      if (method === UPDATE) {
        this.index = Object.keys(branch);
        this._waiting = difference(this._waiting, this.index);
      }

      this._mergeThrottled();
      return this;
    },

    delete: function (key) {
      const object = {};
      object[key] = undefined;
      return this.update(object);
    },

    update: function (object) {
      return this._update(object, UPDATE);
    },

    publish: function (object) {
      return this._update(object, PUBLISH);
    },

    /**
     * Serialize the data in this object into a plain object.
     *
     * @param {number=} limit Optional limit parameter. Controls how many levels
     *     deep to serialize.
     *
     * @return {Object} The data object.
     */
    serialize: function (limit) {
      if (limit === 0) return {};

      const object = {};
      const data = this._data;
      const nextLimit = limit === undefined ? undefined : limit - 1;

      for (const key in data) {
        if (!data.hasOwnProperty(key)) continue;
        const value = data[key];
        if (value === undefined) continue;
        let serializedValue = value;
        if (value && value.serialize) {
          serializedValue = value.serialize(nextLimit);
        }
        object[key] = serializedValue;
      }

      return object;
    },

    _getDataFromMask: function (mask) {
      const data = {};

      for (let i = 0, l = mask.length; i < l; i++) {
        const thisMask = mask[i];
        const nextMask = thisMask.mask;
        const key = thisMask.key;

        const realValue = this.get(key);
        let value = realValue;

        // Set the value to an empty object or array, and then it will be filled
        // in with the found data in the next step.
        if (isLiveObject(realValue)) value = {};
        if (isLiveList(realValue)) value = [];

        if (nextMask) {
          if (isLiveObject(realValue)) {
            const innerData = realValue._getDataFromMask(nextMask);
            deepMixIn(value, innerData);
          } else if (isLiveList(realValue)) {
            value = realValue._getDataFromMask(nextMask);
          }
        }

        data[key] = value;
      }

      return data;
    },

    _query: function (selector, callback, mode) {
      const query = () => {
        queryObject(this, selector, (error, data, wasSync) => {
          if (error) {
            callback.call(this, error);
          } else {
            if (!wasSync) {
              this._query(selector, callback, mode);
            } else {
              callback.call(this, null, data);
            }
          }
        });
      };

      if (mode === ASYNC) defer.immediate(query);else query();
    },

    /**
     * Query properties in this object.
     * This can be called in two different ways: with a callback or without. When
     * calling it with a callback, it will wait for any missing properties and
     * always return the data you queried for. When calling it without a callback,
     * it will return an object structure with only the data that was found in the
     * object at the moment. It will not kick off any events for waiting for
     * properties.
     *
     * @param {String} selector - The query selector. Only selectors without
     *     filters are supported when not providing a callback.
     * @param {Array} params - The query replace parameters. Optional.
     * @param {LiveObject~queryCallback} callback - The callback function.
     * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
     * @param {Number} timeout - optional timeout in milliseconds
     *
     * @return {LiveObject|Object} If no callback is passed it returns an object
     *                             with the data matching the query, that was found
     *                             at the moment in the object.
     *                             If a callback is passed it returns the instance.
     */
    query: function (selector, params, callback, mode, timeout) {
      let newParams = params;
      let newCallback = callback;
      let newMode = mode;
      let newTimeout = timeout;

      /**
       * @callback LiveObject~queryCallback
       * @param {Error|Null} error - An error that you can throw, or null.
       * @param {LiveObject} [data] - The response as a plain object.
       */
      if (typeof newParams === 'function') {
        // shift for empty params
        newTimeout = newMode;
        newMode = newCallback;
        newCallback = newParams;
        newParams = [];
      }

      if (!newCallback) {
        return this._getDataFromMask(parse(selector, newParams).mask);
      }

      if (!newMode) {
        newMode = ASYNC;
      } else if (isNumber(newMode)) {
        // shift once again
        newTimeout = newMode;
        newMode = ASYNC;
      }

      if (newTimeout) {
        newCallback = createTimedCallback(newCallback, newTimeout);
      }

      this._query(parse(selector, newParams), newCallback, newMode);
      return this;
    },

    _wait: function (keys) {
      if (!this._required) {
        // if _required is set, it was deferred already
        this._required = [];
        defer.immediate(function () {
          const missingFromIndex = this.missing(this._required);
          const missingFromWaiting = difference(missingFromIndex, this._waiting);
          this._waiting = combine(this._waiting, missingFromWaiting);
          delete this._required;
          if (missingFromWaiting.length) {
            this.emit('wait', missingFromWaiting, EMIT_SYNC);
          }
        }, this);
      }
      this._required = combine(this._required, keys);
    },

    missing: function (keys) {
      return difference(keys, this.index);
    },

    /**
     * Checks if the key has been set in the object.
     *
     * @param {string} key The name of the key.
     *
     * @return {Boolean} True if the key has been set.
     */
    has: function (key) {
      return this.index.indexOf(key) > -1;
    },

    // the raw, unbeautified get
    // this can callback sync or async
    _get: function (keys, callback) {
      if (this.missing(keys).length) {
        this._wait(keys);

        const check = function () {
          const needed = this.missing(keys);
          if (!needed.length) {
            this.off('update', check);
            callback.call(this);
          }
        };
        this.on('update', check);
      } else {
        // the callback is called with 'true' when syncronous.
        callback.call(this, null, true);
      }
    },

    /**
     * Gets values from the object.
     * @param {...String|Array} keys - An array of strings as arguments.
     * @param {LiveObject~getCallback} [callback] - Optional callback function.
     * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
     * @param {Number} timeout - optional timeout in milliseconds
     * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
     *                             returns the values in an array.
     *                             If no callback is passed and keys is a single parameter it
     *                             returns the requested value (any type).
     *                             If a callback is passed it returns the instance.
     */
    get: function (key) {
      /**
       * @callback LiveObject~getCallback
       * @param {Error|Null} error - An error that you can throw, or null.
       * @param {Array|...*} [data] - If keys are requested as arguments (any #)
       *                              it will return many results as arguments.
       *                              If keys are requested as an array (any #), it will return data as an array
       * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
       */

      // fast, get one
      const data = this._data;
      if (arguments.length === 1 && isString(key)) return data[key];

      const args = slice_.call(arguments);
      let callback;
      let mode;
      let keys;

      for (let i = 0, len = args.length; i < len; i++) {
        const arg = args[i];
        if (typeof arg === 'function') {
          const split = args.splice(i, 3);
          len = args.length;
          callback = split[0];
          if (split[1]) {
            if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
              mode = split[1];
            } else {
              // assume this arg is a timeout
              mode = ASYNC;
              callback = createTimedCallback(callback, split[1]);
              break;
            }
            // is there a timeout ?
            if (split[2] && mode !== SYNC) {
              callback = createTimedCallback(callback, split[2]);
            }
          } else {
            mode = ASYNC;
          }
          break;
        }
      }

      let asArray = false;

      if (Array.isArray(key)) {
        keys = key;
        asArray = true;
      } else {
        keys = args;
      }

      const done = () => {
        const vals = values(data, keys);
        if (asArray) {
          callback.call(this, null, vals);
        } else {
          vals.unshift(null); // unshift no error
          callback.apply(this, vals);
        }
      };

      if (!callback) {
        return values(data, keys);
      } else if (mode === SYNC) {
        done();
      } else {
        if (mode === ASYNC && !this.missing(keys).length) {
          // it has all the data but needs to be ASYNC
          defer.immediate(() => {
            this._get(keys, done);
          });
        } else {
          this._get(keys, done);
        }
      }

      return this;
    }
  });

  const queryAny = function (object, selector, callback) {
    if (isPlainObject(object) || isLiveObject(object)) {
      return queryObject(object, selector, callback);
    } else if (Array.isArray(object) || isLiveList(object)) {
      return queryList(object, selector, callback);
    }
    return callback(null, object, true);
  };

  const queryObject = function (object, selector, callback) {
    const data = {};
    let isSync = true;

    if (!selector) callback(null, data, isSync);

    const keys = map(selector.mask, 'key');

    const done = function (innerValues) {
      parallel(innerValues.map(function (objectValue, i) {
        return function (innerCallback) {
          queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
            if (error) {
              innerCallback(error);
              return;
            }
            if (!wasSync) {
              isSync = false;
            }
            if (data[keys[i]]) {
              deepMixIn(data[keys[i]], dataValue);
            } else {
              data[keys[i]] = dataValue;
            }
            innerCallback();
          });
        };
      }), function (error) {
        callback(error, data, isSync);
      });
    };

    if (isLiveObject(object)) {
      object._get(keys, function (error, wasSync) {
        if (error) {
          callback(error);
        } else {
          if (!wasSync) isSync = false;
          const innerValues = map(keys, function (key) {
            return object._data[key];
          });
          done(innerValues);
        }
      });
    } else {
      const innerValues = pick(object, keys);
      done(innerValues);
    }
  };

  const satisfies = function (value, op, right) {
    if (!op) return !!value;
    if (isRegExp(right)) return right.test(value);

    if (op === '=') return value === right;
    if (op === '!=') return value !== right;

    if (isNumber(right)) {
      if (op === '>') return value > right;
      if (op === '>=') return value >= right;
      if (op === '<') return value < right;
      if (op === '<=') return value <= right;
    }

    if (isString(right)) {
      const escapedRight = escapeRegExp(right);
      // starts with
      if (op === '^=') return new RegExp(`^${escapedRight}`).test(value);
      // ends with
      if (op === '$=') return new RegExp(`${escapedRight}$`).test(value);
      // contains separated by space e.g. 'list of things to look for' ~= 'list'
      if (op === '~=') {
        return new RegExp(`(^|\\s)${escapedRight}(\\s|$)`).test(value);
      }
      // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
      if (op === '|=') return new RegExp(`^${escapedRight}(-|$)`).test(value);
      // contains e.g. 'listofthingstolookfor' ~= 'look'
      if (op === ' *=') return value.toString().indexOf(right) !== -1;
    }

    return false;
  };

  const filterArray = function (array, left, op, right, callback) {
    let isSync = true;
    const filtered = [];

    let todo = array.length;
    let failed = false;
    function done(error) {
      if (error) {
        if (!failed) {
          failed = true;
          callback(error);
        }
        return;
      }
      if (failed || --todo > 0) {
        return;
      }
      const clean = [];
      for (let i = 0; i < filtered.length; i++) {
        if (i in filtered) {
          clean.push(filtered[i]);
        }
      }
      callback(null, clean, isSync);
    }

    for (let i = 0; i < array.length; i++) {
      const item = array[i];

      if (isLiveObject(item)) {
        /* eslint-disable */
        item._get([left], function (error, wasSync) {
          if (error) {
            done(error);
            return;
          }
          if (!wasSync) {
            isSync = false;
          }
          let value = item._data[left];
          if (satisfies(value, op, right)) {
            filtered[i] = item;
          }
          done();
        });
        /* eslint-enable */
      } else {
        if (isPlainObject(item)) {
          // filter objects only
          if (satisfies(item[left], op, right)) {
            filtered[i] = item;
          }
        }
        done();
      }
    }
  };

  // default filter that filters the whole list.
  const defaultFilters = [[{
    left: 0,
    op: ':'
  }]];

  function runSeriallyOnArray(array, startAtIndex, asyncFn, callback) {
    if (startAtIndex >= array.length) {
      callback();
      return;
    }
    asyncFn(array[startAtIndex], function (error) {
      if (error) {
        callback(error);
        return;
      }
      runSeriallyOnArray(array, startAtIndex + 1, asyncFn, callback);
    });
  }

  const queryList = function (list, selector, callback) {
    let isSync = true;
    // if there are no filters we need to query the full length
    if (!selector.filters) selector.filters = defaultFilters;

    function processConditions(conditions, serialTaskCallback) {
      let ref = [];

      function processCondition(condition, parallelTaskCallback) {
        let left = condition.left;
        let right = condition.right;
        let op = condition.op;

        if ('left' in condition && !('right' in condition) && isNumber(left)) {
          if (!op) right = left + 1;else if (op === ':') right = list.length;
          op = ':';
        }

        if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
          left = 0;
        }

        // filter by range.
        if (isNumber(left) && isNumber(right) && op === ':') {
          // if the list is an array it means it has already been filtered.
          if (Array.isArray(list)) {
            const filtered = slice_.call(list, left, right);
            ref = ref.concat(filtered);
            parallelTaskCallback();
          } else {
            list._get([new Range(left, right)], function (error, wasSync) {
              if (error) {
                parallelTaskCallback(error);
              } else {
                for (let i = left; i < right; i++) ref.push(list.values[i]);
                if (!wasSync) isSync = false;
                parallelTaskCallback();
              }
            });
          }
        } else {
          const done = function (array) {
            filterArray(array, left, op, right, function (error, filtered, wasSync) {
              if (error) {
                parallelTaskCallback(error);
              } else {
                if (!wasSync) isSync = false;
                ref = ref.concat(filtered);
                parallelTaskCallback();
              }
            });
          };

          if (Array.isArray(list)) {
            done(list);
          } else {
            // the list is not an array, never been filtered.
            // assume full length.
            // call a function that filters an array once you arraify it.
            list._get([new Range(0, list.length)], function (error, wasSync) {
              if (error) {
                parallelTaskCallback(error);
              } else {
                const array = [];
                for (let i = 0; i < list.length; i++) array.push(list.values[i]);
                if (!wasSync) isSync = false;
                done(array);
              }
            });
          }
        }
      }

      // list of conditions in a single filter.
      // can be parallel.
      parallel(conditions.map(function (condition) {
        return function (parallelTaskCallback) {
          processCondition(condition, parallelTaskCallback);
        };
      }), function (error) {
        if (error) {
          serialTaskCallback(error);
          return;
        }

        // eslint-disable-next-line no-param-reassign
        list = ref;
        serialTaskCallback();
      });
    }

    // single filter.
    // must be sequential.
    runSeriallyOnArray(selector.filters, 0, processConditions, function (error) {
      if (error) {
        callback(error);
      } else {
        const data = [];

        parallel(list.map(function (item, i) {
          return function (parallelTaskCallback) {
            queryAny(item, selector, function (err, res, wasSync) {
              if (!wasSync) isSync = false;
              if (data[i]) deepMixIn(data[i], res);else data[i] = res;
              parallelTaskCallback(err);
            });
          };
        }), function (err) {
          callback(err, data, isSync);
        });
      }
    });
  };

  let cache = {};

  /**
   * Create a new instance of a object, based on an unique identifier.
   * @function
   * @static
   * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
   * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
   */
  const live = function (item) {
    if (Array.isArray(item)) {
      return new LiveList().update([{
        type: 'insert',
        index: 0,
        length: item.length,
        values: item
      }]);
    } else if (isNumber(item)) {
      return new LiveList(item);
    } else if (isString(item)) {
      return cache[item] || (cache[item] = new LiveObject(item));
    } else if (isPlainObject(item)) {
      return live(item.uri).update(item);
    } else if (isLiveList(item) || isLiveObject(item)) {
      return item;
    }

    return new LiveObject();
  };

  // Allow localStorage.debug to also control live.debug.
  if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
    live.debug = true;
  }

  const emitters = {
    keys: [],
    values: []
  };

  /**
   * Subscribe to the specific event of objects matching the pattern.
   * @function
   * @static
   * @param {RegExp} match - Regular expression for matching uris.
   * @param {String} name - The name of the event to listen for.
   * @param {Function} handle - The event handle.
   * @return {Function} The live function.
   */
  live.subscribe = function (match, name, handle) {
    let newMatch = match;
    if (match.matches) {
      newMatch = newMatch.matches;
    }

    const string = newMatch.toString();

    const keys = emitters.keys;
    const innerValues = emitters.values;

    let emitter;
    for (let i = 0, len = keys.length; i < len; i++) {
      const key = keys[i];
      if (key.toString() === string) {
        emitter = innerValues[i];
        if (emitter) break;
      }
    }

    if (!emitter) {
      keys.push(match);
      innerValues.push(emitter = new Emitter());
    }

    emitter.on(name, handle);

    return this;
  };

  /**
   * Unsubscribe to the specific event of objects matching the pattern.
   * @function
   * @static
   * @param {RegExp} match - Regular expression for matching uris.
   * @param {String} name - The name of the event to unsubscribe from.
   * @param {Function} handle - The event handle.
   * @return {Function} The live function.
   */
  live.unsubscribe = function (match, name, handle) {
    let newMatch = match;
    if (newMatch.matches) {
      newMatch = newMatch.matches;
    }

    const string = match.toString();

    const keys = emitters.keys;
    const innerValues = emitters.values;

    let emitter;
    for (let i = 0, len = keys.length; i < len; i++) {
      const key = keys[i];
      if (key.toString() === string) {
        emitter = innerValues[i];
        if (emitter) break;
      }
    }

    if (emitter) emitter.off(name, handle);

    return this;
  };

  /**
   * Delete a model from the live cache.
   *
   * @param {string} uri A uri.
   *
   * @return {Function} The live function.
   */
  live.delete = function (uri) {
    delete cache[uri];
    return this;
  };

  /**
   * Purge the entire cache.
   *
   * @return {Function} The live function.
   */
  live.purge = function () {
    cache = {};
    return this;
  };

  /**
   * Check if live has an object for the URI in the cache.
   *
   * @param {string} uri A uri.
   *
   * @return {Boolean} True if the object is in the cache.
   */
  live.has = function (uri) {
    return !!cache[uri];
  };

  const EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

  const ASYNC = live.ASYNC = 'ASYNC';
  const SYNC = live.SYNC = 'SYNC';
  const ASAP = live.ASAP = 'ASAP';

  const PUBLISH = 3;
  const UPDATE = 4;

  /**
   * @static
   * @see LiveObject
   */
  live.Object = LiveObject;

  /**
   * @static
   * @see LiveList
   */
  live.List = LiveList;

  module.exports = live;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../libs/prime":452,"../../libs/prime/defer":450,"../../libs/prime/emitter":451,"../debug":129,"../range2":454,"./util/ordered-set":415,"./util/parser":416,"./util/throttle":417,"mout/array/combine":775,"mout/array/difference":777,"mout/array/filter":780,"mout/array/map":784,"mout/lang/isPlainObject":801,"mout/lang/isRegExp":802,"mout/object/deepMixIn":806,"mout/object/pick":814,"mout/string/escapeRegExp":816}],414:[function(require,module,exports){
  /**
   * @module live/diff
   */
  'use strict';

  // Original code from: https://github.com/codeparty/arraydiff
  // License: MIT
  // This has been forked to allow for optimizations and patching operations.

  // Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
  // and it can compute diffs on random arrays of length 1024 in about 34ms,
  // though just a few changes on an array of length 1024 takes about 0.5ms

  const splice_ = Array.prototype.splice;
  const slice_ = Array.prototype.slice;

  const annotate = function annotate(before, after) {
    // Find all items in both the before and after array, and represent them
    // as moves. Many of these "moves" may end up being discarded in the last
    // pass if they are from an index to the same index, but we don't know this
    // up front, since we haven't yet offset the indices.
    //
    // Also keep a map of all the indicies accounted for in the before and after
    // arrays. These maps are used next to create insert and remove diffs.
    const beforeLength = before.length;
    const afterLength = after.length;
    const moves = [];
    const beforeMarked = {};
    const afterMarked = {};
    for (let beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
      const beforeItem = before[beforeIndex];
      for (let afterIndex = 0; afterIndex < afterLength; afterIndex++) {
        if (afterMarked[afterIndex]) continue;
        if (beforeItem !== after[afterIndex]) continue;
        const from = beforeIndex;
        const to = afterIndex;
        let length = 0;
        do {
          beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
          length++;
        } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
        const moveDiff = {
          type: 'move',
          from: from,
          to: to,
          length: length
        };
        moves.push(moveDiff);
        beforeIndex--;
        break;
      }
    }

    // Create a remove for all of the items in the before array that were
    // not marked as being matched in the after array as well
    const removes = [];
    for (let beforeIndex = 0; beforeIndex < beforeLength;) {
      if (beforeMarked[beforeIndex]) {
        beforeIndex++;
        continue;
      }
      const index = beforeIndex;
      let length = 0;
      while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
        length++;
      }
      const removeDiff = {
        type: 'remove',
        index: index,
        length: length,
        values: slice_.call(before, index, index + length)
      };
      removes.push(removeDiff);
    }

    // Create an insert for all of the items in the after array that were
    // not marked as being matched in the before array as well
    const inserts = [];
    for (let afterIndex = 0; afterIndex < afterLength;) {
      if (afterMarked[afterIndex]) {
        afterIndex++;
        continue;
      }
      const index = afterIndex;
      let length = 0;
      while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
        length++;
      }
      const values = slice_.call(after, index, index + length);
      inserts.push({
        type: 'insert',
        index: index,
        length: length,
        values: values
      });
    }

    return [removes, moves, inserts];
  };

  const reduceMoves = function reduceMoves(moves) {
    for (let i = 0; i < moves.length; i++) {
      // if we detect a move operation of a lots of items to a near position, we
      // can swap it by a move operation of less items to a farther position
      // (which is going to be much more performant).
      //
      // Example:
      // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
      // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
      // move [1] six positions behind.
      if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
        const to = moves[i].to;
        const length = moves[i].length;

        moves[i].length = Math.abs(moves[i].to - moves[i].from);
        moves[i].from = to;
        moves[i].to = to + length;
      }
    }
  };

  const offset = function offset(removes, moves, inserts) {
    const insertsLength = inserts.length;
    const removesLength = removes.length;
    const movesLength = moves.length;

    // Offset subsequent removes and moves by removes
    let count = 0;
    for (let i = 0; i < removesLength; i++) {
      const remove = removes[i];
      remove.index -= count;
      count += remove.length;
      for (let j = 0; j < movesLength; j++) {
        const move = moves[j];
        if (move.from >= remove.index) move.from -= remove.length;
      }
    }

    // Offset moves by inserts
    for (let i = insertsLength; i--;) {
      const insert = inserts[i];
      const length = insert.length;
      for (let j = movesLength; j--;) {
        const move = moves[j];
        if (move.to >= insert.index) move.to -= length;
      }
    }

    // Offset the to of moves by later moves
    for (let i = movesLength; i-- > 1;) {
      const move = moves[i];
      if (move.to === move.from) continue;
      for (let j = i; j--;) {
        const earlier = moves[j];
        if (earlier.to >= move.to) earlier.to -= move.length;
        if (earlier.to >= move.from) earlier.to += move.length;
      }
    }

    // Only output moves that end up having an effect after offsetting
    const outputMoves = [];

    // Offset the from of moves by earlier moves
    for (let i = 0; i < movesLength; i++) {
      const move = moves[i];
      if (move.to === move.from) continue;
      outputMoves.push(move);
      for (let j = i + 1; j < movesLength; j++) {
        const later = moves[j];
        if (later.from >= move.from) later.from -= move.length;
        if (later.from >= move.to) later.from += move.length;
      }
    }

    // try to reduce the number of move events
    reduceMoves(outputMoves);

    return removes.concat(outputMoves, inserts);
  };

  const insert = function insert(array, index, values) {
    for (let i = 0; i < values.length; i++) {
      if (i in values) {
        const idx = index + i;
        if (array.length < idx) array.length = idx;
        array.splice(idx, 0, values[i]);
      }
    }
    return values;
  };

  const remove = function remove(array, index, length) {
    return splice_.call(array, index, length);
  };

  const move = function move(array, from, to, length) {
    const moved = remove(array, from, length);
    insert(array, to, moved);
    return moved;
  };

  const patch = function patch(array, operations) {
    for (let i = 0; i < operations.length; i++) {
      const operation = operations[i];
      switch (operation.type) {
        case 'move':
          move(array, operation.from, operation.to, operation.length);
          break;
        case 'remove':
          remove(array, operation.index, operation.length);
          break;
        case 'insert':
          insert(array, operation.index, operation.values);
          break;
        default:
          console.error('Unexpected operation type', operation.type);
          break;
      }
    }
    return array;
  };

  const diff = function diff(before, after) {
    const operations = annotate(before, after);
    return offset.apply(this, operations);
  };

  diff.annotate = annotate;
  diff.offset = offset;

  diff.remove = remove;
  diff.insert = insert;
  diff.move = move;
  diff.patch = patch;

  module.exports = diff;

  },{}],415:[function(require,module,exports){
  /**
   * @module live/util/ordered-set
   * @private
   */
  'use strict';

  // prime

  const prime = require('../../../libs/prime');

  // mout
  const forEach = require('mout/array/forEach');

  const Range = require('../../range2');
  const diff = require('./diff');

  const OrderedSet = prime({
    constructor: function (length = 0) {
      this.index = [];
      this.keys = new Array(length);
      this.values = new Array(length);
      this.objectStorage = {};
    },

    get length() {
      return this.keys.length;
    },

    set length(value) {
      this.keys.length = value;
      this.values.length = value;
    },

    forEach: function (fn, ctx) {
      const index = this.index;
      for (let k = 0; k < index.length; k++) {
        const range = index[k];
        for (let i = range.start; i < range.end; i++) {
          if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) {
            break;
          }
        }
      }
      return this;
    },

    map: function (fn, ctx) {
      const values = new Array(this.length);
      this.forEach(function (value, index, key) {
        values[index] = fn.call(ctx, value, index, key, this);
      }, this);
      return values;
    },

    copy: function (set) {
      this.index = set.index.slice();
      this.keys = set.keys.slice();
      this.values = set.values.slice();
      const length = this.keys.length;
      this.objectStorage = {};
      for (let i = 0; i < length; i++) {
        this.objectStorage[this.keys[i]] = this.values[i];
      }
      return this;
    },

    clone: function () {
      return new OrderedSet().copy(this);
    },

    indexOf: function (key) {
      let index = -1;
      this.forEach(function (v, i, k) {
        if (key === k) {
          index = i;
        }
      });
      return index;
    },

    indexOfMany: function (keys) {
      const indexedKeys = {};
      const output = [];

      // create a hash with the keys that are going to be searched, so we can
      // access them really fast later
      for (let i = 0; i < keys.length; i++) {
        indexedKeys[keys[i]] = -1;
      }

      this.forEach(function (v, i, k) {
        // If the element one that is being searched, add its position
        // to the output array
        if (k in indexedKeys) {
          indexedKeys[k] = i;
        }
      });

      for (let i = 0; i < keys.length; i++) {
        output[i] = indexedKeys[keys[i]];
      }

      return output;
    },

    valueOf: function (key) {
      return this.objectStorage[key] || null;
    },

    hasKey: function (key) {
      return this.objectStorage.hasOwnProperty(key);
    },

    sort: function (fn) {
      const keys = this.keys;
      const values = this.values;
      const operations = diff(values.slice(), values.sort(fn));

      forEach(operations, function (op) {
        // unless something is broken, a sort only produces moves.
        diff.move(keys, op.from, op.to, op.length);
      });

      return this;
    },

    move: function (from, to, length) {
      let newLength = length;
      let newTo = to;

      if (from > this.length) {
        return [];
      }
      if (from + newLength > this.length) {
        newLength = from - this.length;
      }
      if (newTo > this.length) {
        newTo = this.length;
      }
      if (from === newTo) {
        return [];
      }

      diff.move(this.keys, from, newTo, newLength);
      diff.move(this.values, from, newTo, newLength);

      return this;
    },

    insert: function (index, keys, values) {
      if (keys.length !== values.length) throw new Error('length mismatch');

      const range = new Range(index, index + keys.length);
      this.index = range.insert(this.index);

      diff.insert(this.keys, index, keys);
      diff.insert(this.values, index, values);

      for (let i = 0, length = keys.length; i < length; i++) {
        this.objectStorage[keys[i]] = values[i];
      }

      return this;
    },

    remove: function (index, length) {
      let newLength = length;

      if (index >= this.length) {
        return [];
      }
      if (index + newLength > this.length) {
        newLength = this.length;
      }

      const range = new Range(index, index + newLength);
      this.index = range.extract(this.index);

      for (let i = 0; i < newLength; i++) {
        delete this.objectStorage[this.keys[i + index]];
      }
      diff.remove(this.keys, index, newLength);
      diff.remove(this.values, index, newLength);

      return this;
    },

    diff: function (target) {
      const operations = diff.annotate(this.keys, target.keys);

      forEach(operations[0], function (op) {
        // remove
        op.keys = op.values;
        op.values = this.values.slice(op.index, op.index + op.length);
      }, this);

      forEach(operations[1], function (op) {
        // move
        op.keys = op.values;
        op.values = this.values.slice(op.from, op.from + op.length);
      }, this);

      forEach(operations[2], function (op) {
        // insert
        op.keys = op.values;
        op.values = target.values.slice(op.index, op.index + op.length);
      });

      return diff.offset.apply(diff, operations);
    },

    patch: function (operations) {
      forEach(operations, function (op) {
        switch (op.type) {
          case 'move':
            this.move(op.from, op.to, op.length);
            break;
          case 'remove':
            this.remove(op.index, op.length);
            break;
          case 'insert':
            this.insert(op.index, op.keys, op.values);
            break;
          default:
            console.error('Invalid patch operation type', op.type);
            break;
        }
      }, this);
      return this;
    }
  });

  module.exports = OrderedSet;

  },{"../../../libs/prime":452,"../../range2":454,"./diff":414,"mout/array/forEach":781}],416:[function(require,module,exports){
  /**
   * @module live/util/parser
   */
  'use strict';

  const normalize = function (value) {
    if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
    return value;
  };

  function escapeForRegExp(str) {
    return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
  }

  const COMMA = ',';
  const BMASK = '(';
  const EMASK = ')';
  const BFILTER = '[';
  const EFILTER = ']';
  const EQUALS = '=';
  const WHITESPACE = '\\s';

  const operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

  const keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
  const keyBlacklistCharacterClass = `[^${keyBlacklist}]`;

  const KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
  const EXACT_KEY_REG_EXP = new RegExp(`^${keyBlacklistCharacterClass}+$`);

  const OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
  const REPLACE_REG_EXP = /\$([\d]+)/;
  const RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

  const parse = function (string, params = []) {
    let selector = { mask: [] };
    const history = [selector];

    let key = '';
    let filter;

    let filterStr = '';
    let left = '';
    let right = '';
    let op = '';

    for (let i = 0; i < string.length + 1; i++) {
      const c = string.charAt(i);

      if (filter) {
        // parse the filter
        filterStr = filterStr.trim();
        if (c === COMMA || c === EFILTER) {
          const match1 = filterStr.match(RANGE_FILTER_REG_EXP);
          const match2 = filterStr.match(OPERATORS_REG_EXP);
          const match3 = filterStr.match(EXACT_KEY_REG_EXP);
          if (match1) {
            left = match1[1];
            op = ':';
            right = match1[2];
          } else if (match2) {
            left = filterStr.substring(0, match2.index);
            op = match2[0];
            right = filterStr.substring(match2.index + op.length);
          } else if (match3) {
            left = match3[0];
          } else {
            throw new SyntaxError(`syntax error: \`${filterStr}\` contains characters not valid in a filter`);
          }

          filterStr = '';

          const condition = {};

          if (left) {
            const leftMatch = left.match(REPLACE_REG_EXP);
            left = leftMatch ? params[+leftMatch[1]] : normalize(left);
            condition.left = left;
          }

          if (op) condition.op = op;

          if (right) {
            const rightMatch = right.match(REPLACE_REG_EXP);
            right = rightMatch ? params[+rightMatch[1]] : normalize(right);
            condition.right = right;
          }

          if ('left' in condition || 'right' in condition) filter.push(condition);

          right = '';
          left = '';
          op = '';

          if (c === EFILTER) {
            if (filter.length) {
              const filters = selector.filters || (selector.filters = []);
              filters.push(filter);
            }

            filter = null;
          }
          continue;
        }

        filterStr += c;
      } else {
        // parse the key

        if (c && KEY_CHARACTER_REG_EXP.test(c)) {
          // key
          key += c;
        } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
          // end key
          // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
          const keyMatch = key.match(REPLACE_REG_EXP);
          // begin a new selector
          history[0].mask.push(selector = {
            key: keyMatch ? params[+keyMatch[1]] : normalize(key)
          });
          key = '';
        } else if (c && key) {
          throw new SyntaxError(`syntax error: \`${c}\` is not a valid character in a key`);
        }

        if (c === BMASK) {
          selector.mask = [];
          history.unshift(selector);
        } else if (c === EMASK) {
          history.shift();
        }

        if (c === BFILTER) {
          filter = [];
        }
      }
    }

    if (history.length !== 1) throw new SyntaxError('syntax error');

    return history[0];
  };

  /** exports */
  module.exports = parse;

  },{}],417:[function(require,module,exports){
  /**
   * @module live/util/throttle
   * @private
   */
  'use strict';

  const defer = require('../../../libs/prime/defer');
  const isInteger = function (n) {
    return typeof n === 'number' && n % 1 === 0;
  };

  const slice = Array.prototype.slice;

  const _throttle = function (fn, method, context) {
    let queued;
    let args;
    let cancel;

    return function () {
      args = arguments;
      if (!queued) {
        queued = true;
        cancel = method(function (time) {
          queued = false;
          fn.apply(context, slice.call(args).concat(time));
        });
      }
      return cancel;
    };
  };

  const throttle = function (callback, argument, context) {
    if (isInteger(argument)) return throttle.timeout(callback, argument, context);
    return throttle.immediate(callback, argument);
  };

  throttle.timeout = function (callback, ms, context) {
    return _throttle(callback, function (run) {
      return defer.timeout(run, ms, context);
    }, context);
  };

  throttle.immediate = function (callback, context) {
    return _throttle(callback, function (run) {
      return defer.immediate(run, context);
    }, context);
  };

  module.exports = throttle;

  },{"../../../libs/prime/defer":450}],418:[function(require,module,exports){
  (function (global){
  'use strict';

  let namespace;
  let fromZlink = false;
  let windowSpace = global;

  function getNamespace() {

    if (!namespace) {
      if (fromZlink) {
        namespace = `zlink:${encodeURIComponent(windowSpace.__spotify.username)}:`;
      } else {
        namespace = `${windowSpace.__spotify.app_uri.split(':')[2]}:${encodeURIComponent(windowSpace.__spotify.username)}:`;
      }
    }
    return namespace;
  }

  function set(key, value) {
    const namespacedKey = getNamespace() + key;

    try {
      windowSpace.localStorage.setItem(namespacedKey, value);
    } catch (error) {
      // Setting local storage might make it reach the quota. This is highly
      // unlikely for regular users as it takes a lot of work to actually fill it
      // up since we don't store that much. However, most of the data is stored
      // namespaced by the user, but it all still exists in the same storage. We
      // noticed fraudulent users that seem to all log in from the same computer,
      // so they share the local storage, and being thousands of users on the same
      // computer can fill up the storage after a while. This started as an issue
      // in 1.0.67 where we didn't have a cap for the Recent Searches, and the
      // fraudulent users seemed to search for lots of things and if lots of
      // users on the same computer did that, the quota was filled up quickly.
      //
      // To solve this, we are ignoring the quota error, but re-throwing all other
      // errors.
      if (error.name !== 'QuotaExceededError') {
        throw error;
      }
    }
  }

  function get(key) {
    return windowSpace.localStorage.getItem(getNamespace() + key);
  }

  function remove(key) {
    return windowSpace.localStorage.removeItem(getNamespace() + key);
  }

  function clear() {
    namespace = getNamespace();
    Object.keys(windowSpace.localStorage).forEach(key => {
      if (key.startsWith(namespace)) {
        delete windowSpace.localStorage[key];
      }
    });
  }

  function _setNamespace(value) {
    namespace = value;
  }

  function useTopLocalStorage(isTopWindow) {
    windowSpace = isTopWindow ? window.top : window;
    namespace = null;
  }

  function useZlink(should) {
    useTopLocalStorage(should)
    fromZlink = should;
  }

  const storage = {
    set: set,
    get: get,
    remove: remove,
    clear: clear,
    _setNamespace: _setNamespace,
    useTopLocalStorage: useTopLocalStorage,
    useZlink: useZlink
  };

  module.exports = storage;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],419:[function(require,module,exports){
  'use strict';

  const languages = require('./languages.json');

  function lookup(language, to) {
    const lang = languages[language];
    if (lang && lang[to]) {
      return lang[to];
    }
    return language;
  }

  module.exports = lookup;
  module.exports.all = function () {
    return Object.keys(languages);
  };

  },{"./languages.json":420}],420:[function(require,module,exports){
  module.exports={
    "cs": {
      "smartling": "cs-CZ"
    },
    "de": {
      "smartling": "de-DE"
    },
    "el": {
      "smartling": "el-GR"
    },
    "en": {
      "smartling": "en-GB"
    },
    "es": {
      "smartling": "es-ES"
    },
    "es-419": {
      "moment": "es",
      "smartling": "es-LA"
    },
    "fi": {
      "smartling": "fi-FI"
    },
    "fr": {
      "smartling": "fr-FR"
    },
    "fr-CA": {
      "smartling": "fr-CA",
      "moment": "fr-ca"
    },
    "hu": {
      "smartling": "hu-HU"
    },
    "id": {
      "smartling": "id-ID"
    },
    "it": {
      "smartling": "it-IT"
    },
    "ja": {
      "smartling": "ja-JP"
    },
    "nl": {
      "smartling": "nl-NL"
    },
    "pl": {
      "smartling": "pl-PL"
    },
    "pt-BR": {
      "moment": "pt-br",
      "smartling": "pt-BR",
      "intl": "pt-PT"
    },
    "sv": {
      "smartling": "sv-SE"
    },
    "th": {
      "smartling": "th-TH"
    },
    "tr": {
      "smartling": "tr-TR"
    },
    "vi": {
      "smartling": "vi-VN"
    },
    "zh-Hant": {
      "moment": "zh-tw",
      "smartling": "zh-TW"
    },
    "zsm": {
      "moment": "ms-my",
      "smartling": "ms-MY",
      "intl": "ms-MY"
    }
  }

  },{}],421:[function(require,module,exports){
  'use strict';

  const schemer = require('./schemer');
  const cosmos = require('spotify-cosmos-api');
  const debug = require('../../debug');

  let id = 0;

  module.exports = function log(schema, data) {
    const body = schemer(schema, Object.assign({}, {
      message_name: schema.name,
      message_version: schema.schema_version
    }, data));

    // Logging cosmos endpoint requires all values to be strings.
    body.fields = body.fields.map(function (f) {
      if (typeof f === 'string') return f;
      if (f === null) return '';
      return JSON.stringify(f);
    });

    const qualifiedName = schema.name + schema.schema_version;

    const messageDebug = debug(`logger:${qualifiedName}`);
    const requestId = ++id;

    messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

    cosmos.resolver.post({
      url: 'sp://logging/v3/log',
      body: body
    }, function (error, response) {
      if (error) {
        console.error(error, body);
      } else {
        messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
      }
    });
  };

  },{"../../debug":129,"./schemer":422,"spotify-cosmos-api":1272}],422:[function(require,module,exports){
  (function (Buffer){
  'use strict';

  var _avroJs = require('avro-js');

  var _avroJs2 = _interopRequireDefault(_avroJs);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const debug = require('../../debug')('logger:');

  function convertType(schema, copy) {
    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(schema.type)) {
      const value = copy[schema.name];
      if (value === null) {
        return;
      }

      copy[schema.name] = {};

      const firstNonNullType = schema.type.filter(t => {
        return t !== 'null';
      })[0];

      // Example type: {type: 'array', items: 'string'}
      //   gives result: {array: ['value1', 'value2']}
      if (typeof firstNonNullType === 'object') {
        copy[schema.name] = {
          [firstNonNullType.type]: value
        };
        convertType(firstNonNullType, copy[schema.name]);
      } else if (firstNonNullType === 'bytes') {
        copy[schema.name][firstNonNullType] = new Buffer(value);
      } else {
        copy[schema.name][firstNonNullType] = value;
      }
    } else if (schema.type === 'bytes') {
      copy[schema.name] = new Buffer(copy[schema.name]);
    }
  }

  module.exports = function (schema, data) {
    debug(schema.name);

    const name = data.message_name;
    const version = data.message_version;
    const copy = Object.assign({}, data);

    if (version !== schema.schema_version) {
      throw new Error(`${'' + 'Invalid message version: received Message with message_version '}${version} but the Schema requires version ${schema.schema_version}`);
    }

    // Create positional array of field values as required by cosmos and
    // log-parser, and also create an avro Field for each value to allow
    // validation.
    const fields = schema.fields.map(f => {
      const value = copy[f.name];

      if (value === undefined) {
        return f.default;
      }

      convertType(f, copy);

      return value;
    })
    // remove name, version
    .slice(2);

    const type = _avroJs2.default.parse(schema);

    type.isValid(copy, {
      errorHook(path, value) {
        throw new Error(`Logger: Invalid data: ${path.join(',')}: ${value}`);
      }
    });

    return {
      message: name,
      version: version,
      fields: fields
    };
  };

  }).call(this,require("buffer").Buffer)
  },{"../../debug":129,"avro-js":568,"buffer":697}],437:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.messageProxy = messageProxy;

  var _debug = require('../debug');

  var _debug2 = _interopRequireDefault(_debug);

  var _uris = require('./uris.json');

  var _uris2 = _interopRequireDefault(_uris);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * This module is to be included in zlink
   */

  const METHODS = ['POST', 'SUB', 'GET', 'REPLY'];
  const BASE_URI = 'message-proxy';
  const debug = (0, _debug2.default)('message-proxy');

  function messageProxy(requestObj, callback) {
    if (typeof window === 'undefined' || !window.top || !window.top.postMessage) {
      return false;
    }

    const uri = requestObj.uri;

    // Validate Request
    if (!requestObj) throw new Error('Need a request object.');
    if (METHODS.indexOf(requestObj.method) === -1) {
      throw new Error('Need a valid method:', METHODS);
    }
    if (!callback && !requestObj.method === 'POST') {
      throw new Error('Callback needed');
    }
    if (!_uris2.default.hasOwnProperty(uri)) {
      throw new Error('Uri need to be one of these: ', Object.keys(_uris2.default));
    }

    const data = {};
    const requiredKeys = _uris2.default[uri][requestObj.method] || [];

    // GET
    if (requestObj.method === 'GET') {
      requiredKeys.forEach(requiredKey => {
        if (!requestObj.body.hasOwnProperty(requiredKey)) {
          throw new Error(`Uri 'GET' request body missing
                          a required key: ${requiredKey}`);
        }
        data[requiredKey] = requestObj.body[requiredKey];
      });

      const getListener = event => {
        if (!isEventValid(event, `${BASE_URI}-${uri}-reply`)) {
          return;
        }
        debug('getListener', uri, event.data);
        if (event.data.error) {
          callback(event.data.error);
        } else {
          delete event.data.uri;
          callback(null, event.data);
        }
        window.removeEventListener('message', getListener);
      };
      window.addEventListener('message', getListener);

      data.uri = `${BASE_URI}-${uri}-get`;
      debug('get', uri, data);
      const messagePosted = postMessageToFrame(requestObj.target, data);
      if (!messagePosted) {
        window.removeEventListener('message', getListener);
        callback('No frame found to post to.');
      }
      return true;
    }

    // REPLY
    if (requestObj.method === 'REPLY') {
      const replyListener = event => {
        if (!isEventValid(event, `${BASE_URI}-${uri}-get`)) {
          return;
        }
        debug('reply listener', uri, event.data);
        delete event.data.uri;
        callback(event.data, function reply(replyErr, rawData) {
          const replyData = {};
          if (replyErr) {
            replyData.error = replyErr;
          } else {
            requiredKeys.forEach(requiredKey => {
              if (!rawData.hasOwnProperty(requiredKey)) {
                throw new Error(`Reply data missing
                                a required key: ${requiredKey}`);
              }
              replyData[requiredKey] = rawData[requiredKey];
            });
          }
          replyData.uri = `${BASE_URI}-${uri}-reply`;
          debug('reply post', uri, replyData);
          event.source.postMessage(replyData, event.origin);
        });
      };
      window.addEventListener('message', replyListener, false);

      return () => {
        window.removeEventListener('message', replyListener);
      };
    }

    // POST
    if (requestObj.method === 'POST') {
      requiredKeys.forEach(requiredKey => {
        if (!requestObj.body.hasOwnProperty(requiredKey)) {
          throw new Error(`Uri 'POST' request body missing
                          a required key: ${requiredKey}`);
        }
        data[requiredKey] = requestObj.body[requiredKey];
      });

      data.uri = `${BASE_URI}-${uri}`;
      debug('post', uri, data);
      const messagePosted = postMessageToFrame(requestObj.target, data);
      if (callback) {
        if (!messagePosted) {
          callback('No frame found to post to.');
        } else {
          callback(null);
        }
      }
      return true;
    }
    // Subscription
    const sub = event => {
      if (!isEventValid(event, `${BASE_URI}-${uri}`)) {
        return;
      }
      debug('subscription event', uri, event.data);
      callback(event.data);
    };

    debug('subscription', uri);
    window.addEventListener('message', sub, false);
    return () => {
      window.removeEventListener('message', sub);
    };
  }

  const originRegex = new RegExp('^https?://[a-zA-Z-]*.app.spotify.com');

  function isEventValid(event, uri) {
    if (!originRegex.test(event.origin)) {
      return false;
    }
    if (event.data.uri !== uri) {
      return false;
    }
    return true;
  }

  function postMessageToFrame(target, data) {
    if (target === 'top' || !target) {
      debug('postMessageToFrame target=top data=%o', data);
      window.top.postMessage(data, '*');
      // no need to continue
      if (target === 'top') {
        return true;
      }
    }
    let frames;
    let frameFound;
    if (window === window.top) {
      frames = window.top.frames;
    } else {
      const topFrames = Array.prototype.slice.call(window.top.frames, 0, window.top.frames.length);
      const thisFrames = Array.prototype.slice.call(window.frames, 0, window.frames.length);
      frames = topFrames.concat(thisFrames);
    }

    const len = frames.length;
    for (let i = 0; i < len; i++) {
      if (target && target !== frames[i].frameElement.src) {
        continue;
      }
      debug('postMessageToFrame target=%o data=%o', frames[i].frameElement.target, data);
      frames[i].postMessage(data, '*');
      frameFound = true;
    }

    debug('postMessageToFrame framesLength=%o frameFound=%o', len, frameFound);
    return frameFound;
  }

  },{"../debug":129,"./uris.json":438}],438:[function(require,module,exports){
  module.exports={
    "unit-test": {
      "GET": ["key1"],
      "POST": ["key2"],
      "REPLY": ["key3"]
    },
    "client-state": {
      "SUB": [],
      "POST": ["state"],
      "GET": [],
      "REPLY": ["state"]
    },
    "history": {
      "GET": ["count"],
      "REPLY": ["history"]
    },
    "hpto": {
      "REPLY": ["ad"],
      "GET": []
    },
    "hpto-refresh": {
      "SUB": [],
      "POST": []
    },
    "station": {
      "GET": ["stationUri", "metadata", "trackCount"],
      "REPLY": ["stationUri", "station"]
    },
    "station-add": {
      "POST": ["stationUri", "add"]
    },
    "station-autoplay": {
      "POST": ["contextUri", "playerPlaybackId", "prevTracks"],
      "SUB": []
    },
    "station-create": {
      "POST": ["stationUri"],
      "SUB": []
    },
    "station-error": {
      "POST": ["stationUri", "message"],
      "SUB": []
    },
    "station-metadata": {
      "POST": ["stationUri", "metadata"]
    },
    "station-last-played": {
      "POST": ["stationUri"]
    },
    "station-thumb": {
      "POST": ["stationUri", "trackUri", "thumb"]
    },
    "station-heart": {
      "POST": ["stationUri", "trackUri"]
    },
    "station-undo-feedback": {
      "POST": ["stationUri", "trackUri", "thumbAction"]
    },
    "stations-all": {
      "GET": [],
      "REPLY": ["user_stations", "genre_stations", "recommended_stations"]
    },
    "stations-saved": {
      "GET": [],
      "REPLY": ["saved_stations"]
    },
    "format-list-heart": {
      "POST": ["entityUri", "trackUri"]
    },
    "format-list-undo-feedback": {
      "POST": ["entityUri", "trackUri"]
    }
  }

  },{}],439:[function(require,module,exports){
  'use strict';

  var _pageIdentifiers = require('./page-identifiers.js');

  var _pageIdentifiers2 = require('./page-identifiers.json');

  var _pageIdentifiers3 = _interopRequireDefault(_pageIdentifiers2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const UUID = require('uuid-js');

  /**
   * Object representing state of an app.
   *
   * @param {String} uri Spotify URI of app.
   * @constructor
   */
  function AppState(uri) {
    /**
     * Spotify URI.
     *
     * @type {String}
     */
    this._uri = undefined;

    if (uri !== undefined) {
      this.setURI(uri);
    }

    /**
     *  Unique ID of this Application.
     *
     *  @type {String}
     */
    this._uuid = UUID.create().toString();
  }

  /**
   * Create new instance of AppState based on JSON string.
   *
   * @param {String} json Serialized representation of AppState object.
   * @return {AppState} Instance of AppState.
   */
  AppState.unserialize = function (json) {
    const s = JSON.parse(json);
    const a = new AppState();
    a.setURI(s.uri);
    return a;
  };

  /**
   * Test if another object is considered equal to this.
   *
   * @param {AppState} state AppState instance to compare.
   */
  AppState.prototype.equals = function (state) {
    return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri;
  };

  /**
   * Test if another app state is for the same app.
   *
   * @param {AppState} state AppState instance to compare.
   */
  AppState.prototype.equalsApp = function (state) {
    const id = this.getAppId();
    return state && id && state.getAppId() === id || false;
  };

  /**
   * Get App identifier.
   *
   * @return {String} Id of app contained in URI.
   */
  AppState.prototype.getAppId = function () {
    const uri = this.getURI();
    const parts = uri.split(':');
    if (parts.length < 3) {
      return undefined;
    }
    if (parts[1] !== 'app') {
      return undefined;
    }
    if (parts[2] === '') {
      return undefined;
    }
    return parts[2];
  };

  /**
   * Get App URI without arguments.
   *
   * @return {String} URI of app without arguments.
   */
  AppState.prototype.getAppURI = function () {
    return this.getURI().split(':').slice(0, 3).join(':');
  };

  /**
   * Get App arguments
   *
   * @return {Array} List of app arguments.
   */
  AppState.prototype.getArgs = function () {
    return this.getURI().split(':').slice(3).map(function (a) {
      return decodeURIComponent(a);
    });
  };

  /**
   * Get URI value.
   *
   * @return {String} URI as string.
   */
  AppState.prototype.getURI = function () {
    if (this._uri === undefined) {
      throw new Error('URI not set');
    }
    return this._uri;
  };

  /**
   * Create serialized representation of this instance.
   *
   * @return {String} Serialized representation of AppState object.
   */
  AppState.prototype.serialize = function () {
    return JSON.stringify({
      uri: this.getURI()
    });
  };

  /**
   * Set arguments for state.
   *
   * @param {Array} args Arguments as array.
   */
  AppState.prototype.setArgs = function (args) {
    if (!Array.isArray(args)) {
      throw new TypeError('Args must be array');
    }

    this._uri = this.getAppURI().split(':').concat(args.map(function (a) {
      return encodeURIComponent(a);
    })).join(':');
  };

  /**
   * Set URI value.
   *
   * @param {String} uri Spotify URI for app.
   */
  AppState.prototype.setURI = function (uri) {
    if (typeof uri !== 'string') {
      throw new TypeError('URI must be string');
    }
    this._uri = uri;
  };

  /**
   * Get UUID value.
   *
   * @return {String} UUID as string.
   */
  AppState.prototype.getUUID = function () {
    return this._uuid;
  };

  /**
   * Get Page ID.
   *
   * @return {String} Page ID as string.
   */
  AppState.prototype.getPageID = function () {
    return (0, _pageIdentifiers.getPageIdFromUri)(this.getAppId(), this.getURI());
  };

  /**
   * Check if page is covered
   *
   * @return {Boolean} True if page ID is known.
   */
  AppState.prototype.isPageCovered = function () {
    return this.getPageID() !== _pageIdentifiers3.default.unknownUncovered;
  };

  module.exports = AppState;

  },{"./page-identifiers.js":443,"./page-identifiers.json":442,"uuid-js":1303}],440:[function(require,module,exports){
  'use strict';

  module.exports = {
    AppState: require('./app-state'),
    Navigator: require('./navigator')
  };

  },{"./app-state":439,"./navigator":441}],441:[function(require,module,exports){
  (function (global){
  'use strict';

  const inherit = require('spotify-inheritance/inherit');
  const EventEmitter = require('spotify-eventemitter');
  const AppState = require('./app-state');

  /**
   * Class containing methods for navigating.
   *
   * @constructor
   */
  function Navigator() {
    this._global = global.top || global;

    EventEmitter.call(this);

    /**
     * Locally bound handler function for message event on global.
     *
     * @type {Function}
     */
    this._messageHandler = this._messageHandler.bind(this);
  }

  inherit(Navigator, EventEmitter);

  /**
   * Maps constants to string values of supported events.
   */
  Navigator.prototype.EVENTS = Navigator.EVENTS = {
    REQUEST_STATE: 'navigation_request_state'
  };

  /**
   * Maps constants to string values of supported methods.
   */
  Navigator.prototype.METHOD = Navigator.METHOD = {
    OPEN: 'open',
    TOGGLE: 'toggle'
  };

  /**
   * Identify posted message and trigger relevant callbacks
   * based on the message contents.
   *
   * @param {Object} message Message object caused by postMessage.
   */
  Navigator.prototype._messageHandler = function (message) {
    if (!message.data.type) {
      return;
    }
    const type = message.data.type;
    if (type === Navigator.EVENTS.REQUEST_STATE) {
      const appState = AppState.unserialize(message.data.state);
      const syncEvent = {
        state: appState,
        method: message.data.method
      };
      if (message.data.extra) {
        syncEvent.extra = JSON.parse(message.data.extra);
      }
      this.emitSync(type, syncEvent);
    }
  };

  /**
   * Start listening to messages.
   */
  Navigator.prototype.attachListener = function () {
    this._global.addEventListener('message', this._messageHandler);
  };

  /**
   * Stop listening to messages.
   */
  Navigator.prototype.detachListener = function () {
    this._global.removeEventListener('message', this._messageHandler);
  };

  /**
   * Short hand method for requesting open AppState with URI only.
   *
   * @param {string} uri URI to open.
   */
  Navigator.prototype.openURI = function (uri, options = {}) {
    this.requestOpenState(new AppState(uri), options);
  };

  /**
   * Short hand method for requesting toggle of AppState with URI only.
   *
   * @param {string} uri URI to open.
   */
  Navigator.prototype.toggleURI = function (uri) {
    this.requestToggleState(new AppState(uri));
  };

  /**
   * Send an open request message.
   *
   * @param {AppState} state AppState instance to base open action on.
   */
  Navigator.prototype.requestOpenState = function (state, options = {}) {
    this.requestState(state, this.METHOD.OPEN, options);
  };

  /**
   * Send a toggle request message.
   *
   * @param {AppState} state AppState instance to base open action on.
   */
  Navigator.prototype.requestToggleState = function (state) {
    this.requestState(state, this.METHOD.TOGGLE);
  };

  /**
   * Send an request for an app state.
   *
   * @param {AppState} state AppState object representing state to request.
   * @param {string} method Method to use.
   */
  Navigator.prototype.requestState = function (state, method, options = null) {
    if (!state) {
      throw new TypeError('AppState not set');
    }
    if (!method) {
      throw new TypeError('Method not set');
    }

    const message = {
      type: this.EVENTS.REQUEST_STATE,
      method: method,
      state: state.serialize()
    };

    if (options) {
      message.extra = JSON.stringify(options);
    }

    this._global.postMessage(message, '*');
  };

  module.exports = Navigator;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./app-state":439,"spotify-eventemitter":1277,"spotify-inheritance/inherit":1280}],442:[function(require,module,exports){
  module.exports={
    "album": "album",
    "artist": "artist",
    "artistAbout": "artist/about",
    "artistAlbums": "artist/albums",
    "artistBio": "artist/bio",
    "artistConcerts": "artist/concerts",
    "artistGallery": "artist/gallery",
    "artistPlaylists": "artist/playlists",
    "artistRelated": "artist/related",
    "browse": "browse",
    "browseCharts": "browse/charts",
    "browseDiscover": "browse/discover",
    "browseGenres": "browse/genres",
    "browseNewReleases": "browse/newreleases",
    "browsePodcasts": "browse/podcasts",
    "browseVideos": "browse/videos",
    "charts": "charts",
    "chartsChart": "charts/chart",
    "chartsRegional": "charts/regional",
    "chartsSocial": "charts/social",
    "chartsViral": "charts/viral",
    "collection": "collection",
    "collectionAlbums": "collection/albums",
    "collectionAlbumsAlbum": "collection/albums/album",
    "collectionArtists": "collection/artists",
    "collectionArtistsArtist": "collection/artists/artist",
    "collectionPlaylists": "collection/playlists",
    "collectionRadio": "collection/radio",
    "collectionRecentlyPlayed": "collection/recently-played",
    "collectionShows": "collection/shows",
    "collectionSongs": "collection/songs",
    "concert": "concert",
    "concerts": "concerts",
    "concertsCitysearch": "concerts/citysearch",
    "concertsConcert": "concerts/concert",
    "debug": "debug",
    "lyrics": "lyrics",
    "home": "home",
    "moments": "moments",
    "momentsCategory": "moments/category",
    "music": "music",
    "musicCategory": "music/category",
    "now": "now",
    "nowplaying": "nowplaying",
    "nowplayingDevicepicker": "connect/devicepicker",
    "nowplayingHistory": "nowplaying/history",
    "nowplayingQueue": "nowplaying/queue",
    "party": "party",
    "partyAddFriends": "party/add-friends",
    "partyEnableBluetooth": "party/enable-bluetooth",
    "partyEnableNearby": "party/enable-nearby",
    "partyPreset": "party/preset",
    "partyQueue": "party/queue",
    "playlist": "playlist",
    "playlistFolder": "playlist/folder",
    "profile": "profile",
    "profileActivity": "profile/activity",
    "profileArtists": "profile/artists",
    "profileFollowers": "profile/followers",
    "profileFollowing": "profile/following",
    "profilePlaylists": "profile/playlists",
    "radio": "radio",
    "radioDailyMixes": "radio/daily-mixes",
    "radioStation": "radio/station",
    "running": "running",
    "runningCategory": "running/category",
    "runningSetup": "running/setup",
    "search": "search",
    "searchAlbums": "search/albums",
    "searchArtists": "search/artists",
    "searchGenres": "search/genres",
    "searchPlaylists": "search/playlists",
    "searchProfiles": "search/profiles",
    "searchRadio": "search/radio",
    "searchShows": "search/shows",
    "searchSongs": "search/songs",
    "searchVideos": "search/videos",
    "settings": "settings",
    "show": "show",
    "shows": "shows",
    "showsAudio": "shows/audio",
    "showsCategory": "shows/category",
    "showsNetwork": "shows/network",
    "showsVideo": "shows/video",
    "unknown": "unknown",
    "unknownUncovered": "unknown/uncovered"
  }

  },{}],443:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getPageIdFromUri = getPageIdFromUri;
  exports.getPageIdFromAppArguments = getPageIdFromAppArguments;

  var _pageIdentifiers = require('./page-identifiers.json');

  var _pageIdentifiers2 = _interopRequireDefault(_pageIdentifiers);

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const extractArg = argNumber => args => args.length > argNumber && args[argNumber] || null;
  const extractHubArg = uri => {
    if (extractArg(0)(uri) === 'charts') {
      // For charts uris: spotify:app:hub:*charts*:*viral*
      return `charts-${extractArg(1)(uri)}`;
    }

    // Everything else can be treated as genre
    return 'genre';
  };

  /**
   * Maps the name of the app with the name of the identifier that has to be used
   * for logging the page view.
   */
  const PAGE_LOGGER_MAP = {
    'album': 'album',
    'app-manager': 'debug',
    'artist-concerts': 'concerts',
    'artist-creator-about': 'artistAbout',
    'artist-overview': 'artist',
    'artist-related': 'artistRelated',
    'artist': 'artist',
    'boilerplate': 'debug',
    'browse-charts': 'charts',
    'browse-discover': 'browseDiscover',
    'browse-genres': 'browseGenres',
    'browse-home': 'browse',
    'browse-releases': 'browseNewReleases',
    'browse-podcasts': 'browsePodcasts',
    'browse-videos': 'browseVideos',
    'browse': 'browse',
    'chart': 'chartsChart',
    'charts': 'charts',
    'collection-album': 'collectionAlbumsAlbum',
    'collection-albums': 'collectionAlbums',
    'collection-artist': 'collectionArtistsArtist',
    'collection-artists': 'collectionArtists',
    'collection-podcasts': 'collectionShows',
    'collection-songs': 'collectionSongs',
    'collection-videos': 'collectionShows',
    'collection': 'collection',
    'concert': 'concert',
    'concerts': 'concerts',
    'daily-mix-hub': 'radioDailyMixes',
    'diag': 'debug',
    'discover': 'browseDiscover',
    'friends-mix': 'friendsMix',
    'genre': 'browseGenres',
    'glue-header-demo': 'debug',
    'glue-reference': 'debug',
    'glue-grid-demo': 'debug',
    'home': 'home',
    'hub-charts-regional': 'chartsRegional',
    'hub-charts-viral': 'chartsViral',
    'hub-genre': 'browseGenres',
    'lyrics': 'lyrics',
    'playlist': 'playlist',
    'playlist-folder': 'playlistFolder',
    'profile-followers': 'profileFollowers',
    'profile-following': 'profileFollowing',
    'profile-overview': 'profile',
    'profile-public-playlists': 'profilePlaylists',
    'profile-recently-played-artists': 'profileArtists',
    'profile': 'profile',
    'radio-hub': 'radio',
    'radio': 'radio',
    'recently-played': 'collectionRecentlyPlayed',
    'search-albums': 'searchAlbums',
    'search-artists': 'searchArtists',
    'search-genres': 'searchGenres',
    'search-playlists': 'searchPlaylists',
    'search-profiles': 'searchProfiles',
    'search-tracks': 'searchSongs',
    'search-shows': 'searchShows',
    'search': 'search',
    'settings': 'settings',
    'show': 'show',
    'station': 'radioStation',
    'stations': 'collectionRadio',
    'video-debug': 'debug',
    'queue-history': 'nowplayingHistory',
    'queue-queue': 'nowplayingQueue',
    'queue': 'nowplayingQueue'
  };

  const EXTRACT_SECTION = {
    // Browse section is the first app argument (i.e.: spotify:app:browse:*releases*)
    browse: extractArg(0),
    // Artist and profile have the argument after the id (i.e.: spotify:user:spotify:*followers*)
    artist: extractArg(1),
    profile: extractArg(1),
    // Queue (spotify:app:queue and spotify:app:queue:history)
    queue: extractArg(0),
    // Search section is the argument after the search query (spotify:app:search:<query>:*albums*)
    // or for search (spotify:app:search:<query>:*albums*)
    search: extractArg(1),
    // Hub (spotify:app:hub:*charts*:*viral* or spotify:app:hub:*special*:*thebeatles*)
    hub: extractHubArg,
    // Collection (spotify:app:collection for albums and artists)
    collection: extractArg(0)
  };

  function getPageIdFromUri(appId, inputUri) {
    if (appId in EXTRACT_SECTION) {
      const uri = _spotifyLiburi2.default.from(inputUri);
      const section = EXTRACT_SECTION[appId](uri.args);
      return getPageIdFromAppIdAndSection(appId, section);
    }
    return getPageIdFromAppIdAndSection(appId);
  }

  function getPageIdFromAppArguments(appId, appArguments) {
    if (appId in EXTRACT_SECTION) {
      const section = EXTRACT_SECTION[appId](appArguments);
      return getPageIdFromAppIdAndSection(appId, section);
    }
    return getPageIdFromAppIdAndSection(appId);
  }

  function getPageIdFromAppIdAndSection(inputAppId, section) {
    let appId = inputAppId;
    if (section) {
      // The appId of an app with sections should be APP-SECTION,
      // such as 'browse-genres'
      appId = `${appId}-${section}`;
    }
    const normalizedAppId = PAGE_LOGGER_MAP[appId];
    return _pageIdentifiers2.default[normalizedAppId] || _pageIdentifiers2.default.unknownUncovered;
  }

  },{"./page-identifiers.json":442,"spotify-liburi":1282}],444:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.splitFeedbackUri = exports.makeFeedbackUri = undefined;
  exports.fetchMadeFors = fetchMadeFors;
  exports.fetchMadeFor = fetchMadeFor;
  exports.buildMadeFor = buildMadeFor;
  exports.originalPlaylistUri = originalPlaylistUri;
  exports.allowsFeedback = allowsFeedback;
  exports.getFeedback = getFeedback;

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  var _bridge = require('../bridge');

  var _bridge2 = _interopRequireDefault(_bridge);

  var _liveWrappedUri = require('../live-wrapped-uri');

  var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Fetch madeFor objects for an array of formatListAttributes
   *
   * @param  {Array} formatLists        Array of `formatListAttributes`
   * @param  {String} viewerUsername
   * @return {Promise}                  The result of Promise.all resolves
   *                                    to a list of `madeFor` objects
   */
  function fetchMadeFors(formatLists, viewerUsername) {
    const promiseList = formatLists.map(formatList => fetchMadeFor(formatList, viewerUsername));
    return Promise.all(promiseList);
  }

  /**
   * Fetch madeFor object based on a playlist's formatListAttributes
   * @param  {Object} formatListAttributes
   * @param  {String} viewerUsername
   * @return {Promise}                      Promise that resolves
   *                                        to a madeFor object
   */
  function fetchMadeFor(formatListAttributes, viewerUsername) {
    if (!formatListAttributes) {
      return Promise.resolve(null);
    }

    const username = formatListAttributes['madeFor.username'];
    if (!username) {
      return Promise.resolve(null);
    }

    let name = formatListAttributes['madeFor.name'];
    if (name) {
      return Promise.resolve(buildMadeFor(name, username, viewerUsername));
    }

    // FormatList does not yet return a name when current user views their own.
    // It may someday. In the meantime, we fetch the name via a Bridge call.
    return new Promise(resolve => {
      const userUri = _spotifyLiburi2.default.profileURI(username).toURI();
      _bridge2.default.request('user_metadata', [userUri], (bridgeError, userMetadata) => {
        if (bridgeError) {
          name = username;
        } else {
          name = userMetadata.name || username;
        }
        resolve(buildMadeFor(name, username, viewerUsername));
      });
    });
  }

  /**
   * Returns an object with data for templates
   *
   * @param  {String} fullName          Playlist was made for a user
   *                                    with this name (fallsback to
   *                                    username if they have no name)
   * @param  {String} username          Playlist was made for this
   *                                    username
   * @param  {String} viewerUsername    The username who is viewing
   *                                    this playlist
   * @return {Object}
   */
  function buildMadeFor(name, username, viewerUsername) {
    const isCurrentUser = username === viewerUsername;
    const shortName = name.split(' ').shift();

    // We try to avoid rendering names and usernames that contain only numbers.
    // If that's the case and we can show "You", we will do it.
    const numbers = /^\d+$/;
    const renderAsYou = isCurrentUser && username === name && numbers.test(username);

    return {
      isCurrentUser,
      name,
      shortName,
      username,
      renderAsYou,
      uri: _spotifyLiburi2.default.profileURI(username).toURI()
    };
  }

  /**
   * Turns a filterlist URI into a regular playlist URI.
   */
  function originalPlaylistUri(playlistUri) {
    return _liveWrappedUri2.default.getOriginUri(playlistUri) || playlistUri;
  }

  function allowsFeedback(formatListAttributes) {
    return !!formatListAttributes && formatListAttributes['like-feedback-available'] === '1';
  }

  /**
   * Parse track-level formatListAttributes related to feedback
   * into one value: 'up', 'down' or null
   */
  function getFeedback(formatListAttributes) {
    if (!formatListAttributes) {
      return null;
    } else if (formatListAttributes['like-feedback-selected'] === '1') {
      return 'up';
    } else if (formatListAttributes['dislike-feedback-selected'] === '1') {
      return 'down';
    }
    return null;
  }

  const makeFeedbackUri = exports.makeFeedbackUri = (contextUri, trackUri) => `spotify:internal:${contextUri}:feedback:${trackUri}`;
  const splitFeedbackUri = exports.splitFeedbackUri = feedbackUri => feedbackUri.split('spotify:internal:').pop().split(':feedback:');

  },{"../bridge":121,"../live-wrapped-uri":412,"spotify-liburi":1282}],445:[function(require,module,exports){
  (function (global){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.formatListUtils = exports.getAvailablePlaylistName = exports.playlistRequest = exports.fetchIsPlaylistOwnedByCurrentUser = exports.fetchPlaylistV1UriFromPlaylist = exports.subscribeToMetadata = exports.fetchPlaylistMetadata = exports.offlineSyncPlaylist = exports.followPlaylist = exports.removePlaylistFolderRecursively = exports.removePlaylist = exports.setPlaylistName = exports.setPlaylistPublished = exports.setPlaylistCollaborative = exports.createNewPlaylistAfter = exports.createNewPlaylistBefore = exports.createNewPlaylist = exports.getCollaborativeStatus = exports.addTracksToPlaylist = exports.OfflineStatus = undefined;
  exports.addAlbumToPlaylist = addAlbumToPlaylist;
  exports.addStationToPlaylist = addStationToPlaylist;
  exports.addStuffToPlaylist = addStuffToPlaylist;
  exports.getRefreshedPlaylistData = getRefreshedPlaylistData;
  exports.createRefreshedPlaylist = createRefreshedPlaylist;
  exports.shouldPlaylistBeOffline = shouldPlaylistBeOffline;
  exports.getPlaylist2ShowsCell = getPlaylist2ShowsCell;
  exports.isPlaylist2Shows = isPlaylist2Shows;
  exports.resyncPlaylist = resyncPlaylist;

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  var _bridge = require('../../libs/bridge');

  var _bridge2 = _interopRequireDefault(_bridge);

  var _live = require('../../libs/live');

  var _live2 = _interopRequireDefault(_live);

  var _playlistActions = require('./playlist-actions');

  var _playlistData = require('./playlist-data');

  var _offlineStatus = require('./offline-status');

  var OfflineStatus = _interopRequireWildcard(_offlineStatus);

  var _formatLists = require('./format-lists');

  var formatListUtils = _interopRequireWildcard(_formatLists);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.OfflineStatus = OfflineStatus;
  exports.addTracksToPlaylist = _playlistActions.addTracksToPlaylist;
  exports.getCollaborativeStatus = _playlistData.getCollaborativeStatus;
  exports.createNewPlaylist = _playlistActions.createNewPlaylist;
  exports.createNewPlaylistBefore = _playlistActions.createNewPlaylistBefore;
  exports.createNewPlaylistAfter = _playlistActions.createNewPlaylistAfter;
  exports.setPlaylistCollaborative = _playlistActions.setPlaylistCollaborative;
  exports.setPlaylistPublished = _playlistActions.setPlaylistPublished;
  exports.setPlaylistName = _playlistActions.setPlaylistName;
  exports.removePlaylist = _playlistActions.removePlaylist;
  exports.removePlaylistFolderRecursively = _playlistActions.removePlaylistFolderRecursively;
  exports.followPlaylist = _playlistActions.followPlaylist;
  exports.offlineSyncPlaylist = _playlistActions.offlineSyncPlaylist;
  exports.fetchPlaylistMetadata = _playlistData.fetchPlaylistMetadata;
  exports.subscribeToMetadata = _playlistData.subscribeToMetadata;
  exports.fetchPlaylistV1UriFromPlaylist = _playlistData.fetchPlaylistV1UriFromPlaylist;
  exports.fetchIsPlaylistOwnedByCurrentUser = _playlistData.fetchIsPlaylistOwnedByCurrentUser;
  exports.playlistRequest = _playlistData.playlistRequest;
  exports.getAvailablePlaylistName = _playlistData.getAvailablePlaylistName;
  exports.formatListUtils = formatListUtils;
  function addAlbumToPlaylist(playlistUri, albumUri, cb) {
    const args = [albumUri.toString(), 0, -1];

    return _bridge2.default.request('album_tracks_snapshot', args, (err, resp) => {
      if (err) {
        cb(err);
        return;
      }
      (0, _playlistActions.addTracksToPlaylist)(playlistUri, resp.array, cb);
    });
  }

  function addStationToPlaylist(playlistUri, stationURI, cb) {
    (0, _live2.default)(stationURI.toString()).query('rows(track(uri))', (err, data) => {
      if (err) {
        cb(err);
        return;
      }
      const trackURIs = data.rows.map(radioTrack => radioTrack.track.uri);
      (0, _playlistActions.addTracksToPlaylist)(playlistUri, trackURIs, cb);
    });
  }

  function addStuffToPlaylist(playlistUri, uris, cb) {
    if (uris[0].type === _spotifyLiburi2.default.Type.ALBUM) {
      addAlbumToPlaylist(playlistUri, uris[0], cb);
      if (uris.length > 1) {
        console.warn('Passed more than a single album to addStuffToPlaylist(). Adding only one.');
      }
    } else if (uris[0].type === _spotifyLiburi2.default.Type.STATION) {
      addStationToPlaylist(playlistUri, uris[0], cb);
    } else {
      const urisStr = uris.map(uri => uri.toString());
      (0, _playlistActions.addTracksToPlaylist)(playlistUri, urisStr, cb);
    }
  }

  function fetchPlaylistName(playlistUri, cb) {
    const policy = {
      name: true
    };

    (0, _playlistData.fetchPlaylistMetadata)(playlistUri, policy, (error, data) => {
      if (data && data.name) {
        cb(error, data.name);
        return;
      }
      cb(error);
    });
  }

  function getRefreshedPlaylistData(playlistUri, cb) {
    fetchPlaylistName(playlistUri, async (nameError, oldName) => {
      if (nameError) {
        cb(nameError);
        return;
      }

      const playlistV1Uri = await (0, _playlistData.fetchPlaylistV1UriFromPlaylist)(playlistUri.toString());
      const name = (0, _playlistActions.refreshedPlaylistName)(oldName);

      _bridge2.default.cosmosJSON({
        method: 'POST',
        uri: 'hm://playlistfreshener/freshen',
        body: {
          playlistURI: playlistV1Uri,
          type: 'W2V_freshener'
        }
      }, (error, body) => {
        if (error) {
          cb(error);
          return;
        }

        const tracks = body.recommendedTracks.map(r => `spotify:track:${r.id}`);

        cb(null, {
          name,
          tracks
        });
      });
    });
  }

  function createRefreshedPlaylist(playlistUri, cb) {
    getRefreshedPlaylistData(playlistUri, (error, { name, tracks } = {}) => {
      if (error) {
        cb(error);
        return;
      }

      (0, _playlistActions.createNewPlaylist)(name, (createNewPlaylistError, newPlaylistUri) => {
        if (createNewPlaylistError) {
          cb(createNewPlaylistError);
          return;
        }

        (0, _playlistActions.addTracksToPlaylist)(newPlaylistUri, tracks, addTracksToPlaylistError => {
          cb(addTracksToPlaylistError, newPlaylistUri);
        });
      });
    });
  }

  function shouldPlaylistBeOffline(uri, cb) {
    const policy = {
      offline: true
    };

    (0, _playlistData.fetchPlaylistMetadata)(uri, policy, (error, data) => {
      if (data && data.offline) {
        const shouldBeOffline = OfflineStatus.shouldBeOffline(data.offline);
        cb(error, shouldBeOffline);
        return;
      }
      cb(error, data);
    });
  }

  // A synchronous way to "fetch" the playlist2shows ABBA flag.
  function getPlaylist2ShowsCell() {
    // initialState.playlist2ShowsCell is initialized on
    // apps/script/zlink/pre-init.js.
    const initialState = global.initialState || global.top && global.top.initialState || {};
    return initialState.playlist2ShowsCell || null;
  }

  function isPlaylist2Shows(formatListType) {
    const isCellEnabled = getPlaylist2ShowsCell() === 'Enabled';
    if (!isCellEnabled) {
      return false;
    }

    const validFormatListTypes = ['format-shows', 'format-shows-shuffle'];

    return validFormatListTypes.includes(formatListType);
  }

  function resyncPlaylist(uri, callback) {
    const opts = {
      method: 'POST',
      uri: `sp://core-playlist/v1/playlist/${uri}/resync`
    };

    return _bridge2.default.cosmos(opts, (err, body) => {
      if (callback) {
        if (err) {
          callback(err);
        } else if (body.status !== 200 && body.status !== 204) {
          const e = new Error(`Cosmos Request Error. Status: ${body.status}`);
          e.status = body.status;
          callback(e);
        } else {
          callback(null, body);
        }
      }
    });
  }

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../libs/bridge":121,"../../libs/live":413,"./format-lists":444,"./offline-status":446,"./playlist-actions":447,"./playlist-data":448,"spotify-liburi":1282}],446:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.YES = exports.DOWNLOADING = exports.WAITING_SYNC_NOT_ALLOWED = exports.WAITING_NO_CONNECTION = exports.WAITING_OFFLINE_MODE = exports.WAITING = exports.NO = undefined;
  exports.isDownloading = isDownloading;
  exports.shouldBeOffline = shouldBeOffline;
  exports.progressFromStatus = progressFromStatus;
  exports.getLabelForStatus = getLabelForStatus;
  exports.sendUserMessageForStatus = sendUserMessageForStatus;

  var _bridge = require('../../libs/bridge');

  var _bridge2 = _interopRequireDefault(_bridge);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const NO = exports.NO = 'no';
  const WAITING = exports.WAITING = 'waiting';
  const WAITING_OFFLINE_MODE = exports.WAITING_OFFLINE_MODE = 'waitingOfflineMode';
  const WAITING_NO_CONNECTION = exports.WAITING_NO_CONNECTION = 'waitingNoConnection';
  const WAITING_SYNC_NOT_ALLOWED = exports.WAITING_SYNC_NOT_ALLOWED = 'waitingSyncNotAllowed';
  const DOWNLOADING = exports.DOWNLOADING = 'downloading';
  const YES = exports.YES = 'yes';

  function isDownloading(offlineStatus) {
    return offlineStatus === DOWNLOADING;
  }

  function shouldBeOffline(offlineStatus) {
    switch (offlineStatus) {
      case WAITING:
      case WAITING_OFFLINE_MODE:
      case WAITING_NO_CONNECTION:
      case DOWNLOADING:
      case WAITING_SYNC_NOT_ALLOWED:
      case YES:
        return true;
      case NO:
      default:
        return false;
    }
  }

  // Returns 0 or 1 if able to derive
  // progress from the offlineStatus,
  // otherwise will return undefined.
  function progressFromStatus(offlineStatus) {
    switch (offlineStatus) {
      case WAITING:
      case WAITING_OFFLINE_MODE:
      case WAITING_NO_CONNECTION:
      case WAITING_SYNC_NOT_ALLOWED:
      case NO:
        return 0;
      case YES:
        return 1;
      case DOWNLOADING:
      default:
        return undefined;
    }
  }

  function getLabelForStatus(offlineStatus, isFormatShows) {
    switch (offlineStatus) {
      case DOWNLOADING:
        return 'Downloading';
      case WAITING_OFFLINE_MODE:
      case WAITING_NO_CONNECTION:
      case WAITING_SYNC_NOT_ALLOWED:
        return 'WaitingForConnection';
      case WAITING:
        return 'WaitingForDownload';
      case YES:
        return isFormatShows ? 'DownloadedSongs' : 'Downloaded';
      case NO:
      default:
        return isFormatShows ? 'DownloadSongs' : 'Download';
    }
  }

  function sendUserMessageForStatus(offlineStatus) {
    switch (offlineStatus) {
      case WAITING_OFFLINE_MODE:
        // Tell the user to turn off offline mode
        _bridge2.default.cosmosJSON({
          method: 'POST',
          uri: 'sp://messages/v1/container/user-message',
          body: {
            id: 'cant-offline-sync-playlist-in-offline-mode'
          }
        });
        return true;
      default:
        return false;
    }
  }

  },{"../../libs/bridge":121}],447:[function(require,module,exports){
  (function (global){
  // Playlist Actions: functions that mutate playlists in some way
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DUPLICATE_ACTIONS = undefined;
  exports.addTracksToPlaylist = addTracksToPlaylist;
  exports.setPlaylistPublished = setPlaylistPublished;
  exports.createNewPlaylist = createNewPlaylist;
  exports.createNewPlaylistBefore = createNewPlaylistBefore;
  exports.createNewPlaylistAfter = createNewPlaylistAfter;
  exports.setPlaylistName = setPlaylistName;
  exports.setPlaylistCollaborative = setPlaylistCollaborative;
  exports.followPlaylist = followPlaylist;
  exports.removePlaylist = removePlaylist;
  exports.removePlaylistFolderRecursively = removePlaylistFolderRecursively;
  exports.refreshedPlaylistName = refreshedPlaylistName;
  exports.offlineSyncPlaylist = offlineSyncPlaylist;

  var _spotifyCosmosApi = require('spotify-cosmos-api');

  var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

  var _live = require('../../libs/live');

  var _live2 = _interopRequireDefault(_live);

  var _bridge = require('../../libs/bridge');

  var _bridge2 = _interopRequireDefault(_bridge);

  var _playlistData = require('./playlist-data');

  var _surroundMessages = require('../../libs/surround-messages');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const DUPLICATE_ACTIONS = exports.DUPLICATE_ACTIONS = {
    ADD_ALL: 'add_all',
    ADD_UNIQUE: 'add_unique',
    CANCEL: 'cancel'
  };

  function getDuplicates(playlistURI, trackURIs, callback) {
    _spotifyCosmosApi2.default.resolver.post({
      url: `sp://core-playlist/v1/playlist/${encodeURIComponent(playlistURI)}/contains`,
      body: {
        items: trackURIs
      }
    }, function (error, response) {
      if (error) {
        callback([]);
        return;
      }

      const body = response.getJSONBody();
      const foundByIndex = body.found;

      const duplicates = [];
      const uniques = [];

      trackURIs.forEach((uri, index) => {
        if (foundByIndex[index]) {
          duplicates.push(trackURIs[index]);
        } else {
          uniques.push(trackURIs[index]);
        }
      });

      callback(duplicates, uniques);
    });
  }

  function maybeFilterDuplicates(playlistURI, trackURIs, callback) {
    getDuplicates(playlistURI, trackURIs, function (duplicates, uniques) {
      if (!duplicates.length) {
        callback(trackURIs);
        return;
      }

      _spotifyCosmosApi2.default.resolver.post({
        url: 'sp://messages/v1/avoidduplicates',
        body: {
          action: 'confirm',
          source: global.__spotify.app_uri,
          playlistUri: playlistURI,
          numItems: trackURIs.length,
          numDuplicates: duplicates.length
        }
      }, function (postError) {
        if (postError) {
          callback(trackURIs);
          return;
        }

        // Subscribe for the dialog response
        const subscription = _spotifyCosmosApi2.default.resolver.subscribe({
          url: 'sp://messages/v1/avoidduplicates'
        }, function (error, response) {
          subscription.cancel();
          if (error) {
            callback(trackURIs);
            return;
          }
          switch (response.getJSONBody().action) {
            case DUPLICATE_ACTIONS.ADD_ALL:
              callback(trackURIs);
              break;

            case DUPLICATE_ACTIONS.ADD_UNIQUE:
              callback(uniques);
              break;

            case DUPLICATE_ACTIONS.CANCEL:
              callback([]);
              break;

            default:
              throw new Error('Invalid DUPLICATE_ACTION.');
          }
        });
      });
    });
  }

  function addTracksToPlaylist(playlistURI, trackURIs, cb) {
    maybeFilterDuplicates(playlistURI, trackURIs, function (filteredTrackURIs) {
      if (!filteredTrackURIs.length) {
        cb();
        return;
      }

      _spotifyCosmosApi2.default.resolver.post({
        url: `sp://core-playlist/v1/playlist/${encodeURIComponent(playlistURI)}`,
        body: {
          operation: 'add',
          uris: filteredTrackURIs,
          after: 'end'
        }
      }, function (error, response) {
        // TODO(jaco): Move over to status code checking when CORE-1638 is done.
        const trackLimitExceeded = error && response && response.getJSONBody() && /exceed the maximum playlist size/i.test(response.getJSONBody().error);
        if (trackLimitExceeded) {
          _spotifyCosmosApi2.default.resolver.post({
            url: 'sp://messages/v1/container/user-message',
            body: { id: 'playlist-limit-exceeded' }
          });
        }

        if (error) {
          cb(error);
          return;
        }
        (0, _surroundMessages.sendQBEAction)(_surroundMessages.QBE_ADD_TO_PLAYLIST);
        cb();
      });
    });
  }

  function setPlaylistPublished(uriOrRowId, published, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'set',
        attributes: { published },
        rows: [uriOrRowId.toString()]
      }
    }, cb);
  }

  function createNewPlaylist(name, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'create',
        playlist: true,
        before: 'start',
        name
      }
    }, (error, body) => cb(error, body && body.uri));
  }

  function createNewPlaylistBefore(name, before, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'create',
        playlist: true,
        before,
        name
      }
    }, (error, body) => cb(error, body && body.uri));
  }

  function createNewPlaylistAfter(name, after, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'create',
        playlist: true,
        after,
        name
      }
    }, (error, body) => cb(error, body && body.uri));
  }

  function setPlaylistName(uri, name, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: `sp://core-playlist/v1/playlist/${encodeURIComponent(uri)}`,
      body: {
        operation: 'set',
        attributes: { name }
      }
    }, (error, body) => {
      if (!error) {
        (0, _live2.default)(uri).update({ name });
      }
      cb(error, body);
    });
  }

  function setPlaylistCollaborative(uri, collaborative, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: `sp://core-playlist/v1/playlist/${encodeURIComponent(uri)}`,
      body: {
        operation: 'set',
        attributes: { collaborative }
      }
    }, (setCollaborativeError, body) => {
      if (setCollaborativeError) {
        cb(setCollaborativeError, body);
        return;
      }

      if (collaborative) {
        // when we set a playlist as collaborative, check if
        // it's public and make it private
        (0, _playlistData.getCollaborativeStatus)(uri, (getCollaborativeError, data) => {
          if (getCollaborativeError || data.published === null) {
            cb(getCollaborativeError || new Error('`published` property unexpectedly missing'), body);
            return;
          }

          if (data.published) {
            exports.setPlaylistPublished(uri, false, cb);
            return;
          }
          cb(null, body);
        });
      } else {
        cb(null, body);
      }
    });
  }

  function broadcastFollowState(uri, isFollowing) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://messages/v1/followstate',
      body: {
        uri: uri.toString(),
        isFollowing
      }
    });
  }

  function followPlaylist(uri, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        before: 'start',
        uris: [uri.toString()]
      }
    }, (error, body) => {
      if (!error) broadcastFollowState(uri.toString(), true);
      cb(error, body);
    });
  }

  function removePlaylist(uri, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'remove',
        rows: [uri.toString()]
      }
    }, (error, body) => {
      if (!error) broadcastFollowState(uri.toString(), false);
      cb(error, body);
    });
  }

  function removePlaylistFolderRecursively(uri, cb) {
    _bridge2.default.cosmosJSON({
      method: 'POST',
      uri: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'remove',
        contents: true,
        rows: [uri.toString()]
      }
    }, cb);
  }

  function refreshedPlaylistName(oldName) {
    if (!oldName) {
      // TODO(jaco): Should be localised, but since the name is still very much up
      // in the air and this will only go out to employees, we don't want to send
      // it off for translation yet since it will likely change a couple of times
      // before we're happy with it.
      return 'Similar Playlist';
    }

    const nextInt = function (intStr) {
      return parseInt(intStr, 10) + 1;
    };

    // Parenthesized number suffix: "Playlist (2)"
    const matches = oldName.match(new RegExp('(.*)\\((\\d+)\\)$'));
    if (matches) {
      return `${matches[1].trim()} (${nextInt(matches[2])})`;
    }

    return `${oldName} (2)`;
  }

  function offlineSyncPlaylist(uri, shouldBeOffline, cb) {
    _bridge2.default.cosmos({
      method: shouldBeOffline ? 'POST' : 'DELETE',
      uri: `sp://offline/v1/resources?uri=${uri}`
    }, cb);
  }

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../libs/bridge":121,"../../libs/live":413,"../../libs/surround-messages":565,"./playlist-data":448,"spotify-cosmos-api":1272}],448:[function(require,module,exports){
  (function (global){
  // Playlist Data: playlist data fetching and data subscription.
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.fetchPlaylistMetadata = fetchPlaylistMetadata;
  exports.subscribeToMetadata = subscribeToMetadata;
  exports.getCollaborativeStatus = getCollaborativeStatus;
  exports.playlistFiltersToReturn = playlistFiltersToReturn;
  exports.replaceFiltersToReturn = replaceFiltersToReturn;
  exports.fetchPlaylistOwner = fetchPlaylistOwner;
  exports.fetchIsPlaylistOwnedByCurrentUser = fetchIsPlaylistOwnedByCurrentUser;
  exports.fetchPlaylistV1UriFromPlaylist = fetchPlaylistV1UriFromPlaylist;
  exports.getCorePlaylistUrl = getCorePlaylistUrl;
  exports.playlistRequest = playlistRequest;
  exports.getAvailablePlaylistName = getAvailablePlaylistName;

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  var _bridge = require('../../libs/bridge');

  var _bridge2 = _interopRequireDefault(_bridge);

  var _liveWrappedUri = require('../../libs/live-wrapped-uri');

  var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

  var _coreSortParams = require('../../libs/core-sort-params');

  var _coreSortParams2 = _interopRequireDefault(_coreSortParams);

  var _abba = require('../../libs/abba');

  var _abba2 = _interopRequireDefault(_abba);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Possible policy fields (may not be an exhaustive list):
   *
   * {
   *   link: true,
   *   loaded: true,
   *   published: true,
   *   browsableOffline: true,
   *   totalLength: true,
   *   name: true,
   *   picture: true,
   *   pictureFromAnnotate: true,
   *   canReportAnnotationAbuse: true,
   *   description: true,
   *   descriptionFromAnnotate: true,
   *   collaborative: true,
   *   formatListAttributes: true,
   *   length: true,
   *   duration: true,
   *   lastModification: true,
   *   allows: {
   *     insert: true,
   *     remove: true
   *   },
   *   followed: true,
   *   offline: true,
   *   followers: true,
   *   owner: {
   *     link: true,
   *     username: true,
   *     name: true
   *   },
   *   ownedBySelf: true
   * }
   */
  function fetchPlaylistMetadata(playlistUri, policy, cb) {
    const playlistUriWithoutQueryParams = _spotifyLiburi2.default.from(playlistUri).toURI();
    const encodedPlaylistUri = encodeURIComponent(playlistUriWithoutQueryParams);

    _bridge2.default.cosmosJSON({
      method: 'GET',
      uri: `sp://core-playlist/v1/playlist/${encodedPlaylistUri}/metadata`,
      body: {
        policy: policy
      }
    }, (error, { error: responseError = null, metadata } = {}) => cb(error || responseError, metadata));
  }

  function subscribeToMetadata(playlistUri, policy, cb) {
    const playlistUriWithoutQueryParams = _spotifyLiburi2.default.from(playlistUri).toURI();
    const encodedPlaylistUri = encodeURIComponent(playlistUriWithoutQueryParams);

    return _bridge2.default.cosmosJSON({
      method: 'SUB',
      uri: `sp://core-playlist/v1/playlist/${encodedPlaylistUri}/metadata`,
      body: { policy: policy }
    }, (subError, body) => cb(subError, body && body.metadata));
  }

  function getCollaborativeStatus(uri, cb) {
    const policy = {
      collaborative: true,
      published: true
    };
    fetchPlaylistMetadata(uri.toString(), policy, cb);
  }

  function playlistFiltersToReturn(returnUnplayableTracks, returnPremiumOnlyTracks) {
    if (returnUnplayableTracks) {
      if (returnPremiumOnlyTracks) {
        // Return all the tracks. No filters. No restrictions!
        return [];
      }
      // Return unplayable tracks without the premium-only tracks.
      // Equivalent to: return all the tracks, except premium-only tracks.
      // Equivalent to: don't return premium-only tracks.
      return ['isPremiumOnly eq false'];
    }

    // returnUnplayableTracks=false

    if (returnPremiumOnlyTracks) {
      // Don't return "regular unplayable" tracks, but return premium-only tracks.
      // A track can be returned if it used to be defined as playable or if it's
      // premium-only.
      const availabilityFlags = 'available|cappingReached|' + 'inPremium'; // regular (pre-premiere) definition of playable // available (playable) only in Premium

      // Availability flags are based on the ResourceAvailabilityType enum defined
      // in core (spotify/metadata/cpp/include/spotify/metadata/resource_availability.h).
      return [`availability in ${availabilityFlags}`];
    }
    // Don't return regular unplayable tracks and don't return premium-only
    // tracks.
    // Equivalent to: don't return any non-playable track.
    return ['playable eq true'];
  }

  function replaceFiltersToReturn(filters, returnUnplayableTracks, returnPremiumOnlyTracks) {
    const newFilters = filters.filter(filter => {
      return !filter.startsWith('playable') && !filter.startsWith('isPremiumOnly') && !filter.startsWith('availability');
    });
    const filtersToAdd = playlistFiltersToReturn(returnUnplayableTracks, returnPremiumOnlyTracks);
    return newFilters.concat(filtersToAdd);
  }

  function isLocalFilesUri(uri) {
    return (/:internal:local-files.*/.test(uri)
    );
  }

  async function fetchPlaylistOwner(playlistUri) {
    const parsedUri = _spotifyLiburi2.default.from(playlistUri);
    if (parsedUri.type === _spotifyLiburi2.default.Type.PLAYLIST) {
      return parsedUri.username;
    } else if (parsedUri.type === _spotifyLiburi2.default.Type.PLAYLIST_V2) {
      return await new Promise((resolve, reject) => fetchPlaylistMetadata(playlistUri, { owner: { username: true } }, (error, { owner: { username: fetchedUsername } = {} } = {}) => {
        if (error) reject(error);else if (!fetchedUsername) {
          reject(new Error(`No owner username found for ${playlistUri}`));
        } else resolve(fetchedUsername);
      }));
    }
    throw new Error(`The uri ${playlistUri} is not any kind of playlist uri`);
  }

  async function fetchIsPlaylistOwnedByCurrentUser(playlistUri) {
    return (await fetchPlaylistOwner(playlistUri)) === global.__spotify.username;
  }

  async function fetchPlaylistV1UriFromPlaylist(uri) {
    const { type, id } = _spotifyLiburi2.default.from(uri);
    if (type === _spotifyLiburi2.default.Type.PLAYLIST_V2) {
      const username = await exports.fetchPlaylistOwner(uri);
      return _spotifyLiburi2.default.playlistURI(username, id).toURI();
    } else if (type === _spotifyLiburi2.default.Type.PLAYLIST) {
      return uri;
    }
    throw new Error(`The uri ${uri} is not any kind of playlist uri`);
  }

  function getCorePlaylistUrl(uri, { type, start, length, includeEpisodes, version = 'v1' } = {}, isOwnPlaylist, windowedPlaylistShowTracklistCell) {
    const { originUri = uri, sort, filter } = _liveWrappedUri2.default.parse(uri) || {};
    let filters = filter ? filter.query.split(',') : [];

    if (!isLocalFilesUri(uri)) {
      // Project Premiere "redefined" what is considered 'playable' in the context
      // of the "Show Unavailable(Unplayable) Tracks in Playlists" setting.
      // We do the proper translation to core URIs here assuming this filter ended
      // up here due to the user setting.
      const returnUnplayableTracks = !filters.includes('playable eq true');

      let returnPremiumOnlyTracks;
      if (isOwnPlaylist) {
        returnPremiumOnlyTracks = true;
      } else if (windowedPlaylistShowTracklistCell === 'Enabled') {
        returnPremiumOnlyTracks = returnUnplayableTracks;
      } else {
        returnPremiumOnlyTracks = false;
      }

      filters = replaceFiltersToReturn(filters, returnUnplayableTracks, returnPremiumOnlyTracks);
    }

    const originUriWithoutQueryParams = _spotifyLiburi2.default.from(originUri).toURI();

    let url = isLocalFilesUri(uri) ? 'sp://local-files/v2' : `sp://core-playlist/${version}/playlist/${encodeURIComponent(originUriWithoutQueryParams)}`;

    if (type) {
      url += `/${isLocalFilesUri(uri) && type === 'rows' ? 'tracks' : type}`;
    }

    const query = [];
    if (sort && type !== 'metadata') {
      const direction = sort.direction === 'desc' ? 'DESC' : 'ASC';
      query.push(`sort=${encodeURIComponent((0, _coreSortParams2.default)(sort.query, direction))}`);
    }
    if (typeof start === 'number') {
      query.push(`start=${start}`);
    }
    if (typeof length === 'number') {
      query.push(`length=${length}`);
    }
    if (includeEpisodes === true) {
      query.push('includeEpisodes=true');
    }

    if (filters.length) {
      query.push(`filter=${filters.map(encodeURIComponent).join(',')}`);
    }
    if (type === 'play') {
      // Include a context URI that is then reflected as the context in the player state
      query.push(`uri=${encodeURIComponent(uri)}`);
    }
    if (query.length) {
      // TODO(felipec): remove the extra & and fix tests
      url += `?${query.join('&')}`;
    }
    return url;
  }

  function playlistRequest(uri, {
    method = 'GET',
    policy = {},
    body = {},
    type,
    start,
    length,
    includeEpisodes,
    version
  } = {}, callback) {
    const { originUri = uri } = _liveWrappedUri2.default.parse(uri) || {};
    let cancelFunction;

    const isOwnPlaylistPromise = isLocalFilesUri(uri) ? Promise.resolve(null) : exports.fetchIsPlaylistOwnedByCurrentUser(originUri);

    Promise.all([isOwnPlaylistPromise, _abba2.default.fetch('windowed-playlist-show-tracklist')]).then(([isOwnPlaylist, windowedPlaylistShowTracklistCell]) => {
      let lastResponseBodyString;
      cancelFunction = _bridge2.default.cosmos({
        method,
        uri: exports.getCorePlaylistUrl(uri, { type, start, length, includeEpisodes, version }, isOwnPlaylist, windowedPlaylistShowTracklistCell),
        body: JSON.stringify(_extends({}, body, {
          policy: _extends({}, body.policy || {}, policy)
        }))
      }, (error, response) => {
        if (error) {
          callback(error, response);
        } else if (response && !response.body && response.status >= 400) {
          callback(new Error(`${response.uri} responded with status ${response.status}`), response);
        } else {
          try {
            // Unfortunately core-playlist may pub even if nothing has changed,
            // and since some callers (eg the playlist app) runs pretty heavy
            // callbacks, we'll make sure to only ever call them when something
            // has actually changed.
            if (method === 'SUB') {
              if (response.body === lastResponseBodyString) return;
              lastResponseBodyString = response.body;
            }
            callback(null, JSON.parse(response.body));
          } catch (parseError) {
            parseError.message = `Failed to parse cosmos response: ${parseError.message}`;
            callback(parseError, response);
          }
        }
      });
    }).catch(callback);

    return {
      cancel() {
        if (cancelFunction) cancelFunction();
      }
    };
  }

  function getAvailablePlaylistName(candidateName, callback) {
    _bridge2.default.cosmosJSON({
      method: 'GET',
      uri: `sp://core-playlist/v1/rootlist?filter=${encodeURIComponent(`name startsWith ${encodeURIComponent(candidateName)}`)}`,
      body: {
        policy: {
          playlist: {
            name: true
          }
        }
      }
    }, (error, body) => {
      if (error) {
        callback(error);
        return;
      }
      const highestSuffix = body.rows.map(({ name }) => name.substr(candidateName.length).trim() || '1').filter(suffix => /\d+/.test(suffix)).map(Number).sort((a, b) => a - b).pop();

      const availablePlaylistName = `${candidateName}${highestSuffix ? ` ${highestSuffix + 1}` : ''}`;
      callback(null, availablePlaylistName);
    });
  }

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../libs/abba":48,"../../libs/bridge":121,"../../libs/core-sort-params":128,"../../libs/live-wrapped-uri":412,"spotify-liburi":1282}],449:[function(require,module,exports){
  'use strict';

  /**
   * Module dependencies
   */

  const extend = require('extend');
  const bridge = require('../bridge');
  const batch = require('spotify-batch');

  /**
   * Bridge methods
   */

  const PREF_ALL = 'preferences_all';
  const PREF_GET = 'preferences_get';
  const PREF_SET = 'preferences_set';
  const PREF_SUB = 'preferences_event_wait';

  /**
   * Converts a string with dot notation into
   * a nested object where the last key is
   * set to value
   *
   *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
   *
   * @api private
   * @param {String} string
   * @param {Mixed} value
   * @param {String} delimiter - optional
   */

  function transformStringIntoObjectAndSetValue(string, value, delimiter) {
    const object = {};
    string.split(delimiter || '.').reduce(function (o, c, i, a) {
      if (i < a.length - 1) {
        o[c] = {};
      } else {
        o[c] = value;
      }

      return o[c];
    }, object);

    return object;
  }

  /**
   * Converts an object with nest objects into a flat object
   *
   *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
   *
   * @api private
   * @param {String} string
   * @param {String} delimiter - optional
   */

  function transformObjectIntoFlatObject(object, delimiter) {
    const flattened = {};
    const newDelimiter = delimiter || '.';
    function traverse(o, key) {
      let tmp = null;
      for (const p in o) {
        if (typeof o[p] === 'object') {
          const newKey = key ? [key, p].join(newDelimiter) : p;
          traverse(o[p], newKey);
        } else {
          tmp = key ? [key, p].join(newDelimiter) : p;
          flattened[tmp] = o[p];
        }
      }
    }

    traverse(object);
    return flattened;
  }

  /**
   * Normalizes data from bridge responses
   *
   * @api private
   * @param {String} key
   * @param {Object} data
   * @param {Boolean} preserve - optional (Default: false)
   */

  function normalizeData(key, data, preserve) {
    const out = {};
    const regex = key === '*' ? null : RegExp(`^${key}`);
    let targets = null;

    if (typeof data !== 'object') {
      return data;
    }

    targets = Object.keys(data).map(function (innerkey) {
      if (regex === null || regex.test(innerkey)) {
        return [innerkey, data[innerkey]];
      }
      return false;
    }).filter(Boolean).reduce(function (t, c) {
      t[c[0]] = c[1];
      return t;
    }, {});

    Object.keys(targets).forEach(function (innerkey) {
      // extend output object with transformed properties
      extend(true, out, transformStringIntoObjectAndSetValue(innerkey, targets[innerkey]));
    });

    if (key === '*' || preserve === true) {
      return out;
    }
    return key.split('.').reduce(function (o, k) {
      return o[k];
    }, out);
  }

  /**
   * Subscribes to a key.
   *
   * @api private
   * @param {Function} rpc The RPC to use.
   * @param {String} key The key (including path).
   * @param {*} lastValue The last value of the key (used for comparing).
   * @param {Function} fn Subscribe handler.
   * @param {Object=} sub Subscription object, optional.
   */

  function subscribeToKey(rpc, key, lastValue, fn, sub) {
    const newSub = sub || {
      isCancelled: false,
      cancel: function () {
        this.isCancelled = true;
      }
    };

    rpc(PREF_SUB, [], function (err, res) {
      if (newSub.isCancelled) return;

      let didValueChange = false;

      let newLastValue = lastValue;
      if (res) {
        const value = normalizeData(key, res);
        if (value !== newLastValue) {
          newLastValue = value;
          didValueChange = true;
        }
      }

      // Resubscribe since one subscription is only for one response
      subscribeToKey(rpc, key, newLastValue, fn, newSub);

      if (didValueChange) {
        fn(null, newLastValue);
      }
    });

    return newSub;
  }

  /**
   * `Preferences' constructor
   *
   * @api public
   * @param {String} path - optional (Default: '*')
   * @param {Function} rpc - optional
   */

  module.exports = Preferences;
  function Preferences(path, rpc) {
    if (!(this instanceof Preferences)) {
      return new Preferences(path, rpc);
    }

    this.path = path || '*';
    this.rpc = rpc || bridge.request.bind(bridge);
  }

  /**
   * Retrieves all preferences at path.
   * If path is '*' then all preferences
   * are retrieved.
   *
   * @api public
   * @param {Function} fn
   */

  Preferences.prototype.all = function (fn) {
    const path = this.path;

    this.rpc(PREF_ALL, [], function (err, res) {
      if (err) {
        fn(err);
      } else if (path === '*') {
        fn(null, res);
      } else {
        fn(null, normalizeData(path, res, true));
      }
    });

    return this;
  };

  /**
   * Sets a preference at key at path
   * with value
   *
   * @api public
   * @param {String} key
   * @param {Mixed} value
   * @param {Function} fn
   */

  Preferences.prototype.set = function (key, value, fn) {
    const path = this.path;
    let map = null;
    let jobs = null;

    // handle batch jobs to extend bridge preferences
    if (typeof key === 'object') {
      const newFn = value;

      map = transformObjectIntoFlatObject(key);
      jobs = batch().concurrency(1);
      Object.keys(map).forEach(k => {
        jobs.push(next => {
          this.set(k, map[k], next);
        });
      });

      jobs.run(newFn);
    } else {
      const newKey = path === '*' ? key : [path, key].join('.');
      this.rpc(PREF_SET, [newKey, value], fn);
    }
    return this;
  };

  /**
   * Sets a preference bitflag at path, based on the inputs.
   *
   * @api public
   * @param {String} key
   * @param {Array} flagBoolPairs
   * @param {Function} fn
   */

  Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
    this.get(key, (err, value) => {
      if (err) {
        fn(err);
      } else {
        let newValue = value;
        flagBoolPairs.forEach(function (pair) {
          const flag = pair[0];
          const bool = pair[1];
          if (bool === undefined || bool === null) return;
          if (bool) newValue |= flag;else newValue &= ~flag;
        });

        this.set(key, newValue, fn);
      }
    });
  };

  /**
   * Gets a preference at key at path
   *
   * @api public
   * @param {String} key
   * @param {Function} fn
   */

  Preferences.prototype.get = function (key, fn) {
    const newKey = this.path === '*' ? key : [this.path, key].join('.');

    // try to get property first
    this.rpc(PREF_GET, [newKey], (err, res) => {
      const value = res ? normalizeData(newKey, res) : null;
      if (value === null) {
        this.rpc(PREF_ALL, [], function (innererr, innerres) {
          if (innererr) {
            fn(innererr);
          } else {
            fn(null, normalizeData(newKey, innerres));
          }
        });
      } else {
        fn(null, normalizeData(newKey, res));
      }
    });
    return this;
  };

  /**
   * Subscribes to a preference at key at path
   *
   * @api public
   * @param {String} key
   * @param {Function} fn
   */

  Preferences.prototype.subscribe = function (key, fn) {
    let sub = null;
    let cancelled = false;

    // Get initial value and then subscribe for changes
    this.get(key, (err, res) => {
      if (cancelled) return;
      const keyWithPath = this.path === '*' ? key : [this.path, key].join('.');
      sub = subscribeToKey(this.rpc, keyWithPath, res, fn);

      // Respond to the GET (initial value for SUB)
      fn(err, res);
    });

    return {
      cancel: function () {
        cancelled = true;
        if (sub) {
          sub.cancel();
        }
      }
    };
  };

  },{"../bridge":121,"extend":709,"spotify-batch":1266}],450:[function(require,module,exports){
  (function (process,global){
  /*
  defer
  */'use strict';

  const now = require('mout/time/now');
  const forEach = require('mout/array/forEach');
  const indexOf = require('mout/array/indexOf');

  const callbacks = {
    timeout: {},
    frame: [],
    immediate: []
  };

  const iterate = function (collection) {
    const time = now();

    forEach(collection.splice(0), function (entry) {
      entry.callback.call(entry.context, time);
    });
  };

  const push = function (collection, callback, context, defer) {
    const iterator = function () {
      iterate(collection);
    };

    if (!collection.length) defer(iterator);

    const entry = {
      callback: callback,
      context: context
    };

    collection.push(entry);

    return function () {
      const io = indexOf(collection, entry);
      if (io > -1) collection.splice(io, 1);
    };
  };

  const defer = {};

  if (global.process && process.nextTick) {
    defer.immediate = function (callback, context) {
      return push(callbacks.immediate, callback, context, process.nextTick);
    };
  } else if (global.setImmediate) {
    defer.immediate = function (callback, context) {
      return push(callbacks.immediate, callback, context, setImmediate);
    };
  } else if (global.postMessage && global.addEventListener) {
    addEventListener('message', function (event) {
      if (event.source === global && event.data === '@deferred') {
        event.stopPropagation();
        iterate(callbacks.immediate);
      }
    }, true);

    defer.immediate = function (callback, context) {
      return push(callbacks.immediate, callback, context, function () {
        postMessage('@deferred', '*');
      });
    };
  } else {
    defer.immediate = function (callback, context) {
      return push(callbacks.immediate, callback, context, function (iterator) {
        setTimeout(iterator, 0);
      });
    };
  }

  let clear;

  defer.timeout = function (callback, ms, context) {
    const ct = callbacks.timeout;

    if (!clear) {
      clear = defer.immediate(function () {
        clear = null;
        callbacks.timeout = {};
      });
    }

    return push(ct[ms] || (ct[ms] = []), callback, context, function (iterator) {
      setTimeout(iterator, ms);
    });
  };

  module.exports = defer;

  }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"_process":823,"mout/array/forEach":781,"mout/array/indexOf":782,"mout/time/now":820}],451:[function(require,module,exports){
  /*
  Emitter
  */'use strict';

  const indexOf = require('mout/array/indexOf');
  const forEach = require('mout/array/forEach');

  const prime = require('./index');
  const defer = require('./defer');

  const slice = Array.prototype.slice;

  let resetCount = 0;

  const Emitter = prime({
    constructor: function (stoppable) {
      this._stoppable = stoppable;
    },

    on: function (event, fn) {
      const listeners = this._listeners || (this._listeners = {});
      const events = listeners[event] || (listeners[event] = []);

      if (indexOf(events, fn) === -1) {
        events.push(fn);
      }

      return this;
    },

    off: function (event, fn) {
      const listeners = this._listeners;
      if (listeners) {
        const events = listeners[event];
        if (events) {
          const io = indexOf(events, fn);
          if (io > -1) events.splice(io, 1);
          if (!events.length) delete listeners[event];
          for (const l in listeners) {
            if (!listeners.hasOwnProperty(l)) continue;
            return this;
          }
          delete this._listeners;
        }
      }
      return this;
    },

    emit: function (event) {
      const args = slice.call(arguments, 1);

      const emit = () => {
        const listeners = this._listeners;
        if (listeners) {
          const events = listeners[event];
          if (events) {
            forEach(events.slice(0), innerEvent => {
              const result = innerEvent.apply(this, args);
              if (this._stoppable) return result;
              return undefined;
            });
          }
        }
        if (this._promiseWaiters && this._promiseWaiters[event]) {
          const execute = this._promiseWaiters[event].slice();
          this._promiseWaiters[event] = [];
          execute.forEach(waiter => waiter(...args));
        }
      };

      if (args[args.length - 1] === Emitter.EMIT_SYNC) {
        args.pop();
        emit();
      } else {
        // Defer, and check that the emitter wasn't reset() in the same event loop iteration
        const currentReset = resetCount;
        defer.immediate(() => {
          if (currentReset === resetCount) {
            emit();
          }
        });
      }

      return this;
    },

    reset: function () {
      resetCount++;
      this._listeners = {};
    },

    whenNextEvent: function (event) {
      return new Promise(resolve => {
        this._promiseWaiters = this._promiseWaiters || {};
        this._promiseWaiters[event] = [...(this._promiseWaiters[event] || []), resolve];
      });
    }
  });

  Emitter.EMIT_SYNC = {};

  module.exports = Emitter;

  },{"./defer":450,"./index":452,"mout/array/forEach":781,"mout/array/indexOf":782}],452:[function(require,module,exports){
  /*
  prime
   - prototypal inheritance
  */'use strict';

  const hasOwn = require('mout/object/hasOwn');
  const mixIn = require('mout/object/mixIn');
  const create = require('mout/lang/createObject');
  const kindOf = require('mout/lang/kindOf');

  let hasDescriptors = true;

  try {
    Object.defineProperty({}, '~', {});
    Object.getOwnPropertyDescriptor({}, '~');
  } catch (e) {
    hasDescriptors = false;
  }

  // we only need to be able to implement "toString" and "valueOf" in IE < 9
  const hasEnumBug = !{ valueOf: 0 }.propertyIsEnumerable('valueOf');
  const buggy = ['toString', 'valueOf'];

  const verbs = /^constructor|inherits|mixin$/;

  const implement = function (proto) {
    const prototype = this.prototype;

    for (const key in proto) {
      if (key.match(verbs)) continue;
      if (hasDescriptors) {
        const descriptor = Object.getOwnPropertyDescriptor(proto, key);
        if (descriptor) {
          Object.defineProperty(prototype, key, descriptor);
          continue;
        }
      }
      prototype[key] = proto[key];
    }

    if (hasEnumBug) {
      buggy.forEach(innerKey => {
        const value = proto[innerKey];
        if (value !== Object.prototype[innerKey]) prototype[innerKey] = value;
      });
    }

    return this;
  };

  const prime = function (proto) {
    let newProto = proto;
    if (kindOf(newProto) === 'Function') {
      newProto = { constructor: proto };
    }

    const superprime = newProto.inherits;

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // newProto.constructor becomes the effective constructor

    let constructor;

    if (hasOwn(newProto, 'constructor')) {
      constructor = newProto.constructor;
    } else {
      if (superprime) {
        constructor = function () {
          return superprime.apply(this, arguments);
        };
      } else {
        constructor = function () {};
      }
    }

    if (superprime) {
      mixIn(constructor, superprime);

      const superproto = superprime.prototype;
      // inherit from superprime
      const cproto = constructor.prototype = create(superproto);

      // setting constructor.parent to superprime.prototype
      // because it's the shortest possible absolute reference
      constructor.parent = superproto;
      cproto.constructor = constructor;
    }

    if (!constructor.implement) constructor.implement = implement;

    let mixins = newProto.mixin;
    if (mixins) {
      if (kindOf(mixins) !== 'Array') mixins = [mixins];
      for (let i = 0; i < mixins.length; i++) {
        constructor.implement(create(mixins[i].prototype));
      }
    }

    // implement newProto and return constructor
    return constructor.implement(newProto);
  };

  module.exports = prime;

  },{"mout/lang/createObject":793,"mout/lang/kindOf":803,"mout/object/hasOwn":811,"mout/object/mixIn":813}],453:[function(require,module,exports){
  /*
  Map
  */
  'use strict';

  const indexOf = require('mout/array/indexOf');

  const prime = require('./index');

  const Map = prime({
    constructor: function Map() {
      this.length = 0;
      this._values = [];
      this._keys = [];
    },

    set: function (key, value) {
      const index = indexOf(this._keys, key);

      if (index === -1) {
        this._keys.push(key);
        this._values.push(value);
        this.length++;
      } else {
        this._values[index] = value;
      }

      return this;
    },

    get: function (key) {
      const index = indexOf(this._keys, key);
      return index === -1 ? null : this._values[index];
    },

    count: function () {
      return this.length;
    },

    forEach: function (method, context) {
      for (let i = 0, l = this.length; i < l; i++) {
        if (method.call(context, this._values[i], this._keys[i], this) === false) {
          break;
        }
      }
      return this;
    },

    map: function (method, context) {
      const results = new Map();
      this.forEach(function (value, key) {
        results.set(key, method.call(context, value, key, this));
      }, this);
      return results;
    },

    filter: function (method, context) {
      const results = new Map();
      this.forEach(function (value, key) {
        if (method.call(context, value, key, this)) results.set(key, value);
      }, this);
      return results;
    },

    every: function (method, context) {
      let every = true;
      this.forEach(function (value, key) {
        if (!method.call(context, value, key, this)) {
          every = false;
        }
      }, this);
      return every;
    },

    some: function (method, context) {
      let some = false;
      this.forEach(function (value, key) {
        if (method.call(context, value, key, this)) {
          some = true;
        }
      }, this);
      return some;
    },

    indexOf: function (value) {
      const index = indexOf(this._values, value);
      return index > -1 ? this._keys[index] : null;
    },

    remove: function (value) {
      const index = indexOf(this._values, value);

      if (index !== -1) {
        this._values.splice(index, 1);
        this.length--;
        return this._keys.splice(index, 1)[0];
      }

      return null;
    },

    unset: function (key) {
      const index = indexOf(this._keys, key);

      if (index !== -1) {
        this._keys.splice(index, 1);
        this.length--;
        return this._values.splice(index, 1)[0];
      }

      return null;
    },

    keys: function () {
      return this._keys.slice();
    },

    values: function () {
      return this._values.slice();
    }
  });

  const map = function () {
    return new Map();
  };

  map.prototype = Map.prototype;

  module.exports = map;

  },{"./index":452,"mout/array/indexOf":782}],454:[function(require,module,exports){
  /**
   * @module range2
   */
  'use strict';

  const prime = require('../../libs/prime');

  const map = require('mout/array/map');

  const push_ = Array.prototype.push;
  const slice_ = Array.prototype.slice;

  const Range = prime(
  /** @lends Range.prototype */{
    /**
     * The representation of a range
     * @constructs
     * @param {Number} start The start of the range.
     * @param {Number} end The end of the range.
     */
    constructor: function Range(start, end) {
      this.update(start, end);
    },

    /** Update a range. */
    update: function (start, end) {
      if (start !== null) this.start = start;
      if (end !== null) this.end = end;
      if (this.start === null || this.end === null || this.start > this.end) {
        throw new Error(`invalid range: [${this.start}, ${this.end}]`);
      }
      this.length = this.end - this.start;
      return this;
    },

    /** Copy a range. */
    copy: function () {
      return new Range(this.start, this.end);
    },

    /** Range is above range. */
    above: function (range) {
      if (!range) return false;
      return this.start >= range.end;
    },

    /** Range is below range. */
    below: function (range) {
      if (!range) return false;
      return this.end <= range.start;
    },

    adjacent: function (range) {
      if (!range) return false;
      return this.end === range.start || this.start === range.end;
    },

    /** Range intersects range. */
    intersects: function (range) {
      if (!range) return false;
      return !this.above(range) && !this.below(range);
    },

    /** Range contains range. */
    contains: function (range) {
      if (!range) return false;
      return this.start <= range.start && this.end >= range.end;
    },

    /** Range is contained by ranges. */
    contained: function (range) {
      let ranges;
      if (range instanceof Range) ranges = arguments;else ranges = range;
      if (!ranges) return false;

      for (let i = 0; ranges[i] !== undefined; i++) {
        const r = ranges[i];
        if (r.start <= this.start && r.end >= this.end) {
          return true;
        }
      }
      return false;
    },

    /** Range fits two ranges. */
    fits: function (prev, next) {
      if (!prev && !next) return true;
      if (!prev) return this.end <= next.start;
      if (!next) return this.start >= prev.end;
      return this.start >= prev.end && this.end <= next.start;
    },

    // get the section of this range contained between two ranges
    // [0, 20] » [0, 8], [16, 20] » [8, 16]

    /** portion of a range between two ranges. */
    between: function (prev, next) {
      if (!prev && !next) return this.copy();
      if (!prev) {
        return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
      }
      if (!next) {
        return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);
      }

      return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
    },

    // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
    // [3, 6] » [5, 7] = [5, 6]
    // [6, 9] » [5, 7] = [6, 7]

    /** intersection of a range with many ranges */
    intersection: function (range) {
      const intersected = [];
      let ranges;
      if (range instanceof Range) ranges = arguments;else ranges = range;
      for (let k = 0; k < ranges.length; k++) {
        const r = ranges[k];
        if (this.below(r)) break;

        if (r.intersects(this)) {
          intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
        }
      }
      return intersected;
    },

    // subtract ranges from this range
    // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

    /** subtract many ranges from the range. */
    subtract: function (range) {
      const subtracted = [];
      let ranges;
      if (range instanceof Range) ranges = arguments;else ranges = range;
      for (let k = -1; k < ranges.length; k++) {
        const prev = ranges[k];
        const next = ranges[k + 1];
        const between = this.between(prev, next);
        if (between) subtracted.push(between);
      }
      return subtracted;
    },

    // extract this range from ranges
    // [0, 8] » [0, 2], [5, 8] = []
    // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
    // [0, 10] » [5, 10], [15, 20] = [5, 10]
    // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
    // [10, 20] » [0, 10], [20, 30] = [0, 20]

    /** extract the range from many ranges. */
    extract: function (range) {
      const ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

      for (let k = 0; k < ranges.length; k++) {
        const prev = ranges[k - 1];
        const next = ranges[k];

        let newRange = null;

        if (this.below(next)) {
          newRange = new Range(next.start - this.length, next.end - this.length);
        } else if (this.intersects(next)) {
          const subtracted = next.subtract(this);
          if (subtracted.length === 2) {
            // is contained
            newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
          } else if (subtracted.length === 1) {
            if (next.end > this.end) {
              // second segment kept
              newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
            } else if (this.start > next.start) {
              // first segment kept
              newRange = new Range(subtracted[0].start, subtracted[0].end);
            }
          } else {
            // gets eaten
            ranges.splice(k--, 1); // decrease k
          }
        } else {
          ranges.splice(k, 1, next.copy());
        }

        if (newRange) {
          if (prev && prev.end === newRange.start) {
            // touches previous
            ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
          } else {
            ranges.splice(k, 1, newRange);
          }
        }
      }

      return ranges;
    },

    // [2,3] » [0,1], [2,3] = [0,1], [2,4]
    // [1,2] » [0,6] = [0,7]
    // [0,1] » [0,1], [5,6] = [0,2], [6,7]
    // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

    // TODO: this can be slightly better. merging can be done in one loop.

    /** insert the range in many ranges. */
    insert: function (range) {
      const ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

      for (let k = 0; k < ranges.length; k++) {
        const next = ranges[k];

        if (this.start >= next.end) {
          ranges.splice(k, 1, next.copy());
        } else if (this.start > next.start && this.start < next.end) {
          ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
        } else {
          ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
        }
      }

      return this.merge(ranges);
    },

    // merge this range in ranges
    // [0, 8] » [0, 2], [5, 8] = [0, 8]
    // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
    // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

    /** merge many ranges to the range. */
    merge: function (range) {
      let ranges;
      if (range instanceof Range) ranges = arguments;else ranges = range;

      ranges = map(ranges, function (r) {
        return r.copy();
      });

      if (!ranges.length) return [this.copy()];

      let k;
      let l;

      for (k = -1, l = ranges.length; k < l; k++) {
        const prev = ranges[k];
        const next = ranges[k + 1];
        const between = this.between(prev, next);

        if (between) {
          if (!prev && next) {
            if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              k++; // increase k since we had a push
              ranges.unshift(between);
            }
          } else if (prev && next) {
            if (prev.end === between.start && between.end === next.start) {
              prev.update(prev.start, next.end);
              ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
            } else if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              ranges.splice(k + 1, 0, between);
            }
          } else if (prev && !next) {
            if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else {
              k++; // increase k since we had a push
              ranges.push(between);
            }
          }
        }
      }

      return ranges;
    },

    /** Remove range from many ranges
     - The range(s) you pass is what you remove from */
    remove: function (range) {
      let ranges;
      if (range instanceof Range) ranges = arguments;else ranges = range;
      const result = [];
      for (let i = 0; i < ranges.length; i++) {
        const remaining = ranges[i].subtract(this);
        if (remaining.length) push_.apply(result, remaining);
      }
      return result;
    },

    /** Range to an array of indices */
    toIndices: function () {
      const indices = [];
      for (let i = this.start; i < this.end; i++) indices.push(i);
      return indices;
    },

    /** Range to a string */
    toString: function () {
      return `${[this.start, this.end]}`;
    }
  });

  /**
   * Range from a string
   * @memberof Range
   * @static
   * @param {String} string - The string.
   * @return {Range} The range.
   */
  Range.fromString = function (string) {
    const parts = string.split(',');
    return new Range(+parts[0], +parts[1]);
  };

  /**
   * Ranges from an array of indices
   * @memberof Range
   * @static
   * @param {Array} indices - An array of indices.
   * @return {Array} An array of Ranges.
   */
  Range.fromIndices = function (indices) {
    indices.sort(function (a, b) {
      return a > b ? 1 : -1;
    });

    const ranges = [];
    let rstart;
    let rend;

    for (let i = 0; i < indices.length; i++) {
      rstart = indices[i];
      rend = rstart;
      while (indices[i + 1] - indices[i] === 1) {
        rend = indices[i + 1]; // increment the index if the numbers sequential
        i++;
      }
      ranges.push(new Range(rstart, rend + 1));
    }

    return ranges;
  };

  /**
   * A function that returns a range.
   * @function
   * @see Range
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  module.exports = Range;

  },{"../../libs/prime":452,"mout/array/map":784}],456:[function(require,module,exports){
  /*
  attributes
  */
  'use strict';

  const $ = require('./base');

  const trim = require('mout/string/trim');
  const forEach = require('mout/array/forEach');
  const filter = require('mout/array/filter');
  const indexOf = require('mout/array/indexOf');

  // attributes

  $.implement({
    setAttribute: function (name, value) {
      return this.forEach(function (node) {
        node.setAttribute(name, value);
      });
    },

    getAttribute: function (name) {
      const attr = this[0].getAttributeNode(name);
      return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function (name) {
      const node = this[0];
      if (node.hasAttribute) return node.hasAttribute(name);
      const attr = node.getAttributeNode(name);
      return !!(attr && attr.specified);
    },

    removeAttribute: function (name) {
      return this.forEach(function (node) {
        const attr = node.getAttributeNode(name);
        if (attr) node.removeAttributeNode(attr);
      });
    }
  });

  const accessors = {};

  forEach(['type', 'value', 'name', 'href', 'title', 'id'], function (name) {
    accessors[name] = function (value) {
      return value !== undefined ? this.forEach(function (node) {
        node[name] = value;
      }) : this[0][name];
    };
  });

  // booleans

  forEach(['checked', 'disabled', 'selected'], function (name) {
    accessors[name] = function (value) {
      return value !== undefined ? this.forEach(function (node) {
        node[name] = !!value;
      }) : !!this[0][name];
    };
  });

  // className

  const classes = function (className) {
    const classNames = trim(className).replace(/\s+/g, ' ').split(' ');
    const uniques = {};

    return filter(classNames, function (innerClassName) {
      if (innerClassName !== '' && !uniques[innerClassName]) {
        return uniques[innerClassName] = innerClassName;
      }
      return false;
    }).sort();
  };

  accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
      node.className = classes(className).join(' ');
    }) : classes(this[0].className).join(' ');
  };

  // attribute

  $.implement({
    attribute: function (name, value) {
      const accessor = accessors[name];
      let ret;
      if (accessor) ret = accessor.call(this, value);
      if (value) ret = this.setAttribute(name, value);
      if (value === null) ret = this.removeAttribute(name);
      if (value === undefined) ret = this.getAttribute(name);

      return ret;
    }
  });

  $.implement(accessors);

  // shortcuts

  $.implement({
    check: function () {
      return this.checked(true);
    },

    uncheck: function () {
      return this.checked(false);
    },

    disable: function () {
      return this.disabled(true);
    },

    enable: function () {
      return this.disabled(false);
    },

    select: function () {
      return this.selected(true);
    },

    deselect: function () {
      return this.selected(false);
    }
  });

  // classNames, has / add / remove Class

  $.implement({
    classNames: function () {
      return classes(this[0].className);
    },

    hasClass: function (className) {
      return indexOf(this.classNames(), className) > -1;
    },

    addClass: function (className) {
      return this.forEach(function (node) {
        const nodeClassName = node.className;
        const classNames = classes(`${nodeClassName} ${className}`).join(' ');
        if (nodeClassName !== classNames) node.className = classNames;
      });
    },

    removeClass: function (className) {
      return this.forEach(function (node) {
        const classNames = classes(node.className);
        forEach(classes(className), function (innerClassName) {
          const index = indexOf(classNames, innerClassName);
          if (index > -1) classNames.splice(index, 1);
        });
        node.className = classNames.join(' ');
      });
    },

    toggleClass: function (className, force) {
      const add = force !== undefined ? force : !this.hasClass(className);
      if (add) this.addClass(className);else this.removeClass(className);
      return !!add;
    }
  });

  // toString

  $.prototype.toString = function () {
    const tag = this.tag();
    const id = this.id();
    const innerClasses = this.classNames();

    let str = tag;
    if (id) str += `#${id}`;
    if (innerClasses.length) str += `.${innerClasses.join('.')}`;
    return str;
  };

  const textProperty = document.createElement('div').textContent === null ? 'innerText' : 'textContent';

  // tag, html, text, data

  $.implement({
    tag: function () {
      return this[0].tagName.toLowerCase();
    },

    html: function (html) {
      return html !== undefined ? this.forEach(function (node) {
        node.innerHTML = html;
      }) : this[0].innerHTML;
    },

    text: function (text) {
      return text !== undefined ? this.forEach(function (node) {
        node[textProperty] = text;
      }) : this[0][textProperty];
    },

    data: function (key, value) {
      switch (value) {
        case undefined:
          return this.getAttribute(`data-${key}`);
        case null:
          return this.removeAttribute(`data-${key}`);
        default:
          return this.setAttribute(`data-${key}`, value);
      }
    }
  });

  module.exports = $;

  },{"./base":457,"mout/array/filter":780,"mout/array/forEach":781,"mout/array/indexOf":782,"mout/string/trim":819}],457:[function(require,module,exports){
  (function (global){
  /*
  elements
  */'use strict';

  const prime = require('../../libs/prime');

  const forEach = require('mout/array/forEach');
  const map = require('mout/array/map');
  const filter = require('mout/array/filter');
  const every = require('mout/array/every');
  const some = require('mout/array/some');

  // uniqueID
  const doc = global.document || {};
  let index = 0;
  const __dc = doc.__counter;
  const counter = doc.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36);
  const key = `uid:${counter}`;

  const uniqueID = function (n) {
    if (n === window) return 'window';
    if (n === document) return 'document';
    if (n === document.documentElement) return 'html';
    return n[key] || (n[key] = (index++).toString(36));
  };

  const instances = new WeakMap();

  // elements prime

  const $ = prime({
    constructor: function $(n, context) {
      // TODO: Fix this to use dependency injection and/or actual classes
      // eslint-disable-next-line no-use-before-define
      if (!n) return this && this.constructor === $ ? new Elements() : null;

      let self;
      let uid;

      // eslint-disable-next-line no-use-before-define
      if (n.constructor !== Elements) {
        // eslint-disable-next-line no-use-before-define
        self = new Elements();

        if (typeof n === 'string') {
          if (!self.search) return null;
          self[self.length++] = context || document;
          return self.search(n);
        }

        if (n.nodeType || n === window) {
          self[self.length++] = n;
        } else if (n.length) {
          // this could be an array, or any object with a length attribute,
          // including another instance of elements from another interface.

          const uniques = {};

          for (let i = 0, l = n.length; i < l; i++) {
            // perform elements flattening
            const nodes = $(n[i], context);
            if (nodes && nodes.length) {
              for (let j = 0, k = nodes.length; j < k; j++) {
                const node = nodes[j];
                uid = uniqueID(node);
                if (!uniques[uid]) {
                  self[self.length++] = node;
                  uniques[uid] = true;
                }
              }
            }
          }
        }
      } else {
        self = n;
      }

      if (!self.length) return null;

      // when length is 1 always use the same elements instance

      if (self.length === 1) {
        const instance = instances.get(self[0]);
        if (instance) {
          return instance;
        }
        instances.set(self[0], self);
      }

      return self;
    }
  });

  const Elements = prime({
    inherits: $,

    constructor: function Elements() {
      this.length = 0;
    },

    unlink: function () {
      return this.map(function (node) {
        instances.delete(node);
        return node;
      });
    },

    // methods

    forEach: function (method, context) {
      forEach(this, method, context);
      return this;
    },

    map: function (method, context) {
      return map(this, method, context);
    },

    filter: function (method, context) {
      return filter(this, method, context);
    },

    every: function (method, context) {
      return every(this, method, context);
    },

    some: function (method, context) {
      return some(this, method, context);
    }
  });

  module.exports = $;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../libs/prime":452,"mout/array/every":779,"mout/array/filter":780,"mout/array/forEach":781,"mout/array/map":784,"mout/array/some":787}],458:[function(require,module,exports){
  /*
  delegation
  */'use strict';

  const Map = require('../../libs/prime/map');

  const $ = require('./events');
  require('./traversal');

  $.implement({
    delegate: function (event, selector, handle) {
      return this.forEach(function (node) {
        const self = $(node);

        const delegation = self._delegation || (self._delegation = {});
        const events = delegation[event] || (delegation[event] = {});
        const map = events[selector] || (events[selector] = new Map());

        if (map.get(handle)) return;

        const action = function (e) {
          const target = $(e.target || e.srcElement);
          const match = target.matches(selector) ? target : target.parent(selector);

          let res;

          if (match) res = handle.call(self, e, match);

          return res;
        };

        map.set(handle, action);

        self.on(event, action);
      });
    },

    undelegate: function (event, selector, handle) {
      return this.forEach(function (node) {
        const self = $(node);
        const delegation = self._delegation;

        if (!delegation) {
          return;
        }

        const events = delegation[event];
        if (!events) {
          return;
        }

        const map = events[selector];
        if (!map) {
          return;
        }

        const action = map.get(handle);

        if (action) {
          self.off(event, action);
          map.remove(action);

          // if there are no more handles in a given selector, delete it
          if (!map.count()) delete events[selector];
          // var evc = evd = 0, x
          let e1 = true;
          let e2 = true;

          for (const x in events) {
            if (!events.hasOwnProperty(x)) continue;
            e1 = false;
            break;
          }
          // if no more selectors in a given event type, delete it
          if (e1) delete delegation[event];
          for (const x in delegation) {
            if (!delegation.hasOwnProperty(x)) continue;
            e2 = false;
            break;
          }
          // if there are no more delegation events in the element, delete the _delegation object
          if (e2) delete self._delegation;
        }
      });
    }
  });

  module.exports = $;

  },{"../../libs/prime/map":453,"./events":459,"./traversal":462}],459:[function(require,module,exports){
  /*
  events
  */'use strict';

  const Emitter = require('../../libs/prime/emitter');

  const $ = require('./base');

  $.implement({
    on: function (event, handle, useCapture) {
      return this.forEach(function (node) {
        const self = $(node);

        const internalEvent = event + (useCapture ? ':capture' : '');

        Emitter.prototype.on.call(self, internalEvent, handle);

        const domListeners = self._domListeners || (self._domListeners = {});
        if (!domListeners[internalEvent]) {
          const listener = function (e) {
            Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
          };
          node.addEventListener(event, listener, useCapture || false);
          domListeners[internalEvent] = listener;
        }
      });
    },

    off: function (event, handle, useCapture) {
      return this.forEach(function (node) {
        const self = $(node);

        const internalEvent = event + (useCapture ? ':capture' : '');

        const domListeners = self._domListeners;
        const listeners = self._listeners;

        if (domListeners && listeners) {
          const domEvent = domListeners[internalEvent];

          if (domEvent) {
            Emitter.prototype.off.call(self, internalEvent, handle);

            if (!self._listeners || !self._listeners[event]) {
              node.removeEventListener(event, domEvent, false);
              delete domListeners[event];

              for (const l in domListeners) {
                if (domListeners.hasOwnProperty(l)) {
                  return;
                }
              }
              delete self._domListeners;
            }
          }
        }
      });
    },

    emit: function () {
      const args = arguments;
      return this.forEach(function (node) {
        Emitter.prototype.emit.apply($(node), args);
      });
    }
  });

  module.exports = $;

  },{"../../libs/prime/emitter":451,"./base":457}],460:[function(require,module,exports){
  /*
  elements
  */'use strict';

  const $ = require('./base');
  require('./attributes');
  require('./events');
  require('./insertion');
  require('./traversal');
  require('./delegation');

  module.exports = $;

  },{"./attributes":456,"./base":457,"./delegation":458,"./events":459,"./insertion":461,"./traversal":462}],461:[function(require,module,exports){
  /*
  insertion
  */'use strict';

  const $ = require('./base');

  // base insertion

  $.implement({
    appendChild: function (child) {
      this[0].appendChild($(child)[0]);
      return this;
    },

    insertBefore: function (child, ref) {
      this[0].insertBefore($(child)[0], $(ref)[0]);
      return this;
    },

    removeChild: function (child) {
      this[0].removeChild($(child)[0]);
      return this;
    },

    replaceChild: function (child, ref) {
      this[0].replaceChild($(child)[0], $(ref)[0]);
      return this;
    }
  });

  // before, after, bottom, top

  $.implement({
    before: function (element) {
      const innerElement = $(element)[0];
      const parent = innerElement.parentNode;
      if (parent) {
        this.forEach(function (node) {
          parent.insertBefore(node, innerElement);
        });
      }
      return this;
    },

    after: function (element) {
      const innerElement = $(element)[0];
      const parent = innerElement.parentNode;
      if (parent) {
        this.forEach(function (node) {
          parent.insertBefore(node, innerElement.nextSibling);
        });
      }
      return this;
    },

    bottom: function (element) {
      const innerElement = $(element)[0];
      return this.forEach(function (node) {
        innerElement.appendChild(node);
      });
    },

    top: function (element) {
      const innerElement = $(element)[0];
      return this.forEach(function (node) {
        innerElement.insertBefore(node, innerElement.firstChild);
      });
    }
  });

  // insert, replace

  $.implement({
    insert: $.prototype.bottom,

    remove: function () {
      return this.forEach(function (node) {
        const parent = node.parentNode;
        if (parent) parent.removeChild(node);
      });
    },

    replace: function (element) {
      const innerElement = $(element)[0];
      innerElement.parentNode.replaceChild(this[0], innerElement);
      return this;
    }
  });

  module.exports = $;

  },{"./base":457}],462:[function(require,module,exports){
  /*
  traversal
  */
  'use strict';

  var _slick = require('slick');

  var _slick2 = _interopRequireDefault(_slick);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const map = require('mout/array/map');

  const $ = require('./base');

  const gen = function (combinator, expression) {
    return map(_slick2.default.parse(expression || '*'), function (part) {
      return `${combinator} ${part}`;
    }).join(', ');
  };

  const push_ = Array.prototype.push;

  $.implement({
    search: function (expression) {
      if (this.length === 1) return $(_slick2.default.search(expression, this[0], new $()));

      let buffer = [];
      for (let i = 0; i < this.length; i++) {
        const node = this[i];
        push_.apply(buffer, _slick2.default.search(expression, node));
      }
      buffer = $(buffer);
      return buffer && buffer.sort();
    },

    find: function (expression) {
      if (this.length === 1) return $(_slick2.default.find(expression, this[0]));

      for (let i = 0; i < this.length; i++) {
        const node = this[i];
        const found = _slick2.default.find(expression, node);
        if (found) return $(found);
      }

      return null;
    },

    sort: function () {
      return _slick2.default.sort(this);
    },

    matches: function (expression) {
      return _slick2.default.matches(this[0], expression);
    },

    contains: function (node) {
      return _slick2.default.contains(this[0], node);
    },

    nextSiblings: function (expression) {
      return this.search(gen('~', expression));
    },

    nextSibling: function (expression) {
      return this.find(gen('+', expression));
    },

    previousSiblings: function (expression) {
      return this.search(gen('!~', expression));
    },

    previousSibling: function (expression) {
      return this.find(gen('!+', expression));
    },

    children: function (expression) {
      return this.search(gen('>', expression));
    },

    firstChild: function (expression) {
      return this.find(gen('^', expression));
    },

    lastChild: function (expression) {
      return this.find(gen('!^', expression));
    },

    parent: function (expression) {
      const buffer = [];
      for (let i = 0; i < this.length; i++) {
        let node = this[i].parentNode;
        while (node && node !== document) {
          if (!expression || _slick2.default.matches(node, expression)) {
            buffer.push(node);
            break;
          }

          node = node.parentNode;
        }
      }
      return $(buffer);
    },

    parents: function (expression) {
      const buffer = [];
      for (let i = 0; i < this.length; i++) {
        let node = this[i];
        while (node && node !== document) {
          if (!expression || _slick2.default.matches(node, expression)) buffer.push(node);
          node = node.parentNode;
        }
      }
      return $(buffer);
    }
  });

  module.exports = $;

  },{"./base":457,"mout/array/map":784,"slick":1264}],463:[function(require,module,exports){
  'use strict';

  const $ = require('../spotify-elements');
  const live = require('../live');
  const liburi = require('spotify-liburi');
  const surroundMessages = require('../surround-messages');

  const center = require('./center');

  const IS_ADDED_PROPERTY = 'added';
  const BUTTON_SELECTOR = '[data-button=add]';
  const JUSTCHANGED_CLASSNAME = 'just-changed';
  const ADDED_CLASSNAME = 'added';
  const INTERACTION_INTENT_ATTR = 'data-interaction-intent';
  const INTERACTION_INTENT_SAVE = 'save';
  const INTERACTION_INTENT_ADD = 'add';
  const INTERACTION_INTENT_REMOVE = 'remove';
  const INTERACTION_INTENT_FOLLOW = 'follow';
  const INTERACTION_INTENT_UNFOLLOW = 'unfollow';
  const INTERACTION_TARGET_ATTR = 'data-interaction-target';
  const TOGGLE_FOLLOW_STATE_BUTTON = 'toggle-follow-state-button';
  const SAVE_REMOVE_BUTTON = 'save-remove-button';

  const changeHandlers = {};
  let isAttached = false;

  function getAddedClass(node) {
    const addedClassNode = node[0].closest('data-class-added');
    return addedClassNode ? addedClassNode.getAttribute('data-class-added') : ADDED_CLASSNAME;
  }

  function getURIFromNode(node) {
    const stateNode = node[0].closest('[data-uri]');
    if (!stateNode) {
      return null;
    }
    return stateNode.getAttribute('data-uri');
  }

  const eventHandlers = {
    click: function (event, node) {
      const stateNode = $(node[0].closest('[data-uri]'));
      if (!stateNode) return;

      let uri = stateNode.data('uri');
      if (!uri) return;

      // Rewrite collection-(album|artist) to vanilla counterparts.
      const uriObject = liburi.from(uri);
      if (uriObject) {
        if (uriObject.type === liburi.Type.COLLECTION_ALBUM) {
          uri = liburi.albumURI(uriObject.id).toURI();
        } else if (uriObject.type === liburi.Type.COLLECTION_ARTIST) {
          uri = liburi.artistURI(uriObject.id).toURI();
        }
      }

      const addedClass = getAddedClass(node);
      const shouldBeAdded = !stateNode.hasClass(addedClass);
      const data = {
        added: shouldBeAdded
      };

      node.addClass(JUSTCHANGED_CLASSNAME);

      // using capture=true to handle buttons with inner divs (used for changing button text)
      node.on('mouseout', function mouseoutHandler(innerEvent) {
        if (innerEvent.target !== node[0]) return;
        node.off('mouseout', mouseoutHandler);
        node.removeClass(JUSTCHANGED_CLASSNAME);
      }, true);

      // Publish will trigger the update event, which will then update the UI
      live(uri).publish(data);

      // Inform Surround (for More-Like-This)
      surroundMessages.dispatchUriAdded(uri, data);
    },

    changeHandler: function (actions, key, value, uri) {
      if (key === IS_ADDED_PROPERTY) {
        const numAffectedButtons = actions.setStateForURI(uri, value);
        if (numAffectedButtons === 0) {
          live(uri).off('update', changeHandlers[uri]);
          delete changeHandlers[uri];
        }
      }
    }
  };

  const actions = {
    setStateForURI: function (uri, isAdded) {
      let numAffectedButtons = 0;

      const nodes = $(document).search(BUTTON_SELECTOR);
      if (!nodes) return numAffectedButtons;

      for (let i = 0, l = nodes.length; i < l; i++) {
        const node = $(nodes[i]);
        const buttonURI = getURIFromNode(node);
        if (uri === buttonURI) {
          numAffectedButtons++;
          actions.setStateForButtonNode(node, isAdded);
        }
      }

      return numAffectedButtons;
    },

    setStateForButtonNode: function (node, isAdded) {
      const stateNode = $(node[0].closest('[data-uri]'));
      if (!stateNode) return;

      const addedClass = getAddedClass(node);
      actions.setVisualState(isAdded, stateNode, node, addedClass);
    },

    setVisualState: function (isAdded, node, button, className) {
      if (isAdded) {
        if (!node.hasClass(className)) node.addClass(className);
        const tooltipRemove = button.data('tooltip-remove');
        if (tooltipRemove) {
          button.setAttribute('data-tooltip', tooltipRemove);
          button.setAttribute('aria-label', tooltipRemove);
        }
        button.setAttribute('data-log-click', 'remove-button');
        const interactionIntent = button.getAttribute(INTERACTION_TARGET_ATTR) === TOGGLE_FOLLOW_STATE_BUTTON ? INTERACTION_INTENT_UNFOLLOW : INTERACTION_INTENT_REMOVE;
        button.setAttribute(INTERACTION_INTENT_ATTR, interactionIntent);
      } else {
        if (node.hasClass(className)) node.removeClass(className);
        const tooltipAdd = button.data('tooltip-add');
        if (tooltipAdd) {
          button.setAttribute('data-tooltip', tooltipAdd);
          button.setAttribute('aria-label', tooltipAdd);
        }
        const interactionTarget = button.getAttribute(INTERACTION_TARGET_ATTR);
        switch (interactionTarget) {
          case SAVE_REMOVE_BUTTON:
            button.setAttribute(INTERACTION_INTENT_ATTR, INTERACTION_INTENT_SAVE);
            break;

          case TOGGLE_FOLLOW_STATE_BUTTON:
            button.setAttribute(INTERACTION_INTENT_ATTR, INTERACTION_INTENT_FOLLOW);
            break;

          default:
            button.setAttribute(INTERACTION_INTENT_ATTR, INTERACTION_INTENT_ADD);
            break;
        }
        button.setAttribute('data-log-click', 'add-button');
      }
    },

    addListenerForNode: function (node) {
      const uri = getURIFromNode(node);

      // If we have already added a change handler for this URI,
      // we don't want to add another one, so we cancel early.
      // Before cancelling though, we should update button states
      // with the current state from the live model, since there
      // might be new buttons in the DOM.
      if (changeHandlers[uri]) {
        live(uri).get('added', function (error, isAdded) {
          if (error) throw error;
          actions.setStateForButtonNode(node, isAdded);
        }, live.ASAP);
        return;
      }

      changeHandlers[uri] = function (properties) {
        for (const key in properties) {
          if (!properties.hasOwnProperty(key)) continue;
          const value = properties[key];
          eventHandlers.changeHandler(actions, key, value, uri);
        }
      };

      const model = live(uri);

      // Get the initial state and update the button
      model.get('added', function (error, isAdded) {
        if (error) throw error;
        actions.setStateForButtonNode(node, isAdded);

        // When the initial state is known, we listen for updates
        // so we can update all buttons for this URI later.
        model.on('update', changeHandlers[uri]);
      }, live.ASAP);
    }
  };

  const update = exports.update = function update(node, nodes) {
    if (!isAttached) return;

    // If the node passed in is a button node, just add listeners for that
    if (node && $(node).matches(BUTTON_SELECTOR)) {
      actions.addListenerForNode($(node));

      // Otherwise search all the children of the node (or the document
      // if node is not provided) for buttons.
    } else {
      const innerNodes = ($(nodes) || $(node) || $(document)).search(BUTTON_SELECTOR);
      if (!innerNodes) return;

      for (let i = 0, l = innerNodes.length; i < l; i++) {
        actions.addListenerForNode($(innerNodes[i]));
      }
    }
  };

  const handleScrollShow = function (data) {
    update(data.pageNode, data.nodes);
  };

  // Export for testing
  exports._classNames = {
    ADDED: ADDED_CLASSNAME,
    JUSTCHANGED: JUSTCHANGED_CLASSNAME
  };

  exports.attach = function attach() {
    if (isAttached) return;
    isAttached = true;

    $(document).delegate('click', BUTTON_SELECTOR, eventHandlers.click);

    center.on('scroll-show-before', handleScrollShow);
  };

  exports.detach = function detach() {
    if (!isAttached) return;
    isAttached = false;

    $(document).undelegate('click', BUTTON_SELECTOR, eventHandlers.click);
    center.off('scroll-show-before', handleScrollShow);
  };

  },{"../live":413,"../spotify-elements":460,"../surround-messages":565,"./center":471,"spotify-liburi":1282}],464:[function(require,module,exports){
  'use strict';

  const $ = require('../spotify-elements');
  const Navigator = require('../navigation/navigator');

  const SELECTOR = 'a';

  const nav = new Navigator();

  const handleAnchorClick = function (event, node) {
    const anchor = node[0];
    const href = anchor.getAttribute('href');
    if (!href || href[0] === '#') {
      return;
    }
    event.preventDefault();
    nav.openURI(href);
  };

  let isAttached = false;

  exports.attach = function attach() {
    if (isAttached) {
      return;
    }
    isAttached = true;
    $(document).delegate('click', SELECTOR, handleAnchorClick);
  };

  exports.detach = function detach() {
    if (!isAttached) {
      return;
    }
    isAttached = false;
    $(document).undelegate('click', SELECTOR, handleAnchorClick);
  };

  exports.update = function () {};

  },{"../navigation/navigator":441,"../spotify-elements":460}],465:[function(require,module,exports){
  'use strict';

  const modules = [require('./touch'), require('./pressed'), require('./loading'), require('./remove')];

  exports.attach = function () {
    modules.forEach(function (module) {
      module.attach();
    });
  };

  exports.detach = function () {
    modules.forEach(function (module) {
      module.detach();
    });
  };

  exports.update = function () {
    modules.forEach(function (module) {
      module.update();
    });
  };

  },{"./loading":466,"./pressed":467,"./remove":468,"./touch":469}],466:[function(require,module,exports){
  'use strict';

  const CARD = '.card';
  const IMAGE_LOADING_TRANSITION = 1000;

  let currentCards = [];

  function addCardImage(card) {
    let imageUri;
    const element = card.querySelector('[data-image-url]');
    if (element) {
      imageUri = element.getAttribute('data-image-url');
    }

    if (imageUri) {
      const onImageLoad = function (t) {
        return () => {
          card.classList.add('image-loaded');
          clearTimeout(t);
        };
      };

      const onImageError = function () {
        card.classList.add('image-error');
      };

      const timeout = setTimeout(function () {
        card.classList.add('image-delayed');
      }, IMAGE_LOADING_TRANSITION);

      const image = new Image();
      image.addEventListener('load', onImageLoad(timeout));
      image.addEventListener('error', onImageError);
      image.src = imageUri;
    }
  }

  let isAttached = false;

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    currentCards = [];
  };

  exports.update = function () {
    if (!isAttached) return;

    // Forget orphaned cards
    currentCards = currentCards.filter(function (card) {
      return card.closest('body');
    });

    const cards = document.querySelectorAll(CARD);
    cards.forEach(card => {
      const known = currentCards.indexOf(card) !== -1;
      if (known) {
        return;
      }
      currentCards.push(card);
      addCardImage(card);
    });
  };

  exports._reset = function () {
    currentCards = [];
  };

  },{}],467:[function(require,module,exports){
  'use strict';

  const $ = require('../../spotify-elements');
  const CARD = '[data-card-pressed-container]';
  const TRIGGER = '[data-card-trigger-pressed-state]';

  const doc = $(document);
  let pressedElement;

  function handleMouseDown(event, element) {
    // The card shouldn't animate when pressing buttons inside of it.
    if (event.target.nodeName.toLowerCase() === 'button') {
      return;
    }
    // The card shouldn't animate when right clicking it
    if (event.button === 2) {
      return;
    }
    element[0].closest(CARD).classList.add('pressed');
    pressedElement = element[0];
  }

  function handleMouseUp(event, element) {
    element[0].closest(CARD).classList.remove('pressed');

    if (pressedElement === element[0]) {
      pressedElement = null;
    }
  }

  function handleDragEnd(event, element) {
    element[0].closest(CARD).classList.remove('pressed');

    if (pressedElement === element[0]) {
      pressedElement = null;
    }
  }

  function handleDocumentMouseUp() {
    if (pressedElement) {
      pressedElement.closest(CARD).classList.remove('pressed');
      pressedElement = null;
    }
  }

  let isAttached = false;

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    doc.delegate('mousedown', TRIGGER, handleMouseDown);
    doc.delegate('mouseup', TRIGGER, handleMouseUp);
    doc.delegate('dragend', TRIGGER, handleDragEnd);
    doc.on('mouseup', handleDocumentMouseUp);
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    doc.undelegate('mousedown', TRIGGER, handleMouseDown);
    doc.undelegate('mouseup', TRIGGER, handleMouseUp);
    doc.undelegate('dragend', TRIGGER, handleDragEnd);
    doc.off('mouseup', handleDocumentMouseUp);
  };

  exports.update = function () {};

  },{"../../spotify-elements":460}],468:[function(require,module,exports){
  'use strict';

  var _localStorage = require("localStorage");

  // APPBOOK Remove button behaviours
  const center = require('../center');
  const BUTTON = '[data-card-remove-button]';

  function handleClick(event) {
    const element = event.target;
    if (!element.matches(BUTTON)) {
      return;
    }
    const id = element.getAttribute('bookmark-id');

    removeBookmarkItem(id);

    center.emit('bookmark-update');

    // Make sure CEF doesn't follow the link that the button is contained in.
    event.preventDefault();
    // Also make sure spotify-events/anchor doesn't act upon it and follows the link.
    event.stopPropagation();
  }

  function removeBookmarkItem(id) {
    _localStorage.useZlink(true)
    const raw = _localStorage.get("bookmark_spicetify");
    if (!raw) {
      return;
    }

    let list = JSON.parse(raw);
    list = list.filter((item) => item.id !== id);
    _localStorage.set("bookmark_spicetify", JSON.stringify(list));
    _localStorage.useZlink(false)
  }

  let isAttached = false;

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;
    // We need to get this before spotify-events/anchor.
    document.addEventListener('click', handleClick, true);
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;
    document.removeEventListener('click', handleClick, true);
  };

  exports.update = function () {};

  },{"../center":471, "localStorage":418}],469:[function(require,module,exports){
  'use strict';

  const $ = require('../../spotify-elements');
  const CARD = '.card';
  const IMAGE_HIT_AREA = '.card-image-hit-area';

  const doc = $(document);
  let hoverActive = false;

  let touchArray = [];
  const addEvent = function (touchEvent) {
    touchArray.push(touchEvent);
  };

  function getCards() {
    return doc.search(CARD);
  }

  function isCard(element) {
    return typeof element.closest === 'function' && !!element.closest(CARD);
  }

  function handleEvent(e) {
    const target = e.target;
    if (isCard(target)) {
      switch (e.type) {
        case 'touchstart':
          addEvent(e);
          if (hoverActive) {
            disableHover();
          }
          break;

        case 'touchmove':
          addEvent(e);
          break;

        case 'touchend':
          if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
            e.preventDefault();
            target.click();
          }
          touchArray = [];
          break;

        case 'contextmenu':
          addEvent(e);
          break;

        case 'mousemove':
          if (!hoverActive) {
            enableHover();
          }
          break;

        default:
          break;
      }
    }
  }

  function disableHover() {
    const cards = getCards();
    if (cards) {
      cards.forEach(function (card) {
        const hitArea = $(card).find(IMAGE_HIT_AREA);
        if (hitArea) {
          hitArea.addClass('no-hover');
        }
      });
      hoverActive = false;
    }
  }

  function enableHover() {
    const cards = getCards();
    if (cards) {
      cards.forEach(function (card) {
        const hitArea = $(card).find(IMAGE_HIT_AREA);
        if (hitArea) {
          hitArea.removeClass('no-hover');
        }
      });
      hoverActive = true;
    }
  }

  let isAttached = false;

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    doc.on('touchstart', handleEvent);
    doc.on('touchmove', handleEvent);
    doc.on('touchend', handleEvent);
    doc.on('mousemove', handleEvent);
    doc.on('contextmenu', handleEvent);
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    doc.off('touchstart', handleEvent);
    doc.off('touchmove', handleEvent);
    doc.off('touchend', handleEvent);
    doc.off('mousemove', handleEvent);
    doc.off('contextmenu', handleEvent);
  };

  exports.update = function () {};

  exports._reset = function () {
    hoverActive = true;
  };

  },{"../../spotify-elements":460}],471:[function(require,module,exports){
  /*
  Event Center
  */'use strict';

  const Emitter = require('../../libs/prime/emitter');

  module.exports = new Emitter();

  },{"../../libs/prime/emitter":451}],472:[function(require,module,exports){
    (function (global){
    'use strict';

    const $ = require('../spotify-elements');
    const live = require('../live');
    const selection = require('./selection');
    const wrappedUriUtils = require('../live-wrapped-uri');
    const cosmos = require('spotify-cosmos-api');
    const liburi = require('spotify-liburi');

    // getMetadataForUris can be set by the app.
    let getMetadataForUris;

    const CONTEXTMENU = ['a[data-uri]', '[data-contextmenu]'].join(',');

    const makeContextMenuData = function (selectionContexts, primaryIndex, uris, x, y) {
      const contexts = [];

      selectionContexts.forEach(selectionContext => {
        if (selectionContext !== undefined) {
          const keys = selectionContext.keys || [];
          const indices = selectionContext.indices || [];
          let newPrimaryIndex = primaryIndex || indices[0];
          newPrimaryIndex = newPrimaryIndex === undefined ? null : newPrimaryIndex;

          const contextUri = selectionContext.uri;

          const contextData = {
            uri: contextUri,
            keys: keys,
            indices: indices,
            primaryIndex: newPrimaryIndex
          };

          const origin = selectionContext.origin;
          if (origin) {
            if (newPrimaryIndex !== null) {
              const wrappedList = live(contextUri).get('rows');
              const originList = live(origin.uri).get('rows');
              if (wrappedList && originList) {
                const key = wrappedList.keys[newPrimaryIndex];
                origin.primaryIndex = originList.indexOf(key);
              }
            }
            contextData.origin = origin;
          }
          contexts.push(contextData);
        }
      });
      return {
        contexts: contexts,
        x: x,
        y: y,
        uris: uris
      };
    };

    const handleContextMenuActiveClass = function (node) {
      const subscribedParentNodes = node.parents('[data-contextmenu-spy]');
      const collection = $([node, subscribedParentNodes]);
      collection.addClass('contextmenu-active');

      // when a user right clicks while a context menu is already open,
      // there's a race condition because of the delay in the cosmos message.
      // the second right click both adds and then removes the active class
      // on the new target
      // right click -> post message -> addClass -> subscribe -> receive message -> removeClass
      // this can be avoided by pushing the subscription on the event loop
      // so that it happens after the message is received.
      // right click -> post message -> addClass -> receive message -> subscribe
      // doesn't work in the case of right click on the same target twice
      setTimeout(() => {
        const sub = cosmos.resolver.subscribe({
          url: 'sp://messages/v1/context_menu_state'
        }, function (error, response) {
          if (!error && response.getJSONBody().state === 'hide') {
            collection.removeClass('contextmenu-active');
            sub.cancel();
          }
        });
      }, 0);
    };

    const showContextMenu = function (data) {
      const appUri = global.__spotify.app_uri;
      const isCollectionApp = liburi.from(appUri).id === 'collection';
      data.appURI = appUri;

      // State is not set for neither zlink or buddy-list so we need to check
      // if it exists before getting URI
      data.entityURI = live('spotify:application').get('state') ? live('spotify:application').get('state').getURI() : null;

      // If getMetadataForUris is set by the app, call it with uris to get metadata.
      if (getMetadataForUris) {
        getMetadataForUris(data.uris, response => {
          data.metadata = response;
          const client = live('spotify:client');
          client.emit('show-context-menu', data);
        });
      } else {
        data.metadata = [];
        data.uris.forEach(uri => {
          // The "Save to Your Library"/"Remove from Your Library" menu item needs to
          // know the "added" state of the items to be able to show the correct string.
          // The collection app doesn't use live to handle the collection state, but it
          // can safely be assumed that what's in the collection app, is in collection.
          const added = isCollectionApp ? true : live(uri).get('added');
          if (added !== undefined) {
            data.metadata.push({
              uri: uri,
              added
            });
          }
        });

        const client = live('spotify:client');
        client.emit('show-context-menu', data);
      }
    };

    const handleContextMenuEvent = function (event, node) {
      event.preventDefault();
      event.stopPropagation();

      const x = event.clientX;
      const y = event.clientY;

      handleContextMenuActiveClass(node);

      if (node[0].tagName.toLowerCase() === 'a') {
        const uri = node.data('uri');
        if (uri) {
          showContextMenu({
            uris: [uri],
            x: x,
            y: y
          });
        }
      } else {
        const contextNode = node.parent('[data-list]');

        const index = +node.data('index');

        let isSelected = false;
        const indices = selection.getIndicesPerList();

        if (contextNode) {
          isSelected = selection.isNodeSelected(node);

          if (!isSelected) {
            selection.clear();
            const contextURI = contextNode.getAttribute('data-uri');
            if (contextURI) {
              selection.add(contextURI, index);
            }
          }
        }
        // The Play Queue is built around the notion that the currently playing
        // track has an index of -1 to make it kinda part of the backing live
        // and selection models, but not quite. Changing that notion seems to
        // require more fundamental changes, so I decided to add another workaround
        // here  ¯\_(ツ)_/¯
        //
        // See KM-13039 for more background.
        const canTrustSelecion = index !== -1;
        const uris = isSelected && canTrustSelecion ? selection.getUris() : [node.data('uri')];
        showContextMenu(makeContextMenuData(indices, index, uris, x, y));
      }
    };

    const handleContextMenuButton = function (event, node) {
      let parent;
      let uri = node.data('uri') || (parent = node.parent('[data-uri]')) && parent.data('uri');
      if (!uri) return;

      // The context menu can't know what to offer for a custom list.
      // In case of a sorted and/or filtered list, pass the origin list.
      uri = wrappedUriUtils.getOriginUri(uri) || uri;

      const contextURI = (parent = node.parent('[data-list][data-uri]')) && parent.data('uri');
      const contextIndex = (parent = node.parent('[data-index]')) && +parent.data('index');

      const contextMenuNode = $(node[0].closest('[data-button="contextmenu"]'));
      const relativeTo = contextMenuNode || parent || node;

      const rect = relativeTo[0].getBoundingClientRect();
      let x = rect.left + rect.width / 2;
      let y = rect.top + rect.height;

      // The coordinate must be within the app viewport
      if (y > window.innerHeight) y = window.innerHeight - 1;
      if (x > window.innerWidth) x = window.innerWidth - 1;

      const indices = contextIndex === null || contextIndex === undefined ? null : [contextIndex];

      let context;
      if (contextURI) {
        context = {
          uri: contextURI
        };

        if (indices) {
          context.indices = indices;

          const liveList = live(contextURI).get('rows');
          context.keys = liveList ? indices.map(function (selectedIndex) {
            return liveList.keys[selectedIndex];
          }) : [];
        }

        // Add originList
        const origin = wrappedUriUtils.getOriginUri(contextURI);
        if (origin) {
          context.origin = {
            uri: origin
          };

          if (indices) {
            const wrappedList = live(contextURI).get('rows');
            const originList = live(origin).get('rows');
            if (wrappedList && originList) {
              const originIndices = indices.map(function (index) {
                const key = wrappedList.keys[index];
                return originList.indexOf(key);
              });
              const originKeys = indices.map(function (index) {
                return wrappedList.keys[index];
              });
              context.origin.indices = originIndices;
              context.origin.keys = originKeys;
            }
          }
        }
      }
      showContextMenu(makeContextMenuData([context], contextIndex, [uri], x, y));
      handleContextMenuActiveClass(contextMenuNode);
    };

    let isAttached = false;

    exports.attach = function attach() {
      if (isAttached) return;
      isAttached = true;

      $(document).delegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
      $(document).delegate('click', '[data-button=contextmenu]', handleContextMenuButton);
    };

    exports.detach = function detach() {
      if (!isAttached) return;
      isAttached = false;

      $(document).undelegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
      $(document).undelegate('click', '[data-button=contextmenu]', handleContextMenuButton);
    };

    exports.update = function () {};
    exports.setMetadataRequestFunction = (func = null) => {
      getMetadataForUris = func;
    };

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"../live":413,"../live-wrapped-uri":412,"../spotify-elements":460,"./selection":528,"spotify-cosmos-api":1272,"spotify-liburi":1282}],473:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop/custom/queue
   * @private
   */
  'use strict';

  const hooks = require('../util/hooks');
  const QUEUE_URI = 'spotify:internal:queue:future';

  /**
   * Hook handler for validating a list target.
   *
   * @param {Object} result Result object. Setting the `valid` property will
   *     affect whether the drop is allowed.
   * @param {HTMLElement} list A DOM node marked up as a list.
   */
  function onListDropValidation(result, event, list, location, index) {
    const contextUri = list.getAttribute('data-uri');
    if (!contextUri || contextUri !== QUEUE_URI) return;

    // The "current" track in the queue is marked up as index -1. Disallow
    // dragging anything to that spot.
    if (index === -1) {
      result.valid = false;
      return;
    }
  }

  /**
   * Attach the module.
   */
  function attach() {
    hooks.add('list-drop-validation', onListDropValidation);
  }

  /**
   * Detach the module.
   */
  function detach() {
    hooks.remove('list-drop-validation', onListDropValidation);
  }

  exports.attach = attach;
  exports.detach = detach;

  },{"../util/hooks":482}],474:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop/custom/rootlist
   * @private
   */
  'use strict';

  const $ = require('../../../spotify-elements');

  const liburi = require('spotify-liburi');
  const live = require('../../../live');
  const intersection = require('mout/array/intersection');

  const hooks = require('../util/hooks');
  const eventModel = require('../util/eventmodel');
  const selection = require('../../selection');

  const SELECTOR_LIST = '[data-list]';
  const SELECTOR_LIST_ITEM = '[data-list-item]';
  const SELECTOR_DRAGGABLE = 'a, [draggable]';
  const ATTR_TARGET = 'data-drop-target';

  let dragFolderElement = null;

  /**
   * Handler for the dragstart event.
   */
  function onDragStart(event, node) {
    // Don't handle items that are specified with the new implementation.
    if (node.closest('[data-glue-draggable]')) {
      return;
    }

    dragFolderElement = null;

    const uris = selection.getUris();
    if (uris.length > 1) return;

    const uri = uris[0];
    const uriObject = uri && liburi.fromString(uri);
    if (!uriObject) return;

    // If dragging a folder, we need to temporarily save the folder DOM node,
    // so that while dragging over items we can check whether to show the drop
    // indicator. Dropping a folder inside itself should not be allowed.
    if (uriObject.type === liburi.Type.FOLDER) {
      const selectedNodes = selection.getNodes();
      for (let i = 0, l = selectedNodes.length; i < l; i++) {
        const selectedNode = selectedNodes[i];
        if (selectedNode.getAttribute('data-uri') === uri) {
          dragFolderElement = selectedNode;
          break;
        }
      }
    }
  }

  /**
   * Handler for ending a drag.
   */
  function onDragEnd() {
    dragFolderElement = null;
  }

  /**
   * Hook handler for setting drag data.
   *
   * @param {MouseEvent} event Event object for a dragstart event.
   * @param {Array.<string>} uris Array of URIs being dragged.
   * @param {string=} optContext Optional context URI.
   */
  function onSetDragData(event, uris, optContext) {
    if (optContext !== 'spotify:rootlist') {
      let followedPlaylistCount = 0;
      for (let i = 0, l = uris.length; i < l; i++) {
        if (liburi.isPlaylistV1OrV2(uris[i])) {
          const isFollowing = live(uris[i]).get('added');
          if (isFollowing) followedPlaylistCount++;
        } else {
          // If the item is not a playlist, it means we are dragging either only
          // items of another type, or playlists as well as other types.
          break;
        }
      }

      // Dropping only playlists that you are following in the rootlist should
      // not be allowed. If multiple playlists are dragged and some of them are
      // not being followed, dropping is allowed (and the receiver should handle
      // only inserting the new ones). To allow telling these cases apart while
      // not having access to drag data, we set a special MIME type that can be
      // checked later.
      if (followedPlaylistCount === uris.length) {
        event.dataTransfer.setData('text/x-spotify-only-followed-playlists', '');
      }
    }
  }

  /**
   * Hook handler for validating a list drop.
   *
   * @param {Object} result Result object. Setting the `valid` property will
   *     affect whether the drop is allowed.
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} list A DOM node marked up as a list.
   * @param {string} location The location of the cursor in relation to the list.
   *     This can be either 'inside' or 'below'. The value 'below' means that the
   *     cursor was below the last list found in the DOM.
   */
  function onListDropValidation(result, event, list, location) {
    const contextUri = list.getAttribute('data-uri');
    if (contextUri === 'spotify:rootlist') {
      // Dropping only already followed playlists into the rootlist should not
      // be allowed, since you can only have playlists once in the rootlist.
      if (hasOnlyFollowedPlaylists(event)) {
        result.valid = false;
        return;
      }

      // Dropping a folder inside or right below itself should not be allowed
      if (isInsideDraggedFolder(event, location)) {
        result.valid = false;
        return;
      }

      // Dropping on the bottom half of a folder should not be allowed as a list
      // target, but will be a regular target for the folder instead. However, if
      // the dragged items match the list target, dropping should be handled by
      // list code instead of target code (dragover should still not validate as
      // we want the active drop target style and not the list indicator).
      if (isInFolderBottomHalf(event)) {
        if (event.type !== 'drop' || !isMatchingTarget(event, list)) {
          result.valid = false;
          return;
        }
      }
    }
  }

  /**
   * Hook handler for validating a target.
   *
   * @param {Object} result Result object. Setting the `valid` property will
   *     affect whether the drop is allowed.
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} target DOM node for target that matches MIME types.
   */
  function onTargetValidation(result, event, target) {
    const list = target.closest(SELECTOR_LIST);
    if (list) {
      const contextUri = list.getAttribute('data-uri');
      if (contextUri === 'spotify:rootlist') {
        // Dropping only already followed playlists into the rootlist should not
        // be allowed, since you can only have playlists once in the rootlist.
        if (hasOnlyFollowedPlaylists(event)) {
          result.valid = false;
          return;
        }

        // Dropping valid rootlist items on the top half of a folder should not
        // be allowed as a regular target, but will be a list drop target instead.
        // For leave events, we need to validate the whole row as valid, so that
        // the target styling is removed correctly.
        if (event.type !== 'dragleave' && isMatchingTarget(event, list)) {
          const folderNode = getFolderNode(event);
          if (folderNode) {
            if (isBelowMiddleOfNode(event.clientY, folderNode)) {
              result.valid = true;
            } else {
              result.valid = false;
            }
            return;
          }
        }
      }
    }
  }

  /**
   * Hook handler for getting the indices being moved.
   *
   * @param {string} contextUri The context URI.
   * @param {LiveList} liveList Live list to be changed.
   * @param {Array.<number>} indices Array of indices in the list.
   */
  function onGetMoveIndices(contextUri, liveList, indices) {
    if (contextUri === 'spotify:rootlist') {
      const firstIndex = indices[0];
      const firstRow = liveList.get(firstIndex);
      const firstItem = firstRow && firstRow.get('playlist');
      const firstUri = firstItem && firstItem.uri;
      const firstUriType = firstUri && liburi.fromString(firstUri).type;
      const isFolder = firstUriType === liburi.Type.FOLDER;

      if (isFolder) {
        // Add all indices for the folder contents and the end marker
        if (indices.length === 1) {
          const length = getFolderLength(liveList, firstUri, firstIndex);
          for (let i = 1; i <= length; i++) {
            indices.push(firstIndex + i);
          }
        }

        // Abort the move operation if it only contains moving a folder start
        // marker, since moving folders should always move the entire folder.
        // Aborting by returning zero indices.
        if (indices.length === 1) {
          indices.length = 0;
          return;
        }

        const lastRow = liveList.get(indices[indices.length - 1]);
        const lastItem = lastRow && lastRow.get('playlist');
        const lastUri = lastItem && lastItem.uri;

        // Abort the move operation if moving a folder and the last item to move
        // is not the end marker for the folder. Aborting by returning zero
        // indices.
        if (lastUri !== `${firstUri}:end`) {
          indices.length = 0;
          return;
        }
      }
    }
  }

  /**
   * Check if only dragging playlists that are being followed already.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {boolean} True if only followed playlists are being dragged.
   */
  function hasOnlyFollowedPlaylists(event) {
    const types = event.dataTransfer.types;
    if (types.indexOf('text/x-spotify-only-followed-playlists') > -1) {
      return true;
    }

    return false;
  }

  /**
   * Check if dragging a folder into (or below) itself.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {string} location The location of the cursor in relation to the list.
   *     This can be either 'inside' or 'below'. The value 'below' means that the
   *     cursor was below the last list found in the DOM.
   *
   * @return {boolean} True if dragging into the same folder being dragged.
   */
  function isInsideDraggedFolder(event, location) {
    if (dragFolderElement) {
      const rowNode = location === 'below' ? getLastRowNode() : getRowNode(event);
      if (rowNode) {
        let targetIndex = +rowNode.getAttribute('data-index');
        if (location === 'inside') {
          if (!isBelowMiddleOfNode(event.clientY, rowNode)) {
            targetIndex--;
          }
        }
        if (isIndexInsideDraggedFolder(targetIndex)) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Check if dragging onto the bottom half of a folder.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {boolean} True if dragging onto the bottom half.
   */
  function isInFolderBottomHalf(event) {
    const folderNode = getFolderNode(event);
    if (folderNode) {
      return isBelowMiddleOfNode(event.clientY, folderNode);
    }
    return false;
  }

  /**
   * Check if the position is below the middle of the node.
   *
   * @param {number} y The Y position relative to the viewport.
   * @param {HTMLElement} node DOM node to check against.
   *
   * @return {boolean} True if the position is below.
   */
  function isBelowMiddleOfNode(y, node) {
    const rect = node.getBoundingClientRect();
    return y >= rect.top + rect.height / 2;
  }

  /**
   * Check if the index is inside (or right below) the folder being dragged.
   *
   * @param {number} index Current target index.
   *
   * @return {boolean} True if the target index is inside the folder.
   */
  function isIndexInsideDraggedFolder(index) {
    if (!dragFolderElement) return false;

    const liveList = live('spotify:rootlist').get('rows');
    if (!liveList) return false;

    const folderUri = dragFolderElement.getAttribute('data-uri');
    if (!folderUri) return false;

    const start = +dragFolderElement.getAttribute('data-index');
    const end = start + getFolderLength(liveList, folderUri, start);

    if (start > -1 && end > start && index >= start && index <= end) {
      return true;
    }

    return false;
  }

  /**
   * Check if the MIME types in the drag event matches the MIME types for the
   * specified drop target.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} node A DOM node.
   *
   * @return {boolean} True if the element matches the event.
   */
  function isMatchingTarget(event, node) {
    const eventTypes = event.dataTransfer.types;
    const nodeTypes = node.getAttribute(ATTR_TARGET);

    if (nodeTypes) {
      const matching = intersection(nodeTypes.split('|'), eventTypes);
      if (matching.length > 0) return true;
    }

    return false;
  }

  /**
   * Get the folder row node from the event.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {HTMLElement?} DOM node for the folder, or null if not found.
   */
  function getFolderNode(event) {
    const rowNode = getRowNode(event);
    if (rowNode) {
      const uri = rowNode.getAttribute('data-uri');
      const uriObject = liburi.from(uri);
      if (uriObject && uriObject.type === liburi.Type.FOLDER) {
        return rowNode;
      }
    }

    return null;
  }

  /**
   * Get the list row element from the event target.
   * If the event target itself isn't a list row, it will step out in the parent
   * tree until it finds a row.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {HTMLElement?} The list row element, or null if not found.
   */
  function getRowNode(event) {
    return event.target.closest(SELECTOR_LIST_ITEM);
  }

  /**
   * Get the last list row from the last list in the DOM.
   *
   * @return {HTMLElement?} The list row element, or null if not found.
   */
  function getLastRowNode() {
    const lists = $(SELECTOR_LIST);
    const lastList = lists && lists[lists.length - 1];
    if (lastList) {
      const listItems = $(lastList).search(SELECTOR_LIST_ITEM);
      const lastItem = listItems && listItems[listItems.length - 1];
      if (lastItem) return lastItem;
    }

    return null;
  }

  /**
   * Get the length of a folder, including the contents and end marker, but not
   * the start marker.
   *
   * @param {LiveList} liveList Live list for the rootlist.
   * @param {string} folderUri The folder URI.
   * @param {number} index The index where the folder start marker is.
   *
   * @return {number} The length of the folder.
   */
  function getFolderLength(liveList, folderUri, index) {
    let rowAtIndex = liveList.get(index);
    let itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
    let uriAtIndex = itemAtIndex && itemAtIndex.uri;
    if (uriAtIndex !== folderUri) return 0;

    const folderEndUri = `${folderUri}:end`;
    let amount = 0;

    for (let i = index + 1, l = liveList.length; i < l; i++) {
      amount++;

      rowAtIndex = liveList.get(i);
      itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
      uriAtIndex = itemAtIndex && itemAtIndex.uri;
      if (uriAtIndex === folderEndUri) break;
    }

    return amount;
  }

  /**
   * Attach the module.
   */
  function attach() {
    eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.delegate('dragend', 'body', onDragEnd);

    hooks.add('set-drag-data', onSetDragData);
    hooks.add('list-drop-validation', onListDropValidation);
    hooks.add('target-validation', onTargetValidation);
    hooks.add('get-move-indices', onGetMoveIndices);
  }

  /**
   * Detach the module.
   */
  function detach() {
    eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.undelegate('dragend', 'body', onDragEnd);

    hooks.remove('set-drag-data', onSetDragData);
    hooks.remove('list-drop-validation', onListDropValidation);
    hooks.remove('target-validation', onTargetValidation);
    hooks.remove('get-move-indices', onGetMoveIndices);
  }

  exports.attach = attach;
  exports.detach = detach;

  },{"../../../live":413,"../../../spotify-elements":460,"../../selection":528,"../util/eventmodel":481,"../util/hooks":482,"mout/array/intersection":783,"spotify-liburi":1282}],475:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop/custom/sortlist
   * @private
   */
  'use strict';

  const liburi = require('spotify-liburi');
  const sortUriUtils = require('../../../live-sort-uri');

  const hooks = require('../util/hooks');
  const eventModel = require('../util/eventmodel');
  const selection = require('../../selection');

  const SELECTOR_DRAGGABLE = 'a, [draggable]';

  let dragSelectionState = null;

  /**
   * Handler for the dragstart event.
   */
  function onDragStart(event, node) {
    // Don't handle items that are specified with the new implementation.
    if (node.closest('[data-glue-draggable]')) {
      return;
    }

    dragSelectionState = selection.getIndicesPerList();
  }

  /**
   * Handler for ending a drag.
   */
  function onDragEnd() {
    dragSelectionState = null;
  }

  /**
   * Hook handler for validating a list drop.
   *
   * @param {Object} result Result object. Setting the `valid` property will
   *     affect whether the drop is allowed.
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} list A DOM node marked up as a list.
   */
  function onListDropValidation(result, event, list) {
    const contextUri = list.getAttribute('data-uri');
    if (!contextUri) return;

    // Dropping in sorted lists should not allow specific drop positions,
    if (sortUriUtils.isValid(contextUri) && event.type !== 'drop') {
      result.valid = false;
    }
  }

  /**
   * Hook handler for validating a list target.
   *
   * @param {Object} result Result object. Setting the `valid` property will
   *     affect whether the drop is allowed.
   * @param {HTMLElement} list A DOM node marked up as a list.
   */
  function onListTargetValidation(result, list) {
    const contextUri = list.getAttribute('data-uri');
    if (!contextUri) return;

    // Bail on all invalid uris
    if (!sortUriUtils.isValid(contextUri)) return;

    // We should support incoming drag and drops as well, like from the
    // now playing view for example
    if (!dragSelectionState) {
      result.valid = true;
      return;
    }

    // Dropping in sorted lists should be allowed as a regular target
    if (dragSelectionState.length === 1) {
      if (dragSelectionState[0].uri !== contextUri) {
        result.valid = true;
      }
    }
  }

  /**
   * Hook handler for checking if a list is a track list.
   *
   * @param {Object} result Result object. Setting the `valid` property will
   *     affect the result.
   * @param {LiveList} liveList The live list.
   * @param {string} contextUri The context URI.
   */
  function onIsListOfTracks(result, liveList, contextUri) {
    if (sortUriUtils.isValid(contextUri)) {
      const originUri = sortUriUtils.getOriginUri(contextUri);
      if (liburi.isPlaylistV1OrV2(originUri)) {
        result.valid = true;
      }
    }
  }

  /**
   * Attach the module.
   */
  function attach() {
    eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.delegate('dragend', 'body', onDragEnd);

    hooks.add('list-drop-validation', onListDropValidation);
    hooks.add('list-target-validation', onListTargetValidation);
    hooks.add('is-list-of-tracks', onIsListOfTracks);
  }

  /**
   * Detach the module.
   */
  function detach() {
    eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.undelegate('dragend', 'body', onDragEnd);

    hooks.remove('list-drop-validation', onListDropValidation);
    hooks.remove('list-target-validation', onListTargetValidation);
    hooks.remove('is-list-of-tracks', onIsListOfTracks);
  }

  exports.attach = attach;
  exports.detach = detach;

  },{"../../../live-sort-uri":411,"../../selection":528,"../util/eventmodel":481,"../util/hooks":482,"spotify-liburi":1282}],476:[function(require,module,exports){
  (function (global){
  /**
   * @module spotify-events/dragndrop/dragdata
   * @private
   */
  'use strict';

  const liburi = require('spotify-liburi');

  const selection = require('../selection');
  const hooks = require('./util/hooks');
  const eventModel = require('./util/eventmodel');
  const itemText = require('./util/itemtext');
  const getLogContext = require('../util/get-log-context');

  const SELECTOR_DRAGGABLE = 'a, [draggable]';

  /**
   * Handler for the dragstart event.
   *
   * @param {MouseEvent} event Event object for a dragstart event.
   * @param {HTMLElement} target The target element.
   */
  function onDragStart(event, target) {
    // Don't handle items that are specified with the new implementation.
    if (target.closest('[data-glue-draggable]')) {
      return;
    }

    const isSelected = selection.isNodeSelected(target);

    if (isSelected) {
      const uris = selection.getUris();
      if (uris.length > 0) {
        const state = selection.getIndicesPerList();
        const singleContext = state.length === 1;
        const context = singleContext ? state[0] && state[0].uri : null;
        if (context) {
          setEventData(event, uris, null, context, getLogContext(target));
        } else {
          setEventData(event, uris, null, null, getLogContext(target));
        }
      }
    } else {
      let uri = target.getAttribute('data-uri');
      if (!uri) {
        const uriObject = liburi.from(target.getAttribute('href'));
        uri = uriObject ? uriObject.toURI() : '';
      }
      const dragText = itemText.getForElement(target);

      if (uri) {
        setEventData(event, [uri], [dragText], null, getLogContext(target));
      }
    }
  }

  /**
   * Set drag data on the event.
   * This includes regular MIME types such as plain text and html, but also custom
   * Spotify MIME types that can be used to detect the dragged content while
   * dragging (you can't access data while dragging, so there is no other way
   * to detect what kind of items are being dragged).
   *
   * @param {MouseEvent} event Event object for a dragstart event.
   * @param {Array.<string>} uris Array of Spotify URIs.
   * @param {Array.<string>=} optDragTexts Optional drag texts for each URI.
   * @param {string=} optContext Optional context URI.
   * @param {string=} optLogContext Optional log context.
   */
  function setEventData(event, uris, optDragTexts, optContext, optLogContext) {
    const urlsPerMimeType = getUrlsPerMimeType(uris);
    const urls = getUrlsForUris(uris);
    const urlList = urls.join('\n');
    const html = getLinkHTML(uris, urls, optDragTexts);

    // We set this before others because safari overrides any data that was set
    // before this particular mimetype was set.
    event.dataTransfer.setData('text/uri-list', urlList);

    for (const type in urlsPerMimeType) {
      if (!urlsPerMimeType.hasOwnProperty(type)) continue;
      const urlsForType = urlsPerMimeType[type];
      event.dataTransfer.setData(type, urlsForType.join('\n'));
    }

    event.dataTransfer.setData('text/plain', urlList);
    event.dataTransfer.setData('text/html', html);

    if (optContext) {
      // Provide the context as drag data. This can be used in the drop event to
      // know where it came from.
      event.dataTransfer.setData('text/x-spotify-data-context', optContext);
      event.dataTransfer.setData(`text/x-spotify-data-context-${optContext}`, '');
    }

    if (optLogContext) {
      event.dataTransfer.setData('text/x-spotify-data-log-context', optLogContext);
    }

    event.dataTransfer.setData('text/x-spotify-data-app-uri', global.__spotify && global.__spotify.app_uri || null);

    hooks.run('set-drag-data', event, uris, optContext);
  }

  /**
   * Get URLs for the URIs organized by MIME type.
   *
   * @param  {Array.<string>} uris Array of Spotify URIs.
   *
   * @return {Object.<string, Array.<string>>} Object of arrays of URLs.
   */
  function getUrlsPerMimeType(uris) {
    const urlsPerMimeType = {};
    for (let i = 0, l = uris.length; i < l; i++) {
      const uri = uris[i];
      const type = getMimeType(uri);
      const urlsForType = urlsPerMimeType[type] || (urlsPerMimeType[type] = []);
      urlsForType.push(getShareLink(uri));
    }
    return urlsPerMimeType;
  }

  /**
   * Get URLs for the URIs.
   *
   * @param {Array.<string>} uris Array of Spotify URIs.
   *
   * @return {Array.<string>} Array of share URLs.
   */
  function getUrlsForUris(uris) {
    const urls = new Array(uris.length);
    for (let i = 0, l = uris.length; i < l; i++) {
      urls[i] = getShareLink(uris[i]);
    }
    return urls;
  }

  /**
   * Get a share URL from a Spotify URI.
   *
   * @param {string} uri A Spotify URI.
   *
   * @return {string} The share URL.
   */
  function getShareLink(uri) {
    const uriObject = liburi.from(uri);
    return uriObject ? uriObject.toOpenURL() : uri;
  }

  /**
   * Get the custom Spotify MIME type for a URI.
   *
   * @param {string} uri A Spotify URI.
   *
   * @return {string} The MIME type.
   */
  function getMimeType(uri) {
    const type = 'text/x-spotify-';

    const uriObject = liburi.from(uri);
    if (uriObject) {
      const uriType = uriObject.type;

      if (uriType === liburi.Type.TRACK || uriType === liburi.Type.LOCAL) {
        return `${type}tracks`;
      }
      if (uriType === liburi.Type.ALBUM || uriType === liburi.Type.LOCAL_ALBUM) {
        return `${type}albums`;
      }
      if (uriType === liburi.Type.ARTIST || uriType === liburi.Type.LOCAL_ARTIST) {
        return `${type}artists`;
      }
      if (uriType === liburi.Type.USER || uriType === liburi.Type.PROFILE) {
        return `${type}users`;
      }
      if (uriType === liburi.Type.PLAYLIST || uriType === liburi.Type.PLAYLIST_V2) {
        return `${type}playlists`;
      }
      if (uriType === liburi.Type.FOLDER) {
        return `${type}folders`;
      }
      if (uriType === liburi.Type.STATION && !(uriObject.args.length > 2 && uriObject.args[2] === 'cluster')) {
        return `${type}stations`;
      }
      if (uriType === liburi.Type.EPISODE) {
        return `${type}episodes`;
      }
    }

    return `${type}unknown`;
  }

  /**
   * Get the HTML for links to the given URLs.
   *
   * @param {Array.<string>} uris Array of Spotify URIs.
   * @param {Array.<string>} urls Array of Spotify URLs used for sharing.
   * @param {Array.<string>=} optDragTexts Optional drag texts for each URI.
   *
   * @return {string} String of HTML.
   */
  function getLinkHTML(uris, urls, optDragTexts) {
    let html = '';

    for (let i = 0, l = uris.length; i < l; i++) {
      const textFromArgs = optDragTexts && optDragTexts[i];
      const text = textFromArgs || itemText.getForUri(uris[i]);

      html += `<a href="${urls[i]}">${text}</a>`;

      if (i < uris.length - 1) {
        html += '<br>';
      }
    }

    return html;
  }

  /**
   * Attach the module.
   */
  function attach() {
    eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  }

  /**
   * Detach the module.
   */
  function detach() {
    eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  }

  exports.attach = attach;
  exports.detach = detach;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../selection":528,"../util/get-log-context":542,"./util/eventmodel":481,"./util/hooks":482,"./util/itemtext":483,"spotify-liburi":1282}],477:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop/dragimage
   * @private
   */
  'use strict';

  const liburi = require('spotify-liburi');
  const defer = require('../../../libs/prime/defer');

  const selection = require('../selection');
  const eventModel = require('./util/eventmodel');
  const itemText = require('./util/itemtext');

  const i18n = require('../i18n/index');

  const SELECTOR_DRAGGABLE = 'a, [draggable]';
  const DRAGIMAGE_POS_X = -10;
  const DRAGIMAGE_POS_Y = -5;

  let dragImageElement = null;
  let dragImageShelter = null;

  /**
   * Handler for the dragstart event.
   *
   * @param {MouseEvent} event Event object for a dragstart event.
   * @param {HTMLElement} target The target element.
   */
  function onDragStart(event, target) {
    // Don't handle items that are specified with the new implementation.
    if (target.closest('[data-glue-draggable]')) {
      return;
    }

    const isSelected = selection.isNodeSelected(target);

    let text = '';

    if (isSelected) {
      const uris = selection.getUris();
      if (uris.length === 1) {
        text = itemText.getForUri(uris[0]);
      } else {
        text = getLocalizedTypeFromUris(uris);
      }
    } else {
      text = itemText.getForElement(target);
    }

    const dragImage = getDragImage(text);

    event.dataTransfer.setDragImage(dragImage, DRAGIMAGE_POS_X, DRAGIMAGE_POS_Y);

    removeDragImage();
  }

  /**
   * Get the drag image element with the specified text set.
   *
   * @param {string} text The text to set.
   *
   * @return {HTMLElement} The drag image element.
   */
  function getDragImage(text) {
    if (!dragImageElement) {
      dragImageElement = document.createElement('div');
      dragImageElement.className = 'dnd-image';
    }
    if (!dragImageShelter) {
      dragImageShelter = document.createElement('div');
      dragImageShelter.className = 'dnd-image-shelter';
    }

    dragImageElement.textContent = text;

    document.body.appendChild(dragImageElement);
    document.body.appendChild(dragImageShelter);

    return dragImageElement;
  }

  /**
   * Remove the drag image element and the shelter it hides behind.
   * This must be delayed a tick to let the native drag and drop handling
   * get the time to read the image.
   */
  function removeDragImage() {
    defer.immediate(function () {
      if (dragImageElement && dragImageElement.parentNode) {
        dragImageElement.parentNode.removeChild(dragImageElement);
      }
      if (dragImageShelter && dragImageShelter.parentNode) {
        dragImageShelter.parentNode.removeChild(dragImageShelter);
      }
    });
  }

  /**
   * Get a localized type for a list of URIs.
   * This could be for example 'tracks', 'playlists' etc. Falls back to 'items'
   * if the URIs are of different type. As this is only called when we drag
   * multiple items, we don't need the singular form.
   *
   * @param {Array.<string>} uris Array of URIs.
   *
   * @return {string} The localized type.
   */
  function getLocalizedTypeFromUris(uris) {
    let type = 'item';

    const uriObjectForFirst = liburi.from(uris[0]);
    const typeForFirst = uriObjectForFirst && uriObjectForFirst.type;

    if (typeForFirst) {
      type = typeForFirst;

      for (let i = 0, l = uris.length; i < l; i++) {
        const uriObject = liburi.from(uris[i]);
        if (!uriObject || uriObject.type !== typeForFirst) {
          type = 'item';
          break;
        }
      }
    }

    // User URIs are parsed with type 'profile' in liburi, but we want 'user'
    if (type === 'profile') {
      type = 'user';
    }

    const pluralType = `${type}s`;

    // Get the localized version of the plural type
    let localized = i18n.get(`drag_tooltip_many_${pluralType}`, uris.length);

    // If the type was not the generic 'items' type and no localization was found,
    // localize the generic type.
    if (localized === `drag_tooltip_many_${pluralType}` && pluralType !== 'items') {
      localized = i18n.get('drag_tooltip_many_items', uris.length);
    }

    // Return the localized type, or if nothing is found, fall back to the type
    return localized || pluralType;
  }

  /**
   * Attach the module.
   */
  function attach() {
    eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  }

  /**
   * Detach the module.
   */
  function detach() {
    eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  }

  exports.attach = attach;
  exports.detach = detach;

  },{"../../../libs/prime/defer":450,"../i18n/index":487,"../selection":528,"./util/eventmodel":481,"./util/itemtext":483,"spotify-liburi":1282}],478:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop
   */
  'use strict';

  const dragDataModule = require('./dragdata');
  const dragImageModule = require('./dragimage');
  const targetModule = require('./target');
  const listModule = require('./list');

  // Custom behaviors
  const sortlistModule = require('./custom/sortlist');
  const rootlistModule = require('./custom/rootlist');
  const queueModule = require('./custom/queue');

  /**
   * Attach the module.
   */
  function attach() {
    dragDataModule.attach();
    dragImageModule.attach();
    targetModule.attach();
    listModule.attach();
    queueModule.attach();

    sortlistModule.attach();
    rootlistModule.attach();
  }

  /**
   * Detach the module.
   */
  function detach() {
    dragDataModule.detach();
    dragImageModule.detach();
    targetModule.detach();
    listModule.detach();
    queueModule.detach();

    sortlistModule.detach();
    rootlistModule.detach();
  }

  exports.attach = attach;
  exports.detach = detach;
  exports.update = function () {};

  },{"./custom/queue":473,"./custom/rootlist":474,"./custom/sortlist":475,"./dragdata":476,"./dragimage":477,"./list":479,"./target":480}],479:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop/list
   * @private
   */
  'use strict';

  const $ = require('../../spotify-elements');
  const intersection = require('mout/array/intersection');
  const Range = require('../../range2');
  const live = require('../../live');
  const liburi = require('spotify-liburi');
  const listOperations = require('../../../libs/live-list-operations');

  const hooks = require('./util/hooks');
  const eventModel = require('./util/eventmodel');
  const selection = require('../selection');

  const SELECTOR_DROP_TARGET = '[data-drop-target]';
  const SELECTOR_LIST = '[data-list]';
  const SELECTOR_LIST_ITEM = '[data-list-item]';
  const SELECTOR_LIST_TARGET = `${SELECTOR_DROP_TARGET}, body`;
  const SELECTOR_DRAGGABLE = 'a, [draggable]';
  const ATTR_TARGET = 'data-drop-target';

  let dropIndicator = null;
  let draggedLinkContext = null;
  const disabledLists = {};

  /**
   * Simple wrapper to cache calls to selection.getIndicesPerList()
   *
   * @return {Object} The result of selection.getIndicesPerList()
   */
  const cachedSelectionState = function () {
    let cache = {
      lastTime: 0,
      lastValue: null
    };
    const CACHE_TIMEOUT = 500;

    return {
      get: function () {
        const now = Date.now();

        if (now - cache.lastTime > CACHE_TIMEOUT) {
          cache = {
            lastValue: selection.getIndicesPerList(),
            lastTime: now
          };
        }

        return cache.lastValue;
      },
      clear: function () {
        cache.lastTime = 0;
      }
    };
  }();

  /**
   * Handler for the dragstart event.
   *
   * @param {MouseEvent} event Event object for a dragstart event.
   * @param {HTMLElement} target The target element.
   */
  function onDragStart(event, target) {
    // Don't handle items that are specified with the new implementation.
    if (target.closest('[data-glue-draggable]')) {
      return;
    }

    draggedLinkContext = null;

    // clear the selectionState cache
    cachedSelectionState.clear();

    const matchingTarget = getMatchingTarget(event);
    if (matchingTarget) {
      const isInList = $(matchingTarget).matches(SELECTOR_LIST);
      if (isInList) {
        const uri = matchingTarget.getAttribute('data-uri');

        // Dragging a link from inside a list needs to store the list context,
        // since it is not allowed to drop a dragged link inside the same list.
        if (target.tagName.toLowerCase() === 'a') {
          draggedLinkContext = uri;
        }

        // Dragging is disallowed for lists where we're waiting for a list move
        // to finish. This is to prevent multiple moves to be called before the
        // response from the first comes back.
        if (disabledLists[uri]) {
          event.preventDefault();
          return;
        }

        const rowNode = getRowNode(event);
        if (rowNode) {
          const index = getTargetIndex(event.clientY, rowNode);
          if (index !== -1) {
            event.dataTransfer.setData('text/x-spotify-data-log-source-index', index);
          }
        }
      }
    }
  }

  /**
   * Handler for dragging over a drop target.
   *
   * @param {MouseEvent} event A dragover event object.
   * @param {HTMLElement} target DOM element for the drop target. This can be the
   *     body element even if it's not a drop target.
   */
  function onDragOver(event, target) {
    let positionedListDrop = false;
    let rowNode = null;

    const isBody = target === document.body;
    let list = null;
    if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

    // If we found a list from the event, we must validate if it's allowed to drop
    // in the list.
    if (list) {
      const location = isBody ? 'below' : 'inside';

      let index = -1;
      rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        index = getTargetIndex(event.clientY, rowNode);
      }

      const contextUri = list.getAttribute('data-uri');

      if (validateListDrop(event, list, contextUri, location, index)) {
        if (isBody) {
          positionedListDrop = true;
        } else {
          if (rowNode) {
            positionedListDrop = true;
          }
        }
      }
    }

    if (positionedListDrop) {
      event.preventDefault();

      if (isBody) showDropIndicatorBelowList(list);else if (rowNode) showDropIndicatorForRow(rowNode, event.clientY);
    } else {
      hideDropIndicator();

      const listHookResult = { valid: false };
      if (list) {
        hooks.run('list-target-validation', listHookResult, list);
      }

      // The list might be accepted as a drop target even if dropping in a
      // specific position was not accepted. In that case we need to prevent the
      // default action to tell the browser that we accept drops here.
      if (listHookResult.valid) {
        event.preventDefault();
      } else if (!isBody && list) {
        const targetHookResult = { valid: false };
        hooks.run('target-validation', targetHookResult, event, target);

        // If we know that dropping is not allowed here at all, we need to remove
        // the drop effect from the cursor. This is mainly since the handler in
        // targets.js has already handled the event and accepted it, which sets
        // the drop effect.
        if (!targetHookResult.valid) {
          event.dataTransfer.dropEffect = 'none';
        }
      }
    }
  }

  /**
   * Handler for dragging out from a drop target.
   */
  function onDragLeave() {
    hideDropIndicator();
  }

  /**
   * Handler for ending a drag.
   */
  function onDragEnd() {
    hideDropIndicator();
    draggedLinkContext = null;
  }

  /**
   * Handler for dropping onto a drop target.
   *
   * @param {MouseEvent} event A drop event object.
   * @param {HTMLElement} target DOM element for the drop target.
   */
  function onDrop(event, target) {
    hideDropIndicator();

    const isBody = target === document.body;
    let list = null;
    if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

    if (list) {
      const location = isBody ? 'below' : 'inside';

      let index = -1;
      const rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        index = getTargetIndex(event.clientY, rowNode);
      }

      const contextUri = list.getAttribute('data-uri');

      if (validateListDrop(event, list, contextUri, location, index)) {
        if (contextUri) {
          performListChangesForEvent(event, list, contextUri, location);
          event.handled = true;
        }
      }
    }
  }

  /**
   * Show the drop indicator below the provided list element.
   *
   * @param {HTMLElement} list A list element.
   */
  function showDropIndicatorBelowList(list) {
    const listRect = list.getBoundingClientRect();
    showDropIndicator(listRect.left, listRect.bottom, listRect.width);
  }

  /**
   * Show the drop indicator above or below a list row.
   *
   * @param {HTMLElement} rowNode A list row element.
   * @param {number} cursorY The cursor Y position, relative to the viewport.
   */
  function showDropIndicatorForRow(rowNode, cursorY) {
    const belowMiddle = isBelowMiddleOfNode(cursorY, rowNode);
    const rowRect = rowNode.getBoundingClientRect();
    const x = rowRect.left;
    const y = rowRect.top + (belowMiddle ? rowRect.height : 0);
    showDropIndicator(x, y, rowRect.width);
  }

  /**
   * Show the drop indicator line for the specified row and cursor position.
   * If the cursor position is below the middle of the row, the indicator will be
   * placed below the row, otherwise above the row.
   *
   * @param {number} x The X position relative to the viewport.
   * @param {number} y The Y position relative to the viewport.
   * @param {number} width The width of the indicator.
   */
  function showDropIndicator(x, y, width) {
    // Don't use window.scroll X/Y because cross browser issues.
    // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
    const indicatorAbsX = window.pageXOffset + x;
    const indicatorAbsY = window.pageYOffset + y;
    const indicatorWidth = width;

    if (!dropIndicator) {
      dropIndicator = document.createElement('div');
      dropIndicator.className = 'tr-drag-indicator';
    }

    dropIndicator.style.left = `${indicatorAbsX}px`;
    dropIndicator.style.width = `${indicatorWidth}px`;
    dropIndicator.style.top = `${indicatorAbsY}px`;

    if (!dropIndicator.parentNode) {
      document.body.appendChild(dropIndicator);
    }
  }

  /**
   * Hide the drop indicator.
   */
  function hideDropIndicator() {
    if (dropIndicator && dropIndicator.parentNode) {
      dropIndicator.parentNode.removeChild(dropIndicator);
    }
  }

  /**
   * Perform the list changes that are needed from the drop event.
   *
   * @param {MouseEvent} event A drop event.
   * @param {HTMLElement} list The list DOM node.
   * @param {string} contextUri The context URI for the list.
   * @param {string} location The location of the cursor in relation to the list.
   *     This can be either 'inside' or 'below'. The value 'below' means that the
   *     cursor was below the last list found in the DOM.
   */
  function performListChangesForEvent(event, list, contextUri, location) {
    const liveList = live(contextUri).get('rows');
    if (!liveList) return;

    let targetIndex = 0;

    if (location === 'below') {
      const lastRowNode = getLastRowFromLastList();

      // Dropping below a list without rows will use target index 0
      if (lastRowNode) {
        targetIndex = getTargetIndex(event.clientY, lastRowNode);
      }
    } else {
      const rowNode = getRowNode(event);
      if (!rowNode) return;
      targetIndex = getTargetIndex(event.clientY, rowNode);
    }

    const sourceContext = event.dataTransfer.getData('text/x-spotify-data-context');
    const isSameContext = sourceContext && sourceContext === contextUri;

    if (isSameContext) {
      performMoveChanges(contextUri, liveList, targetIndex);
    } else {
      performInsertChanges(event, list, contextUri, liveList, targetIndex);
    }
    event.data = {
      targetIndex: targetIndex
    };
  }

  /**
   * Move the selected items to a target index in the list.
   *
   * @param {string} contextUri The context URI of the list.
   * @param {LiveList} liveList The live list for the context.
   * @param {number} targetIndex The target index in the list.
   */
  function performMoveChanges(contextUri, liveList, targetIndex) {
    const indices = getMoveIndices(contextUri, liveList);

    // Selection can be nothing. This can happen if you select a row, drag it
    // and before dropping, the row is removed by something else (on another
    // device perhaps). Dropping should in that case not perform any action.
    // Similarly, if dragging multiple rows and some of the rows are removed
    // while dragging, only the rows that are still in the list will be moved.
    if (indices.length === 0) return;

    const operations = listOperations.getMoveOperations(indices, targetIndex);

    // If the list changed while dragging, it might happen that we end up
    // dropping at the same index as we're dragging from, which would give
    // us no operations to perform.
    if (operations.length === 0) return;

    liveList.publish(operations);

    temporarilyDisableList(contextUri, liveList);
  }

  /**
   * Insert items from the event into the list at the target index.
   *
   * @param {MouseEvent} event A drop event.
   * @param {HTMLElement} list The list DOM node.
   * @param {string} contextUri The context URI for the list.
   * @param {LiveList} liveList The live list for the context.
   * @param {number} targetIndex The target index in the list.
   */
  function performInsertChanges(event, list, contextUri, liveList, targetIndex) {
    getInsertValues(event, list, liveList, contextUri, function (error, values) {
      if (error) return;
      if (values.length === 0) return;

      const operations = [{ type: 'insert', index: targetIndex, values: values }];

      liveList.publish(operations);

      temporarilyDisableList(contextUri, liveList);
    });
  }

  /**
   * Check if dropping at the current position in a list is allowed.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} list A DOM node marked up as a list.
   * @param {string} contextUri The context URI of the list being dropped on.
   * @param {string} location The location of the cursor in relation to the list.
   *     This can be either 'inside' or 'below'. The value 'below' means that the
   *     cursor was below the last list found in the DOM.
   *
   * @return {boolean} True if it's a valid drop position.
   */
  function validateListDrop(event, list, contextUri, location, index) {
    // All positions are valid if we're not dragging from a context in the first
    // place. If we do have a context though, we need to validate the position.
    const types = event.dataTransfer.types;

    // We can't read drag data while dragging (only on drop), so we put the
    // context in the MIME type. The browser makes all MIME types in the drag
    // event lowercase, so we need to make it lowercase to properly compare it.
    const contextMimeType = `text/x-spotify-data-context-${contextUri}`.toLowerCase();

    const isDraggingFromContext = types.includes(contextMimeType);
    if (isDraggingFromContext) {
      if (!validatePotentialOperations(event, list, location)) {
        return false;
      }
    }

    const uri = list.getAttribute('data-uri');
    if (uri && draggedLinkContext === uri) {
      return false;
    }

    const result = { valid: true };
    hooks.run('list-drop-validation', result, event, list, location, index);

    return !!result.valid;
  }

  /**
   * Check if dropping at the current event position would actually result in
   * operations that would change the list.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} list A DOM node marked up as a list.
   * @param {string} location The location of the cursor in relation to the list.
   *     This can be either 'inside' or 'below'. The value 'below' means that the
   *     cursor was below the last list found in the DOM.
   *
   * @return {boolean} True if it would result in a change.
   */
  function validatePotentialOperations(event, list, location) {
    // get a cached version of the selectionState
    const selectionState = cachedSelectionState.get();

    // Dropping inside the only selected range inside the only container that
    // has a selection is not allowed, as that would result in no change.
    if (selectionState.length === 1) {
      // Dropping inside a different context is always fine
      const contextUri = list.getAttribute('data-uri');
      if (contextUri !== selectionState[0].uri) {
        return true;
      }

      const selectedRanges = Range.fromIndices(selectionState[0].indicesWithHidden);

      if (selectedRanges.length === 1) {
        const selectedRange = selectedRanges[0];

        // Include the next row in the selected range to handle holding on the
        // top part of the next row, which would be a no-op. The bottom part of
        // the previous row will be taken care of by the code below.
        selectedRange.update(selectedRange.start, selectedRange.end + 1);

        const rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
        if (rowNode) {
          const targetIndex = getTargetIndex(event.clientY, rowNode);
          if (targetIndex > -1) {
            const targetRange = new Range(targetIndex, targetIndex + 1);

            // If the target index is inside the selected range, it's not allowed
            // to drop, as that would be a no-op.
            if (targetRange.contained(selectedRange)) {
              return false;
            }
          }
        }
      }
    }

    return true;
  }

  /**
   * Get the drop target element that is matching the event target and the drag
   * MIME types of the event. This will start with the event target and step
   * outwards in the DOM tree to find the first matching element.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {HTMLElement?} The element or null if not found.
   */
  function getMatchingTarget(event) {
    let currentNode = event.target;

    while (currentNode) {
      if (isMatchingTarget(event, currentNode)) {
        return currentNode;
      }
      currentNode = currentNode.parentElement;
    }

    return null;
  }

  /**
   * Get the list element that is matching the event target and the drag MIME
   * types of the event. This will start with the event target and step outwards
   * in the DOM tree to find the first matching element.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {HTMLElement?} The list element or null if not found.
   */
  function getMatchingListTarget(event) {
    let currentNode = event.target;

    while (currentNode) {
      const isList = $(currentNode).matches(SELECTOR_LIST);
      if (isList && isMatchingTarget(event, currentNode)) {
        return currentNode;
      }
      currentNode = currentNode.parentElement;
    }

    return null;
  }

  /**
   * Get a valid list target from the end of body.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {HTMLElement?} The list element or null if not found.
   */
  function getListTargetFromBody(event) {
    const lastList = getLastListNode();
    if (lastList) {
      const sameParent = event.target.contains(lastList);
      if (sameParent && isMatchingTarget(event, lastList)) {
        if (isBelowNode(event.clientX, event.clientY, lastList)) {
          return lastList;
        }
      }
    }

    return null;
  }

  /**
   * Get the list row element from the event target.
   * If the event target itself isn't a list row, it will step out in the parent
   * tree until it finds a row.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   *
   * @return {HTMLElement?} The list row element, or null if not found.
   */
  function getRowNode(event) {
    return event.target.closest(SELECTOR_LIST_ITEM);
  }

  /**
   * Get the last list row from the last list in the DOM.
   *
   * @return {HTMLElement?} The list row element, or null if not found.
   */
  function getLastRowFromLastList() {
    const lastList = getLastListNode();
    if (lastList) {
      const listItems = $(lastList).search(SELECTOR_LIST_ITEM);
      const lastItem = listItems && listItems[listItems.length - 1];
      if (lastItem) return lastItem;
    }

    return null;
  }

  /**
   * Get the last list in the DOM.
   *
   * @return {HTMLElement?} The list element, or null if not found.
   */
  function getLastListNode() {
    const lists = document.querySelectorAll(SELECTOR_LIST);
    const lastList = lists && lists[lists.length - 1];
    return lastList || null;
  }

  /**
   * Get the target index based on a cursor position and the row that the cursor
   * is on.
   *
   * @param {number} y The Y position relative to the viewport.
   * @param {HTMLElement} rowNode The DOM node for the row.
   *
   * @return {number} The target index or -1 if not found.
   */
  function getTargetIndex(y, rowNode) {
    let index = rowNode.getAttribute('data-index');

    if (index === null) {
      index = -1;
    } else {
      index = parseInt(index, 10);

      if (isNaN(index)) {
        index = -1;
      } else {
        // If cursor is in the bottom part of the row, dropping will place items
        // after the row, so we need to increment the index.
        if (isBelowMiddleOfNode(y, rowNode)) {
          index++;
        }
      }
    }

    return index;
  }

  /**
   * Get the indices of the rows to move.
   *
   * @param {string} contextUri The context URI.
   * @param {LiveList} liveList The live list to be changed.
   *
   * @return {Array.<number>} Array of indices.
   */
  function getMoveIndices(contextUri, liveList) {
    // As we need the indices, we must use the current selection state,
    // since the list might have changed since the start of the drag.
    // We are only in this function if we are dragging in the same
    // context, so the current selection state will always be valid.
    const selectionState = selection.getIndicesPerList();
    if (selectionState.length !== 1) return [];

    const firstContainer = selectionState[0];
    const selectedIndices = firstContainer.indices;
    const indices = selectedIndices.slice();

    if (indices.length === 0) return [];

    hooks.run('get-move-indices', contextUri, liveList, indices);

    // The indices must be sorted for the utility that creates the list operations
    indices.sort(function (a, b) {
      return a - b;
    });

    return indices;
  }

  /**
   * Get the values to use for insertion in the list. This will get the event data
   * for the matching MIME types.
   *
   * @param {MouseEvent} event A drop event.
   * @param {HTMLElement} list The list DOM node.
   * @param {LiveList} liveList The live list for the context.
   * @param {string} contextUri The context URI for the list.
   * @param {Function} callback A callback function. The data argument will be an
   *     array of object values.
   */
  function getInsertValues(event, list, liveList, contextUri, callback) {
    const eventTypes = event.dataTransfer.types;
    const listTypes = list.getAttribute(ATTR_TARGET);
    if (!listTypes) {
      callback(null, []);
      return;
    }

    const matchingTypes = intersection(listTypes.split('|'), eventTypes);
    if (matchingTypes.length === 0) {
      callback(null, []);
      return;
    }

    const data = getDataFromTypes(event, matchingTypes);

    const isTrackList = isListOfTracks(liveList, contextUri);

    getRowsFromData(data, isTrackList, function (error, rows) {
      if (error) {
        callback(error);
        return;
      }

      callback(null, rows);
    });
  }

  /**
   * Get the event data associated with the provided MIME types.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {Array.<string>} types Array of MIME types.
   *
   * @return {Object.<string, Array>} Object where key is MIME type and value is
   *     array of values (URIs).
   */
  function getDataFromTypes(event, types) {
    const data = {};

    for (let i = 0, l = types.length; i < l; i++) {
      const type = types[i];
      const itemsInData = data[type] = [];

      // A MIME type that starts with text/x-spotify is always containing a list
      // of Open URLs separated by '\n'.
      const hasURIs = type.indexOf('text/x-spotify') === 0;

      const dataForType = event.dataTransfer.getData(type);
      const items = hasURIs ? dataForType.split('\n') : [dataForType];
      for (let n = 0, len = items.length; n < len; n++) {
        const item = items[n];
        if (hasURIs) {
          const uriObject = liburi.from(item);
          if (uriObject) {
            itemsInData.push(uriObject.toURI());
          }
        } else {
          itemsInData.push(item);
        }
      }
    }

    return data;
  }

  /**
   * Get list row data from the event data. This might expand items if the list
   * is a track list (dropping an album into a track list will expand the album
   * into its tracks and return track rows instead).
   *
   * @param {Object.<string, Array>} data Data from drop event.
   * @param {boolean} isTrackList True if the list is a track list.
   * @param {Function} callback A callback function. The data argument will be an
   *     array of object values.
   */
  function getRowsFromData(data, isTrackList, callback) {
    const promised = [];

    if (data['text/x-spotify-tracks']) {
      promised.push(getRowObjects('track', data['text/x-spotify-tracks']));
    }

    if (data['text/x-spotify-albums']) {
      const albums = data['text/x-spotify-albums'];
      if (isTrackList) {
        promised.push(fetchListTrackRows(albums));
      } else {
        promised.push(getRowObjects('album', albums));
      }
    }

    if (data['text/x-spotify-playlists']) {
      const playlists = data['text/x-spotify-playlists'];
      if (isTrackList) {
        promised.push(fetchListTrackRows(playlists));
      } else {
        promised.push(getRowObjects('playlist', playlists));
      }
    }

    if (data['text/x-spotify-artists']) {
      promised.push(getRowObjects('artist', data['text/x-spotify-artists']));
    }

    if (data['text/x-spotify-users']) {
      promised.push(getRowObjects('user', data['text/x-spotify-users']));
    }

    Promise.all(promised).then(function (arrays) {
      let rows = [];
      rows = rows.concat.apply(rows, arrays);
      callback(null, rows);
    }, function (error) {
      callback(error);
    });
  }

  /**
   * Fetch the track rows from a set of list URIs. This is for the expansion of
   * for example an album into the tracks of the album.
   *
   * @param {Array.<string>} listUris Array of list URIs.
   */
  function fetchListTrackRows(listUris) {
    const promised = listUris.map(function (listUri) {
      return new Promise(function (resolve, reject) {
        live(listUri).query('rows(track(uri))', function (error, data) {
          if (error) {
            reject(error);
            return;
          }
          const rows = data.rows.map(function (row) {
            return live(row);
          });
          resolve(rows);
        }, live.ASAP);
      });
    });

    return Promise.all(promised).then(function (arrays) {
      let rows = [];
      rows = rows.concat.apply(rows, arrays);
      return rows;
    });
  }

  /**
   * Fetch the live object for the row of an item.
   *
   * @param {string} itemType The type of an item (for example 'track').
   * @param {Array.<string>} uris Array of item URIs.
   *
   * @return {Array.<LiveObject>} Array of row live objects.
   */
  function getRowObjects(itemType, uris) {
    return uris.map(function (uri) {
      const row = {};
      row[itemType] = { uri: uri };
      return live(row);
    });
  }

  /**
   * Check if the list is a track list.
   *
   * @param {LiveList} liveList The live list.
   * @param {string} contextUri The context URI for the list.
   *
   * @return {boolean} True if the list is a track list.
   */
  function isListOfTracks(liveList, contextUri) {
    if (liburi.isPlaylistV1OrV2(contextUri)) {
      return true;
    }

    const result = { valid: false };
    hooks.run('is-list-of-tracks', result, liveList, contextUri);

    if (!result.valid) {
      const firstRow = liveList.get(0);
      const firstTrack = firstRow && firstRow.get('track');
      if (firstTrack) return true;
    }

    return !!result.valid;
  }

  /**
   * Check if the position is below the bottom edge of the node.
   *
   * @param {number} x The X position relative to the viewport.
   * @param {number} y The Y position relative to the viewport.
   * @param {HTMLElement} node DOM node to check against.
   *
   * @return {boolean} True if the position is below.
   */
  function isBelowNode(x, y, node) {
    const rect = node.getBoundingClientRect();
    const below = y >= rect.bottom;
    const betweenX = x >= rect.left && x <= rect.right;
    return below && betweenX;
  }

  /**
   * Check if the position is below the middle of the node.
   *
   * @param {number} y The Y position relative to the viewport.
   * @param {HTMLElement} node DOM node to check against.
   *
   * @return {boolean} True if the position is below.
   */
  function isBelowMiddleOfNode(y, node) {
    const rect = node.getBoundingClientRect();
    return y >= rect.top + rect.height / 2;
  }

  /**
   * Check if the MIME types in the drag event matches the MIME types for the
   * specified drop target.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} node A DOM node.
   *
   * @return {boolean} True if the element matches the event.
   */
  function isMatchingTarget(event, node) {
    const eventTypes = event.dataTransfer.types;
    const nodeTypes = node.getAttribute(ATTR_TARGET);

    if (nodeTypes) {
      const matching = intersection(nodeTypes.split('|'), eventTypes);
      if (matching.length > 0) return true;
    }

    return false;
  }

  /**
   * Temporarily disable drag and dropping inside a list until the move or insert
   * is done. This is to prevent multiple operations to be called before the
   * response from the first comes back. We consider the operation done when we
   * receive the next update event, since it's very tricky to know when this
   * specific move is done. To prevent possible errors with being disabled
   * infinitely, we will enable it again after a certain timeout. This could
   * happen for example if the live list is switched out for a new list, in which
   * case we won't get the update event.
   *
   * @param {string} contextUri The context URI.
   * @param {LiveList} liveList The live list that was changed.
   */
  function temporarilyDisableList(contextUri, liveList) {
    disabledLists[contextUri] = true;

    const handler = function (t) {
      return () => {
        clearTimeout(t);
        liveList.off('update', handler);

        // Wait slighly longer to allow the change to trickle down to DOM
        setTimeout(function () {
          delete disabledLists[contextUri];
        }, 100);
      };
    };

    const timer = setTimeout(() => {
      handler(timer);
    }, 500);

    liveList.on('update', handler(timer));
  }

  /**
   * Attach the module.
   */
  function attach() {
    eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.delegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
    eventModel.delegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
    eventModel.delegate('dragend', 'body', onDragEnd);
    eventModel.delegate('drop', SELECTOR_LIST_TARGET, onDrop);
  }

  /**
   * Detach the module.
   */
  function detach() {
    eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.undelegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
    eventModel.undelegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
    eventModel.undelegate('dragend', 'body', onDragEnd);
    eventModel.undelegate('drop', SELECTOR_LIST_TARGET, onDrop);
  }

  exports.attach = attach;
  exports.detach = detach;

  },{"../../../libs/live-list-operations":358,"../../live":413,"../../range2":454,"../../spotify-elements":460,"../selection":528,"./util/eventmodel":481,"./util/hooks":482,"mout/array/intersection":783,"spotify-liburi":1282}],480:[function(require,module,exports){
  (function (global){
  /**
   * @module spotify-events/dragndrop/target
   * @private
   */
  'use strict';

  const $ = require('../../spotify-elements');
  const liburi = require('spotify-liburi');
  const defer = require('../../../libs/prime/defer');

  const center = require('../center');
  const eventModel = require('./util/eventmodel');
  const hooks = require('./util/hooks');

  const SELECTOR_DROP_TARGET = '[data-drop-target]';
  const SELECTOR_DRAGGABLE = 'a, [draggable]';
  const ATTR_TARGET = 'data-drop-target';
  const ATTR_TARGET_INCLUDE_TEXT = 'data-drop-target-include-text';
  const ATTR_NO_CLASSNAME = 'data-drop-no-classname';
  const CLASSNAME_ACTIVE = 'drop-target-active';
  const TEXT_PLAIN = 'text/plain';

  let longHoldTimerId = 0;
  let longHoldTimerDuration = 1000;
  let draggedElement = null;
  let lastEnteredElement = null;

  /**
   * Handler for starting to drag.
   *
   * @param {MouseEvent} event A dragstart event object.
   * @param {HTMLElement} node The draggable DOM element.
   */
  function onDragStart(event, node) {
    // Don't handle items that are specified with the new implementation.
    if (node.closest('[data-glue-draggable]')) {
      return;
    }

    draggedElement = node;
    lastEnteredElement = null;
  }

  /**
   * Handler for ending a drag.
   */
  function onDragEnd() {
    draggedElement = null;
    lastEnteredElement = null;

    stopLongHoldTimer();
    removeAnyActiveClass();
  }

  /**
   * Handler for dragging into a drop target.
   *
   * @param {MouseEvent} event A dragenter event object.
   * @param {HTMLElement} target DOM element for the drop target.
   */
  function onDragEnter(event, target) {
    if (validateTarget(event, target)) {
      setEnter(event, target);
    }
  }

  /**
   * Handler for dragging out from a drop target.
   *
   * @param {MouseEvent} event A dragleave event object.
   * @param {HTMLElement} target DOM element for the drop target.
   */
  function onDragLeave(event, target) {
    if (validateTarget(event, target)) {
      setLeave(event, target);
    }
  }

  /**
   * Handler for dragging over a drop target.
   *
   * @param {MouseEvent} event A dragover event object.
   * @param {HTMLElement} target DOM element for the drop target.
   */
  function onDragOver(event, target) {
    if (validateTarget(event, target)) {
      // Tell the event that we are accepting drops on this target
      event.preventDefault();

      // Since other code might have set the dropEffect to something else,
      // we need to override that, since we're now accepting drops
      event.dataTransfer.dropEffect = 'copy';

      setEnter(event, target);

      // If the target is not valid, remove any styling for active drop target
    } else {
      setLeave(event, target);
    }
  }

  /**
   * Handler for dropping on a drop target.
   *
   * @param {MouseEvent} event A drop event object.
   * @param {HTMLElement} target DOM element for the drop target.
   */
  function onDrop(event, target) {
    stopLongHoldTimer();

    // Dropping should remove active target class name.
    // Dropping outside of a target doesn't need this, as the target is only
    // active when hovering it.
    removeAnyActiveClass();

    if (validateTarget(event, target)) {
      const types = getMimeTypesForTarget(event, target);
      const dropData = getDropData(event, types);
      const sourceUri = event.dataTransfer.getData('text/x-spotify-data-context') || null;
      const sourceLogContext = event.dataTransfer.getData('text/x-spotify-data-log-context') || null;
      const sourceAppUri = event.dataTransfer.getData('text/x-spotify-data-app-uri') || null;
      let sourceIndex = parseInt(event.dataTransfer.getData('text/x-spotify-data-log-source-index'), 0);
      if (isNaN(sourceIndex)) sourceIndex = null;

      const targetUriNode = target.closest('[data-uri]');
      const targetUri = targetUriNode && targetUriNode.getAttribute('data-uri') || null;

      // Give any other delegates a chance to handle the drop, and if so pass
      // that info along in the event.
      defer.immediate(function () {
        center.emit('drop', {
          handled: event.handled,
          node: target,
          sourceUri: sourceUri,
          targetUri: targetUri,
          data: dropData
        });
      });
    }

    // Prevent navigation on drop
    event.preventDefault();

    // Reset here since our multi-frame architecture means we're not guaranteed
    // to have gotten a dragstart event in this frame prior to dropping.
    lastEnteredElement = null;
  }

  /**
   * Set target to be entered, including setting style and sending event.
   *
   * @param {MouseEvent} event A dragenter event object.
   * @param {HTMLElement} target DOM element for the drop target.
   */
  function setEnter(event, target) {
    if (target === lastEnteredElement) {
      return;
    }

    lastEnteredElement = target;

    if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
      $(target).addClass(CLASSNAME_ACTIVE);
    }

    const types = getMimeTypesForTarget(event, target);
    center.emit('dragenter', { node: target, types: types });

    startLongHoldTimer(target, types);
  }

  /**
   * Set target to be left, including removing style and sending event.
   *
   * @param {MouseEvent} event A dragleave event object.
   * @param {HTMLElement} target DOM element for the drop target.
   */
  function setLeave(event, target) {
    if (target !== lastEnteredElement) {
      return;
    }

    lastEnteredElement = null;

    if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
      $(target).removeClass(CLASSNAME_ACTIVE);
    }

    const types = getMimeTypesForTarget(event, target);
    center.emit('dragleave', { node: target, types: types });

    stopLongHoldTimer();
  }

  /**
   * Check if the drop target matches the MIME types for the event.
   *
   * @param {MouseEvent} event Some kind of drag and drop event.
   * @param {HTMLElement} target DOM element for the drop target.
   *
   * @return {boolean} True if the target is valid.
   */
  function validateTarget(event, target) {
    // The element being dragged is not accepted as a drop target
    if (target === draggedElement) {
      return false;
    }

    const types = getMimeTypesForTarget(event, target);

    if (types.length) {
      const result = { valid: true };
      hooks.run('target-validation', result, event, target);

      if (result.valid) {
        return true;
      }
    }

    return false;
  }

  /**
   * Get the data associated with the drop, grouped by MIME type.
   * If the data contained Spotify URLs, they will be converted to Spotify URIs.
   *
   * @param {MouseEvent} event Event object for a drop event.
   * @param {Array.<string>} types Array of MIME types.
   *
   * @return {Object.<string, Array.<string>>} Data object of arrays of item
   *     URIs, grouped by MIME type.
   */
  function getDropData(event, types) {
    const data = {};

    for (let i = 0, l = types.length; i < l; i++) {
      const itemsInData = data[types[i]] = [];
      const dataForType = event.dataTransfer.getData(types[i]);
      const hasURIs = types[i].indexOf('text/x-spotify') === 0;
      const items = hasURIs ? dataForType.split('\n') : [dataForType];

      for (let n = 0, len = items.length; n < len; n++) {
        let item = items[n];
        if (hasURIs) {
          const uriObject = liburi.from(item);
          if (uriObject) item = uriObject.toURI();
        }
        if (item) itemsInData.push(item);
      }
    }

    const hasContextData = types.indexOf('text/x-spotify-data-context') > -1;
    if (hasContextData) {
      data['text/x-spotify-data-context'] = [event.dataTransfer.getData('text/x-spotify-data-context')];
    }

    return data;
  }

  /**
   * Start a timer for emitting an event for long-hold on a target.
   * If one is already started, it will use the previous timer and not restart it.
   *
   * @param {HTMLElement} target A DOM element for the drop target.
   * @param {Array.<string>} types Array of MIME types.
   */
  function startLongHoldTimer(target, types) {
    // Don't start a new timer if we already have one running
    if (longHoldTimerId) return;

    longHoldTimerId = setTimeout(function () {
      center.emit('dragover-long', { node: target, types: types });
    }, longHoldTimerDuration);
  }

  /**
   * Stop any running timer for emitting an event for long-hold on a target.
   */
  function stopLongHoldTimer() {
    clearTimeout(longHoldTimerId);

    // Reset the timer ID so we can know that there is no timer running
    longHoldTimerId = 0;
  }

  /**
   * Remove the active class name from any element that has it.
   */
  function removeAnyActiveClass() {
    const active = $(`.${CLASSNAME_ACTIVE}`);
    if (active) {
      active.removeClass(CLASSNAME_ACTIVE);
    }
  }

  /**
   * Get the MIME types that are matching both the drag event and the target.
   *
   * @param {MouseEvent} event Any kind of drag and drop event.
   * @param {HTMLElement} target A DOM element.
   *
   * @return {Array.<string>} Array of MIME types.
   */
  function getMimeTypesForTarget(event, target) {
    const mimeTypes = [];
    const dataTypes = event.dataTransfer.types;

    let targetTypes = target.getAttribute(ATTR_TARGET);
    // Even though the target may not accept just text/plain data, in can still
    // opt to receive that data along side the ones it accepts.
    // For example to get a list of mixed data types in order.
    const includeText = target.hasAttribute(ATTR_TARGET_INCLUDE_TEXT);

    if (targetTypes) {
      targetTypes = targetTypes.split('|');

      for (let i = 0, l = dataTypes.length; i < l; i++) {
        const type = dataTypes[i];
        if (targetTypes.indexOf(type) > -1) {
          mimeTypes.push(type);
        }
      }

      if (includeText && mimeTypes.length) {
        if (mimeTypes.indexOf(TEXT_PLAIN) === -1) {
          mimeTypes.push(TEXT_PLAIN);
        }
      }
    }

    return mimeTypes;
  }

  /**
   * Attach the module.
   */
  function attach() {
    eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.delegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
    eventModel.delegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
    eventModel.delegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
    eventModel.delegate('dragend', 'body', onDragEnd);
    eventModel.delegate('drop', SELECTOR_DROP_TARGET, onDrop);
  }

  /**
   * Detach the module.
   */
  function detach() {
    eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
    eventModel.undelegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
    eventModel.undelegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
    eventModel.undelegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
    eventModel.undelegate('dragend', 'body', onDragEnd);
    eventModel.undelegate('drop', SELECTOR_DROP_TARGET, onDrop);
  }

  exports.attach = attach;
  exports.detach = detach;

  // Exporting for testing
  const originalDuration = longHoldTimerDuration;
  exports.setLongHoldDuration = function setLongHoldDuration(duration) {
    longHoldTimerDuration = duration;
  };
  exports.resetLongHoldDuration = function resetLongHoldDuration() {
    longHoldTimerDuration = originalDuration;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../../libs/prime/defer":450,"../../spotify-elements":460,"../center":471,"../util/get-log-context":542,"./util/eventmodel":481,"./util/hooks":482,"spotify-liburi":1282}],481:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop/util/eventmodel
   * @private
   *
   * This module is made to be an abstraction of the event model for drag and
   * drop. It also exposes a delegation interface which allows you to only
   * listen for events for targets matching a certain selector.
   *
   * The need for this abstraction is to simplify the code listening to drag
   * and drop events.
   *
   * - The raw events we get from the browser are sometimes not that easy to
   *   work with. For example, when moving from one target to another, we get
   *   a dragenter event before the dragleave event, which can cause confusion.
   *   This abstraction flips that around, so that you always get the dragleave
   *   event before the dragenter event.
   *
   * - The raw events also trigger for children. For example, if moving the
   *   cursor from one element to one of its children, we get a dragenter event
   *   for the child element and a dragleave for the outer element. This makes
   *   it difficult to highlight drop targets based on dragenter/dragleave.
   *   This abstraction helps by making sure the handler is not called if moving
   *   to a child element inside an element that matches the selector. There
   *   is an exception though when moving to a child that is also matching a
   *   selector, the outer element is then left and the child is entered.
   *
   * @example
   * function onDragEnter(event, target) {
   *   event instanceof MouseEvent; // true
   *   target instanceof HTMLElement; // true
   *   target.matches('[data-drop-target]'); // true
   * }
   *
   * // Start listening
   * eventmodel.delegate('dragenter', '[data-drop-target]', onDragEnter);
   *
   * // Stop listening
   * eventmodel.undelegate('dragenter', '[data-drop-target]', onDragEnter);
   */
  'use strict';

  const $ = require('../../../spotify-elements');

  const attached = {};
  const delegations = {};
  let movementHandlerCount = 0;

  // State variables
  let hasEntered = false;
  let lastEnteredElement = null;
  let lastEnterTarget = null;
  let lastEnterEvent = null;
  let wasLastEventEnter = false;

  /**
   * Reset the temporary state variables used while dragging.
   */
  function resetState() {
    hasEntered = false;
    lastEnteredElement = null;
    lastEnterTarget = null;
    lastEnterEvent = null;
    wasLastEventEnter = false;
  }

  /**
   * Generic handler for any event.
   * This function will look at the current delegations and run the handler
   * functions for the matching delegations.
   * Some events will be handled by calling a special handler, which in some cases
   * later will check for matching delegations.
   *
   * @param {Event} event Event object.
   */
  function onEvent(event) {
    const handler = getPrimaryHandler(event.type);
    if (handler) {
      handler(event);
    } else {
      handleDelegationsForEvent(event);
    }
  }

  /**
   * Handler for a dragenter event.
   * Depending on state, this might save the event for later and call the
   * handler at a later point, to ensure that the dragenter event is sent
   * after the dragleave.
   *
   * @param {MouseEvent} event Event object for a dragenter event.
   */
  function onPrimaryDragEnter(event) {
    wasLastEventEnter = true;

    if (hasEntered) {
      if (lastEnteredElement !== event.target) {
        lastEnterEvent = event;
      }
    } else {
      hasEntered = true;
      lastEnteredElement = event.target;
      handleDelegationsForEvent(event);
    }
  }

  /**
   * Handler for a dragleave event.
   * Depending on state, this might also trigger the handlers for a dragenter
   * event, if there was a saved event from before.
   *
   * @param {MouseEvent} event Event object for a dragleave event.
   */
  function onPrimaryDragLeave(event) {
    wasLastEventEnter = false;
    lastEnteredElement = null;

    handleDelegationsForEvent(event);

    if (hasEntered) {
      if (lastEnterEvent) {
        lastEnteredElement = lastEnterEvent.target;
        handleDelegationsForEvent(lastEnterEvent);
        lastEnterEvent = null;
      } else {
        hasEntered = false;
      }
    }
  }

  /**
   * Handler for a drop event.
   * This is handled by a special handler only to reset some state.
   *
   * @param {MouseEvent} event Event object for a drop event.
   */
  function onPrimaryDrop(event) {
    resetState();
    handleDelegationsForEvent(event);
  }

  /**
   * Handler for a dragend event.
   * This is handled by a special handler only to reset some state.
   *
   * @param {MouseEvent} event Event object for a drop event.
   */
  function onPrimaryDragEnd(event) {
    resetState();
    handleDelegationsForEvent(event);
  }

  /**
   * Delegation handler for a dragenter event.
   * After matching against stored delegations, we need to do some final checking
   * before calling the user handler.
   *
   * @param {MouseEvent} event Event object for a dragenter event.
   * @param {HTMLElement} target A DOM element.
   * @param {Function} handler The user handler.
   */
  function onDragEnter(event, target, handler) {
    if (target !== lastEnterTarget) {
      lastEnterTarget = target;
      callUserHandler(event, target, handler);
    }
  }

  /**
   * Delegation handler for a dragleave event.
   * After matching against stored delegations, we need to do some final checking
   * before calling the user handler.
   *
   * @param {MouseEvent} event Event object for a dragleave event.
   * @param {HTMLElement} target A DOM element.
   * @param {Function} handler The user handler.
   * @param {string} selector A CSS selector string.
   */
  function onDragLeave(event, target, handler, selector) {
    let shouldCallUserHandler = false;

    const lastElement = lastEnterEvent && lastEnterEvent.target;
    if (lastElement) {
      const isSameElement = target === lastElement;
      const isEnteringChild = !isSameElement && target.contains(lastElement);
      const isEnteringMatchingElement = $(lastElement).matches(selector);
      if (!isSameElement && (!isEnteringChild || isEnteringMatchingElement)) {
        shouldCallUserHandler = true;
      }
    }

    // Most often the sequence of events will be dragenter->dragenter->dragleave
    // when moving into one element and then into another element. But if the
    // sequence is just dragenter->dragleave, we should also call the user
    // handler. This would happen if there is no new entered element.
    if (!wasLastEventEnter) {
      shouldCallUserHandler = true;
    }

    if (shouldCallUserHandler) {
      lastEnterTarget = null;
      callUserHandler(event, target, handler);
    }
  }

  /**
   * Find matching delegations and call the handlers.
   *
   * @param {Event} event Event object.
   */
  function handleDelegationsForEvent(event) {
    const type = event.type;
    const delegationData = delegations[type];

    if (delegationData && delegationData.length > 0) {
      delegationData.forEach(function (data) {
        const selector = data.selector;
        // Check that the event.target is not the document element as it does not
        // have the closest function. This happens when dragging over scrollbars which
        // belong to the document.
        const matchingTarget = event.target !== document && event.target.closest(selector);

        if (matchingTarget) {
          const handler = getHandler(type) || callUserHandler;
          handler(event, matchingTarget, data.handler, selector);
        }
      });
    }
  }

  /**
   * Call the user handler for a delegation.
   *
   * @param {Event} event Event object.
   * @param {HTMLElement} target A DOM element.
   * @param {Function} handler The user handler.
   */
  function callUserHandler(event, target, handler) {
    handler.call(exports, event, target);
  }

  /**
   * Get any handler that needs to be called for a raw event before looking
   * for any delegations.
   *
   * @param {string} type Event type.
   *
   * @return {Function?} The handler function or null if no special handler
   *     should be called.
   */
  function getPrimaryHandler(type) {
    switch (type) {
      case 'dragenter':
        return onPrimaryDragEnter;
      case 'dragleave':
        return onPrimaryDragLeave;
      case 'dragend':
        return onPrimaryDragEnd;
      case 'drop':
        return onPrimaryDrop;
      default:
        break;
    }
    return null;
  }

  /**
   * Get any handler that needs to be called after matching delegations,
   * but before calling the user handler.
   *
   * @param {string} type Event type.
   *
   * @return {Function?} The handler function or null if no special handler
   *     should be called.
   */
  function getHandler(type) {
    switch (type) {
      case 'dragenter':
        return onDragEnter;
      case 'dragleave':
        return onDragLeave;
      default:
        break;
    }
    return null;
  }

  /**
   * Check if the event type is one of the events that need special handling
   * for movement (enter/leave events).
   *
   * @param {string} type Event type.
   *
   * @return {boolean} True if the type is a movement type, false otherwise.
   */
  function isMovementType(type) {
    switch (type) {
      case 'dragenter':
        return true;
      case 'dragleave':
        return true;
      case 'dragend':
        return true;
      case 'drop':
        return true;
      default:
        break;
    }
    return false;
  }

  /**
   * Attach a global event listener on document for the specified type.
   *
   * @param {string} type Event type.
   */
  function attach(type) {
    if (attached[type]) return;
    attached[type] = true;
    document.addEventListener(type, onEvent, false);
  }

  /**
   * Detach a global event listener on document for the specified type.
   *
   * @param {string} type Event type.
   */
  function detach(type) {
    if (!attached[type]) return;
    attached[type] = false;
    document.removeEventListener(type, onEvent, false);
  }

  /**
   * Start listening for an event via event delegation for the specified
   * selector.
   *
   * @example
   * var selector = '[data-drop-target]';
   * eventModel.delegate('dragenter', selector, function(event, target) {
   *   event instanceof MouseEvent; // true
   *   target instanceof HTMLElement; // true
   *   target.matches('[data-drop-target]'); // true
   * });
   */
  function delegate(type, selector, handler) {
    if (isMovementType(type)) {
      movementHandlerCount++;
      if (movementHandlerCount === 1) {
        attach('dragenter');
        attach('dragleave');
        attach('dragend');
        attach('drop');
      }
    } else if (!attached[type]) {
      attach(type);
    }

    if (!delegations[type]) delegations[type] = [];

    delegations[type].push({ selector: selector, handler: handler });
  }

  /**
   * Stop listening for an event via event delegation for the specified
   * selector and handler.
   *
   * @example
   * eventModel.undelegate('dragenter', '[data-drop-target]', handler);
   */
  function undelegate(type, selector, handler) {
    if (isMovementType(type)) {
      movementHandlerCount = Math.max(0, movementHandlerCount - 1);
      if (movementHandlerCount === 0) {
        detach('dragenter');
        detach('dragleave');
        detach('dragend');
        detach('drop');
      }
    }

    const delegationsForType = delegations[type];
    if (delegationsForType) {
      for (let i = 0, l = delegationsForType.length; i < l; i++) {
        const data = delegationsForType[i];
        if (data.selector === selector && data.handler === handler) {
          delegationsForType.splice(i, 1);
          break;
        }
      }

      if (!isMovementType && delegationsForType.length === 0) {
        detach(type);
      }
    }
  }

  exports.delegate = delegate;
  exports.undelegate = undelegate;

  },{"../../../spotify-elements":460}],482:[function(require,module,exports){
  /**
   * Hooks
   *
   * Almost like an event emitter. You can add hooks for different ids, and when
   * a hook for an ID is run, the handlers are called.
   *
   * @module spotify-events/dragndrop/util/hooks
   * @private
   */
  'use strict';

  const hooks = {};

  /**
   * Add a hook handler for a specific hook ID.
   *
   * @param {string} id The hook ID.
   * @param {function} handler The handler function. The hook sets the arguments.
   */
  function add(id, handler) {
    if (!hooks[id]) hooks[id] = [];
    hooks[id].push(handler);
  }

  /**
   * Remove a hook handler for a specific hook ID.
   *
   * @param {string} id The hook ID.
   * @param {function} handler The handler function.
   */
  function remove(id, handler) {
    if (hooks[id]) {
      const index = hooks[id].indexOf(handler);
      if (index > -1) {
        hooks[id].splice(index, 1);
      }
    }
  }

  /**
   * Run the hook handlers for a specific hook ID.
   *
   * @param {string} id The hook ID.
   */
  function run(id) {
    const handlers = hooks[id];
    if (handlers && handlers.length > 0) {
      const args = Array.prototype.slice.call(arguments, 1);
      for (let i = 0, l = handlers.length; i < l; i++) {
        handlers[i].apply(null, args);
      }
    }
  }

  exports.add = add;
  exports.remove = remove;
  exports.run = run;

  },{}],483:[function(require,module,exports){
  /**
   * @module spotify-events/dragndrop/util/itemtext
   * @private
   */
  'use strict';

  const live = require('../../../live');
  const liburi = require('spotify-liburi');

  /**
   * Get the text for a URI.
   *
   * @param {string} uri Any URI.
   *
   * @return {string} The text.
   */
  function getForUri(uri) {
    const uriObject = liburi.from(uri);
    if (!uriObject) return '';

    const type = uriObject.type;

    if (type === liburi.Type.TRACK || type === liburi.Type.LOCAL) {
      return getForTrack(uri);
    } else if (type === liburi.Type.ARTIST || type === liburi.Type.LOCAL_ARTIST) {
      return getForArtist(uri);
    } else if (type === liburi.Type.ALBUM || type === liburi.Type.LOCAL_ALBUM) {
      return getForAlbum(uri);
    } else if (type === liburi.Type.PLAYLIST || type === liburi.Type.PLAYLIST_V2) {
      return getForPlaylist(uri);
    } else if (type === liburi.Type.USER || type === liburi.Type.PROFILE) {
      return getForUser(uri);
    } else if (type === liburi.Type.FOLDER) {
      return getForFolder(uri);
    } else if (type === liburi.Type.STATION) {
      return getForStation(uri);
    } else if (type === liburi.Type.EPISODE) {
      return getForEpisode(uri);
    } else if (type === liburi.Type.SHOW) {
      return getForShow(uri);
    }

    return '';
  }

  /**
   * Get the text for a track URI.
   *
   * Examples:
   * Track Name – First Artist, Second Artist, Third Artist (and so on...)
   * Track Name
   *
   * @param {string} uri Track URI.
   *
   * @return {string} The text.
   */
  function getForTrack(uri) {
    const object = live(uri);
    const itemName = object.get('name');
    if (!itemName) return '';

    const artists = object.get('artists');
    if (!artists || artists.length === 0) return itemName;

    const artistNames = artists.get(0, artists.length).map(function (artist) {
      return artist.get('name');
    }).join(', ');
    if (!artistNames) return itemName;

    return separateDragTextItems(itemName, artistNames);
  }

  /**
   * Get the text for an artist URI.
   *
   * Examples:
   * Artist Name
   *
   * @param {string} uri Artist URI.
   *
   * @return {string} The text.
   */
  function getForArtist(uri) {
    return live(uri).get('name') || '';
  }

  /**
   * Get the text for an album URI.
   *
   * Examples:
   * Artist Name – Album Name
   * Album Name
   *
   * @param {string} uri Album URI.
   *
   * @return {string} The text.
   */
  function getForAlbum(uri) {
    const object = live(uri);
    const itemName = object.get('name');
    if (!itemName) return '';

    const artists = object.get('artists');
    if (!artists || artists.length === 0) return itemName;

    const artistName = artists.get(0).get('name');
    if (!artistName) return itemName;

    return separateDragTextItems(artistName, itemName);
  }

  /**
   * Get the text for a playlist URI.
   *
   * Examples:
   * Playlist Name – Owner Name
   * Playlist Name – owner_username
   * Playlist Name
   *
   * @param {string} uri Playlist URI.
   *
   * @return {string} The text.
   */
  function getForPlaylist(uri) {
    const object = live(uri);
    const itemName = object.get('name');
    if (!itemName) return '';

    const owner = object.get('owner');
    const ownerName = owner && (owner.get('name') || owner.get('username'));
    if (!ownerName) return itemName;

    return separateDragTextItems(itemName, ownerName);
  }

  /**
   * Get the text for a playlist URI.
   *
   * Examples:
   * User Name
   * username
   *
   * @param {string} uri Playlist URI.
   *
   * @return {string} The text.
   */
  function getForUser(uri) {
    const object = live(uri);
    const itemName = object.get('name');
    if (itemName) return itemName;

    const uriObject = liburi.fromString(uri);
    const username = uriObject && uriObject.username;
    return username || '';
  }

  /**
   * Get the text for a folder URI.
   *
   * Examples:
   * Folder Name
   *
   * @param {string} uri Folder URI.
   *
   * @return {string} The text.
   */
  function getForFolder(uri) {
    return live(uri).get('name');
  }

  /**
   * Get the text for a station URI.
   *
   * Examples:
   * Station Name
   *
   * @param {string} uri Station URI.
   *
   * @return {string} The text.
   */
  function getForStation(uri) {
    return live(uri).get('name');
  }

  /**
   * Get the text for a episode URI.
   *
   * Examples:
   * The Making of "Day of the Dead"
   *
   * @param {string} uri Episode URI.
   *
   * @return {string} The text.
   */
  function getForEpisode(uri) {
    return live(uri).get('name');
  }

  /**
   * Get the text for a show URI.
   *
   * Examples:
   * "Stuff You Should Know"
   *
   * @param {string} uri Show URI.
   *
   * @return {string} The text.
   */
  function getForShow(uri) {
    return live(uri).get('name');
  }

  /**
   * Separate two strings by the special dash ('en dash', &#8211;) we use.
   *
   * @param {string} item1 First string.
   * @param {string} item2 Second string.
   *
   * @return {string} Final string.
   */
  function separateDragTextItems(item1, item2) {
    return `${item1} – ${item2}`;
  }

  /**
   * Get the text for an element.
   *
   * @param {HTMLElement} target The target element being dragged.
   *
   * @return {string} The drag text.
   */
  function getForElement(target) {
    let title = target.getAttribute('data-drag-text');
    if (title) return title;

    let uri = target.getAttribute('data-uri');
    if (!uri) {
      const uriObject = liburi.from(target.getAttribute('href'));
      uri = uriObject ? uriObject.toURI() : '';
    }
    if (uri) {
      title = getForUri(uri);
      if (title) return title;
    }

    title = target.getAttribute('title');
    if (title) return title;

    return target.textContent;
  }

  exports.getForUri = getForUri;
  exports.getForElement = getForElement;

  },{"../../../live":413,"spotify-liburi":1282}],484:[function(require,module,exports){
  'use strict';

  var _liveWrappedUri = require('../live-wrapped-uri');

  var _liveWrappedUri2 = _interopRequireDefault(_liveWrappedUri);

  var _formatLists = require('../playlist-utils/format-lists');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const $ = require('../spotify-elements');
  const live = require('../live');
  const dom = require('./util/dom');
  const center = require('./center');

  const SELECTOR_FEEDBACK_BUTTON = '[data-button=feedback]';
  const SELECTOR_HEART_BUTTON = '[data-button=heart]';
  const SELECTOR_BAN_BUTTON = '[data-button=contextmenu]';
  const SELECTOR_UNDO_HEART_BUTTON = '[data-button=undo-heart]';
  const SELECTOR_UNDO_BAN_BUTTON = '[data-button=undo-ban]';
  const HEART_CLASSNAME = 'spoticon-heart-16';
  const BAN_CLASSNAME = 'spoticon-ban-16';
  const ACTIVE_HEART_CLASSNAME = 'spoticon-heart-active-16';
  const ACTIVE_BAN_CLASSNAME = 'spoticon-ban-active-16';

  let isAttached = false;

  /**
   * Handle the click on a Heart feedback button.
   *
   * @param {MouseEvent} event An event object for a click event.
   * @param {HTMLElement} button A button DOM node.
   *
   * @private
   */
  function handleFeedbackClick(event, button) {
    const type = dom.getAttributeFromNodeOrParent(event.target, 'data-button');
    const trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
    let contextUri = dom.getContextFromNodeOrParent(button[0]);
    if (_liveWrappedUri2.default.parse(contextUri)) {
      contextUri = _liveWrappedUri2.default.parse(contextUri).originUri;
    }

    if (!trackUri || !contextUri) return;

    // Emit heart / undo-feedback event and update thumb to update UI
    if (type === 'heart') {
      live(contextUri).emit('heart', trackUri);
    } else if (type === 'undo-heart' || type === 'undo-ban') {
      live(contextUri).emit(type, trackUri);
    }
  }

  function updateFeedbackUI(feedbackContainer, thumbState) {
    const heartBtn = feedbackContainer.querySelector(SELECTOR_HEART_BUTTON) || feedbackContainer.querySelector(SELECTOR_UNDO_HEART_BUTTON);
    const banBtn = feedbackContainer.querySelector(SELECTOR_BAN_BUTTON) || feedbackContainer.querySelector(SELECTOR_UNDO_BAN_BUTTON);
    const trackRow = feedbackContainer.parentNode.classList.contains('tl-row') ? feedbackContainer.parentNode : null;

    const shouldThumbUp = thumbState === 'up';
    const shouldThumbDown = thumbState === 'down';
    const shouldThumbNone = !shouldThumbUp && !shouldThumbDown;

    if (feedbackContainer) {
      feedbackContainer.classList.toggle('thumbs-up', shouldThumbUp);
      feedbackContainer.classList.toggle('thumbs-none', shouldThumbNone);
      feedbackContainer.classList.toggle('thumbs-down', shouldThumbDown);
    }

    if (heartBtn) {
      updateHeartUI(heartBtn, thumbState);
    }

    if (banBtn) {
      updateBanUI(banBtn, thumbState);
    }

    if (trackRow) {
      trackRow.classList.toggle('thumbs-up', shouldThumbUp);
      trackRow.classList.toggle('thumbs-none', shouldThumbNone);
      trackRow.classList.toggle('thumbs-down', shouldThumbDown);
    } else if (heartBtn) {
      // heart gets the active class (green) everywhere except track row
      heartBtn.classList.toggle('active', shouldThumbUp);
    }
  }

  function updateHeartUI(button, thumbState) {
    if (thumbState === 'up') {
      button.classList.remove(HEART_CLASSNAME);
      button.classList.add(ACTIVE_HEART_CLASSNAME);
      button.setAttribute('data-button', 'undo-heart');

      // update tooltips...
      const tooltipUndo = button.getAttribute('data-tooltip-undo');
      button.setAttribute('data-tooltip', tooltipUndo);
      button.setAttribute('aria-label', tooltipUndo);

      // update intent
      button.setAttribute('data-interaction-intent', 'undo-heart');
    } else if (thumbState === null) {
      button.classList.add(HEART_CLASSNAME);
      button.classList.remove(ACTIVE_HEART_CLASSNAME);
      button.setAttribute('data-button', 'heart');

      // update tooltips...
      const tooltipHeart = button.getAttribute('data-tooltip-heart');
      button.setAttribute('data-tooltip', tooltipHeart);
      button.setAttribute('aria-label', tooltipHeart);

      // update intent
      button.setAttribute('data-interaction-intent', 'heart');
    }
  }

  function updateBanUI(button, thumbState) {
    if (thumbState === 'down') {
      button.classList.remove(BAN_CLASSNAME);
      button.classList.add(ACTIVE_BAN_CLASSNAME);
      button.setAttribute('data-button', 'undo-ban');

      // update tooltips...
      const tooltipUndo = button.getAttribute('data-tooltip-undo');
      button.setAttribute('data-tooltip', tooltipUndo);
      button.setAttribute('aria-label', tooltipUndo);

      // update intent
      button.setAttribute('data-interaction-intent', 'undo-ban');
    } else if (thumbState === null) {
      button.classList.add(BAN_CLASSNAME);
      button.classList.remove(ACTIVE_BAN_CLASSNAME);
      button.setAttribute('data-button', 'contextmenu');

      // update tooltips...
      const tooltipBan = button.getAttribute('data-tooltip-ban');
      button.setAttribute('data-tooltip', tooltipBan);
      button.setAttribute('aria-label', tooltipBan);

      // update intent
      button.setAttribute('data-interaction-intent', 'show-ban-options');
    }
  }

  function getURIFromNode(node) {
    const stateNode = node[0].closest('[data-uri]');

    if (!stateNode) {
      return null;
    }
    return stateNode.getAttribute('data-uri');
  }

  const changeHandlers = {};

  const eventHandlers = {
    changeHandler: function (actionsRef, key, value, feedbackUri) {
      if (key === 'thumb') {
        const numAffectedButtons = actionsRef.setStateForURI(feedbackUri, value);
        if (numAffectedButtons === 0) {
          live(feedbackUri).off('update', changeHandlers[feedbackUri]);
          delete changeHandlers[feedbackUri];
        }
      }
    }
  };

  const actions = {
    addListenerForNode: function (node, pageNode) {
      const uri = getURIFromNode(node);
      let contextUri;

      if (pageNode && pageNode[0]) {
        contextUri = dom.getContextFromNodeOrParent(pageNode[0]);
      }

      if (!uri || !contextUri) {
        return;
      }

      if (_liveWrappedUri2.default.parse(contextUri)) {
        contextUri = _liveWrappedUri2.default.parse(contextUri).originUri;
      }

      const feedbackUri = (0, _formatLists.makeFeedbackUri)(contextUri, uri);

      // If we have already added a change handler for this URI,
      // we don't want to add another one, so we cancel early.
      // Before cancelling though, we should update button states
      // with the current state from the live model, since there
      // might be new buttons in the DOM.
      if (changeHandlers[feedbackUri]) {
        live(feedbackUri).get('thumb', function (error, thumbState) {
          if (error) throw error;
          actions.setStateForFeedbackNode(node, thumbState);
        }, live.ASAP);
        return;
      }

      changeHandlers[feedbackUri] = function (properties) {
        for (const key in properties) {
          if (!properties.hasOwnProperty(key)) continue;
          const value = properties[key];
          eventHandlers.changeHandler(actions, key, value, feedbackUri);
        }
      };

      const model = live(feedbackUri);

      model.get('thumb', function (error, thumbState) {
        if (error) throw error;
        actions.setStateForFeedbackNode(node, thumbState);

        // when the initial state is known, we listen for updates
        // so we can update all the buttons for this URI later
        model.on('update', changeHandlers[feedbackUri]);
      }, live.ASAP);
    },

    setStateForURI: function (feedbackUri, thumbState) {
      let numAffectedButtons = 0;
      const trackUri = (0, _formatLists.splitFeedbackUri)(feedbackUri)[1];

      const nodes = $(document).search(SELECTOR_FEEDBACK_BUTTON);
      if (!nodes) return numAffectedButtons;

      for (let i = 0, l = nodes.length; i < l; i++) {
        const node = $(nodes[i]);
        const buttonURI = getURIFromNode(node);
        if (trackUri === buttonURI) {
          numAffectedButtons++;
          actions.setStateForFeedbackNode(node, thumbState);
        }
      }

      return numAffectedButtons;
    },

    setStateForFeedbackNode: function (node, thumbState) {
      const feedbackNode = $(node[0].closest('[data-button="feedback"]')) || $(node[0].querySelector('[data-button="feedback"]'));
      if (!feedbackNode) return;
      updateFeedbackUI(feedbackNode[0], thumbState);
    }
  };

  const update = exports.update = function (node, nodes) {
    if (!isAttached) return;

    const innerNodes = $(nodes) || $(node) || $(document).search(SELECTOR_FEEDBACK_BUTTON);
    if (!innerNodes) return;

    const contextNode = node || $(document).search('[data-context]');

    for (let i = 0, l = innerNodes.length; i < l; i++) {
      actions.addListenerForNode($(innerNodes[i]), $(contextNode));
    }
  };

  const handleScrollShow = function (data) {
    update(data.pageNode, data.nodes);
  };

  /**
   * Attach the event listeners for the module.
   * Part of the spotify-events interface.
   */
  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    const doc = $(document);
    doc.delegate('click', SELECTOR_FEEDBACK_BUTTON, handleFeedbackClick);

    center.on('scroll-show-before', handleScrollShow);
  };

  /**
   * Detach the event listeners for the module.
   * Part of the spotify-events interface.
   */
  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    const doc = $(document);
    doc.undelegate('click', SELECTOR_FEEDBACK_BUTTON, handleFeedbackClick);

    center.off('scroll-show-before', handleScrollShow);
  };

  },{"../live":413,"../live-wrapped-uri":412,"../playlist-utils/format-lists":444,"../spotify-elements":460,"./center":471,"./util/dom":541}],485:[function(require,module,exports){
  'use strict';

  const $ = require('../spotify-elements');
  const live = require('../live');
  const center = require('./center');
  const stickyEvents = require('./sticky');
  const cosmos = require('./util/cosmos');
  const merge = require('mout/object/merge');
  const deepEquals = require('mout/lang/deepEquals');
  const getOriginUri = require('../live-wrapped-uri').getOriginUri;
  const appUtil = require('./util/app');

  const SCROLL_PADDING = 8;
  const STRING_FILTER_KEY = 'list-filter-string-';
  const SESSION_STORAGE = 'spotify:session-storage';

  let isAttached = false;
  let states;
  let lastEmittedStates;

  let controlMessageSubscription;

  function update(node) {
    if (!isAttached) return;

    const newNode = $(node) || $(document);
    const nodes = newNode.matches('[data-filter]') ? [newNode[0]] : newNode.search('[data-filter]');
    if (!nodes) {
      return;
    }
    nodes.forEach(function (n) {
      const uri = getURI(n);
      if (!uri) {
        return;
      }

      // When no state is initialized for the uri, initialize it and set the string from the DOM.
      // This is the case when the playlist app loaded a URI that globally has a filter string set.
      const hasState = states[uri];
      if (!hasState) {
        const inputElement = $(n).find('input[type=text]')[0];
        const value = inputElement.value;
        if (value) {
          updateState(uri, {
            activated: true,
            enteredString: value
          });
        }
      }

      handleStale(uri);
    });
  }

  function handleStale(uri) {
    render(uri);

    const state = getState(uri);
    const stateHasBeenEmitted = deepEquals(state, lastEmittedStates[uri]);
    if (!stateHasBeenEmitted) {
      lastEmittedStates[uri] = state;
      const value = state.activated ? state.enteredString : '';
      emitFilterRequest(uri, value);
      persistFilterOnSessionStorage(uri, value);
    }
  }

  function render(uri) {
    const $candidateContainers = $(document).search('[data-uri] [data-filter]');
    if (!$candidateContainers) return;

    const $matchingCandidates = $candidateContainers.filter(function (container) {
      return getURI(container) === uri;
    });
    $matchingCandidates.forEach(function (mainElement) {
      const state = getState(uri);
      const inputElement = $(mainElement).find('input[type=text]')[0];
      const wrapperElement = $(mainElement).find('.h-search-wrapper')[0];
      if (state.activated) {
        if (!$(wrapperElement).hasClass('focus')) {
          $(wrapperElement).addClass('focus');

          mainElement.setAttribute('data-sticky', '');
          stickyEvents.update();
        }

        // NOTE: Setting input.value makes the cursor jump
        // which is annoying when changing typos in the
        // search field. Only set value if text ACTUALLY
        // changes:
        if (inputElement.value !== state.enteredString) {
          inputElement.value = state.enteredString;
        }
      } else {
        inputElement.blur();
        if ($(wrapperElement).hasClass('focus')) {
          $(wrapperElement).removeClass('focus');

          mainElement.removeAttribute('data-sticky');
          stickyEvents.update();
        }
        inputElement.value = '';
      }
    });
  }

  function focusAndSelectInput(inputElement) {
    // Only focus and select the input text if doesn't have focus already.
    if (document.activeElement !== inputElement) {
      inputElement.focus();
      inputElement.select();
    }
  }

  function scrollIntoView(inputElement) {
    const rect = inputElement.getBoundingClientRect();

    // Only scroll if the input is out of view
    const filterFieldOffset = rect.top - SCROLL_PADDING;
    if (filterFieldOffset < 0 || rect.bottom > window.innerHeight) {
      window.scrollTo(0, window.pageYOffset + filterFieldOffset);
    }
  }

  function emitFilterRequest(uri, value) {
    center.emit('filter-request', uri, value);
  }

  function persistFilterOnSessionStorage(uri, value) {
    const newUri = getOriginUri(uri) || uri;

    const key = STRING_FILTER_KEY + newUri;
    const publish = {};
    publish[key] = value;
    live(SESSION_STORAGE).publish(publish);
  }

  function handleCancelClick(e) {
    clear(getURI(e.target));
  }

  function handleInputInput(e) {
    updateState(getURI(e.target), { enteredString: e.target.value });
  }

  function handleInputKeyup(e) {
    const isEscape = e.keyCode === 27;
    if (isEscape) {
      clear(getURI(e.target));
    }
  }

  function handleInputFocus(e) {
    updateState(getURI(e.target), { activated: true });
  }
  function handleInputFocusOut(e) {
    const state = getState(getURI(e.target));
    if (state.enteredString === '') {
      updateState(getURI(e.target), { activated: false });
    }
  }

  function clear(uri) {
    updateState(uri, { activated: false, enteredString: '' });
  }

  function getState(uri) {
    return states[uri] || {
      activated: false,
      enteredString: ''
    };
  }

  function updateState(uri, newUpdateState) {
    states[uri] = merge(getState(uri), newUpdateState);
    handleStale(uri);
  }

  function getURI(element) {
    let uri = element.getAttribute('data-uri');
    if (!uri) {
      const parents = $(element).parents('[data-uri]');
      if (parents) {
        uri = parents[0].getAttribute('data-uri');
      }
    }
    uri = getOriginUri(uri) || uri;

    // We use the data-uri as a key for state, but the uri of the
    // container might change to the "sorted" versions of the
    // original uri. From a filter UX state standpoint, these are the
    // same, so we normalize it here.
    return uri || null;
  }

  const attach = function attach() {
    if (isAttached) {
      return;
    }
    isAttached = true;
    states = {};
    lastEmittedStates = {};
    controlMessageSubscription = cosmos.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (_, response) {
      if (!appUtil.isActive()) return;

      const isMessageOfTypeFind = response && response.body && response.body.type === 'filter';
      if (!isMessageOfTypeFind) return;
      $('[data-filter]').forEach(function (mainElement, i) {
        updateState(getURI(mainElement), {
          activated: true
        });

        const inputElement = $(mainElement).find('input[type=text]')[0];
        if (inputElement) {
          // Only scroll first filter into view.
          if (i === 0) {
            scrollIntoView(inputElement);
          }

          focusAndSelectInput(inputElement);
        }
      });
    });

    center.on('filter-reset', clear);

    $(document).delegate('click', '[data-filter] .h-search-close', handleCancelClick);
    $(document).delegate('click', '[data-filter-reset]', handleCancelClick);
    $(document).delegate('input', '[data-filter] input', handleInputInput);
    $(document).delegate('keyup', '[data-filter] input', handleInputKeyup);
    $(document).delegate('focusin', '[data-filter] input', handleInputFocus);
    $(document).delegate('focusout', '[data-filter] input', handleInputFocusOut);
  };

  const detach = function detach() {
    if (!isAttached) return;
    states = null;
    controlMessageSubscription.cancel();

    center.off('filter-reset', clear);

    $(document).undelegate('click', '[data-filter] .h-search-close', handleCancelClick);
    $(document).undelegate('click', '[data-filter-reset]', handleCancelClick);
    $(document).undelegate('input', '[data-filter] input', handleInputInput);
    $(document).undelegate('keyup', '[data-filter] input', handleInputKeyup);
    $(document).undelegate('focusin', '[data-filter] input', handleInputFocus);
    $(document).undelegate('focusout', '[data-filter] input', handleInputFocusOut);
    isAttached = false;
  };

  // Tells native container that the current app can handle filter
  // commands. Enables filter commands in the native menu,
  // along with corresponding keyboard shortcuts.
  const broadcast = function broadcast(enabled) {
    if (enabled === undefined) {
      throw new Error('broadcast requires enabled argument');
    }
    cosmos.post({
      url: 'sp://messages/v1/container/control',
      body: {
        type: 'update_menu_state',
        enable_filter_item: enabled
      }
    });
  };

  module.exports = {
    attach: attach,
    detach: detach,
    update: update,
    broadcast: broadcast
  };

  },{"../live":413,"../live-wrapped-uri":412,"../spotify-elements":460,"./center":471,"./sticky":534,"./util/app":539,"./util/cosmos":540,"mout/lang/deepEquals":795,"mout/object/merge":812}],486:[function(require,module,exports){
  (function (global){
  'use strict';

  var _glue = require('../glue');

  var _glue2 = _interopRequireDefault(_glue);

  var _frameUpdater = require('../frame-updater');

  var _cancellationTokenSource = require('../cancellation-token-source');

  var _cancellationTokenSource2 = _interopRequireDefault(_cancellationTokenSource);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // Export _-prefixed functions for unit tests. This is so that we don't have to
  // repeat all the tests for the contents of these functions in all situations
  // it's run in and lets us test the functions as units and test that the various
  // situations call these functions.

  let isAttached = false;
  let isFontLoaded = false;
  let topBarHeight = 0;
  let headerHeight = 0;
  let lastHeaderHeight = 0;
  let stickyHeight = 0;
  let currentScrollY = 0;
  let lastScrollY = 0;
  let lastScrollYDiffs = [0, 0, 0, 0, 0];
  let lastLoadedImageNode = null;
  let scrollListenerId = 0;
  let needsTitleSizeUpdate = true;
  let lastUpdatedTitleNode = null;
  let lastUpdatedTitleContent = '';
  let fontPromise = null;
  let cancellationTokenSource = null;
  let frameRequestIds = [];
  let lastHeaderNode = null;
  let scrollNode = null;
  let lastDescriptionNode = null;
  let lastDescriptionMouseEnterHandler = null;
  let lastDescriptionMouseLeaveHandler = null;
  let fullDescriptionNode = null;

  exports._updateHeader = function _updateHeader() {
    const header = document.querySelector('[data-glue-page-header]');

    // Optimize to only run header updates when scrolling within the header area
    // at the top of the page, and also when the current scroll event is below the
    // header but the previous event was within the header.
    if (header !== lastHeaderNode || currentScrollY < headerHeight || lastScrollY < headerHeight || headerHeight !== lastHeaderHeight) {
      lastHeaderNode = header;
      lastHeaderHeight = headerHeight;

      removeDescriptionHandlers();
      addDescriptionHandlers();

      updateHeaderBackgroundPosition();
      updateHeaderAlphaMask();
      updateHeaderBackgroundScrollOverlay();
      updateHeaderBackgroundScrollOverlayEllipse();
      updateHeaderImageScaling();
    }
  };

  // This function runs first in each update cycle and sets variables scoped to
  // the module. Ideally each function would just read the value it needs, but for
  // performance reasons we do this once at the start of each update.
  exports._updateHeaderSizes = function _updateHeaderSizes() {
    const header = document.querySelector('[data-glue-page-header]');
    if (header) {
      const node = scrollNode === document ? document.documentElement : scrollNode;
      topBarHeight = parseInt(node.getAttribute('data-top-bar-height'), 10) || 0;
      headerHeight = header.offsetHeight;
      stickyHeight = parseInt(header.getAttribute('data-glue-page-header-sticky-height'), 10) || 0;
    } else {
      topBarHeight = 0;
      headerHeight = 0;
      stickyHeight = 0;
    }
  };

  function updateHeaderAlphaMask() {
    const headerContent = document.querySelector('[data-glue-page-header-content]');
    if (headerContent) {
      const maskHeight = 24;
      const offset1 = currentScrollY + topBarHeight;
      const offset2 = offset1 + maskHeight;

      headerContent.style.webkitMaskImage = `linear-gradient(to bottom, transparent ${offset1}px, black ${offset2}px)`;
    }
  }

  function updateHeaderBackgroundPosition() {
    const headerBackground = document.querySelector('[data-glue-page-header-background]');
    if (headerBackground) {
      const isSticky = currentScrollY > headerHeight - stickyHeight;
      headerBackground.style.position = isSticky ? 'fixed' : '';
      headerBackground.style.top = isSticky ? `-${headerHeight - stickyHeight}px` : '';
      // JSDom doesn't seem to support the `auto` keyword as a value for bottom
      // so we set it on a different property to be able to test it in unit tests.
      headerBackground.style._bottom = isSticky ? 'auto' : '';
      headerBackground.style.bottom = headerBackground.style._bottom;
      headerBackground.style.height = isSticky ? `${headerHeight}px` : '';
    }

    const headerImage = document.querySelector('[data-glue-page-header-background-image]');
    if (headerImage) {
      const currentTransform = headerImage.style.transform || '';
      headerImage.style.transform = `${currentTransform.replace(/translateY\(.*?\)/, '')} translateY(${Math.min(currentScrollY, headerHeight - stickyHeight)}px)`.trim();
    }
  }

  function updateHeaderBackgroundScrollOverlay() {
    const scrollOverlay = document.querySelector('[data-glue-page-header-background-scroll-overlay]');
    if (scrollOverlay) {
      const maxOpacity = 0.4;
      scrollOverlay.style.opacity = Math.round(Math.min(1, currentScrollY / (headerHeight - stickyHeight)) * maxOpacity * 1000) / 1000;
    }
  }

  function updateHeaderBackgroundScrollOverlayEllipse() {
    const scrollPercentage = Math.min(1, currentScrollY / (headerHeight - stickyHeight));

    const scrollOverlay = document.querySelector('[data-glue-page-header-background-scroll-overlay-ellipse]');
    if (scrollOverlay) {
      scrollOverlay.style.opacity = Math.round(Math.min(1, scrollPercentage * 2) * 1000) / 1000;
    }

    const scrollOverlayBackdrop = document.querySelector('[data-glue-page-header-background-scroll-overlay-ellipse-backdrop]');
    if (scrollOverlayBackdrop) {
      scrollOverlayBackdrop.style.opacity = Math.round(scrollPercentage * 1000) / 1000;
    }
  }

  function updateHeaderImageScaling() {
    const headerImage = document.querySelector('[data-glue-page-header-background-image]');
    if (headerImage) {
      const loader = document.querySelector('[data-glue-page-header-background-image-loader]');
      const isImageLoaded = loader ? loader.classList.contains('glue-page-header__background-image-loader--is-loaded') : false;
      if (isImageLoaded) {
        const maxScale = 1.07;
        const minScale = 1;
        const scrollPercentage = Math.min(1, currentScrollY / (headerHeight - stickyHeight));
        const scale = Math.round((maxScale - scrollPercentage * (maxScale - minScale)) * 1000) / 1000;
        const currentTransform = headerImage.style.transform || '';
        headerImage.style.transform = `${currentTransform.replace(/scale\(.*?\)/, '')} scale(${scale})`.trim();
      }
    }
  }

  function addDescriptionHandlers() {
    const headerNode = document.querySelector('[data-glue-page-header]');
    const descriptionNode = document.querySelector('[data-glue-page-header-description]');
    if (!headerNode || !descriptionNode) {
      return;
    }

    lastDescriptionNode = descriptionNode;

    lastDescriptionMouseEnterHandler = event => {
      // Only show the full description if it doesn't fit already.
      if (event.target.scrollHeight !== event.target.clientHeight) {
        const rect = event.target.getBoundingClientRect();
        fullDescriptionNode = event.target.cloneNode(true);
        fullDescriptionNode.addEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
        fullDescriptionNode.classList.add('glue-page-header__full-description-overlay');
        fullDescriptionNode.style.top = `${rect.top}px`;
        fullDescriptionNode.style.left = `${rect.left}px`;
        fullDescriptionNode.style.width = `${rect.width}px`;
        headerNode.appendChild(fullDescriptionNode);
      }
    };

    lastDescriptionMouseLeaveHandler = event => {
      // Hide the full description if leaving the description area, but only if
      // the user is not hovering the full description or any link inside of it.
      if (fullDescriptionNode && event.relatedTarget !== fullDescriptionNode && !fullDescriptionNode.contains(event.relatedTarget)) {
        fullDescriptionNode.parentNode.removeChild(fullDescriptionNode);
        fullDescriptionNode.removeEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
        fullDescriptionNode = null;
      }
    };

    lastDescriptionNode.addEventListener('mouseenter', lastDescriptionMouseEnterHandler);
    lastDescriptionNode.addEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
  }

  function removeDescriptionHandlers() {
    if (fullDescriptionNode) {
      fullDescriptionNode.removeEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
      fullDescriptionNode.parentNode.removeChild(fullDescriptionNode);
      fullDescriptionNode = null;
    }

    if (lastDescriptionMouseEnterHandler) {
      lastDescriptionNode.removeEventListener('mouseenter', lastDescriptionMouseEnterHandler);
      lastDescriptionMouseEnterHandler = null;
    }

    if (lastDescriptionMouseLeaveHandler) {
      lastDescriptionNode.removeEventListener('mouseleave', lastDescriptionMouseLeaveHandler);
      lastDescriptionMouseLeaveHandler = null;
    }

    lastDescriptionNode = null;
  }

  exports._updateTitleTypeSize = function _updateTitleTypeSize() {
    const title = document.querySelector('[data-glue-page-header-content] [data-glue-page-header-title]');
    if (title) {
      // Optimize performance by only updating if specifically needed (triggered
      // by resize for example) or if the title node is different or if title
      // content changed.
      const isNewNode = title !== lastUpdatedTitleNode;
      const isNewContent = title.textContent !== lastUpdatedTitleContent;
      if (title && (needsTitleSizeUpdate || isNewNode || isNewContent)) {
        needsTitleSizeUpdate = false;
        lastUpdatedTitleNode = title;
        lastUpdatedTitleContent = title.textContent;

        _glue2.default.responsiveTitleType.setSizeForTitle(title, {
          useLargeTitle: title.hasAttribute('data-glue-page-header-use-large-title')
        });

        // Force an update of sizes since it might have changed due to title size
        exports._updateHeaderSizes();
      }
    }
  };

  exports._updateScrollClassNames = function _updateScrollClassNames() {
    const header = document.querySelector('[data-glue-page-header]');
    if (header) {
      const hasNewHeaderNode = !header._hasBeenSeen;

      // Disable header animations when the header node changes. This solves the
      // problem where the header content would otherwise animate when switching
      // between playlists.
      if (hasNewHeaderNode) {
        header._hasBeenSeen = true;
        header.classList.add('glue-page-header--with-no-animations');
      } else {
        frameRequestIds.push((0, _frameUpdater.requestFrame)(null, () => {
          header.classList.remove('glue-page-header--with-no-animations');
        }));
      }

      lastScrollYDiffs.push(Math.abs(currentScrollY - lastScrollY));
      lastScrollYDiffs.shift();

      const threshold = 30;
      const isScrollingFast = lastScrollYDiffs.reduce((isFast, diff) => {
        return isFast || diff > threshold;
      }, false);

      // This allows the header to go into a fast scroll mode where the header
      // animations are tweaked a bit.
      if (isScrollingFast) {
        header.classList.add('glue-page-header--with-fast-scrolling');
      } else {
        header.classList.remove('glue-page-header--with-fast-scrolling');
      }

      if (global.onPageHeaderToggleFastScrolling) {
        global.onPageHeaderToggleFastScrolling(isScrollingFast);
      }
    }
  };

  exports._updateHeaderImageLoading = function _updateHeaderImageLoading() {
    const headerImage = document.querySelector('[data-glue-page-header-background-image]');

    if (headerImage) {
      if (headerImage === lastLoadedImageNode) {
        return;
      }

      const imageUrl = headerImage.getAttribute('data-glue-page-header-background-image-url');

      lastLoadedImageNode = headerImage;

      if (imageUrl) {
        const image = new window.Image();
        image.onload = () => {
          const loader = document.querySelector('[data-glue-page-header-background-image-loader]');

          if (!loader.classList.contains('glue-page-header__background-image-loader--is-loaded')) {
            loader.classList.add('glue-page-header__background-image-loader--is-loaded');
            loader.classList.add('glue-page-header__background-image-loader--with-loading-animation');
            updateHeaderImageScaling();

            loader.addEventListener('transitionend', function handler() {
              loader.removeEventListener('transitionend', handler);
              loader.classList.remove('glue-page-header__background-image-loader--with-loading-animation');
            });
          }
        };
        image.src = imageUrl;
      }
    }
  };

  exports._updateScrollValue = function _updateScrollValue() {
    currentScrollY = scrollNode === document ? window.scrollY : scrollNode.scrollTop;
  };

  exports._updateLastScrollValue = function _updateLastScrollValue() {
    lastScrollY = currentScrollY;
  };

  function handleResize() {
    needsTitleSizeUpdate = true;

    exports._ensureFontIsLoaded(error => {
      if (error) {
        console.error(error);
        return;
      }
      exports._updateTitleTypeSize();
      exports._updateHeaderSizes();
      exports._updateHeader();
    });
  }

  exports._ensureFontIsLoaded = function _ensureFontIsLoaded(callback) {
    if (isFontLoaded) {
      callback(null);
      return;
    }
    if (!fontPromise) {
      fontPromise = _glue2.default.responsiveTitleType.loadFont();
    }
    const token = cancellationTokenSource.token();
    fontPromise.then(() => {
      if (token.isCanceled()) {
        callback(token.operationCanceledError());
        return;
      }
      isFontLoaded = true;
      callback(null);
    }, fontPromiseError => {
      callback(token.errorIfCanceled() || fontPromiseError);
    });
  };

  exports.attach = function attach() {
    if (!isAttached) {
      isAttached = true;
      cancellationTokenSource = new _cancellationTokenSource2.default();

      if (!scrollNode) {
        scrollNode = document;
      }

      exports._ensureFontIsLoaded(error => error && console.error(error));
      exports._updateHeaderSizes();

      scrollListenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, () => {
        exports._updateScrollValue();
      }, () => {
        exports._updateScrollClassNames();
        exports._updateHeader();
        exports._updateLastScrollValue();
      });

      window.addEventListener('resize', handleResize);
    }
  };

  exports.detach = function detach() {
    if (isAttached) {
      cancellationTokenSource.cancel();
      cancellationTokenSource = null;

      frameRequestIds.forEach(id => {
        (0, _frameUpdater.cancelFrame)(id);
      });
      frameRequestIds = [];

      removeDescriptionHandlers();

      isAttached = false;
      isFontLoaded = false;
      fontPromise = null;
      headerHeight = 0;
      stickyHeight = 0;
      currentScrollY = 0;
      lastScrollY = 0;
      lastScrollYDiffs = [0, 0, 0, 0, 0];
      needsTitleSizeUpdate = true;
      lastUpdatedTitleNode = null;
      lastUpdatedTitleContent = '';
      scrollNode = null;
      lastDescriptionNode = null;
      lastDescriptionMouseEnterHandler = null;
      lastDescriptionMouseLeaveHandler = null;
      fullDescriptionNode = null;

      (0, _frameUpdater.removeDebouncedScrollListener)(scrollListenerId);
      window.removeEventListener('resize', handleResize);
    }
  };

  exports.update = function update() {
    if (!isAttached) {
      return;
    }

    frameRequestIds.push((0, _frameUpdater.requestFrame)(() => {
      exports._updateScrollValue();
    }, () => {
      exports._updateScrollClassNames();
      exports._updateHeaderImageLoading();
    }));

    exports._ensureFontIsLoaded(error => {
      if (error) {
        console.error(error);
        return;
      }
      frameRequestIds.push((0, _frameUpdater.requestFrame)(() => {
        exports._updateHeaderSizes();
      }, () => {
        exports._updateTitleTypeSize();
        exports._updateHeader();
      }));
    });
  };

  // A way to let an app override the node to listen for scroll events on.
  // This has to be called before `attach` is called.
  exports.setScrollNode = function setScrollNode(node) {
    scrollNode = node;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../cancellation-token-source":122,"../frame-updater":132,"../glue":159}],487:[function(require,module,exports){
  arguments[4][1][0].apply(exports,arguments)
  },{"../../../libs/spotify-i18n":562,"./json/cs.json":488,"./json/de.json":489,"./json/el.json":490,"./json/en.json":491,"./json/es-419.json":492,"./json/es.json":493,"./json/fi.json":494,"./json/fr-CA.json":495,"./json/fr.json":496,"./json/hu.json":497,"./json/id.json":498,"./json/it.json":499,"./json/ja.json":500,"./json/nl.json":501,"./json/pl.json":502,"./json/pt-BR.json":503,"./json/sv.json":504,"./json/th.json":505,"./json/tr.json":506,"./json/vi.json":507,"./json/zh-Hant.json":508,"./json/zsm.json":509,"dup":1}],488:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 položka",
      "other": "Počet položek: {0}"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 skladba",
      "other": "Počet skladeb: {0}"
    },
    "drag_tooltip_many_artists": {
      "one": "1 umělec",
      "other": "Počet umělců: {0}"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "Počet alb: {0}"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlistů"
    },
    "drag_tooltip_many_users": {
      "one": "1 uživatel",
      "other": "Počet uživatelů: {0}"
    }
  }
  },{}],489:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 Element",
      "other": "{0} Elemente"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 Titel",
      "other": "{0} Titel"
    },
    "drag_tooltip_many_artists": {
      "one": "1 Künstler",
      "other": "{0} Künstler"
    },
    "drag_tooltip_many_albums": {
      "one": "1 Album",
      "other": "{0} Alben"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 Playlist",
      "other": "{0} Playlists"
    },
    "drag_tooltip_many_users": {
      "one": "1 User",
      "other": "{0} User"
    }
  }
  },{}],490:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 στοιχείο",
      "other": "{0} στοιχεία"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 κομμάτι",
      "other": "{0} κομμάτια"
    },
    "drag_tooltip_many_artists": {
      "one": "1 καλλιτέχνης",
      "other": "{0} καλλιτέχνες"
    },
    "drag_tooltip_many_albums": {
      "one": "1 άλμπουμ",
      "other": "{0} άλμπουμ"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} λίστες"
    },
    "drag_tooltip_many_users": {
      "one": "1 χρήστης",
      "other": "{0} χρήστες"
    }
  }
  },{}],491:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 item",
      "other": "{0} items"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 track",
      "other": "{0} tracks"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artist",
      "other": "{0} artists"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} albums"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlists"
    },
    "drag_tooltip_many_users": {
      "one": "1 user",
      "other": "{0} users"
    }
  }
  },{}],492:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 elemento",
      "other": "{0} elementos"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 canción",
      "other": "{0} canciones"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artista",
      "other": "{0} artistas"
    },
    "drag_tooltip_many_albums": {
      "one": "1 álbum",
      "other": "{0} álbumes"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "Playlists de {0}"
    },
    "drag_tooltip_many_users": {
      "one": "1 usuario",
      "other": "{0} usuarios"
    }
  }
  },{}],493:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 elemento",
      "other": "{0} elementos"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 canción",
      "other": "{0} canciones"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artista",
      "other": "{0} artistas"
    },
    "drag_tooltip_many_albums": {
      "one": "1 álbum",
      "other": "{0} álbumes"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlists"
    },
    "drag_tooltip_many_users": {
      "one": "1 usuario",
      "other": "{0} usuarios"
    }
  }
  },{}],494:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 kohde",
      "other": "{0} kohdetta"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 kappale",
      "other": "{0} kappaletta"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artisti",
      "other": "{0} artistia"
    },
    "drag_tooltip_many_albums": {
      "one": "1 albumi",
      "other": "{0} albumia"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 soittolista",
      "other": "{0} soittolistaa"
    },
    "drag_tooltip_many_users": {
      "one": "1 käyttäjä",
      "other": "{0} käyttäjää"
    }
  }
  },{}],495:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 article",
      "other": "{0} articles"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 chanson",
      "other": "{0} chansons"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artiste",
      "other": "{0} artistes"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} albums"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 liste de lecture",
      "other": "{0} listes de lecture"
    },
    "drag_tooltip_many_users": {
      "one": "1 utilisateur",
      "other": "{0} utilisateur"
    }
  }
  },{}],496:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 élément",
      "other": "{0} éléments"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 titre",
      "other": "{0} titres"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artiste",
      "other": "{0} artistes"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} albums"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlists"
    },
    "drag_tooltip_many_users": {
      "one": "1 utilisateur",
      "other": "{0} utilisateurs"
    }
  }
  },{}],497:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 elem",
      "other": "{0} elem"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 dal",
      "other": " {0} dal"
    },
    "drag_tooltip_many_artists": {
      "one": "1 előadó",
      "other": "{0} előadó"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} album"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 műsorlista",
      "other": "{0} lejátszási lista"
    },
    "drag_tooltip_many_users": {
      "one": "1 felhasználó",
      "other": "{0} felhasználó"
    }
  }
  },{}],498:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 item",
      "other": "{0} item"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 lagu",
      "other": "{0} lagu"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artis",
      "other": "{0} artis"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} album"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlist"
    },
    "drag_tooltip_many_users": {
      "one": "1 pengguna",
      "other": "{0} pengguna"
    }
  }
  },{}],499:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 elemento",
      "other": "{0} elementi"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 brano",
      "other": "{0} brani"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artista",
      "other": "{0} artisti"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} album"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlist"
    },
    "drag_tooltip_many_users": {
      "one": "1 utente",
      "other": "{0} utenti"
    }
  }
  },{}],500:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1個のアイテム",
      "other": "{0}個のアイテム"
    },
    "drag_tooltip_many_tracks": {
      "one": "1曲",
      "other": "{0}曲"
    },
    "drag_tooltip_many_artists": {
      "one": "1人のアーティスト",
      "other": "{0}人のアーティスト"
    },
    "drag_tooltip_many_albums": {
      "one": "1枚のアルバム",
      "other": "{0}枚のアルバム"
    },
    "drag_tooltip_many_playlists": {
      "one": "1つのプレイリスト",
      "other": "{0}個のプレイリスト"
    },
    "drag_tooltip_many_users": {
      "one": "1人のユーザー",
      "other": "{0}人のユーザー"
    }
  }
  },{}],501:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 item",
      "other": "{0} items"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 nummer",
      "other": "{0} nummers"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artist",
      "other": "{0} artiesten"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} albums"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 afspeellijst",
      "other": "{0} afspeellijsten"
    },
    "drag_tooltip_many_users": {
      "one": "1 gebruiker",
      "other": "{0} gebruikers"
    }
  }
  },{}],502:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 element",
      "other": "Elementy: {0}"
    },
    "drag_tooltip_many_tracks": {
      "one": "1utwór",
      "other": "Liczba utworów: {0}"
    },
    "drag_tooltip_many_artists": {
      "one": "1 wykonawca",
      "other": "Wykonawcy: {0}"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "Albumy: {0}"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlista",
      "other": "{0} playlisty"
    },
    "drag_tooltip_many_users": {
      "one": "1 użytkownik",
      "other": "Użytkownicy: {0}"
    }
  }
  },{}],503:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 item",
      "other": "{0} itens"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 faixa",
      "other": "{0} faixas"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artista",
      "other": "{0} artistas"
    },
    "drag_tooltip_many_albums": {
      "one": "1 álbum",
      "other": "{0} álbuns"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlists"
    },
    "drag_tooltip_many_users": {
      "one": "1 usuário",
      "other": "{0} usuários"
    }
  }
  },{}],504:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 objekt",
      "other": "{0} objekt"
    },
    "drag_tooltip_many_tracks": {
      "one": "Ett spår",
      "other": "{0} spår"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artist",
      "other": "{0} artister"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} album"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 spellista",
      "other": "{0} spellistor"
    },
    "drag_tooltip_many_users": {
      "one": "1 användare",
      "other": "{0} användare"
    }
  }
  },{}],505:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 รายการ",
      "other": "{0} รายการ"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 แทร็ก",
      "other": "{0} แทร็ก"
    },
    "drag_tooltip_many_artists": {
      "one": "ศิลปิน 1 ราย",
      "other": "ศิลปิน {0} ราย"
    },
    "drag_tooltip_many_albums": {
      "one": "1 อัลบั้ม",
      "other": "{0} อัลบั้ม"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 เพลย์ลิสต์",
      "other": "{0} เพลย์ลิสต์"
    },
    "drag_tooltip_many_users": {
      "one": "ผู้ใช้ 1 คน",
      "other": "ผู้ใช้ {0} คน"
    }
  }
  },{}],506:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 Öge",
      "other": "{0} öge"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 parça",
      "other": "{0} parça"
    },
    "drag_tooltip_many_artists": {
      "one": "1 sanatçı",
      "other": "{0} sanatçı"
    },
    "drag_tooltip_many_albums": {
      "one": "1 albüm",
      "other": "{0} albüm"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 çalma listesi",
      "other": "{0} çalma listesi"
    },
    "drag_tooltip_many_users": {
      "one": "1 kullanıcı",
      "other": "{0} kullanıcı"
    }
  }
  },{}],507:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 mục",
      "other": "{0} mục"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 bản nhạc",
      "other": "{0} bản nhạc"
    },
    "drag_tooltip_many_artists": {
      "one": "1 nghệ sĩ",
      "other": "{0} nghệ sĩ"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} album"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 playlist",
      "other": "{0} playlist"
    },
    "drag_tooltip_many_users": {
      "one": "1 người dùng",
      "other": "{0} người dùng"
    }
  }
  },{}],508:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 個項目",
      "other": "{0} 個項目"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 首歌曲",
      "other": "{0} 首歌曲"
    },
    "drag_tooltip_many_artists": {
      "one": "1 位藝人",
      "other": "{0} 位藝人"
    },
    "drag_tooltip_many_albums": {
      "one": "1 張專輯",
      "other": "{0} 張專輯"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 個播放清單",
      "other": "{0} 個播放清單"
    },
    "drag_tooltip_many_users": {
      "one": "1 位使用者",
      "other": "{0} 位使用者"
    }
  }
  },{}],509:[function(require,module,exports){
  module.exports={
    "drag_tooltip_many_items": {
      "one": "1 item",
      "other": "{0} item"
    },
    "drag_tooltip_many_tracks": {
      "one": "1 lagu",
      "other": "{0} lagu"
    },
    "drag_tooltip_many_artists": {
      "one": "1 artis",
      "other": "{0} artis"
    },
    "drag_tooltip_many_albums": {
      "one": "1 album",
      "other": "{0} album"
    },
    "drag_tooltip_many_playlists": {
      "one": "1 senarai main",
      "other": "{0} senarai main"
    },
    "drag_tooltip_many_users": {
      "one": "1 pengguna",
      "other": "{0} pengguna"
    }
  }
  },{}],510:[function(require,module,exports){
  'use strict';

  const modules = [require('./lang'), require('./anchor'), require('./player'), require('./dragndrop'), require('./add'), require('./contextmenu'), require('./sticky'), require('./navbar'), require('./offline'), require('./filter'), require('./tooltip'), require('./menu'), require('./scroll'), require('./scrollbar'), require('./header'), require('./thumbs'), require('./feedback'), require('./cards')];

  const events = {};

  let isAttached = false;

  events.update = function update(node) {
    if (!isAttached) return;

    modules.forEach(function (module) {
      module.update(node);
    });
  };

  events.attach = function attach() {
    if (isAttached) return;
    isAttached = true;

    modules.forEach(function (module) {
      module.attach();
    });
  };

  events.detach = function detach() {
    if (!isAttached) return;
    isAttached = false;

    modules.forEach(function (module) {
      module.detach();
    });
  };

  module.exports = events;

  },{"./add":463,"./anchor":464,"./cards":465,"./contextmenu":472,"./dragndrop":478,"./feedback":484,"./filter":485,"./header":486,"./lang":511,"./menu":514,"./navbar":515,"./offline":516,"./player":518,"./scroll":523,"./scrollbar":524,"./sticky":534,"./thumbs":535,"./tooltip":536}],511:[function(require,module,exports){
  'use strict';

  let isAttached = false;

  exports.update = () => {};

  exports.attach = () => {
    if (isAttached) return;
    isAttached = true;

    const locale = window.__spotify && window.__spotify.locale;
    if (locale) {
      document.documentElement.setAttribute('lang', locale);
    }
  };

  exports.detach = () => {
    if (!isAttached) return;
    isAttached = false;

    document.documentElement.removeAttribute('lang');
  };

  },{}],514:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.attach = attach;
  exports.detach = detach;
  exports.update = update;

  var _throttle = require('./util/throttle');

  var _throttle2 = _interopRequireDefault(_throttle);

  var _center = require('./center');

  var _center2 = _interopRequireDefault(_center);

  var _navigation = require('../navigation');

  var _navigation2 = _interopRequireDefault(_navigation);

  var _appState = require('../navigation/app-state');

  var _appState2 = _interopRequireDefault(_appState);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const SELECTOR_MENU = '[data-menu]';
  const SELECTOR_MENU_ITEM = '[data-menu-item]';
  const SELECTOR_MENU_ITEM_DISABLED = '[data-menu-item-disabled]';
  const SELECTOR_MENU_ITEM_ENABLED = '[data-menu-item]:not([data-menu-item-disabled])';
  const SELECTOR_SUBMENU = '[data-submenu="true"]';
  const ATTRIBUTE_MENU = 'data-menu';
  const ATTRIBUTE_MENU_ITEM = 'data-menu-item';

  const navigator = new _navigation2.default.Navigator();

  let isAttached = false;

  // The state will take the following shape (a nested structure that can be any
  // number of levels deep):
  // {
  //   menu: { // null if root menu is not open
  //     node: menuNode,
  //     selectedNode: menuItemNode, // or null
  //     menu: { // null if a sub menu is not open
  //       node: subMenuNode,
  //       selectedNode: subMenuItemNode, // or null,
  //       menu: null, // null if a sub menu is not open
  //       parent: <back-reference>, // a reference to the object one level up
  //     },
  //     parent: null, // always null for the root menu
  //   }
  // }
  const state = {
    menu: null
  };

  /**
   * Handler for when the mouse is moved over a menu.
   * This is only attached for the current menu (if there is a current menu).
   *
   * @param {MouseEvent} event A mouse event.
   */
  function onMouseMove(event) {
    const isMenu = event.target.matches(SELECTOR_MENU);
    if (isMenu) {
      return;
    }

    const targetItem = event.target.closest(SELECTOR_MENU_ITEM);
    if (!targetItem) {
      return;
    }

    const targetMenu = targetItem.closest(SELECTOR_MENU);
    const targetMenuState = getStateForMenu(targetMenu);
    let activeMenuState = getStateForActiveMenu();

    if (targetItem === activeMenuState.selectedNode) {
      return;
    }

    if (targetItem.matches(SELECTOR_MENU_ITEM_DISABLED)) {
      deselectItemInMenu(activeMenuState);
    } else {
      selectItemInMenu(activeMenuState, targetMenuState, targetItem);
      activeMenuState = getStateForActiveMenu();
    }

    // When hovering over an item that has a sub menu, open the sub menu if not
    // open already.
    if (targetItem.matches(SELECTOR_SUBMENU)) {
      if (!targetMenuState.menu) {
        openSubMenu(targetMenuState, targetItem);
      }

      // When hovering over a regular item and a sub menu is currently shown, close
      // the sub menu.
    } else if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
  }
  const onMouseMoveThrottled = (0, _throttle2.default)(onMouseMove);

  /**
   * Handler for when an element gets focused.
   *
   * @param {FocusEvent} event A focus event.
   */
  function onFocus(event) {
    const targetMenu = event.target.closest(SELECTOR_MENU);
    if (targetMenu && !state.menu) {
      state.menu = {
        node: targetMenu,
        selectedNode: null,
        menu: null,
        active: true,
        parent: null
      };

      targetMenu.addEventListener('mousemove', onMouseMoveThrottled);
      targetMenu.addEventListener('mouseleave', onMouseLeave);

      // We need to ensure that before triggering the "touchstart" event in the <LI> element
      // of the node, we emulate the mouse being moved over it. This way, the listeners are
      // attached and they will fire.
      // Note: this "mouseMove" call cannot be throttled, because the "touchstart" that will
      // trigger in the <LI> will happen before the throttler fires the event. Additionally,
      // there's no need to use the throttling logic for the touchstart event.
      targetMenu.addEventListener('touchstart', onMouseMove, true);
    }
  }

  /**
   * Handler for when an element loses focus.
   *
   * @param {FocusEvent} event A blur event.
   */
  function onBlur(event) {
    const { target, relatedTarget } = event;

    if (state.menu) {
      if (target === state.menu.node) {
        // A blur on the menu (target) can mean an element inside of it gains focus.
        // No need to reset then.
        if (!relatedTarget || !target.contains(relatedTarget)) {
          hideMenu();
        }
      } else if (state.menu.node.contains(target) && !state.menu.node.contains(relatedTarget)) {
        hideMenu();
      }
    }
  }

  /**
   * Handler for when a key is pressed.
   *
   * @param {KeyboardEvent} event A keyboard event.
   */
  function onKeyDown(event) {
    // Only act on events when a menu is open
    if (!state.menu) {
      return;
    }

    const keyCode = event.keyCode;
    const isEnter = keyCode === 13;
    const isEscape = keyCode === 27;
    const isUp = keyCode === 38;
    const isDown = keyCode === 40;
    const isLeft = keyCode === 37;
    const isRight = keyCode === 39;

    if (isEnter) {
      // Look for links to follow inside the current menu item.
      const activeMenuState = getStateForActiveMenu();
      const selectedMenuItem = activeMenuState.selectedNode;
      const link = selectedMenuItem && selectedMenuItem.querySelector('a[href]');
      if (link) {
        navigator.requestOpenState(new _appState2.default(link.getAttribute('href')));
      }
      emitActivateItemEvent(selectedMenuItem);
      return;
    }

    if (isEscape) {
      hideMenu();
      return;
    }

    if (isUp || isDown) {
      const activeMenuState = getStateForActiveMenu();
      if (activeMenuState.node) {
        const newActiveMenuItem = isDown ? getMenuItemBelow(activeMenuState) : getMenuItemAbove(activeMenuState);

        if (newActiveMenuItem) {
          selectItemInMenu(activeMenuState, activeMenuState, newActiveMenuItem);
        }
      }
      return;
    }

    if (isRight) {
      const activeMenuState = getStateForActiveMenu();
      if (activeMenuState.selectedNode) {
        if (activeMenuState.selectedNode.matches(SELECTOR_SUBMENU)) {
          // Open the sub menu if not open already (might have been opened by the
          // mouse cursor)
          if (!activeMenuState.menu) {
            openSubMenu(activeMenuState, activeMenuState.selectedNode);
          }

          // Select the first item in the sub menu
          const subMenuNode = activeMenuState.menu.node;
          const firstItemInSubMenu =
          // We'd like to get firstElementChild to avoid text nodes, but since
          // JSDom doesn't support that, fall back to firstChild for tests.
          subMenuNode.firstElementChild || subMenuNode.firstChild;
          selectItemInMenu(activeMenuState, activeMenuState.menu, firstItemInSubMenu);
        }
      }
      return;
    }

    if (isLeft) {
      const activeMenuState = getStateForActiveMenu();
      if (activeMenuState.parent) {
        closeSubMenuOf(activeMenuState.parent);
      }
      return;
    }
  }

  /**
   * Handler for when the mouse leaves a menu.
   * This is only attached for the current menu (if there is a current menu).
   *
   * @param {MouseEvent} event A mouse event.
   */
  function onMouseLeave(event) {
    if (!event.relatedTarget || !event.relatedTarget.closest(SELECTOR_MENU)) {
      const activeMenuState = getStateForActiveMenu();
      deselectItemInMenu(activeMenuState);
      if (activeMenuState.menu) {
        closeSubMenuOf(activeMenuState);
      }
    }
  }

  /**
   * Handler for when the current menu item is clicked.
   * This is only attached for the current menu item (if there is one).
   *
   * @param {MouseEvent} event A mouse event.
   */
  function onItemClick(event) {
    const targetMenu = event.target.closest(SELECTOR_MENU);
    const targetMenuState = getStateForMenu(targetMenu);
    const itemNode = targetMenuState.selectedNode;

    emitActivateItemEvent(itemNode);
  }

  /**
   * In order to prevent the simulated click event when using a touchscreen,
   * we prevent default so click won't trigger. That click event would otherwise
   * trigger a click on the layer beneath since the menu is closed after activating an item.
   *
   * @param {TouchEvent} event a Touch event.
   */
  function onItemTouchStart(event) {
    event.preventDefault();
    onItemClick(event);
  }

  /**
   * Emit a center event to activate the current item.
   *
   * @param {HTMLElement} itemNode HTML element for the item.
   */
  function emitActivateItemEvent(itemNode) {
    _center2.default.emit('menu-activate-item', {
      menu: {
        id: state.menu.node.getAttribute(ATTRIBUTE_MENU) || '',
        element: state.menu.node
      },
      item: {
        id: itemNode.getAttribute(ATTRIBUTE_MENU_ITEM) || '',
        element: itemNode
      }
    });
  }

  /**
   * Set the current menu item to a new item.
   *
   * @param {Object} activeMenuState Menu state object for the currently active
   *   menu.
   * @param {Object} targetMenuState Menu state object for the menu where the item
   *   that is to be selected is located.
   * @param {HTMLElement} itemNode An HTML element for the menu item.
   */
  function selectItemInMenu(activeMenuState, targetMenuState, itemNode) {
    const isTargetSubMenu = activeMenuState.menu === targetMenuState;
    const isTargetParentMenu = isSecondContainedInFirst(targetMenuState, activeMenuState);

    // If the item is in a sub menu we only want to remove any item event
    // listeners. Removing visual selection should only happen when moving within
    // the same menu.
    if (isTargetSubMenu) {
      removeItemListeners(activeMenuState.selectedNode);
    } else {
      deselectItemInMenu(activeMenuState);
    }

    // Deselect the currently selected item in parent menu, if moving from sub
    // menu to the parent menu.
    if (isTargetParentMenu) {
      deselectItemInMenu(targetMenuState);
    }

    activeMenuState.active = false;

    if (targetMenuState.selectedNode !== itemNode) {
      itemNode.classList.add('selected');
      itemNode.focus();
      addItemListeners(itemNode);
      targetMenuState.selectedNode = itemNode;
    }

    targetMenuState.active = true;
  }

  /**
   * Deselect any selected item in the menu represented by the passed state.
   *
   * @param {Object} menuState The menu state object.
   */
  function deselectItemInMenu(menuState) {
    if (menuState.selectedNode) {
      const itemNode = menuState.selectedNode;
      itemNode.classList.remove('selected');
      removeItemListeners(itemNode);
      menuState.selectedNode = null;
    }
  }

  /**
   * Add the click listeners from an item node.
   *
   * @param {HTMLElement} itemNode An HTML element for the menu item.
   */
  function addItemListeners(itemNode) {
    itemNode.addEventListener('click', onItemClick);
    itemNode.addEventListener('touchstart', onItemTouchStart);
  }

  /**
   * Remove the click listeners from an item node.
   *
   * @param {HTMLElement} itemNode An HTML element for the menu item.
   */
  function removeItemListeners(itemNode) {
    itemNode.removeEventListener('click', onItemClick);
    itemNode.removeEventListener('touchstart', onItemTouchStart);
  }

  /**
   * Open a sub menu for the provided menu state object and item node.
   *
   * @param {Object} menuState The menu state object for the parent menu.
   * @param {HTMLElement} itemNode An HTML element for the menu item.
   */
  function openSubMenu(menuState, itemNode) {
    const menuNode = itemNode.querySelector(SELECTOR_MENU);
    if (menuNode) {
      menuState.menu = {
        parent: menuState,
        node: menuNode,
        selectedNode: null,
        menu: null,
        active: false
      };
      menuNode.classList.add('open');
    }
  }

  /**
   * Close all sub menus for the provided menu state object.
   *
   * @param {Object} menuState The menu state object for the parent menu.
   */
  function closeSubMenuOf(menuState) {
    // Close deeper sub menus first
    if (menuState.menu.menu) {
      closeSubMenuOf(menuState.menu);
    }

    // Focus the selectedNode before hiding submenu.
    // Otherwise a blur event will fire, cause the root menu to close as well.
    // See `onBlur` method in this file.
    menuState.selectedNode.focus();

    if (menuState.menu.active) {
      menuState.menu.active = false;
      menuState.active = true;
    }

    deselectItemInMenu(menuState.menu);
    menuState.menu.node.classList.remove('open');
    menuState.menu = null;
  }

  /**
   * Hide the current menu by broadcasting a message via center.
   * A listener can be added via center and the handler will then really hide it.
   *
   * @example
   * center.on('menu-hide', function(event) {
   *   if (event.menu.id === 'profile-menu') {
   *     hideProfileMenu();
   *   }
   * });
   */
  function hideMenu() {
    if (state.menu) {
      const menuNode = state.menu.node;

      menuNode.removeEventListener('mousemove', onMouseMoveThrottled);
      menuNode.removeEventListener('mouseleave', onMouseLeave);
      menuNode.removeEventListener('touchstart', onMouseMove, true);

      // Remove any sub menus
      let menuState = state.menu;
      while (menuState) {
        deselectItemInMenu(menuState);
        menuState.node.classList.remove('open');
        menuState = menuState.menu;
      }

      delete state.menu;

      _center2.default.emit('menu-hide', {
        menu: {
          id: menuNode.getAttribute(ATTRIBUTE_MENU) || '',
          element: menuNode
        }
      });
    }
  }

  /**
   * Test if the second menu state object is contained in the second state object.
   *
   * @param {Object} first Menu state object.
   * @param {Object} second Menu state object.
   *
   * @return {Boolean}        True if it is.
   */
  function isSecondContainedInFirst(first, second) {
    let statePart = first.menu;
    while (statePart && statePart !== second) {
      statePart = statePart.menu;
    }

    return !!statePart;
  }

  /**
   * Get the menu state object for the provided menu node. This assumes the node
   * is part of the state tree.
   *
   * @param {HTMLElement} menuNode The menu element.
   *
   * @return {Object} Menu state object.
   */
  function getStateForMenu(menuNode) {
    let statePart = state.menu;
    while (statePart && statePart.node !== menuNode) {
      statePart = statePart.menu;
    }

    return statePart;
  }

  /**
   * Get the menu state object for the currently active menu.
   *
   * @return {Object} Menu state object.
   */
  function getStateForActiveMenu() {
    let statePart = state.menu;
    while (statePart && !statePart.active) {
      statePart = statePart.menu;
    }

    return statePart;
  }

  /**
   * Find the menu item that is below the current one.
   * This will skip disabled menu items as well as any elements that are not
   * defined as menu items. If there is no menu item below the current one,
   * this will return null.
   *
   * @param {Object} activeMenuState Menu state object for the currently active
   *   menu.
   *
   * @return {HTMLElement?} The HTML element for the menu item, or null.
   */
  function getMenuItemBelow(activeMenuState) {
    if (!activeMenuState.selectedNode) {
      return activeMenuState.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);
    }

    let item = activeMenuState.selectedNode.nextElementSibling;
    while (item) {
      const isMenuItem = item.matches(SELECTOR_MENU_ITEM);
      const isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
      if (isMenuItem && !isDisabled) {
        break;
      }
      item = item.nextElementSibling;
    }

    return item;
  }

  /**
   * Find the menu item that is above the current one.
   * This will skip disabled menu items as well as any elements that are not
   * defined as menu items. If there is no menu item above the current one,
   * this will return null.
   *
   * @param {Object} activeMenuState Menu state object for the currently active
   *   menu.
   *
   * @return {HTMLElement?} The HTML element for the menu item, or null.
   */
  function getMenuItemAbove(activeMenuState) {
    if (!activeMenuState.selectedNode) {
      const results = activeMenuState.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);
      return results[results.length - 1] || null;
    }

    let item = activeMenuState.selectedNode.previousElementSibling;
    while (item) {
      const isMenuItem = item.matches(SELECTOR_MENU_ITEM);
      const isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
      if (isMenuItem && !isDisabled) {
        break;
      }
      item = item.previousElementSibling;
    }

    return item;
  }

  /**
   * The spotify-events style attach function. Should be called once when DOM
   * is ready.
   */
  function attach() {
    if (isAttached) return;
    isAttached = true;

    document.addEventListener('keydown', onKeyDown);

    // use capture to work around the non-bubbling events
    document.addEventListener('focus', onFocus, true);
    document.addEventListener('blur', onBlur, true);
  }

  /**
   * The spotify-events style detach function. Should be called when you no
   * longer need the events.
   */
  function detach() {
    if (!isAttached) return;
    isAttached = false;

    state.menu = null;

    document.removeEventListener('keydown', onKeyDown);
    document.removeEventListener('focus', onFocus, true);
    document.removeEventListener('blur', onBlur, true);
  }

  /**
   * The spotify-events style update function. Should be called when DOM
   * changes.
   */
  function update() {}

  },{"../navigation":440,"../navigation/app-state":439,"./center":471,"./util/throttle":543}],515:[function(require,module,exports){
  (function (global){
  'use strict';

  const $ = require('../spotify-elements');

  const live = require('../live');
  const center = require('./center');

  const NAVBAR_ATTR_NAME = 'data-navbar';
  const ITEM_ID_ATTR_NAME = 'data-navbar-item-id';
  const ITEM_MATCHER_ATTR_NAME = 'data-navbar-item-matcher';
  const VIEW_ID_ATTR_NAME = 'data-navbar-view-id';
  const ACTIVE_ID_ATTR_NAME = 'data-navbar-active-id';
  const HISTORY_POS_ATTR_NAME = 'data-navbar-history-position';
  const CLASSNAME_ACTIVE = 'active';
  const OVERFLOW_MENU_ID = 'navbar-overflow-menu';
  const STICKY_WRAPPER_ATTR_NAME = 'data-sticky-fixed-wrapper';

  const APPLICATION_MODEL_URI = 'spotify:application';

  const storedMatchers = {};

  let navbarOverflowItems;
  let isShowingNavbarOverflow;
  let shouldShowNavbarOverflow;

  const getSelector = function (name, optOperator, optMatcher) {
    if (optOperator && optMatcher) {
      return `[${name}${optOperator}"${optMatcher}"` + ']';
    }
    return `[${name}]`;
  };

  const updateOverflowMenu = function () {
    const moreMenuItem = document.querySelector('[data-navbar-item-id=navbar-overflow-menu]');
    if (!moreMenuItem) {
      return;
    }

    const canBeOpen = navbarOverflowItems && navbarOverflowItems.length;
    if (!canBeOpen) {
      shouldShowNavbarOverflow = false;
    }

    // There's no check for isShowingNavbarOverflow, the event is intentionally
    // resent on update, to support resizing.
    if (shouldShowNavbarOverflow) {
      isShowingNavbarOverflow = true;
      const descriptors = navbarOverflowItems.map(function (item) {
        const link = item.querySelector('a[href]');

        // The text is in the <a> element inside the item.
        return {
          name: item.firstElementChild && item.firstElementChild.textContent || '',
          id: item.getAttribute(ITEM_ID_ATTR_NAME),
          url: link && link.getAttribute('href'),
          active: item.classList.contains('active')
        };
      });

      const targetRect = moreMenuItem.getBoundingClientRect();
      global.top.postMessage({
        type: 'show-navbar-overflow',
        items: descriptors,
        right: targetRect.right,
        top: targetRect.bottom
      }, '*');
    }

    if (!shouldShowNavbarOverflow && isShowingNavbarOverflow) {
      isShowingNavbarOverflow = false;
      global.top.postMessage({
        type: 'hide-navbar-overflow'
      }, '*');
    }
  };

  const getTabsForId = function (tabId) {
    if (!tabId) {
      return [];
    }
    // This is intentionally selecting on all of the document
    const tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME, '=', tabId));
    return Array.prototype.slice.call(tabs);
  };

  const getView = function (id) {
    return document.querySelector(getSelector(VIEW_ID_ATTR_NAME, '=', id));
  };

  const getNavbar = function (optNode) {
    const node = optNode || document.documentElement;
    const selector = getSelector(NAVBAR_ATTR_NAME);
    return node.matches(selector) ? node : node.querySelector(selector);
  };

  const getActiveTab = function () {
    const navbar = getNavbar();
    if (!navbar) return null;
    const activeTabId = navbar.getAttribute(ACTIVE_ID_ATTR_NAME);
    const activeTabs = getTabsForId(activeTabId);
    return activeTabs[0];
  };

  const getTabs = function () {
    const tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));
    return Array.prototype.slice.call(tabs);
  };

  const setActiveTabs = function (id, tabs) {
    const navbar = getNavbar();
    if (!navbar) {
      return;
    }

    navbar.setAttribute(ACTIVE_ID_ATTR_NAME, id);

    tabs.forEach(function (tab) {
      tab.classList.add(CLASSNAME_ACTIVE);
    });

    // Remove the active class name from all tabs except the ones that should be active
    const tabList = getTabs();
    if (tabList.length) {
      tabList.forEach(function (_tab) {
        if (_tab.getAttribute(ITEM_ID_ATTR_NAME) !== id) {
          _tab.classList.remove(CLASSNAME_ACTIVE);
        }
      });
    }
  };

  const getViews = function () {
    const views = document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));
    return Array.prototype.slice.call(views);
  };

  const hide = function (element) {
    element.style.display = 'none';
  };
  const show = function (element) {
    element.style.display = 'block';
  };

  const setActiveView = function (id, view) {
    if (!view) {
      return;
    }

    const views = getViews();

    // Hide all views except the one that should be active
    for (let i = 0, l = views.length; i < l; i++) {
      if (views[i] !== view[0]) {
        hide(views[i]);
      }
    }

    show(view);
  };

  const setActive = function (id, tabs, view) {
    const currentActiveTab = getActiveTab();
    const currentActiveId = currentActiveTab && currentActiveTab.getAttribute(ITEM_ID_ATTR_NAME);

    // Abort if the new tab is already active
    if (currentActiveId === id) {
      return;
    }

    setActiveTabs(id, tabs);
    setActiveView(id, view);

    center.emit('navbar-change', { id: id });
  };

  const activateItem = function (id) {
    updateScrollPosition();

    const view = getView(id);
    const tabs = getTabsForId(id);

    // Set styles for navbar items and show/hide views
    setActive(id, tabs, view);
  };

  const handleClick = function (event, tab) {
    const id = tab.getAttribute(ITEM_ID_ATTR_NAME);
    if (id === OVERFLOW_MENU_ID) {
      shouldShowNavbarOverflow = true;
      updateOverflowMenu();
      return;
    }

    activateItem(id);
    // Prevent any default click action (like link navigation)
    event.preventDefault();
  };

  const hideOverflow = function () {
    if (isShowingNavbarOverflow) {
      shouldShowNavbarOverflow = false;
      updateOverflowMenu();
    }
  };

  const onMessage = function (message) {
    if (message.data && message.data.name === 'navbar-overflow-click') {
      activateItem(message.data.itemId);
    }

    if (message.data && message.data.name === 'hide-navbar-overflow') {
      hideOverflow();
    }
  };

  const getFirstTabId = function () {
    const tab = document.querySelector(getSelector(ITEM_ID_ATTR_NAME));
    if (tab) {
      if (tab.getAttribute(ITEM_ID_ATTR_NAME) === OVERFLOW_MENU_ID) {
        return null;
      }
      return tab.getAttribute(ITEM_ID_ATTR_NAME);
    }
    return null;
  };

  const setActiveForMatchingId = function (ids) {
    // Off the list of passed ids, find the first one that matches a tab, then set
    // that one as active.
    let count = 0;
    let tabs;
    let id;
    while (count < ids.length && (!tabs || !tabs.length)) {
      if (ids[count]) {
        id = ids[count];
        tabs = getTabsForId(id);
      }
      count++;
    }
    const useID = id;

    if (!tabs || !tabs.length) {
      return;
    }
    const view = getView(useID);

    setActive(useID, tabs, view);
  };

  // Hack to get around bridge bug (reported at WP-471) where WP reports
  // the uri with the arguments as well.
  const fixAppURI = function (uri) {
    return uri.split(':').slice(0, 3).join(':');
  };

  const getIdFromMatchers = function (uri) {
    for (const regexp in storedMatchers) {
      if (storedMatchers.hasOwnProperty(regexp)) {
        const regexpObj = new RegExp(regexp);
        if (regexpObj.test(uri)) return storedMatchers[regexp];
      }
    }
    return null;
  };

  const updateForNode = function (node) {
    const navbar = getNavbar(node);
    if (!navbar) return;

    live(APPLICATION_MODEL_URI).query('appURI, arguments', function (error, data) {
      if (error) throw error;

      const uri = fixAppURI(data.appURI);
      let fullAppURI = uri;
      if (data.arguments) {
        fullAppURI += `:${data.arguments}`;
      }
      const id = getIdFromMatchers(fullAppURI);

      if (id) {
        // This is only the case when matchers (ITEM_MATCHER_ATTR_NAME) are used in DOM.
        setActiveForMatchingId([id]);
      } else {
        // For cases where id is only to be matched from one argument, find the id to
        // highlight by looking at the argument at HISTORY_POS_ATTR_NAME.
        const argumentIndex = +navbar.getAttribute(HISTORY_POS_ATTR_NAME) || 0;
        const idAtArgumentIndex = data.arguments.split(':')[argumentIndex];

        // For cases where nothing matches, also pass the first tab ID. This is
        // how the first tab is highlighted by default.
        const firstTabId = getFirstTabId();

        setActiveForMatchingId([fullAppURI, idAtArgumentIndex, firstTabId]);
      }
    });
  };

  function updateForOverflow(node) {
    const navbar = getNavbar(node);
    if (!navbar) return;

    const itemSelector = '[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)';
    let items = node.querySelectorAll(itemSelector);
    if (!items) {
      return;
    }

    items = Array.prototype.slice.call(items);

    const overflowMenuButton = navbar.querySelector('.overflow-menu-button');

    // If we have less than two items, only show the navbar and be done. We need
    // at least two items for messurement and chances are a "more" menu won't be
    // needed.
    if (items.length < 2) {
      navbar.style.visibility = 'visible';
      if (overflowMenuButton) {
        overflowMenuButton.style.display = 'none';
      }
      return;
    }

    const navbarWidth = getWidth(navbar);
    if (!navbarWidth) {
      // The navbar isn't rendered. Bail out.
      return;
    }

    // Reset to the initial rendering state to be able to measure items.
    if (overflowMenuButton) {
      overflowMenuButton.style.display = 'inline';
    }

    items.forEach(function (item) {
      item.style.display = 'block';
      item.classList.remove('last-visible');
    });

    const sizing = measureNavbar(items, overflowMenuButton);

    // If stuff doesn't completely fit, reduce the available space by the "more"
    // menu with, then calculate what needs to go in it.
    let availableSpace = navbarWidth;
    let firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
    const needsMoreMenu = items.length !== firstOverflown;

    if (needsMoreMenu) {
      availableSpace -= sizing.overflowMenuButtonWidth;
      firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
    }

    if (!navbarOverflowItems) {
      navbarOverflowItems = [];
    }
    navbarOverflowItems.length = 0;

    items.forEach(function (item, i) {
      const shouldBeInOverflow = i >= firstOverflown;
      if (shouldBeInOverflow) {
        navbarOverflowItems.push(item);
      }

      // If we don't draw an overflow menu, set the last-visible class on the
      // very last item so its margin-right is removed.
      const isLastInNotOverflown = !needsMoreMenu && i === items.length - 1;

      item.style.display = shouldBeInOverflow ? 'none' : 'block';
      item.classList.toggle('last-visible', isLastInNotOverflown);
    });

    if (overflowMenuButton) {
      overflowMenuButton.style.display = needsMoreMenu ? 'inline' : 'none';
    }

    // Update items and position, possibly close the menu
    updateOverflowMenu();
    navbar.style.visibility = 'visible';
  }

  function updateScrollPosition() {
    const scrollTop = window.pageYOffset;
    const stickyElements = Array.prototype.slice.call(document.querySelectorAll(`[${STICKY_WRAPPER_ATTR_NAME}]`));

    if (stickyElements.length === 0) return;

    // Get the `top` value of a sticky element that is
    // in a fixed position (negative value)
    // and the closest to the top (smallest top value).
    const topTarget = stickyElements.reduce(function (res, el) {
      const top = el.getBoundingClientRect().top;
      return top < res ? top : res;
    }, 0);

    const topBarHeight = parseInt(document.documentElement.getAttribute('data-top-bar-height'), 10) || 0;

    if (topTarget < 0) {
      // Add 1 px to have the sticky element in fixed position.
      window.scrollTo(0, scrollTop + topTarget + 1 - topBarHeight);
    }
  }

  function handleResize() {
    updateForOverflow(document.body);
  }

  function measureNavbar(items, overflowMenuButton) {
    // Find out what the margin per item is my messuring beween the first 2 items.
    const item1 = items[0];
    const item2 = items[1];

    const right1 = Math.floor(item1.getBoundingClientRect().right);
    const left2 = Math.floor(item2.getBoundingClientRect().left);
    const marginPerSide = (left2 - right1) / 2;

    let itemWidths = [];
    if (items) {
      itemWidths = items.map(function (item, i, all) {
        const marginLeft = i === 0 ? 0 : marginPerSide;
        const marginRight = i === all.length - 1 ? 0 : marginPerSide;
        return getWidth(item) + marginLeft + marginRight;
      });
    }

    // When the overflowMenuButton is showns, it's always at the end, so it has
    // no right margin.
    let overflowMenuButtonWidth = 0;
    if (overflowMenuButton) {
      overflowMenuButtonWidth = getWidth(overflowMenuButton) + marginPerSide;
    }

    return {
      itemWidths: itemWidths,
      overflowMenuButtonWidth: overflowMenuButtonWidth
    };
  }

  function getWidth(element) {
    return element && element.offsetWidth || 0;
  }

  function getFirstOverflownIndex(space, sizes) {
    let count = 0;
    let used = 0;
    while (sizes[count] !== undefined && used < space) {
      used += sizes[count];
      // This is actually expected to return up to .length of the sizes.
      // That will be the case when everything fits.
      count++;
    }
    if (used < space) {
      return count;
    }
    return count - 1;
  }

  // Matchers allow you to tell a tab to be active for a pattern of the app arguments.
  // If you define data-navbar-item-matcher="user:.*?:playlist:.*$" you tell the tab
  // to be active when the arguments match that regexp.
  const getMatchers = function (node) {
    let matchers = node.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));
    if (!matchers.length) return;

    matchers = Array.prototype.slice.call(matchers);
    matchers.forEach(function (matcher) {
      const regexp = matcher.getAttribute(ITEM_MATCHER_ATTR_NAME);
      const id = matcher.getAttribute(ITEM_ID_ATTR_NAME);
      storedMatchers[regexp] = id;
    });
  };

  const onApplicationChange = function (event) {
    if ('arguments' in event || 'active' in event) {
      updateForNode(document.documentElement);
    }
  };

  let isAttached = false;

  exports.update = function update(node) {
    if (!isAttached) return;

    updateForNode(node || document.documentElement);
    getMatchers(node || document.documentElement);
    updateForOverflow(node || document.documentElement);
  };

  exports.attach = function attach() {
    if (isAttached) return;
    isAttached = true;

    $(document).delegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
    window.addEventListener('message', onMessage);
    live(APPLICATION_MODEL_URI).on('update', onApplicationChange);
    window.addEventListener('resize', handleResize);
    center.on('navbar-hide', hideOverflow);
  };

  exports.detach = function detach() {
    if (!isAttached) return;
    isAttached = false;

    navbarOverflowItems = null;
    isShowingNavbarOverflow = false;
    shouldShowNavbarOverflow = false;

    $(document).undelegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
    window.removeEventListener('message', onMessage);
    live(APPLICATION_MODEL_URI).off('update', onApplicationChange);
    window.removeEventListener('resize', handleResize);
    center.off('navbar-hide', hideOverflow);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../live":413,"../spotify-elements":460,"./center":471}],516:[function(require,module,exports){
  'use strict';

  const $ = require('../spotify-elements');
  const live = require('../live');

  let sessionModel;

  function onSessionUpdate(properties) {
    if ('online' in properties) {
      if (properties.online) {
        $(document.body).removeClass('offline');
      } else {
        $(document.body).addClass('offline');
      }
    }
  }

  function updateWithSessionValue() {
    live('spotify:client').query('session(online)', function (error, data) {
      if (error) throw error;
      onSessionUpdate({ online: data.session.online });
    });
  }

  let isAttached = false;

  exports.update = function () {
    if (!isAttached) return;

    updateWithSessionValue();
  };

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    if (!sessionModel) {
      live('spotify:client').get('session', function (error, session) {
        if (error) throw error;
        sessionModel = session;
        sessionModel.on('update', onSessionUpdate);
      });
    }
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    if (sessionModel) {
      sessionModel.off('update', onSessionUpdate);
      sessionModel = null;
    }
  };

  },{"../live":413,"../spotify-elements":460}],517:[function(require,module,exports){
  'use strict';

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * @private
   */

  const $ = require('../../spotify-elements');
  const utils = require('./utils');
  const playback = require('playback_control');

  const SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
  const SELECTOR_PLAY_BUTTON = '[data-button=play]';
  const SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

  // This array will store event types for touch handling
  let lastEventTypes = [];

  // Methods that need implementation from another module.
  // This is to support generic handling of user actions from within this module,
  // but allow further checks and actions to be performed by another module. This
  // allows multiple different implementations of starting playback for example.
  const methods = {
    getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
    handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
    handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
  };

  /**
   * Handle the click of a play button.
   *
   * @param {MouseEvent} event An event object for a click event.
   * @param {Elements} button An element instance from the `elements` package.
   *
   * @private
   */
  // APPBOOK change play button behaviour
  function handlePlayButtonClick(event, button) {
    const buttonNode = button[0];
    const buttonContextUri = utils.getUriFromButton(buttonNode);

    // We need an associated context URI for the button
    if (!buttonContextUri) {
      return;
    }

    let uri = buttonContextUri;

    const type = uri.split(":")[1];
    if (type === "track" || type === "episode" || type === "local") {
      let time = utils.getTimeFromButton(buttonNode);

      const options = {};
      if (time) {
        options.seekTo = parseInt(time);
      }

      playback.playTrack(uri, options, () => {})
      return;
    }


    const playerContextUri = methods.getPlayerVariantUri();
    const isPlayingContext = methods.getPlayerTrackProvider() !== 'queue' && utils.compareContexts(playerContextUri, buttonContextUri);

    const source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

    methods.handlePlayButton(buttonNode, {
      isPlayingContext: isPlayingContext,
      contextUri: buttonContextUri,
      source: source,
      reason: 'playbtn'
    });
  }

  /**
   * Handle the double click or tap of a list row to start playback.
   *
   * @param {Elements} row An element instance from the `elements` package.
   *
   * @private
   */
  function handleListRow(row) {
    const rowNode = row[0];
    const contextNode = $(rowNode.closest('[data-context]'));
    if (contextNode && !rowNode.classList.contains('thumbs-down')) {
      const source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
      methods.handlePlayFromRow(rowNode, {
        contextUri: contextNode.data('uri'),
        source: source,
        reason: 'clickrow'
      });
    }
  }

  /**
   * Handle double clicking on a list row to start playback.
   *
   * @param {MouseEvent} event An event object for a double click.
   * @param {Elements} row An element instance from the `elements` package.
   *
   * @private
   */
  function handleRowDoubleClick(event, row) {
    // Only play when not clicking on interactive elements such as buttons
    if (!utils.isInteractiveElement(event.target)) {
      handleListRow(row);
    }
  }

  /**
   * Handle a key press on a list row.
   * This will take care of starting playback when pressing Enter.
   *
   * @param {KeyboardEvent} event A keyboard event.
   * @param {Elements} row An element instance from the `elements` package.
   *
   * @private
   */
  function handleRowKeyDown(event, row) {
    const isEnter = event.keyCode === 13;
    if (isEnter) {
      if (utils.isFormOrLinkElement(event.target)) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      handleListRow(row);
    }
  }

  /**
   * Handle the 'contextmenu' event. This is only for touch handling.
   * This is needed since we use a custom context menu in Spotify, and the handler
   * for that calls `preventDefault` for the 'contextmenu' event, which means the
   * rest of the touch handling will go on as usual. So as we don't get the
   * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
   * that we should not act on the following 'touchend' event.
   *
   * @param {MouseEvent} event A 'contextmenu' event.
   *
   * @private
   */
  function handleContextMenu(event) {
    lastEventTypes.push(event.type);
  }

  /**
   * Handle the start of a touch. Used to detect a tap.
   *
   * @param {TouchEvent} event A touch event.
   *
   * @private
   */
  function handleRowTouchStart(event) {
    lastEventTypes.push(event.type);
  }

  /**
   * Handle the move of a touch. Used to abort detection of a tap.
   *
   * @param {TouchEvent} event A touch event.
   *
   * @private
   */
  function handleRowTouchMove(event) {
    lastEventTypes.push(event.type);
  }

  /**
   * Handle the end of a touch. Used to detect a tap and start playback of a row.
   *
   * @param {TouchEvent} event A touch event.
   * @param {Elements} row An element instance from the `elements` package.
   *
   * @private
   */
  function handleRowTouchEnd(event, row) {
    // If this was a tap (only touchstart was triggered before this)
    if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {
      // Prevent the simulated mouse events (including click). This is to
      // avoid the simulated click event to click on the play button that
      // appears when selecting a row on touchstart.
      // See: https://jira.spotify.net/browse/KM-7983
      if (!utils.isInteractiveElement(event.target)) {
        event.preventDefault();

        // Tapping on a row should play it
        handleListRow(row);
      }
    }
    lastEventTypes = [];
  }

  /**
   * Attach the needed event listeners for the module.
   */
  const defaultSelectors = {
    selectorPlayButton: SELECTOR_PLAY_BUTTON,
    selectorListRow: SELECTOR_LIST_ROW,
    selectorPlayContextButton: SELECTOR_PLAY_CONTEXT_BUTTON
  };
  let selectors = defaultSelectors;

  exports.attach = function () {
    const doc = $(document);

    doc.delegate('keydown', selectors.selectorListRow, handleRowKeyDown);
    doc.delegate('click', selectors.selectorPlayButton, handlePlayButtonClick);
    doc.delegate('click', selectors.selectorPlayContextButton, handlePlayButtonClick);
    doc.delegate('dblclick', selectors.selectorListRow, handleRowDoubleClick);

    /* For touch handling */
    doc.delegate('touchstart', selectors.selectorListRow, handleRowTouchStart);
    doc.delegate('touchend', selectors.selectorListRow, handleRowTouchEnd);
    doc.delegate('touchmove', selectors.selectorListRow, handleRowTouchMove);
    doc.delegate('contextmenu', selectors.selectorListRow, handleContextMenu);
  };

  /**
   * Detach the event listeners for the module.
   */
  exports.detach = function () {
    const doc = $(document);

    doc.undelegate('keydown', selectors.selectorListRow, handleRowKeyDown);
    doc.undelegate('click', selectors.selectorPlayButton, handlePlayButtonClick);
    doc.undelegate('click', selectors.selectorPlayContextButton, handlePlayButtonClick);
    doc.undelegate('dblclick', selectors.selectorListRow, handleRowDoubleClick);

    /* For touch handling */
    doc.undelegate('touchstart', selectors.selectorListRow, handleRowTouchStart);
    doc.undelegate('touchend', selectors.selectorListRow, handleRowTouchEnd);
    doc.undelegate('touchmove', selectors.selectorListRow, handleRowTouchMove);
    doc.undelegate('contextmenu', selectors.selectorListRow, handleContextMenu);
  };

  exports.setSelectors = function (customSelectors = {}) {
    exports.detach();
    selectors = _extends({}, defaultSelectors, customSelectors);
    exports.attach();
  };

  /**
   * Set the external methods for this module to add implementations for starting
   * playback etc.
   *
   * @param {Object} methodDefinitions Object where keys are method names and
   *     values are functions.
   */
  exports.setMethods = function (methodDefinitions) {
    for (const name in methodDefinitions) {
      if (methodDefinitions.hasOwnProperty(name)) {
        methods[name] = methodDefinitions[name];
      }
    }
  };

  },{"../../spotify-elements":460,"./utils":520, "playback_control": 380}],518:[function(require,module,exports){
  'use strict';

  const playerWithIndices = require('./withIndices');
  const playerWithUids = require('./withUids');
  const actions = require('./actions');

  let playerModule = playerWithIndices;

  exports.setMode = function (type) {
    switch (type) {
      case 'indices':
        playerModule = playerWithIndices;
        break;
      case 'uids':
        playerModule = playerWithUids;
        break;
      default:
        break;
    }
  };

  exports.setSelectors = actions.setSelectors;

  exports.attach = function () {
    playerModule.attach();
  };

  exports.detach = function () {
    playerModule.detach();
  };

  exports.update = function (optNode) {
    playerModule.update(optNode);
  };

  },{"./actions":517,"./withIndices":521,"./withUids":522}],519:[function(require,module,exports){
  'use strict';

  /**
   * @private
   */

  const difference = require('mout/array/difference');
  const $ = require('../../spotify-elements');
  const live = require('../../live');

  const center = require('../center');
  const utils = require('./utils');

  const CURRENT = 'current';
  const PAUSED = 'paused';
  const PLAYING = 'playing';

  const LOG_PLAY_BUTTON = 'play-button';
  const LOG_PAUSE_BUTTON = 'pause-button';
  const LOG_INTENT_PLAY = 'play';
  const LOG_INTENT_PAUSE = 'pause';

  const SELECTOR_PLAY_BUTTON = '[data-button=play]';
  const SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
  const SELECTOR_ALL_PLAY_BUTTONS = `${SELECTOR_PLAY_BUTTON},${SELECTOR_PLAY_CONTEXT_BUTTON}`;

  const INTERACTION_INTENT_ATTR = 'data-interaction-intent';
  const SELECTOR_PLAYABLE_ROW = '[data-context-index]';

  // Methods that need implementation from another module.
  // This is to support generic handling of DOM updates from within this module,
  // but allow further checks and actions to be performed by another module. This
  // allows multiple different implementations of highlighting playing objects.
  const methods = {
    getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
    getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
    getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

    // This should be a function that takes a function as the first argument. That
    // function argument should be called whenever the player state has changed.
    subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
  };

  let playableChangeHandlers = {};
  let playerSubscription = null;

  /**
   * Update states in the DOM based on current player state.
   *
   * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
   *     of that node will be updated.
   */
  function updateDOM(optNode) {
    const containerNode = optNode || document;

    updateButtonsBasedOnPlayable(containerNode);

    const playingNodes = getPlayingNodes(containerNode);
    const currentNodes = getCurrentNodes(containerNode);

    if (currentNodes) {
      let nodesForRemoval = currentNodes;
      if (playingNodes) {
        nodesForRemoval = difference(currentNodes, playingNodes);
      }
      nodesForRemoval.forEach(removePlayingStateFromNode);
    }

    if (playingNodes) {
      let nodesForAddition = playingNodes;
      if (currentNodes) {
        nodesForAddition = difference(playingNodes, currentNodes);
      }
      nodesForAddition.forEach(addPlayingStateToNode);

      const nodesForUpdate = difference(playingNodes, nodesForAddition);
      nodesForUpdate.forEach(updatePlayingStateForNode);
    }
  }

  /**
   * Update the playable status of all play buttons found inside the passed
   * container node.
   *
   * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
   *
   * @private
   */
  function updateButtonsBasedOnPlayable(containerNode) {
    // `[data-button=play]` buttons are used to play something specific *in* a
    // context (defining an index as a track number or uid/uri or range).
    // Those are currently not updated themselves, instead their rows are being
    // set to `.unavailable`.
    const buttons = $(containerNode).search('[data-button=play-context]');
    if (buttons) {
      buttons.forEach(updateButtonBasedOnPlayable);
    }
  }

  /**
   * Update the playable status of the passed button.
   *
   * @param {HTMLElement} button A button DOM node.
   *
   * @private
   */
  function updateButtonBasedOnPlayable(button) {
    // Play buttons in list rows should not be handled, as the buttons are
    // hidden by CSS anyway for unplayable rows.
    if ($(button).parent('[data-list-item]')) {
      return;
    }

    const contextURI = utils.getUriFromButton(button);

    // Check if the context has a playable flag specified.
    const playableValue = live(contextURI).get('playable');
    const definesPlayable = playableValue !== undefined;

    // If it does, update the `disabled` attribute based on it
    if (definesPlayable) {
      if (playableValue) {
        button.removeAttribute('disabled');
      } else {
        button.setAttribute('disabled', 'disabled');
      }

      if (!playableChangeHandlers[contextURI]) {
        playableChangeHandlers[contextURI] = function (changed) {
          if (!changed.hasOwnProperty('playable')) {
            return;
          }
          // Update all buttons currently in DOM when `playable` changes on a
          // context. Not worth adding logic to only pick out buttons pointing to
          // a specific URI.
          updateButtonsBasedOnPlayable(document.body);
        };
        live(contextURI).on('update', playableChangeHandlers[contextURI]);
      }
    }
  }

  /**
   * Get the nodes inside the passed container node that are currently marked as
   * playing.
   *
   * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
   *
   * @return {?Elements} An element instance from the `elements` package, or null.
   *
   * @private
   */
  function getCurrentNodes(containerNode) {
    return $(containerNode).search('[data-playback-active=true]');
  }

  /**
   * Get the nodes inside the passed container node that should be marked as
   * playing based on the current player state.
   *
   * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
   *
   * @return {?Elements} An element instance from the `elements` package, or null.
   *
   * @private
   */
  function getPlayingNodes(containerNode) {
    let contextNodes = [];

    if (methods.getPlayerTrackProvider() !== 'queue') {
      const variantUri = methods.getPlayerVariantUri();
      const selectors = utils.getContextSelectorsWithVariants(variantUri);

      const foundContextNodes = $(containerNode).search(selectors.join(', '));
      if (foundContextNodes) {
        contextNodes = Array.prototype.slice.call(foundContextNodes);
      }
    }

    // Pass it through the outside implementation, which might filter out
    // nodes from `contextNodes` and add more nodes to the match.
    return methods.getPlayingNodes(containerNode, contextNodes);
  }

  /**
   * Remove the playing state from the passed DOM node, as it's no longer playing.
   *
   * @param {HTMLElement} node The DOM node to remove state from.
   *
   * @private
   */
  function removePlayingStateFromNode(node) {
    const className = [CURRENT, PAUSED, PLAYING].join(' ');
    const newNode = $(node);
    newNode.removeClass(className).removeAttribute('data-playback-active');

    if (newNode.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
      newNode.attribute('data-log-click', LOG_PLAY_BUTTON);
      newNode.attribute(INTERACTION_INTENT_ATTR, LOG_INTENT_PLAY);
    }

    // Play buttons in list rows are not handled automatically
    if (newNode.matches(SELECTOR_PLAYABLE_ROW)) {
      const playButton = newNode[0].querySelector(SELECTOR_PLAY_BUTTON);
      if (playButton) {
        playButton.setAttribute(INTERACTION_INTENT_ATTR, LOG_INTENT_PLAY);
      }
    }
  }

  /**
   * Add the playing state to the passed DOM node, as it's now playing.
   *
   * @param {HTMLElement} node The DOM node to add state to.
   *
   * @private
   */
  function addPlayingStateToNode(node) {
    const isPlaying = methods.getPlayerIsPlaying();

    const classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

    const newNode = $(node);
    newNode.addClass(classNames).data('playback-active', true);

    if (newNode.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
      newNode.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
      newNode.attribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
    }

    // Play buttons in list rows are not handled automatically
    if (newNode.matches(SELECTOR_PLAYABLE_ROW)) {
      const playButton = newNode[0].querySelector(SELECTOR_PLAY_BUTTON);
      if (playButton) {
        playButton.setAttribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
      }
    }
  }

  /**
   * Update the playing state for the passed DOM node, as it's still representing
   * the currently playing context, but the player might switch between
   * playing/paused.
   *
   * @param {HTMLElement} node The DOM node to update state for.
   *
   * @private
   */
  function updatePlayingStateForNode(node) {
    const isPlaying = methods.getPlayerIsPlaying();

    const currentClassName = isPlaying ? PAUSED : PLAYING;
    const newClassName = isPlaying ? PLAYING : PAUSED;
    const element = $(node);

    if (element.hasClass(currentClassName)) {
      element.removeClass(currentClassName);
    }

    if (!element.hasClass(newClassName)) {
      element.addClass(newClassName);
    }

    if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
      element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
      element.attribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
    }

    // Play buttons in list rows are not handled automatically
    if (node.matches(SELECTOR_PLAYABLE_ROW)) {
      const playButton = node.querySelector(SELECTOR_PLAY_BUTTON);
      if (playButton) {
        playButton.setAttribute(INTERACTION_INTENT_ATTR, isPlaying ? LOG_INTENT_PAUSE : LOG_INTENT_PLAY);
      }
    }
  }

  /**
   * Handle updating of DOM nodes when they have been added to the DOM by a scroll
   * agent.
   *
   * @param {Object} event Custom event object sent from the scroll agent. Should
   *     contain a `container` property pointing to the DOM node containing the
   *     rows.
   *
   * @private
   */
  function handleScrollShowAfter(event) {
    const container = $(event.container);
    let contextNode = null;
    if (container.matches('[data-context]')) {
      contextNode = container;
    } else {
      contextNode = container.parent('[data-context]');
    }

    // We can't pass the context node itself as root because of how the playing
    // state queries are set up.
    const contextParent = contextNode && contextNode[0].parentElement || document;

    updateDOM(contextParent);
  }

  /**
   * Attach the needed event listeners for the module.
   */
  exports.attach = function () {
    playerSubscription = methods.subscribeToPlayerChange(function () {
      updateDOM();
    });

    center.on('scroll-show-after', handleScrollShowAfter);
  };

  /**
   * Detach the needed event listeners for the module.
   */
  exports.detach = function () {
    if (playerSubscription) {
      playerSubscription.cancel();
      playerSubscription = null;
    }

    for (const contextUri in playableChangeHandlers) {
      if (playableChangeHandlers.hasOwnProperty(contextUri)) {
        live(contextUri).off('update', playableChangeHandlers[contextUri]);
      }
    }
    playableChangeHandlers = {};

    center.off('scroll-show-after', handleScrollShowAfter);
  };

  /**
   * Update things in the DOM.
   */
  exports.update = updateDOM;

  /**
   * Set the external methods for this module to add implementations for methods
   * needed for highlighting playing objects.
   *
   * @param {Object} methodDefinitions Object where keys are method names and
   *     values are functions.
   */
  exports.setMethods = function (methodDefinitions) {
    for (const name in methodDefinitions) {
      if (methodDefinitions.hasOwnProperty(name)) {
        methods[name] = methodDefinitions[name];
      }
    }
  };

  },{"../../live":413,"../../spotify-elements":460,"../center":471,"./utils":520,"mout/array/difference":777}],520:[function(require,module,exports){
  (function (global){
  'use strict';

  /**
   * This module might be used by modules outside of spotify-events.
   * @public
   */

  const liburi = require('spotify-liburi');

  const getOriginUri = require('../../live-wrapped-uri').getOriginUri;

  /**
   * Get the context URI from a button node or its parents.
   *
   * @param {HTMLElement} button A DOM node for a button.
   *
   * @return {string} The context URI or empty string if not found.
   */
  function getUriFromButton(button) {
    const contextNode = button.closest('[data-context]');
    return contextNode && contextNode.getAttribute('data-uri') || '';
  }

  /**
   * Get the time from a button node or its parents.
   *
   * @param {HTMLElement} button A DOM node for a button.
   *
   * @return {string} The context URI or empty string if not found.
   */
  function getTimeFromButton(button) {
    const contextNode = button.closest('[data-context]');
    return contextNode && contextNode.getAttribute('data-time') || '';
  }

  /**
   * Get the value for the passed attribute name, either from the passed node or
   * from any parent node.
   *
   * @param {HTMLElement} node The node to start searching from.
   * @param {string} attributeName The name of the attribute.
   *
   * @return {string} The value, or empty string if not found.
   */
  function getAttributeValueFromNode(node, attributeName) {
    const selector = `[${attributeName}]`;
    const attributeNode = node.closest(selector);
    return attributeNode && attributeNode.getAttribute(attributeName) || '';
  }

  /**
   * Check if the passed element is a form or link element.
   *
   * @param {HTMLElement} element A DOM node.
   *
   * @return {boolean} True if it is a form or link element.
   */
  function isFormOrLinkElement(element) {
    const tagName = element.tagName.toLowerCase();
    const elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
    return elements.indexOf(tagName) > -1;
  }

  /**
   * Check if the passed element is an interactive element (links, buttons).
   *
   * @param {HTMLElement}  element A DOM node.
   *
   * @return {boolean} True if the element is interactive.
   */
  function isInteractiveElement(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName === 'a' || tagName === 'button';
  }

  /**
   * Get a CSS selector string for a context.
   *
   * @param {string} operator A CSS selector operator ($= or similar).
   * @param {string} uri The context URI.
   *
   * @return {string} The CSS selector string.
   */
  function getContextSelector(operator, uri) {
    return `[data-context][data-uri${operator}${uri}]`;
  }

  /**
   * Get an array of CSS selectors for searching for context nodes inside the DOM.
   * This also includes any variant of the passed context URI. For example, if
   * passing a sorted playlist URI, it will return selectors for matching all
   * variations of that playlist URI, including the regular playlist URI, filtered
   * URI etc.
   *
   * @param {string} uri The context URI to search for. This can be either the
   *     origin URI, or any variant URI. The function will convert it to the
   *     origin URI automatically.
   *
   * @return {Array.<string>} Array of CSS selector strings.
   */
  function getContextSelectorsWithVariants(uri) {
    const STARTS_WITH = '^=';
    const ENDS_WITH = '$=';
    const EQUALS = '=';

    const originUri = getOriginUri(uri) || uri;
    const originUriNormalized = normalizeUri(originUri);

    const originUriEnding = originUri.replace(/^spotify:/, ':');
    const originUriEndingNormalized = normalizeUri(originUriEnding);

    const selectors = [getContextSelector(EQUALS, originUri)];

    selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:filterlist:') + getContextSelector(ENDS_WITH, originUri.replace(/^spotify:/, ':')));

    selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:sortlist:') + getContextSelector(ENDS_WITH, originUri.replace(/^spotify:/, ':')));

    if (originUri !== originUriNormalized) {
      selectors.push(getContextSelector(EQUALS, originUriNormalized));
      selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:filterlist:') + getContextSelector(ENDS_WITH, originUriEndingNormalized));
      selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:sortlist:') + getContextSelector(ENDS_WITH, originUriEndingNormalized));
    }

    return selectors;
  }

  /**
   * Check if two context URIs are representing the same context. This will take
   * care of normalizing the casing of URL encoding and filtered/sorted contexts.
   *
   * @param {string} context1 The first context.
   * @param {string} context2 The second context.
   *
   * @return {boolean} True if they represent the same context.
   */
  function compareContexts(context1, context2) {
    if (!context1 || !context2) return false;

    const newContext1 = normalizeUri(getOriginUri(context1) || context1);
    const newContext2 = normalizeUri(getOriginUri(context2) || context2);

    return newContext1 === newContext2;
  }

  /**
   * A URI might contain URL encoded characters, and per spec the URL encoding can
   * be either in lowercase or uppercase (should be treated as same URL). If the
   * input URL has lowercase encoding, liburi will convert it into uppercase
   * encoding.
   *
   * @param {string} uri The URI to normalize.
   *
   * @return {string} The normalized URI.
   */
  function normalizeUri(uri) {
    const uriObj = liburi.from(uri);
    let normalized = uriObj ? uriObj.toString() : uri;

    // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
    // since it does not recognize `internal` URIs, and therefore uses the default
    // `app` type.
    normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

    // Work around the bad conversion of spaces in filtered list URIs. The URI
    // spec we use says that spaces should be encoded as `+`, but the `filterlist`
    // URI uses the regular `%20` encoding for spaces. Passing it through liburi
    // converts it to `+`, so we need to convert it back to `%20` again.
    normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
      return match.replace(/\+/g, '%20');
    });

    return normalized;
  }

  /**
   * Create an empty method that will only log a warning when called.
   *
   * @param {string} methodName The name of the method to warn about.
   *
   * @return {Function} The function.
   */
  function createEmptyMethod(methodName) {
    return function () {
      if (global.console) {
        console.warn(`spotify-events/player: \`${methodName}\` is not implemented.`);
      }
    };
  }

  exports.getUriFromButton = getUriFromButton;
  exports.getTimeFromButton = getTimeFromButton;
  exports.getAttributeValueFromNode = getAttributeValueFromNode;
  exports.isFormOrLinkElement = isFormOrLinkElement;
  exports.isInteractiveElement = isInteractiveElement;
  exports.getContextSelector = getContextSelector;
  exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
  exports.compareContexts = compareContexts;
  exports.normalizeUri = normalizeUri;
  exports.createEmptyMethod = createEmptyMethod;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live-wrapped-uri":412,"spotify-liburi":1282}],521:[function(require,module,exports){
  'use strict';

  /**
   * @private
   */

  const live = require('../../live');
  const Range = require('../../range2');
  const $ = require('../../spotify-elements');

  const playerActions = require('./actions');
  const playerUpdates = require('./updates');
  const utils = require('./utils');

  let isAttached = false;

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    playerActions.setMethods({
      getPlayerTrackProvider: getPlayerTrackProvider,
      getPlayerVariantUri: getPlayerVariantUri,
      handlePlayButton: handlePlayButton,
      handlePlayFromRow: handlePlayFromRow
    });

    playerUpdates.setMethods({
      getPlayerTrackProvider: getPlayerTrackProvider,
      getPlayerVariantUri: getPlayerVariantUri,
      getPlayerIsPlaying: getPlayerIsPlaying,
      getPlayingNodes: getPlayingNodes,
      subscribeToPlayerChange: subscribeToPlayerChange
    });

    playerActions.attach();
    playerUpdates.attach();
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    playerActions.detach();
    playerUpdates.detach();
  };

  exports.update = function (optNode) {
    if (!isAttached) return;

    playerUpdates.update(optNode);
  };

  function getPlayerTrackProvider() {
    const track = live('spotify:player').get('track');
    return track ? track.get('provider') || '' : '';
  }

  /**
   * Get the variant URI for the currently playing context. For example, if
   * playing a sorted playlist, this should return the sorted URI.
   *
   * @return {string} The context variant URI, or empty string if nothing is
   *     playing.
   */
  function getPlayerVariantUri() {
    const variant = live('spotify:player').get('variant');
    return variant ? variant.uri : '';
  }

  /**
   * Get the index of the currently playing track within the playing context.
   *
   * @return {number} The index, or -1 if not found.
   */
  function getPlayerIndex() {
    const indexObject = live('spotify:player').get('index');
    return indexObject ? indexObject.get('track') : -1;
  }

  /**
   * Get the URI of the currently playing track.
   *
   * @return {string} The track URI, or empty string if nothing is playing.
   */
  function getPlayerTrackUri() {
    const track = live('spotify:player').get('track');
    return track && track.uri || '';
  }

  /**
   * Get the playing status of the player.
   *
   * @return {boolean} True if the player is currently playing audio.
   */
  function getPlayerIsPlaying() {
    const isPlaying = live('spotify:player').get('isPlaying');
    const isPaused = live('spotify:player').get('isPaused');
    return isPlaying && !isPaused;
  }

  /**
   * Subscribe to player changes.
   *
   * @param {Function} handler A handler function. The data passed to this
   *     function is irrelevent, only the fact that something changed is needed.
   *
   * @return {Object} An object with a `cancel` method to cancel the subscription.
   */
  function subscribeToPlayerChange(handler) {
    live('spotify:player').on('update', handler);
    let active = true;
    return {
      cancel: function () {
        if (active) {
          live('spotify:player').off('update', handler);
          active = false;
        }
      }
    };
  }

  /**
   * Handle the click of a play button.
   * This function should decide what the action should be, and pause/resume
   * playback or start playback of a new context.
   *
   * @param {HTMLElement} buttonNode A button DOM node.
   * @param {Object} data Object of data about the action:
   *     isPlayingContext: (boolean) Whether the button looks to be representing
   *         the currently playing context.
   *     contextUri: (string) The context URI for the button.
   *     source: (string) The 'play source' value, for logging purposes.
   *     reason: (string) The 'play reason' value, for logging purposes.
   */
  function handlePlayButton(buttonNode, data) {
    const button = $(buttonNode);
    const playerIndex = getPlayerIndex();
    let range;
    let newIndex;
    let uids;
    let uris;

    const dataRange = button.data('range');
    if (dataRange) {
      range = Range.fromString(dataRange);
      const list = live(data.contextUri).get('rows');
      if (list) {
        const indices = range.toIndices();
        uids = indices.map(function (index) {
          return list.keys[index];
        });
        uris = indices.map(function (index) {
          const track = list.get(index).get('track');
          return track.uri;
        });
      }
      newIndex = null;
    } else {
      let contextIndexNode = null;
      if (button.matches('[data-context-index]')) {
        contextIndexNode = button;
      } else {
        contextIndexNode = button.parent('[data-context-index]');
      }

      if (contextIndexNode) {
        newIndex = parseInt(contextIndexNode.data('context-index'), 10);
        const list = live(data.contextUri).get('rows');
        if (list) {
          uids = [list.keys[newIndex]];
          uris = [list.get(newIndex).get('track').uri];
        }
      } else {
        newIndex = null;
      }
    }

    let shouldPauseResume = false;

    if (data.isPlayingContext) {
      if (range) {
        shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
      } else if (newIndex !== null) {
        shouldPauseResume = newIndex === playerIndex;
      } else {
        shouldPauseResume = true;
      }
    }

    if (shouldPauseResume) {
      if (getPlayerIsPlaying()) {
        live('spotify:player').emit('pause');
      } else {
        live('spotify:player').emit('resume');
      }
    } else {
      const eventData = {
        context: data.contextUri,
        index: newIndex,
        source: data.source,
        reason: data.reason
      };

      if (range) {
        eventData.range = [range.start, range.end];
      }

      if (uids) {
        eventData.uids = uids;
      }

      if (uris) {
        eventData.uris = uris;
      }

      live('spotify:player').emit('play', eventData);
    }
  }

  /**
   * Handle playing a list row. This function should start playback of a context
   * starting from a specific row.
   *
   * @param {HTMLElement} rowNode A DOM node for a list row.
   * @param {Object} data Object of data about the action:
   *     contextUri: (string) The context URI for the list.
   *     source: (string) The 'play source' value, for logging purposes.
   *     reason: (string) The 'play reason' value, for logging purposes.
   */
  function handlePlayFromRow(rowNode, data) {
    let index = parseInt(rowNode.getAttribute('data-context-index'), 10);
    if (isNaN(index)) {
      index = -1;
    }
    const uid = rowNode.getAttribute('data-uid') || '';
    const uri = rowNode.getAttribute('data-uri') || '';

    const eventData = {
      context: data.contextUri,
      index: index,
      source: data.source,
      reason: data.reason
    };

    if (uid) {
      eventData.uids = [uid];
    }

    if (uri) {
      eventData.uris = [uri];
    }

    live('spotify:player').emit('play', eventData);
  }

  /**
   * Get the nodes inside the passed container node that should be marked as
   * playing.
   *
   * @param {HTMLElement} containerNode The DOM node to search inside.
   * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
   *     matched based on context URIs. These can be filtered if needed, but
   *     otherwise they should be included in the return value.
   *
   * @return {Array.<HTMLElement>} An array of DOM nodes.
   */
  function getPlayingNodes(containerNode, contextNodes) {
    const playerIndex = getPlayerIndex();
    const playerTrackUri = getPlayerTrackUri();
    const variantUri = getPlayerVariantUri();

    // Remove any matched context nodes that have a range specified and where
    // the current player index does not match.
    const filteredContextNodes = filterRanges(playerIndex, contextNodes);

    const selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

    const rowNodes = getContextNodesForRows(containerNode, selectorsWithVariants, playerIndex, playerTrackUri) || [];

    const rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

    // Only return button nodes whos closest context is one of the nodes in the
    // contextNodes array. Imagine this minimal node tree:
    //
    // [data-context][data-uri="spotify:root-context"]
    //   [data-button=play-context]
    //   [data-context][data-uri="spotify:nested-context"]
    //     [data-button=play-context]
    //
    // The first [data-button=play-context] should play "spotify:root-context".
    // Ths second [data-button=play-context] should play "spotify:nested-context".
    let buttonNodes = [];
    if (contextNodes.length) {
      const candidates = $(contextNodes).search('[data-button=play-context]');
      if (candidates) {
        buttonNodes = candidates.filter(candidate => {
          const closestContextNode = candidate.closest('[data-context]');
          return contextNodes.indexOf(closestContextNode) >= 0;
        });
      }
    }

    // Let `elements` remove any duplicate nodes
    const nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

    return nodes ? Array.prototype.slice.call(nodes) : [];
  }

  /**
   * Get the nodes inside the passed container node that match what's currently
   * playing and are list rows.
   *
   * @param {HTMLElement} containerNode The DOM node to search inside.
   * @param {Array.<string>} selectors Array of CSS selectors for matching the
   *     currently playing context.
   * @param {number} index The currently playing index.
   * @param {string} trackUri The URI of the currently playing track.
   *
   * @return {Array.<HTMLElement>} Array of DOM nodes.
   */
  function getContextNodesForRows(containerNode, selectors, index, trackUri) {
    // Per container node, find a node that's playing in two steps by finding
    // Attempt 1: the first node where the playing index and
    // the track uri matches.
    // Attempt 2: the first node where only the track uri matches [1].
    const uriSelector = `[data-uri="${trackUri}"]`;
    const indexAndUriSelector = `[data-context-index=${index}]${uriSelector}`;

    // Attempt 1
    const selectorsIndexAndUriSelector = selectors.map(s => `${s} ${indexAndUriSelector}`);
    const elemsViaIndexAndUriSelector = $(containerNode).find(selectorsIndexAndUriSelector);

    if (elemsViaIndexAndUriSelector) {
      return elemsViaIndexAndUriSelector;
    }

    // Attempt 2
    const selectorsUriSelector = selectors.map(s => `${s} ${uriSelector}`);
    return $(containerNode).find(selectorsUriSelector);

    // [1] The index is very likely wrong when while on shuffle, the playing
    // device has changed. Indices are then shuffled indices, and despite this
    // files is all about highlighting in "index mode" we can disregard the index.
  }

  /**
   * Get the nodes inside the passed container node that match what's currently
   * playing and have a matching range specified.
   *
   * @param {HTMLElement} containerNode The DOM node to search inside.
   * @param {Array.<string>} selectors Array of CSS selectors for matching the
   *     currently playing context.
   * @param {number} index The currently playing index.
   *
   * @return {Array.<HTMLElement>} Array of DOM nodes.
   */
  function getContextNodesForRanges(containerNode, selectors, index) {
    const rangeAttribute = '[data-range]';

    // It needs to search for all range elements somewhere inside an element
    // marked up as a context, as well as range elements that themselves are
    // contexts.
    const newSelectors = selectors.map(function (s) {
      const rangeInContextSelector = `${s} ${rangeAttribute}`;
      const rangedContextSelector = s + rangeAttribute;
      const rangeSelector = `${rangeInContextSelector}, ${rangedContextSelector}`;
      return rangeSelector;
    });

    let rangeNodes = $(containerNode).search(newSelectors.join(', '));
    if (rangeNodes) {
      rangeNodes = Array.prototype.slice.call(rangeNodes);
    } else {
      rangeNodes = [];
    }

    return filterRanges(index, rangeNodes);
  }

  /**
   * Return a new array of nodes where nodes that specify a range that doesn't
   * match the currently playing index are removed.
   *
   * @param {number} index The currently playing index.
   * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
   *
   * @return {Array.<HTMLElement>} Array of DOM nodes.
   */
  function filterRanges(index, nodes) {
    const thisRange = new Range(index, index + 1);

    return nodes.filter(function (node) {
      const newNode = $(node);
      let range = newNode.data('range');

      // Node without a range should always be active
      if (!range) return true;

      // If player has no index, but the node has a range, we can't be sure if
      // it's playing
      if (!thisRange) return false;

      range = Range.fromString(range);
      return range.contains(thisRange);
    });
  }

  },{"../../live":413,"../../range2":454,"../../spotify-elements":460,"./actions":517,"./updates":519,"./utils":520}],522:[function(require,module,exports){
  'use strict';

  const live = require('../../live');
  const $ = require('../../spotify-elements');

  const playerActions = require('./actions');
  const playerUpdates = require('./updates');
  const utils = require('./utils');

  let isAttached = false;

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    playerActions.setMethods({
      getPlayerTrackProvider: getPlayerTrackProvider,
      getPlayerVariantUri: getPlayerVariantUri,
      handlePlayButton: handlePlayButton,
      handlePlayFromRow: handlePlayFromRow
    });

    playerUpdates.setMethods({
      getPlayerTrackProvider: getPlayerTrackProvider,
      getPlayerVariantUri: getPlayerVariantUri,
      getPlayerIsPlaying: getPlayerIsPlaying,
      getPlayingNodes: getPlayingNodes,
      subscribeToPlayerChange: subscribeToPlayerChange
    });

    playerActions.attach();
    playerUpdates.attach();
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    playerActions.detach();
    playerUpdates.detach();
  };

  exports.update = function (optNode) {
    if (!isAttached) return;

    playerUpdates.update(optNode);
  };

  function getPlayerTrackProvider() {
    const track = live('spotify:player').get('track');
    return track ? track.get('provider') || '' : '';
  }

  /**
   * Get the variant URI for the currently playing context. For example, if
   * playing a sorted playlist, this should return the sorted URI.
   *
   * @return {string} The context variant URI, or empty string if nothing is
   *     playing.
   */
  function getPlayerVariantUri() {
    const variant = live('spotify:player').get('variant');
    return variant ? variant.uri : '';
  }

  /**
   * Get the index of the currently playing page.
   *
   * @return {number} The page index, or -1 if not found.
   */
  function getPlayerPageIndex() {
    const indexObject = live('spotify:player').get('index');
    const pageIndex = indexObject && indexObject.get('page');
    const hasPageIndex = typeof pageIndex === 'number';
    return hasPageIndex ? pageIndex : -1;
  }

  /**
   * Get the UID of the currently playing track.
   *
   * @return {string} The UID, or empty string if not found.
   */
  function getPlayerTrackUid() {
    return live('spotify:player').get('uid') || '';
  }

  /**
   * Get the URI of the currently playing track.
   *
   * @return {string} The track URI, or empty string if nothing is playing.
   */
  function getPlayerTrackUri() {
    const track = live('spotify:player').get('track');
    return track && track.uri || '';
  }

  /**
   * Get the playing status of the player.
   *
   * @return {boolean} True if the player is currently playing audio.
   */
  function getPlayerIsPlaying() {
    const isPlaying = live('spotify:player').get('isPlaying');
    const isPaused = live('spotify:player').get('isPaused');
    return isPlaying && !isPaused;
  }

  /**
   * Get whether the playback was initiated from open.spotify.com
   *
   * This info is needed to be able to do a best-effort of highlighting rows when
   * playing from open.
   *
   * @return {boolean} True if playing from open.spotify.com.
   */
  function getPlayerIsPlayingFromOpen() {
    const playOrigin = live('spotify:player').get('playOrigin');
    const externalReferrer = playOrigin && playOrigin.get('externalReferrer');

    return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
  }

  /**
   * Subscribe to player changes.
   *
   * @param {Function} handler A handler function. The data passed to this
   *     function is irrelevent, only the fact that something changed is needed.
   *
   * @return {Object} An object with a `cancel` method to cancel the subscription.
   */
  function subscribeToPlayerChange(handler) {
    live('spotify:player').on('update', handler);
    let active = true;
    return {
      cancel: function () {
        if (active) {
          live('spotify:player').off('update', handler);
          active = false;
        }
      }
    };
  }

  /**
   * Handle the click of a play button.
   * This function should decide what the action should be, and pause/resume
   * playback or start playback of a new context.
   *
   * @param {HTMLElement} buttonNode A button DOM node.
   * @param {Object} data Object of data about the action:
   *     isPlayingContext: (boolean) Whether the button looks to be representing
   *         the currently playing context.
   *     contextUri: (string) The context URI for the button.
   *     source: (string) The 'play source' value, for logging purposes.
   *     reason: (string) The 'play reason' value, for logging purposes.
   */
  function handlePlayButton(buttonNode, data) {
    let isPlaying = data.isPlayingContext;

    const trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
    const trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
    const pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

    if (isPlaying) {
      isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
    }

    if (isPlaying) {
      if (getPlayerIsPlaying()) {
        live('spotify:player').emit('pause');
      } else {
        live('spotify:player').emit('resume');
      }
    } else {
      const eventData = {
        context: data.contextUri,
        source: data.source,
        reason: data.reason
      };

      if (trackUid) {
        eventData.uid = trackUid;
      }

      if (trackUri) {
        eventData.trackUri = trackUri;
      }

      if (!isNaN(pageIndex)) {
        eventData.page = pageIndex;
      }

      live('spotify:player').emit('play', eventData);
    }
  }

  /**
   * Verify that a uid, uri or pageIndex is playing, or that just the context
   * is playing when none of that is set.
   * This is used when we already know that we're playing the context.
   *
   * @param {string} trackUid
   * @param {string} trackUri
   * @param {number} pageIndex
   *
   * @return {boolean} True if it's really playing
   */
  function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
    if (trackUid) {
      const playerTrackUid = getPlayerTrackUid();
      return playerTrackUid === trackUid;
    }

    if (trackUri) {
      const playerTrackUri = getPlayerTrackUri();
      return playerTrackUri === trackUri;
    }

    if (!isNaN(pageIndex)) {
      const playerPageIndex = getPlayerPageIndex();
      return playerPageIndex === pageIndex;
    }

    // No index given also means it's really playing.
    return true;
  }

  /**
   * Handle playing a list row. This function should start playback of a context
   * starting from a specific row.
   *
   * @param {HTMLElement} rowNode A DOM node for a list row.
   * @param {Object} data Object of data about the action:
   *     contextUri: (string) The context URI for the list.
   *     source: (string) The 'play source' value, for logging purposes.
   *     reason: (string) The 'play reason' value, for logging purposes.
   */
  function handlePlayFromRow(rowNode, data) {
    const eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    const uid = rowNode.getAttribute('data-uid');
    if (uid) {
      eventData.uid = uid;
    }

    const pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }

  /**
   * Get the nodes inside the passed container node that should be marked as
   * playing.
   *
   * @param {HTMLElement} containerNode The DOM node to search inside.
   * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
   *     matched based on context URIs. These can be filtered if needed, but
   *     otherwise they should be included in the return value.
   *
   * @return {Array.<HTMLElement>} An array of DOM nodes.
   */
  function getPlayingNodes(containerNode, contextNodes) {
    const playerPageIndex = getPlayerPageIndex();
    const playerTrackUid = getPlayerTrackUid();
    const playerTrackUri = getPlayerTrackUri();
    const variantUri = getPlayerVariantUri();

    // Remove any matched context nodes that have a page specified and where
    // the current player page does not match.
    const filteredContextNodes = filterPages(playerPageIndex, contextNodes);

    const selectors = utils.getContextSelectorsWithVariants(variantUri);
    const rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

    const selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
    const pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

    // Only return button nodes whos closest context is one of the nodes in the
    // contextNodes array. Imagine this minimal node tree:
    //
    // [data-context][data-uri="spotify:root-context"]
    //   [data-button=play-context]
    //   [data-context][data-uri="spotify:nested-context"]
    //     [data-button=play-context]
    //
    // The first [data-button=play-context] should play "spotify:root-context".
    // Ths second [data-button=play-context] should play "spotify:nested-context".
    let buttonNodes = [];
    if (contextNodes.length) {
      const candidates = $(contextNodes).search('[data-button=play-context]');
      if (candidates) {
        buttonNodes = candidates.filter(candidate => {
          const closestContextNode = candidate.closest('[data-context]');
          return contextNodes.indexOf(closestContextNode) >= 0;
        });
      }
    }

    // Let `elements` remove any duplicate nodes
    const nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

    return nodes ? Array.prototype.slice.call(nodes) : [];
  }

  /**
   * Get the nodes inside the passed container node that match what's currently
   * playing and are list rows.
   *
   * @param {HTMLElement} containerNode The DOM node to search inside.
   * @param {Array.<string>} selectors Array of CSS selectors for matching the
   *     currently playing context.
   * @param {string} trackUid The UID of the currently playing track.
   *
   * @return {Array.<HTMLElement>} Array of DOM nodes.
   */
  function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {
    // When playing from this client, we highlight the playing UIDs.
    const useTrackSelector = getPlayerIsPlayingFromOpen();

    const selector = selectors.map(function (s) {
      let newSelector = `${s} `;
      if (useTrackSelector) newSelector += `[data-uri=${trackUri}]`;
      if (!useTrackSelector) newSelector += `[data-uid=${trackUid}]`;
      return newSelector;
    }).join(', ');

    let nodes = $(containerNode).search(selector);
    if (nodes) {
      nodes = Array.prototype.slice.call(nodes);

      if (useTrackSelector) {
        // Gets UID of the first node and find all the nodes
        // with the same UID
        const firstUid = $(nodes[0]).data('uid');
        nodes = nodes.filter(function (row) {
          return firstUid === $(row).data('uid');
        });
      }
    } else {
      nodes = [];
    }

    return nodes;
  }

  /**
   * Get the nodes inside the passed container node that match what's currently
   * playing and have a matching page specified.
   *
   * @param {HTMLElement} containerNode The DOM node to search inside.
   * @param {Array.<string>} selectors Array of CSS selectors for matching the
   *     currently playing context.
   * @param {number} playerPageIndex The currently playing page index.
   *
   * @return {Array.<HTMLElement>} Array of DOM nodes.
   */
  function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
    const pageAttribute = '[data-context-page]';

    // It needs to search for all range elements somewhere inside an element
    // marked up as a context, as well as range elements that themselves are
    // contexts.
    const newSelectors = selectors.map(function (selector) {
      const pageInContextSelector = `${selector} ${pageAttribute}`;
      const pagedContextSelector = selector + pageAttribute;
      const pageSelector = `${pageInContextSelector}, ${pagedContextSelector}`;
      return pageSelector;
    });

    let pageNodes = $(containerNode).search(newSelectors.join(', '));
    if (pageNodes) {
      pageNodes = Array.prototype.slice.call(pageNodes);
    } else {
      pageNodes = [];
    }

    return filterPages(playerPageIndex, pageNodes);
  }

  /**
   * Return a new array of nodes where nodes that specify a context page that
   * doesn't match the currently playing context page are removed.
   *
   * @param {number} playerPageIndex The currently playing page index.
   * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
   *
   * @return {Array.<HTMLElement>} Array of filtered nodes.
   */
  function filterPages(playerPageIndex, contextNodes) {
    return contextNodes.filter(function (node) {
      const nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

      // Node without a page should always be active
      if (isNaN(nodePageIndex)) return true;

      // If player has no page, but the node has a page, we can't be sure if it's
      // playing.
      if (isNaN(playerPageIndex)) return false;

      // Node that matches the player page should be active
      return playerPageIndex === nodePageIndex;
    });
  }

  },{"../../live":413,"../../spotify-elements":460,"./actions":517,"./updates":519,"./utils":520}],523:[function(require,module,exports){
  'use strict';

  const Range = require('../range2');

  const contains = require('mout/array/contains');

  const $ = require('../spotify-elements');

  const SYNC = require('../../libs/prime/emitter').EMIT_SYNC;
  const attentionHighlight = require('../../libs/glue').attentionHighlight;

  const throttle = require('./util/throttle');
  const ListManager = require('./util/ListManager.js');

  const center = require('./center');

  const doc = $(document);
  const win = $(window);

  let scrollContainers = [];
  let listManagers = [];
  let scrollHandlers = [];
  const pendingScrollContainers = [];
  const pendingHiddenIndices = [];
  let cleanupHandlers = [];

  const getBounds = function (view, container) {
    const dde = document.documentElement;
    let newView = view;

    if (newView === window || newView === document.body) newView = dde;
    const viewTop = newView === dde ? 0 : newView.getBoundingClientRect().top;

    const viewHeight = newView.clientHeight;
    const containerTop = container.getBoundingClientRect().top;
    const containerHeight = container.offsetHeight;

    const viewBox = {
      top: viewTop,
      height: viewHeight,
      bottom: viewTop + viewHeight
    };

    const containerBox = {
      top: containerTop,
      height: containerHeight,
      bottom: containerTop + containerHeight
    };

    return {
      view: viewBox,
      container: containerBox
    };
  };

  const getRange = function (view, container, height, hotZone = 0) {
    const bounds = getBounds(view, container);
    const top = -(bounds.container.top - bounds.view.top);
    let startsAt = Math.floor((top - hotZone) / height);
    const endsAt = Math.ceil((top + bounds.view.height + hotZone) / height);
    if (startsAt < 0) startsAt = 0;
    if (endsAt <= startsAt) return false;
    return new Range(startsAt, endsAt);
  };

  const init = function (view, container, length, height, tag) {
    const view0 = view[0];
    const container0 = container[0];
    let savedAttentionHighlightIndex = -1;

    container.addClass('scroll-container-enabled');

    const attentionHighlightIndex = (c, index) => {
      if ($(c) === container) {
        const row = container0.querySelector(`[data-index='${index}']`);
        if (!row) {
          savedAttentionHighlightIndex = index;
          return;
        }

        savedAttentionHighlightIndex = -1;

        let tableRowAttentionHighlight = document.querySelector('[data-table-row-attention-highlight]');
        if (!tableRowAttentionHighlight) {
          tableRowAttentionHighlight = document.createElement('div');
          tableRowAttentionHighlight.className = 'tl-attention-highlight';
          tableRowAttentionHighlight.setAttribute('data-table-row-attention-highlight', '');
          document.body.appendChild(tableRowAttentionHighlight);
        }

        const scrollY = window.pageYOffset;
        const rect = row.getBoundingClientRect();

        // Use document width instead of window width to handle the case when
        // there are scroll bars that are not overlay scroll bars.
        const viewportWidth = document.documentElement.offsetWidth;

        tableRowAttentionHighlight.classList.add('visible');
        tableRowAttentionHighlight.style.top = `${rect.top + scrollY}px`;
        tableRowAttentionHighlight.style.left = `${rect.left}px`;
        tableRowAttentionHighlight.style.right = `${viewportWidth - rect.right}px`;

        setTimeout(() => {
          tableRowAttentionHighlight.classList.remove('visible');
        }, attentionHighlight.HIDE_DELAY);
      }
    };

    const manager = new ListManager(container0, {
      height: height,
      length: length,
      tag: tag,
      debug: false,
      request: function (range, callback) {
        center.emit('scroll-request', container0, range, callback, SYNC);
      }
    });
    listManagers.push(manager);

    // Update the manager with previously saved hidden indices.
    // This allows the scroller to take hidden indices into account even for the
    // first render.
    const pendingIndex = pendingScrollContainers.indexOf(container);
    if (pendingIndex > -1) {
      manager.reset(length, pendingHiddenIndices[pendingIndex]);
      pendingScrollContainers.splice(pendingIndex, 1);
      pendingHiddenIndices.splice(pendingIndex, 1);
    }

    manager.on('before-show', function (range, nodes) {
      center.emit('scroll-show-before', {
        pageNode: container,
        container: container,
        range: range,
        nodes: nodes
      }, SYNC);
    });

    manager.on('after-show', function (range, nodes) {
      center.emit('scroll-show-after', {
        pageNode: container,
        container: container,
        range: range,
        nodes: nodes
      }, SYNC);
    });

    manager.on('index-change', function (index) {
      center.emit('scroll-index-change', {
        pageNode: container,
        container: container,
        ranges: index
      }, SYNC);
    });

    let hasRequestedMore = false;

    const scrollReset = function (c, scrollResetHeight, hiddenIndices, fromIndex) {
      if ($(c) === container) {
        const hasFromIndex = typeof fromIndex === 'number';
        if (hasFromIndex && fromIndex > 0) {
          manager.resetFrom(fromIndex, scrollResetHeight, hiddenIndices);
        } else {
          manager.reset(scrollResetHeight, hiddenIndices);
        }
        container._scrollEvent();
      }
    };

    const scroll = function () {
      const bounds = getBounds(view0, container0);
      let show = getRange(view0, container0, height);

      if (show) {
        manager.on('after-show', function onAfterShow() {
          manager.off('after-show', onAfterShow);

          if (savedAttentionHighlightIndex > -1 && savedAttentionHighlightIndex >= show.start && savedAttentionHighlightIndex < show.end) {
            attentionHighlightIndex(container, savedAttentionHighlightIndex);
          }
        });

        const padding = 2;
        show = new Range(show.start - padding, show.end + padding);
        manager.show(new Range(show.start, show.end));
      }

      // If the scroll position is close enough to the end, an event should be
      // emitted to allow for more content to be loaded. Not all lists will use this,
      // but some lists want to lazy load content by loading more when you reach the
      // bottom, and then they can listen for this event.
      if (!hasRequestedMore) {
        if (bounds.container.bottom < 2000) {
          hasRequestedMore = true;

          // Emit the event and also pass a callback to the event.
          // The receiver of this event should pass the new total length of the list
          // as the second argument to the callback.
          center.emit('scroll-request-more', container0, function (error, emitLength) {
            if (error) throw error;
            hasRequestedMore = false;
            scrollReset(container0, emitLength);
          });
        }
      }
    };

    scrollHandlers.push(scroll);
    container._scrollEvent = throttle(scroll);

    center.on('scroll-reset', scrollReset);
    container._scrollResetEvent = scrollReset;

    const scrollToIndex = function (c, index, options = {}) {
      if (view0 !== window) {
        throw new Error("Can't scroll to index if view is not `window`");
      }

      if ($(c) === container) {
        const bounds = getBounds(view0, container0);

        const offset = options.centerRowIfScrollIsNeeded ? (bounds.view.height - manager.height) / 2 : 0;

        const indexTopRelativeToContainer = manager.height * index;
        const position = bounds.container.top + indexTopRelativeToContainer;

        let scrollY = position + window.pageYOffset;
        let stickyOffset = (doc.search('[data-sticky-active]') || []).map(function (sticky) {
          return sticky.offsetHeight;
        }).reduce(function (a, b) {
          return a + b;
        }, 0);

        if (document.querySelector('[data-top-bar-height]')) {
          stickyOffset += parseInt(document.querySelector('[data-top-bar-height]').getAttribute('data-top-bar-height'), 10);
        }

        if (position <= stickyOffset) {
          // item is above viewport
          scrollY -= offset + stickyOffset;
        } else if (position + manager.height > bounds.view.height) {
          // item is below viewport
          scrollY += offset + manager.height - bounds.view.height;
        } else {
          // item is in viewport
          return;
        }

        view0.scrollTo(0, scrollY);
      }
    };

    const hideAttentionHighlight = () => {
      const tableRowAttentionHighlight = document.querySelector('[data-table-row-attention-highlight]');
      if (tableRowAttentionHighlight) {
        tableRowAttentionHighlight.parentNode.removeChild(tableRowAttentionHighlight);
      }
    };

    center.on('scroll-to-index', scrollToIndex);
    center.on('attention-highlight-index', attentionHighlightIndex);
    center.on('hide-attention-highlight', hideAttentionHighlight);

    view.on('scroll', scroll);
    win.on('resize', scroll);
    scroll();

    cleanupHandlers.push({
      container: container,
      clean: function () {
        center.off('scroll-reset', scrollReset);
        center.off('scroll-to-index', scrollToIndex);
        center.off('attention-highlight-index', attentionHighlightIndex);
        center.off('hide-attention-highlight', hideAttentionHighlight);
        view.off('scroll', scroll);
        win.off('resize', scroll);

        delete container._scrollEvent;
        delete container._scrollResetEvent;

        savedAttentionHighlightIndex = -1;

        container.removeClass('scroll-container-enabled');
      }
    });
  };

  function onScrollSetHidden(data) {
    const hiddenIndices = data.indices;

    const container = $(data.itemContainer);
    const index = scrollContainers.indexOf(container);
    if (index > -1) {
      const manager = listManagers[index];
      if (manager) {
        manager.reset(manager.length, hiddenIndices);
      }
      const scrollHandler = scrollHandlers[index];
      if (scrollHandler) {
        scrollHandler();
      }
    } else {
      pendingScrollContainers.push(container);
      pendingHiddenIndices.push(hiddenIndices);
    }
  }

  let isAttached = false;

  exports.update = function (node) {
    if (!isAttached) return;

    const newNode = $(node) || doc;

    let scrollNodes = doc.search('[data-scroll-container]');

    const handlers = [];
    const managers = [];
    scrollContainers = scrollContainers.filter(function (container, index) {
      if (!contains(scrollNodes, container[0])) {
        for (let i = 0; i < cleanupHandlers.length; i++) {
          if (cleanupHandlers[i].container === container) {
            cleanupHandlers[i].clean();
            cleanupHandlers.splice(i, 1);
            break;
          }
        }
        return false;
      }
      managers.push(listManagers[index]);
      handlers.push(scrollHandlers[index]);
      return true;
    });
    listManagers = managers;
    scrollHandlers = handlers;

    if (newNode !== doc) scrollNodes = newNode.search('[data-scroll-container]');

    if (scrollNodes) {
      scrollNodes.forEach(function (node0) {
        const container = $(node0);

        if (container._scrollEvent || node0.children.length) return;

        scrollContainers.push(container);
        const view = container.parent('[data-scroll-view]') || win;

        const callback = function (error, children, length) {
          if (error) throw error;

          let newChildren = children;

          // Only continue initialization if the container is still in the DOM
          if (contains(doc.search('[data-scroll-container]'), container[0])) {
            newChildren = $(newChildren);
            newChildren.insert(container);

            const second = newChildren[1];
            const height = second.offsetHeight;
            const tag = $(second).tag();
            newChildren.remove();
            init(view, container, length, height, tag);
          }
        };

        center.emit('scroll-request', container[0], new Range(0, 3), callback, SYNC);
      });
    }
  };

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    center.on('scroll-set-hidden', onScrollSetHidden);
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    center.off('scroll-set-hidden', onScrollSetHidden);

    scrollContainers = [];
    cleanupHandlers.forEach(function ({ clean }) {
      clean();
    });
    cleanupHandlers = [];
  };

  },{"../../libs/glue":159,"../../libs/prime/emitter":451,"../range2":454,"../spotify-elements":460,"./center":471,"./util/ListManager.js":537,"./util/throttle":543,"mout/array/contains":776}],524:[function(require,module,exports){
  'use strict';

  var _spotifyCosmosApi = require('spotify-cosmos-api');

  var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

  var _tokens = require('@spotify/glue-tokens/tokens.json');

  var _tokens2 = _interopRequireDefault(_tokens);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  let isAttached = false;
  let controlMessageSubscription;
  let currentStyle = 'always-visible';

  function refreshStyle() {
    const isMac = window.navigator.platform.startsWith('Mac');
    const isWindows = window.navigator.platform.startsWith('Win');

    let os = 'linux';
    if (isMac) {
      os = 'mac';
    }
    if (isWindows) {
      os = 'windows';
    }

    if (currentStyle === 'always-visible') {
      document.documentElement.classList.add(`scrollbar-style-visible-${os}`);

      if (os === 'mac') {
        document.documentElement.classList.remove('scrollbar-style-when-scrolling-mac');
      }
    } else {
      document.documentElement.classList.remove(`scrollbar-style-visible-${os}`);

      if (os === 'mac') {
        document.documentElement.classList.add('scrollbar-style-when-scrolling-mac');
      }
    }
  }

  // Fix a rendering bug in Chromium. When scroller style changes in the
  // system (changing system preference, connecting/disconnecting a mouse
  // etc), Chromium will not always render properly. Sometimes it shows a
  // white area where the scroll bar is supposed to be and sometimes it
  // renders it with native styles even though the CSS styles should be
  // applied. By changing the scroll bar style temporarily it will force the
  // scroll bars to re-render. We use a background that will most likely not be
  // part of our color palette (with alpha 0 to not show it), to make sure we
  // actually trigger a re-render.
  //
  // https://jira.spotify.net/browse/KM-8285
  // http://crbug.com/538579
  function performFixWithScrollBarBackgroundColor() {
    const styleNode = document.createElement('style');
    styleNode.innerHTML = '::-webkit-scrollbar {background-color: rgba(1, 2, 3, 0) !important}';
    document.head.appendChild(styleNode);
    // Delay removal one tick so that it has time to render
    setTimeout(() => {
      document.head.removeChild(styleNode);
    }, 0);
  }

  // Fix a rendering bug in Chromium. When loading an iframe, the scroll bar color
  // is the wrong color (black scroll bar on black background). We can shake this
  // in place by changing the background color on body (the scrollable element).
  //
  // http://crbug.com/811725
  function performFixWithBodyBackgroundColor() {
    document.body.style.backgroundColor = _tokens2.default.GLUE_COLOR_GRAY_10;

    // Delay removal one tick so that it has time to render
    setTimeout(() => {
      document.body.style.removeProperty('background-color');
    }, 0);
  }

  exports.update = function () {};

  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    const initialValue = window.__spotify && window.__spotify.scroller_style;
    currentStyle = initialValue === 'overlay' ? 'overlay' : 'always-visible';
    refreshStyle();

    performFixWithBodyBackgroundColor();

    // Sometimes when navigating back and forward in history navigation the
    // scroll bars disappear. They reappear when hovering some elements like the
    // play button on cards that have a scale animation. We can force show them
    // by performing the background color fix to trigger a re-render.
    window.addEventListener('message', event => {
      if (event.data.name === 'set_active' && event.data.active) {
        performFixWithScrollBarBackgroundColor();
      }
    });

    controlMessageSubscription = _spotifyCosmosApi2.default.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, (error, response) => {
      if (!error) {
        const data = response.getJSONBody();
        if (data) {
          let styleWasChanged = false;
          switch (data.type) {
            case 'set_scroller_style_always_visible':
              currentStyle = 'always-visible';
              styleWasChanged = true;
              break;
            case 'set_scroller_style_overlay':
              currentStyle = 'overlay';
              styleWasChanged = true;
              break;
            default:
              break;
          }

          if (styleWasChanged) {
            refreshStyle();
          }

          if (styleWasChanged) {
            // Perform the fix twice (once with a delay), since it sometimes might
            // be slow and won't apply the fix on the first try.
            performFixWithScrollBarBackgroundColor();
            setTimeout(performFixWithScrollBarBackgroundColor, 1000);
          }
        }
      } else {
        controlMessageSubscription.cancel();
      }
    });
  };

  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    if (controlMessageSubscription) {
      controlMessageSubscription.cancel();
      controlMessageSubscription = null;
    }
  };

  },{"@spotify/glue-tokens/tokens.json":567,"spotify-cosmos-api":1272}],526:[function(require,module,exports){
  /**
   * @module spotify-events/selection/containers
   * @private
   */
  'use strict';

  const $ = require('../../spotify-elements');
  const live = require('../../live');

  /**
   * Container DOM nodes.
   *
   * @type {Array.<HTMLElement>}
   */
  const containers = [];

  /**
   * Forget the known containers.
   */
  function reset() {
    containers.length = 0;
  }

  /**
   * Update container storage based on the current DOM.
   */
  function update() {
    const nodes = $(document).search(':not(.sticky-clone) > [data-list]');
    if (!nodes) return;

    // Don't drop any containers. If they are removed from the DOM we just keep
    // the reference along with the selection state at the same index. Clearing
    // has to be done manually instead.

    nodes.forEach(function (container) {
      if (!containers.includes(container)) {
        containers.push(container);
        containers.sort((a, b) => {
          let n;
          if (a === b) {
            n = 0;
          } else if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_PRECEDING) {
            n = 1;
          } else {
            n = -1;
          }
          return n;
        });
      }
    });
  }

  /**
   * Get the number of rows in the container at the specified index.
   *
   * @param {number} index The container index.
   *
   * @return {number} The number of rows.
   */
  function getContainerLength(index) {
    const container = $(containers[index]);
    if (!container) return 0;

    const uri = container.data('uri');
    if (!uri) return 0;

    const list = live(uri).get('rows');
    if (!list) return 0;

    return list.length;
  }

  /**
   * Get the index of a container based on URI.
   *
   * @param {string} uri The URI of the container.
   *
   * @return {number} The index of the container. Returns -1 if not found.
   */
  function getContainerIndex(uri) {
    for (let i = 0, l = containers.length; i < l; i++) {
      const containerUri = getUri(i);
      if (containerUri === uri) return i;
    }

    return -1;
  }

  /**
   * Get the URI for a container.
   *
   * @param {number} index The container index.
   *
   * @return {string?} The URI or null if not found.
   */
  function getUri(index) {
    const element = containers[index];
    const uri = element && element.getAttribute('data-uri');
    return uri || null;
  }

  /**
   * Get the URIs for all containers.
   *
   * @return {Array.<string?>} Array of URIs.
   */
  function getUris() {
    const uris = [];
    for (let i = 0, l = containers.length; i < l; i++) {
      uris.push(getUri(i));
    }
    return uris;
  }

  /**
   * Get the live list for a container.
   *
   * @param {number} index The container index.
   *
   * @return {LiveList?} A live list or null if not found.
   */
  function getLiveList(index) {
    const uri = getUri(index);
    const list = live(uri).get('rows');
    return list || null;
  }

  exports.elements = containers;
  exports.reset = reset;
  exports.update = update;
  exports.getContainerLength = getContainerLength;
  exports.getContainerIndex = getContainerIndex;
  exports.getUri = getUri;
  exports.getUris = getUris;
  exports.getLiveList = getLiveList;

  },{"../../live":413,"../../spotify-elements":460}],527:[function(require,module,exports){
  (function (global){
  /**
   * spotify-events/selection/controller
   * @private
   */
  'use strict';

  const $ = require('../../spotify-elements');
  const intersection = require('mout/array/intersection');
  const live = require('../../live');
  const liburi = require('spotify-liburi');

  const center = require('../center');
  const selection = require('./index');
  const model = require('./model');
  const rows = require('./rows');
  const containers = require('./containers');
  const positions = require('./positions');
  const Position = require('../util/Position');
  const cosmos = require('../util/cosmos');

  let focusEventValid = false;
  let mouseDownTarget = null;

  // Listeners per URI (key is URI)
  const listListeners = {};
  const listListenerUris = [];

  const SELECTABLE = '[data-list-item]';
  const CLIPBOARD_ENDPOINT = 'sp://desktop/v1/clipboard';

  /**
   * Check whether the event occured on the documentElement.
   *
   * @param {Event} event A event object.
   *
   * @return {boolean}
   */
  function isOnDocument(event) {
    return event.target === document.documentElement;
  }

  /**
   * Get the row node from a mouse event.
   *
   * @param {MouseEvent} event A mouse event object.
   *
   * @return {HTMLElement} A DOM node.
   */
  function getNodeFromEvent(event) {
    return event.target !== document && event.target.closest(SELECTABLE);
  }

  /**
   * Check if a target is inside a filter component.
   *
   * @param {HTMLElement} target A DOM node.
   *
   * @return {boolean} Whether the target was inside a filter component.
   */
  function isFilterTarget(target) {
    return target !== document && !!target.closest('[data-filter]');
  }

  /**
   * Handle a mousedown event.
   *
   * @param {MouseEvent|TouchEvent} event A mouse or touch event.
   * @param {boolean=} isMouseUp Pass true if this is a simulated mousedown
   *     triggered by a mouseup event.
   */
  function handleMouseDown(event, isMouseUp) {
    if (isOnDocument(event)) {
      return;
    }

    focusEventValid = false;
    const node = getNodeFromEvent(event);

    if (isMouseUp) {
      if (event.target !== mouseDownTarget) {
        mouseDownTarget = null;
        return;
      }
      mouseDownTarget = null;
    } else {
      mouseDownTarget = event.target;
    }

    if (node) {
      handleRowMouseDown(event, node, isMouseUp);
    } else {
      handleOutsideMouseDown(event);
    }
  }

  /**
   * Handle when the mouse is pressed down on a list row.
   *
   * @param {MouseEvent|TouchEvent} event A mouse or touch event.
   * @param {HTMLElemtn} rowNode The DOM node for the clicked row.
   * @param {boolean=} isMouseUp Pass true if this is a simulated mousedown
   *     triggered by a mouseup event.
   */
  function handleRowMouseDown(event, rowNode, isMouseUp) {
    const button = getButtonFromEvent(event);
    const isPrimaryButton = button === 1;

    // If we can't find a valid position for the DOM node, we can't handle
    // selection correctly.
    const position = positions.getFromNode(rowNode);
    if (!position) return;

    const isSelected = model.isSelected(position);
    let singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
    let multiselect = event.shiftKey || singleMultiSelect;
    let singleClick = !event.shiftKey;

    if (!isMultiSelectEnabled()) {
      singleMultiSelect = multiselect = false;
      singleClick = true;
    }

    // Remove selection if a selected item is clicked with cmd/ctrl
    if (multiselect && singleClick && isSelected && isPrimaryButton) {
      // For multiselect, make sure we do the deselection only on mouseup
      if (!isMouseUp) return;
      handleDeselectOnSingleMultiSelect(position);

      // Select multiple items if clicked with shift key
    } else if (!singleClick) {
      // Optimize by doing this only on mousedown
      if (isMouseUp) return;
      handleShiftMultiSelect(position);

      // Select a single item
    } else {
      // Handle the case when the primary button is pressed down on a selected item.
      // The method will be called once again in that case, on mouse up. This is
      // to allow the drag and drop to abort the selection change.

      // So we do the actual selection on mouseup, where we know it's not a drag n drop thing.
      if (isPrimaryButton && isSelected && !isMouseUp) {
        return;
      }
      // For multiselect, make sure we do the selection only on mouseup
      if (multiselect && !isMouseUp) {
        return;
      }

      handleSingleSelect(position, event, isMouseUp);
    }
    rows.update();
  }

  /**
   * Handle when the mouse is pressed down outside a list row.
   *
   * @param {MouseEvent} event A mouse event.
   */
  function handleOutsideMouseDown(event) {
    const isSort = event.target !== document && !!event.target.closest('[data-sort]');
    const isFilter = isFilterTarget(event.target);
    const hasSelection = model.hasSelection();

    // Deselect if clicked outside the list.
    // Clicking sort headers should just sort, not clear selection.
    if (!(isSort || isFilter) && hasSelection) {
      model.clear();
      rows.update();
    }
  }

  /**
   * Handle a focus event.
   *
   * @param {MouseEvent} event A mouse event.
   */
  function handleFocus(event) {
    if (!focusEventValid) return;
    const node = getNodeFromEvent(event);
    if (node) {
      handleRowFocus(event, node);
    } else {
      handleOutsideFocus(event);
    }
    focusEventValid = false;
  }

  /**
   * Handle when a row receives focus.
   *
   * @param {MouseEvent} event A mouse event.
   * @param {HTMLElement} rowNode The DOM node for the focused row.
   */
  function handleRowFocus(event, rowNode) {
    const position = positions.getFromNode(rowNode);

    // Invalid positions and already selected rows don't need to be handled
    if (!position || model.isSelected(position)) {
      return;
    }

    model.clear();
    model.add(position);
    model.setFocus(position);
    model.setOrigin(position);
    rows.update();
  }

  /**
   * Handle when an element outside the table receives focus.
   *
   * @param {MouseEvent} event A mouse event.
   */
  function handleOutsideFocus(event) {
    if (isFilterTarget(event.target)) return;
    model.clear();
    rows.update();
  }

  /**
   * Handle when the mouse button is released.
   *
   * @param {MouseEvent|TouchEvent} event A mouse or touch event.
   */
  function handleMouseUp(event) {
    if (isOnDocument(event)) {
      return;
    }

    handleMouseDown(event, true);
  }

  /**
   * Handle deselecting a currently selected row in a multi-select situation
   * (cmd/ctrl). This might mean that we need to adjust origin and focus as well.
   *
   * @param {Position} position Position clicked on.
   */
  function handleDeselectOnSingleMultiSelect(position) {
    const origin = model.getOrigin();
    const focus = model.getFocus();
    let dir = positions.getDirection(origin, focus);

    // When removing the node that is both origin and focus, there will be no
    // direction in which the origin/focus could be moved. Like here:

    // Click A, CMD click C, CMD click B, CMD click B again.

    // Native desktop will now still have origin on B. MacOS Finder does move
    // origin but it's hard to know how it decides.

    // For a predictable behaviour, default to look downwards, and always reverse
    // the direction when no selected node is found.

    if (!dir) dir = 1;

    const isOrigin = position.isSame(origin);
    const isFocus = position.isSame(focus);
    let above;
    let below;

    if (isOrigin || isFocus) {
      above = getClosestSelected(position, 'up');
      below = getClosestSelected(position, 'down');
    }

    // If direction is down (1), the next after origin is found below
    if (isOrigin) {
      model.setOrigin(dir === 1 ? below || above : above || below);
    }

    // If direction is down (1), the next after focus is found above
    if (position.isSame(focus)) {
      model.setFocus(dir === 1 ? above || below : below || above);
    }

    model.remove(position);
  }

  /**
   * Handle multi-selecting a range from the current focus to the new position.
   * This also handles deselecting as needed.
   *
   * @param {Position} position Position clicked on.
   */
  function handleShiftMultiSelect(position) {
    let origin = model.getOrigin();
    const focus = model.getFocus();

    // Remove selection from origin to old focus.
    // If it's part of the new selection it will be re-added.
    if (origin && focus && !origin.isSame(focus)) {
      model.remove(origin, focus);
    }

    // If there is no origin, we will set the origin to the first selectable row
    if (!origin) {
      origin = new Position(0, 0);
      model.setOrigin(origin);
    }

    // Add selection from the current origin to the clicked position
    model.add(origin, position);
    model.setFocus(position);
  }

  /**
   * Handle a normal mousedown without any multi-select keys.
   *
   * @param {Position} position Position clicked on.
   * @param {MouseEvent|TouchEvent} event A mouse or touch event.
   */
  function handleSingleSelect(position, event) {
    const origin = model.getOrigin();

    const button = getButtonFromEvent(event);
    const isPrimaryButton = button === 1;
    const isSecondaryButton = button === 2;

    const isSelected = model.isSelected(position);
    let singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
    let multiselect = event.shiftKey || singleMultiSelect;

    if (!isMultiSelectEnabled()) {
      singleMultiSelect = multiselect = false;
    }

    // Left click without cmd/ctrl/shift clears selection.
    // Also right click on something that wasn't selected clears.
    const isRegularPrimary = !multiselect && isPrimaryButton;
    const isSelectedSecondary = !isSelected && isSecondaryButton;
    if (isRegularPrimary || isSelectedSecondary) {
      model.clear();
    }

    // Add item to selection
    model.add(position);
    model.setFocus(position, { isTouch: isTouchEvent(event) });

    // When adding to an existing selection, leave origin alone.
    let isNextToSelection;
    if (origin && !origin.isSame(position)) {
      const next = positions.getClosest(position, 'down');

      isNextToSelection = next && model.isSelected(next);
      if (!isNextToSelection) {
        const prev = positions.getClosest(position, 'up');
        isNextToSelection = prev && model.isSelected(prev);
      }
    }
    if (!isNextToSelection) {
      model.setOrigin(position);
    }
  }

  /**
   * Handler for when a key is pressed down in the list. Depending on the key,
   * this will either move the selection (up and down arrows), shrink/grow the
   * selection (shift up and down arrows) or clear the selection (escape key).
   *
   * @param {KeyboardEvent} event The event object.
   */
  function handleKeyDown(event) {
    if (isFilterTarget(event.target)) return;

    focusEventValid = true;
    const isUp = event.keyCode === 38;
    const isDown = event.keyCode === 40;

    if (!isKeyboardNavEnabled()) return;

    if (!isUp && !isDown) return;

    const origin = model.getOrigin();
    const focus = model.getFocus();
    let next = focus;

    do {
      next = next && positions.getClosest(next, isDown ? 'down' : 'up');
    } while (next && model.isPositionHidden(next));

    // Only move the selection if the up or down key was pressed.
    // And only do it if the cmd/ctrl key is not also pressed.
    // The cmd/ctrl key will change the volume in the client.
    if ((isUp || isDown) && !event.metaKey && !event.ctrlKey && next) {
      // Multi-select must have a previous selection position
      if (event.shiftKey && isMultiSelectEnabled() && origin && focus) {
        const keyDirection = isDown ? 1 : -1;
        const direction = positions.getDirection(origin, focus);
        const isSingleRange = direction === 0;
        if (isSingleRange || keyDirection === direction) {
          model.add(next);
          scrollIntoView(next);
        } else {
          model.remove(focus);
        }

        // If multi-select can't be performed, just move the current selection
      } else {
        model.clear();
        model.add(next);
        model.setOrigin(next);
        scrollIntoView(next);
        event.preventDefault(); // Prevent normal scrolling
      }

      // Always set the new focus to the row above or below
      model.setFocus(next);
    }

    rows.update();
  }

  /**
   * Handle when a section of a list is scrolled into view.
   * This needs to update selection state of the row nodes.
   *
   * @param {Object} event Event object.
   */
  function handleScrollShowAfter(event) {
    const node = event.pageNode && event.pageNode[0];
    rows.update(node);
  }

  /**
   * Handle setting which indices are hidden.
   *
   * @param {Object} data Object with properties `hiddenIndices` (array of
   *     indices) and `uri` (URI of the list).
   */
  function handleSetHidden(data) {
    model.setHiddenIndices(data.indices, data.uri);
  }

  /**
   * Add a row to the selection based on a list URI.
   * TODO: Remove logic to handle global lists.
   *
   * @param {string} listUri The list URI.
   * @param {number} index The index within the list.
   * @param {boolean=} doNotScrollIntoView Optionally skip scrolling added index into view
   */
  function handleAddByUri(listUri, index, doNotScrollIntoView) {
    const uriNodes = $(`[data-uri=${listUri}]`);
    const matches = intersection(containers.elements, uriNodes);
    let newIndex = index;

    if (!matches || matches.length < 1) {
      return;
    }

    const container = $(matches[0]);
    let containerIndex = container && containers.elements.indexOf(container[0]);
    const listIsPlayContext = container && container.matches('[data-context]');

    if (listIsPlayContext) {
      // Selection is not based on the global container that is defined via data-context,
      // so the indices need to be resolved to match the selection containers.
      const localPosition = positions.getPositionFromGlobalIndex(newIndex);
      containerIndex = localPosition.containerIndex;
      newIndex = localPosition.index;
    } else if (containerIndex === -1) {
      console.warn("No container matching this uri was found or selection doesn't know " + 'about the container. Possibly you need to run events.update.');
      return;
    }

    if (!isMultiSelectEnabled()) model.clear();

    const position = new Position(containerIndex, newIndex);
    if (!model.getOrigin()) model.setOrigin(position);
    model.setFocus(position);
    model.add(position);

    rows.update();

    if (doNotScrollIntoView !== true) {
      scrollIntoView(position);
    }
  }

  /**
   * Handle a select_all event from Cosmos.
   */
  function handleSelectAll() {
    if (!isMultiSelectEnabled()) {
      return;
    }

    model.clear();

    const first = new Position(0, 0);
    model.setOrigin(first);

    const last = positions.getLastPositionForSelectAll();
    model.setFocus(last);

    model.add(first, last);
    rows.update();
  }

  function handleCopy() {
    cosmos.put({
      url: CLIPBOARD_ENDPOINT,
      body: handleGetUris().map(uri => {
        const uriObject = liburi.from(uri);
        return uriObject && uriObject.toOpenURL();
      }).filter(Boolean).join('\n')
    });
  }

  function handleCopyAdvanced() {
    cosmos.put({
      url: CLIPBOARD_ENDPOINT,
      body: handleGetUris().filter(Boolean).join('\n')
    });
  }

  /**
   * Handle a cut event from Cosmos.
   */
  function handleCut() {
    handleCopy();

    cosmos.post({
      url: 'sp://messages/v1/container/control',
      body: { type: 'delete' }
    });
  }

  /**
   * Gets list of uris for selected rows
   *
   * @return {Array.<string>} Array of URIs.
   */
  function handleGetUris() {
    const selections = model.selections;
    const uris = [];

    let containerSelection;
    const containerSelectionByKey = key => {
      return !!containerSelection[key];
    };

    for (let container = 0; container < selections.length; container++) {
      containerSelection = selections[container];
      if (!containerSelection) continue;

      let entity;

      const list = containers.getLiveList(container);
      if (!list) continue;

      // * Order the keys
      // Since the user can select tracks in any order,
      // the selection is an unordered set until we actually retrieve the
      // uris of the selection. In this case we want to get the uris
      // in the same order as they are shown in the list.
      const orderedSelectedKeys = list.keys.filter(containerSelectionByKey);

      for (let i = 0, l = orderedSelectedKeys.length; i < l; i++) {
        const item = list.valueOf(orderedSelectedKeys[i]);
        if (!item) continue;

        entity = item.get('track');
        if (!entity) entity = item.get('playlist');
        if (!entity) entity = item.get('album');
        if (!entity) entity = item.get('artist');
        if (!entity) entity = item.get('user');
        if (!entity) entity = item;

        uris.push(entity.get('uri'));
      }
    }

    return uris;
  }

  /**
   * Get the mouse button number identifier from an event object.
   *
   * @param {MouseEvent|TouchEvent} event A mouse event.
   *
   * @return {number} A number representing the pressed button:
   *     0: No button pressed
   *     1: Primary button (usually left)
   *     2: Secondary button (usually right)
   *     3: Middle (usually the wheel)
   */
  function getButtonFromEvent(event) {
    // Touches don't have buttons, so treat all touches as a primary button
    if (isTouchEvent(event)) {
      return 1;
    }

    switch (event.button) {
      case 0:
        return 1;
      case 2:
        return 2;
      case 1:
        return 3;
      default:
        return 0;
    }
  }

  /**
   * Check if the user agent is on a Mac.
   *
   * @return {boolean} True if Mac, false otherwise.
   */
  function isMac() {
    if (!global.window) return false;
    if (!global.window.navigator) return false;
    const userAgent = global.window.navigator.userAgent || '';
    return userAgent.indexOf('Mac') > -1;
  }

  /**
   * Check if multi-select is enabled.
   * We currently disable it for the Web Player, since not much can be done with
   * a multi-selection there.
   *
   * @return {boolean} True if enabled, false otherwise.
   */
  function isMultiSelectEnabled() {
    if ($('body').data('multi-select-disabled') !== null) return false;
    if (!global.window) return false;
    return !!global.window._getSpotifyModule;
  }

  /**
   * Check if keyboard selection is enabled.
   * If it's not enabled it is not possible to move the selection with arrow
   * keys or extend it with shift + arrow keys.
   *
   * @return {boolean} True if enabled, false otherwise.
   */
  function isKeyboardNavEnabled() {
    return $('body').data('keyboard-select-disabled') === null;
  }

  /**
   * Check if the event is a touch event.
   *
   * @param {Event} event Event object.
   *
   * @return {boolean} True if it is a touch event object.
   */
  function isTouchEvent(event) {
    return !!event.changedTouches;
  }

  /**
   * Get the closest selected position in the specified direction.
   *
   * @param {Position} position A position.
   * @param {string} direction The direction to search in: 'up' or 'down'.
   *
   * @return {Position?} A position or null if not found.
   */
  function getClosestSelected(position, direction) {
    let newPosition = position;
    while (newPosition) {
      newPosition = positions.getClosest(newPosition, direction);
      if (newPosition && model.isSelected(newPosition)) {
        return newPosition;
      }
    }
    return null;
  }

  /**
   * Scroll the position into view.
   *
   * @param {Position} position A position.
   */
  function scrollIntoView(position) {
    const container = containers.elements[position.containerIndex];
    const scrollContainer = container && container.querySelector('[data-scroll-container]');
    if (scrollContainer) {
      center.emit('scroll-to-index', scrollContainer, position.index);
    } else {
      const node = positions.getNodeFromPosition(position);
      if (!node) return;

      const offset = node.getBoundingClientRect().top;
      if (offset < 0 || offset >= window.innerHeight) {
        node.scrollIntoView(offset < 0);
      }
    }
  }

  /**
   * Update the list listeners for the current containers.
   */
  function updateListListeners() {
    const uris = containers.getUris();

    for (let i = 0, l = uris.length; i < l; i++) {
      const uri = uris[i];
      if (uri && listListenerUris.indexOf(uri) === -1) {
        const list = live(uri).get('rows');
        if (list) {
          const listener = createListListener(uri);
          list.on('update', listener);
          listListeners[uri] = listener;
          listListenerUris.push(uri);
        }
      }
    }
  }

  /**
   * Create an event listener for list updates.
   * When an update happens, the selection model will be updated for the right
   * container.
   *
   * @param {string} uri A URI for a list.
   *
   * @return {function} A listener function.
   */
  function createListListener(uri) {
    return function (operations) {
      const uris = containers.getUris();
      const containerIndex = uris.indexOf(uri);
      if (containerIndex > -1) {
        // If something was removed from the list, we must update the selection
        // state, as something that was selected might have been removed.
        // Insert and move operations don't affect the current selection state,
        // as everything is based on row IDs, which don't change.
        for (let i = 0, l = operations.length; i < l; i++) {
          const operation = operations[i];
          if (operation.type === 'remove') {
            model.updateContainer(containerIndex);
            break;
          }
        }

        // Update the rows visually based on the model state
        rows.update();
      }
    };
  }

  /**
   * Remove all list listeners.
   */
  function resetListListeners() {
    for (let i = 0, l = listListenerUris.length; i < l; i++) {
      const uri = listListenerUris[i];
      const listener = listListeners[uri];
      const list = live(uri).get('rows');
      if (list && listener) {
        list.off('update', listener);
        delete listListeners[uri];
        listListenerUris.splice(i, 1);
        i--;
        l--;
      }
    }
  }

  function handleListSwap(event) {
    const rowsListBefore = live(event.before).get('rows');
    if (!rowsListBefore) return;

    const selectionBefore = selection.getIndicesPerList().filter(function (indicesPerList) {
      return indicesPerList.uri === event.before;
    })[0];

    let selectedKeysBefore = [];
    if (selectionBefore) {
      selectedKeysBefore = selectionBefore.indices.map(function (index) {
        return rowsListBefore.keys[index];
      });
    }

    center.on('scroll-reset', function onScrollReset() {
      center.off('scroll-reset', onScrollReset);

      live(event.after).get('rows', function (error, rowsListAfter) {
        selectedKeysBefore.forEach(function (selectedKeyBefore) {
          const indexAfter = rowsListAfter.keys.indexOf(selectedKeyBefore);
          if (indexAfter !== -1) {
            handleAddByUri(event.after, indexAfter, true);
          }
        });
      }, live.ASAP);
    });
  }

  exports.handleMouseDown = handleMouseDown;
  exports.handleMouseUp = handleMouseUp;
  exports.handleKeyDown = handleKeyDown;
  exports.handleFocus = handleFocus;
  exports.handleScrollShowAfter = handleScrollShowAfter;
  exports.handleSetHidden = handleSetHidden;
  exports.handleAddByUri = handleAddByUri;
  exports.handleSelectAll = handleSelectAll;
  exports.handleCopy = handleCopy;
  exports.handleCopyAdvanced = handleCopyAdvanced;
  exports.handleCut = handleCut;
  exports.handleGetUris = handleGetUris;
  exports.updateListListeners = updateListListeners;
  exports.resetListListeners = resetListListeners;
  exports.handleListSwap = handleListSwap;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../live":413,"../../spotify-elements":460,"../center":471,"../util/Position":538,"../util/cosmos":540,"./containers":526,"./index":528,"./model":529,"./positions":530,"./rows":531,"mout/array/intersection":783,"spotify-liburi":1282}],528:[function(require,module,exports){
    /**
     * spotify-events/selection
     */
    'use strict';

    const $ = require('../../spotify-elements');
    const live = require('../../live');
    const getOriginUri = require('../../live-wrapped-uri').getOriginUri;

    const center = require('../center');
    const controller = require('./controller');
    const containers = require('./containers');
    const model = require('./model');
    const rows = require('./rows');
    const positions = require('./positions');
    const Position = require('../util/Position');
    const appUtil = require('../util/app');

    const cosmos = require('../util/cosmos');

    let controlMessageSubscription;

    /**
     * Attach event listeners etc.
     */
    exports.attach = function () {
      const doc = $(document);
      doc.on('mousedown', controller.handleMouseDown);
      doc.on('touchstart', controller.handleMouseDown);
      doc.on('mouseup', controller.handleMouseUp);
      doc.on('touchend', controller.handleMouseUp);
      doc.on('keydown', controller.handleKeyDown);
      doc.on('focus', controller.handleFocus, true);

      center.on('scroll-show-after', controller.handleScrollShowAfter);
      center.on('selection-set-hidden', controller.handleSetHidden);
      center.on('list-swap', controller.handleListSwap);

      // Creating an "intentional bug".. By switching to use row IDs internally
      // for the selection model, we no longer need to manually update indices
      // as long as the new list has the same IDs (which we require anyway for
      // other reasons). We stopped using this event a long time ago anyway,
      // because it never really worked without odd behaviors. I've done a
      // code search (indexed Nov 23 2014), and there is not a single place
      // where this event is used, except in old versions of spotify-events,
      // which is not a problem. Technically, not responding to this event
      // is a breaking change, but for simplicity's sake let's stop handling it.
      // Fixing code that never gets used just for the sake of it makes no sense.
      // If someone really needs this in the future, we can fix it then.
      // So, this line should be commented for now.
      //
      // center.on('update-indices', controller.handleUpdateIndices);

      controlMessageSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
        if (error) throw error;
        const data = response.body;
        if (data && appUtil.isActiveAndFocused()) {
          if (data.type === 'select_all') {
            controller.handleSelectAll();
          } else if (data.type === 'copy') {
            controller.handleCopy();
          } else if (data.type === 'copy_advanced') {
            controller.handleCopyAdvanced();
          } else if (data.type === 'cut') {
            controller.handleCut();
          }
        }
      });
    };

    /**
     * Detach event listeners etc.
     */
    exports.detach = function () {
      const doc = $(document);
      doc.off('mousedown', controller.handleMouseDown);
      doc.off('touchstart', controller.handleMouseDown);
      doc.off('mouseup', controller.handleMouseUp);
      doc.off('touchend', controller.handleMouseUp);
      doc.off('keydown', controller.handleKeyDown);
      doc.off('focus', controller.handleFocus, true);

      center.off('scroll-show-after', controller.handleScrollShowAfter);
      center.off('selection-set-hidden', controller.handleSetHidden);
      center.off('list-swap', controller.handleListSwap);

      // See comment in `attach` for the long story why this is commented.
      // center.off('update-indices', controller.handleUpdateIndices);

      if (controlMessageSubscription) {
        controlMessageSubscription.cancel();
        controlMessageSubscription = null;
      }
    };

    /**
     * Update the module based on the current DOM state.
     */
    exports.update = function () {
      containers.update();
      controller.updateListListeners();
    };

    /**
     * Add a row to the selection based on a list URI.
     *
     * @param {string} listUri The list URI.
     * @param {number} index The index within the list.
     */
    exports.add = function (listUri, index) {
      controller.handleAddByUri(listUri, index);
    };

    /**
     * Check if the selection has any holes (contains many ranges).
     *
     * @return {boolean} True if it has holes, false otherwise.
     */
    exports.hasHoles = function () {
      return model.hasHoles();
    };

    /**
     * Check if the row node is selected.
     *
     * @param {HTMLElement|Elements} node A DOM node for a row.
     *
     * @return {boolean} True if it is selected, false otherwise.
     */
    exports.isNodeSelected = function (node) {
      const newNode = 'innerHTML' in node ? node : node[0];
      if (!newNode) return false;

      const position = positions.getFromNode(newNode);
      if (!position) return false;

      return model.isSelected(position);
    };

    /**
     * Reset the selection state and its knowledge of any containers.
     */
    exports.reset = function () {
      controller.resetListListeners();
      model.reset();
      rows.update();
      containers.reset();
    };

    /**
     * Clear the current selection.
     */
    exports.clear = function () {
      model.clear();
      rows.update();
    };

    /**
     * Set the origin to a new position.
     *
     * @param {number} containerIndex The index of the container.
     * @param {number} index The index within the container.
     */
    exports.setOrigin = function (containerIndex, index) {
      model.setOrigin(new Position(containerIndex, index));
    };

    /**
     * Set the focus to a new position.
     *
     * @param {number} containerIndex The index of the container.
     * @param {number} index The index within the container.
     */
    exports.setFocus = function (containerIndex, index) {
      model.setFocus(new Position(containerIndex, index));
    };

    /**
     * Get the current origin position.
     *
     * @return {Object?} An object with numeric properties `containerIndex`
     *     and `index`, or null if no origin is set.
     */
    exports.getOrigin = function () {
      const origin = model.getOrigin();
      if (!origin) return null;
      return {
        containerIndex: origin.containerIndex,
        index: origin.index
      };
    };

    /**
     * Get the current focus position.
     *
     * @return {Object?} An object with numeric properties `containerIndex`
     *     and `index`, or null if no origin is set.
     */
    exports.getFocus = function () {
      const focus = model.getFocus();
      if (!focus) return null;
      return {
        containerIndex: focus.containerIndex,
        index: focus.index
      };
    };

    /**
     * Get all selected indices organized by list.
     *
     * @return {Array.<Object>} Array of objects of this structure:
     *     {
     *       containerIndex: 0,
     *
     *       // This is the list in the UI (could be sorted or unsorted)
     *       uri: 'spotify:internal:sortlist:asc:track(name):list',
     *       keys: ['c', 'd', 'e', 'j', 'o', 't'],
     *       indices: [3, 4, 5, 10, 15, 20], // Ordered indices in the list
     *
     *       // If all items between two selected items are hidden, they will be
     *       // included here to allow nice ranges to be created from this. It will
     *       // also include hidden items right after the last selected item.
     *       keysWithHidden: ['c', 'd', 'e', 'j', 'k', 'l', 'm', 'n', 'o', 't'],
     *       indicesWithHidden: [3, 4, 5, 10, 11, 12, 13, 14, 15, 20],
     *
     *       // Optional object for the unsorted list if the list is a sorted list
     *       origin: {
     *         uri: 'spotify:list',
     *         keys: ['c', 'd', 'e', 'j', 'o', 't'],
     *         indices: [7, 19, 8, 14, 0, 9] // Unordered indices in the original list
     *       }
     *     }
     */
    exports.getIndicesPerList = function () {
      const selections = model.selections;
      const indicesPerList = [];

      let list;

      const listKeys = selectedIndex => {
        return list.keys[selectedIndex];
      };

      for (let i = 0; i < selections.length; i++) {
        const containerSelection = selections[i];
        if (containerSelection && Object.keys(containerSelection).length) {
          const uri = containers.getUri(i);
          if (!uri) continue;

          list = containers.getLiveList(i);
          if (!list) continue;

          const indices = model.getIndicesForContainer(i);
          if (!indices) continue;

          const keys = indices.map(listKeys);

          const indicesWithHidden = model.getIndicesWithHiddenForContainer(i);
          const keysWithHidden = indicesWithHidden.map(listKeys);

          const context = {
            containerIndex: i,
            uri: uri,
            indices: indices,
            keys: keys,
            indicesWithHidden: indicesWithHidden,
            keysWithHidden: keysWithHidden
          };

          const originUri = getOriginUri(uri);
          if (originUri) {
            const wrappedList = live(uri).get('rows');
            const originList = live(originUri).get('rows');

            let originIndices;
            let originKeys;
            if (wrappedList && originList) {
              let key;
              const originListKeyIndexMap = {};
              originIndices = new Array(indices.length);
              originKeys = new Array(indices.length);

              const originListKeys = originList.keys;
              for (let j = 0; j < originListKeys.length; j++) {
                originListKeyIndexMap[originListKeys[j]] = j;
              }

              for (let j = 0; j < indices.length; j++) {
                key = wrappedList.keys[indices[j]];
                originIndices[j] = originListKeyIndexMap[key];
                originKeys[j] = originList.keys[originIndices[j]];
              }
            }
            context.origin = {
              uri: originUri,
              indices: originIndices || [],
              keys: originKeys || []
            };
          }

          indicesPerList.push(context);
        }
      }

      return indicesPerList;
    };

    /**
     * Get all selected indices relative to the full page (across all containers).
     *
     * @return {Object?} The value null if no global context is found or if found,
     *     an object of this structure:
     *     {
     *       uri: 'spotify:context:uri',
     *       indices: [0, 3, 56, 120],
     *
     *       // These elements are Elements instances from the 'elements' npm
     *       // package. This should be fixed in a future major version, to be
     *       // normal HTML elements.
     *       containers: [
     *         containerElement1,
     *         containerElement1,
     *         containerElement4,
     *         containerElement5
     *       ]
     *     }
     */
    exports.getIndicesGlobal = function () {
      const selections = model.selections;
      const elements = containers.elements;
      const indices = [];
      const selectionContainers = [];

      if (elements.length === 0) {
        return null;
      }
      const contextUriContainer = elements[0].closest('[data-context]');
      const contextUri = contextUriContainer && contextUriContainer.getAttribute('data-uri');

      if (!contextUri) return null;

      let containerSelection;
      const containerSelectionByKey = key => {
        return !!containerSelection[key];
      };

      for (let container = 0; container < selections.length; container++) {
        containerSelection = selections[container];
        const list = containers.getLiveList(container);
        if (list && containerSelection) {
          const orderedSelectedKeys = list.keys.filter(containerSelectionByKey);

          for (let i = 0, l = orderedSelectedKeys.length; i < l; i++) {
            const j = list.keys.indexOf(orderedSelectedKeys[i]);
            indices.push(positions.getGlobalIndexFromPosition(new Position(container, j)));
            selectionContainers.push($(elements[container]));
          }
        }
      }

      return {
        uri: contextUri,
        indices: indices,
        containers: selectionContainers
      };
    };

    /**
     * Get the URI of all selected rows.
     *
     * @return {Array.<string>} Array of URIs.
     */
    exports.getUris = function () {
      return controller.handleGetUris();
    };

    /**
     * Get the nodes for all selected rows that can be found.
     *
     * @return {Array.<HTMLElement>} Array of DOM nodes.
     */
    exports.getNodes = function () {
      return rows.getSelectedRows();
    };

    },{"../../live":413,"../../live-wrapped-uri":412,"../../spotify-elements":460,"../center":471,"../util/Position":538,"../util/app":539,"../util/cosmos":540,"./containers":526,"./controller":527,"./model":529,"./positions":530,"./rows":531}],529:[function(require,module,exports){
  /**
   * @module spotify-events/selection/model
   * @private
   */
  'use strict';

  const live = require('../../live');
  const Range = require('../../range2');
  const containers = require('./containers');
  const positions = require('./positions');
  const Position = require('../util/Position');

  /**
   * Selections for all known containers.
   * Each container's selection space is represented as an object where keys are
   * row IDs. This allows for quick lookups.
   *
   * @type {Array.<Object.<string, boolean>>}
   */
  const selections = [];

  /**
   * Hidden items for all known containers.
   * Each container is represented as an object where keys are row IDs. This
   * allows for quick lookups.
   *
   * @type {Object.<number, Object.<string, boolean>>}
   */
  let hiddenKeysPerContainer = {};

  let originContainerIndex = null;
  let originKey = null;
  let focusContainerIndex = null;
  let focusKey = null;
  let focusIsTouch = false;

  /**
   * Get the current origin.
   *
   * @return {Position?} The origin position or null if not set.
   */
  function getOrigin() {
    if (originContainerIndex === null) return null;
    if (originKey === null) return null;

    const list = containers.getLiveList(originContainerIndex);
    if (list) {
      const index = list.keys.indexOf(originKey);
      if (index === -1) return null;
      const position = new Position(originContainerIndex, index);
      return position;
    }
    return null;
  }

  /**
   * Get the current focus. This is the position for the keyboard focus.
   *
   * @return {Position?} The focus position or null if not set.
   */
  function getFocus() {
    if (focusContainerIndex === null) return null;
    if (focusKey === null) return null;

    const list = containers.getLiveList(focusContainerIndex);
    if (list) {
      const index = list.keys.indexOf(focusKey);
      const position = new Position(focusContainerIndex, index);
      return position;
    }
    return null;
  }

  /**
   * Set the current origin.
   *
   * @param {Position?} position A position or null if removing the origin.
   */
  function setOrigin(position) {
    if (position) {
      const list = containers.getLiveList(position.containerIndex);
      if (list) {
        originContainerIndex = position.containerIndex;
        originKey = list.keys[position.index] || null;
        return;
      }
    }

    originContainerIndex = null;
    originKey = null;
  }

  /**
   * Set the current focus.
   *
   * @param {Position?} position A position or null if removing the focus.
   */
  function setFocus(position, options) {
    focusIsTouch = !!(options && options.isTouch);

    if (position) {
      const list = containers.getLiveList(position.containerIndex);
      if (list) {
        focusContainerIndex = position.containerIndex;
        focusKey = list.keys[position.index];
        return;
      }
    }

    focusContainerIndex = null;
    focusKey = null;
  }

  /**
   * Check if the current focus was triggered by a touch.
   * This is done since we might want to have different styles for selection focus
   * when triggered by a touch event.
   *
   * @return {boolean} True if triggered by touch.
   */
  function wasFocusTriggeredByTouch() {
    return focusIsTouch;
  }

  /**
   * Handle setting which indices are hidden.
   *
   * @param {Array.<number>} hiddenIndices Array of indices that are hidden.
   * @param {string} containerUri The URI of the container.
   */
  function setHiddenIndices(hiddenIndices, containerUri) {
    const list = live(containerUri).get('rows');
    if (list) {
      const keys = list.keys;
      const hiddenKeys = {};
      for (let i = 0, l = hiddenIndices.length; i < l; i++) {
        const key = keys[hiddenIndices[i]];
        if (key) hiddenKeys[key] = true;
      }

      const containerIndex = containers.getContainerIndex(containerUri);

      hiddenKeysPerContainer[containerIndex] = hiddenKeys;

      updateContainer(containerIndex);
    }
  }

  /**
   * Check if given position is hidden.
   *
   * @param {Position} from The position to check.
   * @return {boolean} True if position is hidden.
   */
  function isPositionHidden(pos) {
    const idsPerContainer = getIds(pos, pos);
    const id = idsPerContainer[0][0];
    const hiddenKeys = hiddenKeysPerContainer[pos.containerIndex];
    return hiddenKeys && hiddenKeys[id];
  }

  /**
   * Add rows to the selection.
   *
   * @param {Position} from The start position to add.
   * @param {Position=} optTo The end position to add. If not provided, it will
   *     only add a single row to the selection.
   */
  function add(from, optTo) {
    let to = optTo || from;
    let newFrom = from;

    // Flip the positions if the direction is up.
    if (positions.getDirection(newFrom, to) === -1) {
      const temp = newFrom;
      newFrom = to;
      to = temp;
    }

    const idsPerContainer = getIds(newFrom, to);

    for (let i = 0, l = idsPerContainer.length; i < l; i++) {
      const containerIndex = newFrom.containerIndex + i;
      const selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
      const ids = idsPerContainer[i];
      const hiddenKeys = hiddenKeysPerContainer[containerIndex];

      // Set all new items as selected, unless they're hidden
      for (let j = 0; j < ids.length; j++) {
        const id = ids[j];
        if (!hiddenKeys || !hiddenKeys[id]) {
          selected[id] = true;
        }
      }
    }
  }

  /**
   * Remove rows from the selection.
   *
   * @param {Position} from The start position to remove.
   * @param {Position=} optTo The end position to remove. If not provided, it will
   *     only remove a single row from the selection.
   */
  function remove(from, optTo) {
    let to = optTo || from;
    let newFrom = from;

    // Flip the positions if the direction is up.
    if (positions.getDirection(newFrom, to) === -1) {
      const temp = newFrom;
      newFrom = to;
      to = temp;
    }

    const idsPerContainer = getIds(newFrom, to);

    for (let i = 0, l = idsPerContainer.length; i < l; i++) {
      const containerIndex = newFrom.containerIndex + i;
      const selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
      const ids = idsPerContainer[i];

      // Loop the row ids that are to be removed and remove them from the selection.
      // That's usually faster than looping the selection since there's no UI for
      // removing a big chunk of selection in one go.
      for (let j = 0; j < ids.length; j++) {
        const id = ids[j];
        delete selected[id];
      }
    }
  }

  /**
   * Clear the current selection.
   */
  function clear() {
    selections.length = 0;
    setOrigin(null);
    setFocus(null);
  }

  /**
   * Reset the current selection state.
   */
  function reset() {
    clear();
    hiddenKeysPerContainer = {};
  }

  /**
   * Update the model state based on the current state of the list.
   * If items were removed from the list, removed items that were selected
   * will be removed from selection state.
   */
  function updateContainer(containerIndex) {
    const keys = selections[containerIndex];
    if (!keys) return;

    const list = containers.getLiveList(containerIndex);
    if (!list) return;

    // TODO: Fix for-in statement so it doesn't REQUIRE
    // prototype chain iteration
    // eslint-disable-next-line guard-for-in
    for (const key in keys) {
      const hasKey = list.hasKey(key);
      let shouldDelete = !hasKey;
      if (!shouldDelete) {
        const hiddenKeys = hiddenKeysPerContainer[containerIndex];
        shouldDelete = hiddenKeys ? hiddenKeys[key] : false;
      }
      if (shouldDelete) {
        delete keys[key];
      }
    }
  }

  /**
   * Get IDs for the provided global range.
   *
   * @param {Position} from The start position.
   * @param {Position} to The end position. This position must be below the
   *     `from` position.
   *
   * @return {Array.<Array.<string>>} Array of IDs per container.
   */
  function getIds(from, to) {
    const idsPerContainer = [];

    const fromContainer = from.containerIndex;
    const toContainer = to.containerIndex;

    for (let i = fromContainer; i <= toContainer; i++) {
      const fromIndex = i === fromContainer ? from.index : 0;
      let toIndex;
      if (i === toContainer) {
        toIndex = to.index;
      } else {
        const containerLength = containers.getContainerLength(i);
        if (containerLength > 0) {
          toIndex = containerLength - 1;
        }
      }

      if (toIndex === undefined) {
        idsPerContainer.push([]);
      } else {
        const ids = [];
        idsPerContainer.push(ids);

        const containerUri = containers.getUri(i);
        const list = live(containerUri).get('rows');
        if (list) {
          const keys = list.keys;

          for (let n = fromIndex; n < toIndex + 1; n++) {
            ids.push(keys[n]);
          }
        }
      }
    }

    return idsPerContainer;
  }

  /**
   * Check if the position is selected.
   *
   * @param {Position} position A position.
   *
   * @return {boolean} True if it is selected, false otherwise.
   */
  function isSelected(position) {
    // Get the ranges of the according container
    const keys = selections[position.containerIndex];
    if (!keys) return false;

    // Check if the row is within the selected ranges for the container
    const list = containers.getLiveList(position.containerIndex);
    if (list) {
      const key = list.keys[position.index];
      return !!keys[key];
    }

    return false;
  }

  /**
   * Check if the selection has any holes (contains many ranges).
   *
   * @return {boolean} True if it has holes, false otherwise.
   */
  function hasHoles() {
    let rangeCount = 0;

    for (let containerIndex = 0; containerIndex < selections.length; containerIndex++) {
      const containerSelection = selections[containerIndex];
      const list = containers.getLiveList(containerIndex);

      const keys = Object.keys(containerSelection);

      // A selection in more than one container means the selection has holes
      if (keys.length > 0) {
        rangeCount++;

        // Also more than one range in only one container means it has holes.
        if (list) {
          const indices = [];
          for (let j = 0, len = keys.length; j < len; j++) {
            indices.push(list.indexOf(keys[j]));
          }
          indices.sort(function (a, b) {
            return a - b;
          });
          let previousIndex;
          for (let i = 0, l = indices.length; i < l; i++) {
            const index = indices[i];
            if (i > 0 && index > previousIndex + 1) {
              rangeCount++;
              break;
            }
            previousIndex = index;
          }
        }
      }
      if (rangeCount > 1) return true;
    }

    return false;
  }

  /**
   * Check if there is any selection in any container.
   *
   * @return {boolean} True if there is a selection.
   */
  function hasSelection() {
    for (let i = 0, l = selections.length; i < l; i++) {
      if (selections[i] && Object.keys(selections[i]).length > 0) {
        return true;
      }
    }

    return false;
  }

  /**
   * Get the selected indices for a container.
   *
   * @param {number} containerIndex The container index.
   *
   * @return {Array.<number>?} An array of indices or null if nothing is selected.
   */
  function getIndicesForContainer(containerIndex) {
    const unorderedKeys = selections[containerIndex];
    if (!unorderedKeys) return null;
    let indices = [];

    const list = containers.getLiveList(containerIndex);

    const orderedKeys = list.keys.filter(function (key) {
      return !!unorderedKeys[key];
    });

    if (list && orderedKeys.length) {
      if (orderedKeys.length > 1) {
        // indexOfMany() is much more perfomant for big selections
        indices = list.indexOfMany(orderedKeys);
      } else {
        // for a single selected item, indexOf() is a little bit more perfomant
        indices = [list.indexOf(orderedKeys[0])];
      }
    }

    return indices.length ? indices : null;
  }

  /**
   * Get the selected indices for a container, including hidden items that join
   * two ranges. For example, in a list [A, B, C, D, E, F, G, H], everything is
   * selected except C, D, F and G. There are hidden items, C, D, F and G. This
   * method would then return the indices of all items except H,
   * [0, 1, 2, 3, 4, 5, 6]. It does include hidden items right after the last
   * selected one.
   *
   * @param {number} containerIndex The container index.
   *
   * @return {Array.<number>?} An array of indices or null if nothing is selected.
   */
  function getIndicesWithHiddenForContainer(containerIndex) {
    let indices = getIndicesForContainer(containerIndex);
    if (!indices) return null;

    const hiddenKeys = hiddenKeysPerContainer[containerIndex];
    if (!hiddenKeys) return indices;

    const ranges = Range.fromIndices(indices);
    if (ranges.length === 1) return indices;

    const list = containers.getLiveList(containerIndex);
    if (!list) return indices;

    const hiddenIds = Object.keys(hiddenKeys);
    let hiddenIndices = [];

    if (hiddenIds.length) {
      if (hiddenIds.length > 1) {
        // indexOfMany() is much more perfomant for big selections
        hiddenIndices = list.indexOfMany(hiddenIds);
      } else {
        // for a single selected item, indexOf() is a little bit more perfomant
        hiddenIndices = [list.indexOf(hiddenIds[0])];
      }
    }

    hiddenIndices = hiddenIndices.filter(function (index) {
      return index > -1;
    });

    const hiddenRanges = Range.fromIndices(hiddenIndices);
    const hiddenStarts = hiddenRanges.map(function (range) {
      return range.start;
    });
    const hiddenEnds = hiddenRanges.map(function (range) {
      return range.end;
    });

    for (let i = 0, l = ranges.length; i < l; i++) {
      const range = ranges[i];
      const nextRange = ranges[i + 1];

      const indexOfRange = hiddenStarts.indexOf(range.end);
      if (indexOfRange > -1) {
        const hiddenEnd = hiddenEnds[indexOfRange];
        if (!nextRange || hiddenEnd === nextRange.start) {
          const hiddenIndicesInRange = hiddenRanges[indexOfRange].toIndices();
          if (hiddenIndicesInRange.length > 0) {
            indices = indices.concat(hiddenIndicesInRange);
          }
        }
      }
    }

    indices.sort(function (a, b) {
      return a - b;
    });

    return indices.length ? indices : null;
  }

  exports.selections = selections;
  exports.getOrigin = getOrigin;
  exports.getFocus = getFocus;
  exports.setOrigin = setOrigin;
  exports.setFocus = setFocus;
  exports.wasFocusTriggeredByTouch = wasFocusTriggeredByTouch;
  exports.setHiddenIndices = setHiddenIndices;
  exports.isPositionHidden = isPositionHidden;
  exports.add = add;
  exports.remove = remove;
  exports.clear = clear;
  exports.reset = reset;
  exports.updateContainer = updateContainer;
  exports.isSelected = isSelected;
  exports.hasHoles = hasHoles;
  exports.hasSelection = hasSelection;
  exports.getIndicesForContainer = getIndicesForContainer;
  exports.getIndicesWithHiddenForContainer = getIndicesWithHiddenForContainer;

  },{"../../live":413,"../../range2":454,"../util/Position":538,"./containers":526,"./positions":530}],530:[function(require,module,exports){
  /**
   * @module spotify-events/selection/positions
   * @private
   */
  'use strict';

  const $ = require('../../spotify-elements');

  const containers = require('./containers');
  const Position = require('../util/Position');

  /**
   * Get the closest position in the specified direction.
   *
   * @param {Position} position A position.
   * @param {string} direction The direction to search in: 'up' or 'down'.
   *
   * @return {Position?} A position or null if not found.
   */
  function getClosest(position, direction) {
    const isDown = direction === 'down';
    let containerIndex = position.containerIndex;
    const index = position.index;

    // Find next position within the current container
    let containerLength = containers.getContainerLength(containerIndex);
    let nextIndex = isDown ? index + 1 : index - 1;
    if (nextIndex < containerLength && nextIndex >= 0) {
      return new Position(containerIndex, nextIndex);
    }

    // Out of bounds, traverse containers
    containerIndex = isDown ? containerIndex + 1 : containerIndex - 1;
    containerLength = containers.getContainerLength(containerIndex);
    if (containerLength) {
      nextIndex = isDown ? 0 : containerLength - 1;
      return new Position(containerIndex, nextIndex);
    }

    return null;
  }

  /**
   * Get a position from a row node.
   *
   * @param {HTMLElement} node A DOM node for a list row.
   *
   * @return {Position?} A position or null if not found.
   */
  function getFromNode(node) {
    // We need a parent node, since we will be checking if the row is inside
    // one of the known selection containers.
    if (!node.parentNode) return null;

    // We also need a data-index attribute on the row to get the index for the
    // row within the current selection container.
    if (!node.hasAttribute('data-index')) return null;

    const elements = containers.elements;
    if (elements.length === 0) return null;

    for (let i = 0, l = elements.length; i < l; i++) {
      if (elements[i] && containsNode(elements[i], node)) {
        const row = +node.getAttribute('data-index');
        return new Position(i, row);
      }
    }

    return null;
  }

  /**
   * Check if an element contains another node.
   *
   * @param {HTMLElement} element The container element.
   * @param {HTMLElement} child The potential child node.
   *
   * @return {boolean} True if element contains the child, false otherwise.
   */
  function containsNode(element, child) {
    let newChild = child;
    while (newChild && newChild.parentNode !== element) {
      newChild = newChild.parentNode;
    }
    return !!newChild;
  }

  /**
   * Get the row node that the specified position represents.
   *
   * @param {Position} position A position.
   *
   * @return {HTMLElement?} A DOM node or null if not found.
   */
  function getNodeFromPosition(position) {
    const container = containers.elements[position.containerIndex];
    if (!container) return null;
    const node = $(container).find(`[data-index=${position.index}]`);
    return node ? node[0] : null;
  }

  /**
   * Get the direction from one position to another.
   *
   * @param {Position} from First position.
   * @param {Position} to Second position.
   *
   * @return {number} A number representing the direction.
   *     -1 is up
   *      0 is same
   *      1 is down
   */
  function getDirection(from, to) {
    if (!from || !to) return 0;

    // With different containers we can just compare the containers
    if (from.containerIndex !== to.containerIndex) {
      return from.containerIndex < to.containerIndex ? 1 : -1;
    }

    // Within the same container, compare the row indices
    if (from.index === to.index) {
      return 0;
    }
    return from.index < to.index ? 1 : -1;
  }

  /**
   * Get data about in which container and where inside that the provided
   * global index is.
   *
   * @param {number} globalIndex An index relative to the full page (all
   *     selection containers).
   *
   * @return {Position} A position.
   */
  function getPositionFromGlobalIndex(globalIndex) {
    let resolvedIndex = globalIndex;
    let resolvedContainerIndex = 0;
    let containerLength;
    let countIndices = 0;

    // Subtract the amount of tracks in containers until passing globalIndex
    for (let i = 0, l = containers.elements.length; i < l; i++) {
      containerLength = containers.getContainerLength(i);
      countIndices += containerLength;

      if (countIndices > globalIndex) break;

      resolvedContainerIndex = i + 1;
      resolvedIndex -= containerLength;
    }

    return new Position(resolvedContainerIndex, resolvedIndex);
  }

  /**
   * Get the global index relative to the full page (across all selection
   * containers) from a position object.
   *
   * @param {Position} position A position.
   *
   * @return {number} A global index.
   */
  function getGlobalIndexFromPosition(position) {
    let resolvedIndex = position.index;

    // Subtract length of previous lists
    for (let i = position.containerIndex - 1; i >= 0; i--) {
      resolvedIndex += containers.getContainerLength(i);
    }

    return resolvedIndex;
  }

  /**
   * Get last position on page.
   *
   * @return {Position} A position.
   */
  function getLastPosition() {
    const lastContainerIndex = containers.elements.length - 1;
    const lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

    return new Position(lastContainerIndex, lastIndex);
  }

  /**
   * Get last position for "select all" on page, disregarding containers with
   * [data-select-all="false"].
   *
   * @return {Position} A position.
   */
  function getLastPositionForSelectAll() {
    let lastContainerIndex;
    containers.elements.forEach(function (element, index) {
      if (element.getAttribute('data-list-may-select-all') !== 'false') {
        lastContainerIndex = index;
      }
    });

    const lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

    return new Position(lastContainerIndex, lastIndex);
  }

  exports.getClosest = getClosest;
  exports.getFromNode = getFromNode;
  exports.getNodeFromPosition = getNodeFromPosition;
  exports.getDirection = getDirection;
  exports.getPositionFromGlobalIndex = getPositionFromGlobalIndex;
  exports.getGlobalIndexFromPosition = getGlobalIndexFromPosition;
  exports.getLastPosition = getLastPosition;
  exports.getLastPositionForSelectAll = getLastPositionForSelectAll;

  },{"../../spotify-elements":460,"../util/Position":538,"./containers":526}],531:[function(require,module,exports){
  /**
   * @module spotify-events/selection/rows
   * @private
   */
  'use strict';

  const $ = require('../../spotify-elements');
  const difference = require('mout/array/difference');

  const model = require('./model');
  const containers = require('./containers');
  const positions = require('./positions');

  const SELECTOR_ROW = '[data-list-item]';
  const CLASSNAME_SELECTED = 'selected';
  const CLASSNAME_FOCUSED = 'selection-focus';
  const CLASSNAME_FOCUSED_TOUCH = 'selection-focus-touch';
  let focusTimeout;

  /**
   * Update the selection state of rows.
   *
   * @param {HTMLElement=} node Optional DOM node. If provided, the update
   *     will only affect rows found inside this node.
   */
  function update(node) {
    const currentlySelectedRows = getSelectedRows(node);
    const rowsToBeSelected = getRowsToSelect(node);

    const rowsToDeselect = difference(currentlySelectedRows, rowsToBeSelected);
    const rowsToSelect = difference(rowsToBeSelected, currentlySelectedRows);

    currentlySelectedRows.forEach(function (row) {
      $(row).removeClass(CLASSNAME_FOCUSED);
      $(row).removeClass(CLASSNAME_FOCUSED_TOUCH);
    });

    // Remove styles for selected rows that should now be deselected
    rowsToDeselect.forEach(function (row) {
      $(row).removeClass(CLASSNAME_SELECTED);
    });

    // Add styles for unselected rows that should now be selected
    rowsToSelect.forEach(function (row) {
      $(row).addClass(CLASSNAME_SELECTED);
    });

    // Add styles for the row with the selection focus
    const focus = model.getFocus();
    if (focus) {
      const focusNode = positions.getNodeFromPosition(focus);
      if (focusNode) {
        // If the focusNode is not yet in the viewport and we `focus()` it, the
        // browser will bluntly scroll it into view, which looks bad. (KM-6508)
        clearTimeout(focusTimeout);
        focusTimeout = setTimeout(function () {
          const isInputFocused = document.activeElement && $(document.activeElement).matches('input, textarea');
          const isButtonFocused = document.activeElement && $(document.activeElement).matches('button');
          if (isElementInViewport(focusNode) && !isInputFocused && !isButtonFocused) {
            focusNode.focus();
          }
        }, 0);
        $(focusNode).addClass(CLASSNAME_FOCUSED);

        if (model.wasFocusTriggeredByTouch()) {
          $(focusNode).addClass(CLASSNAME_FOCUSED_TOUCH);
        }
      }
    }
  }

  /**
   * Get the rows that are currently selected, found inside the known containers.
   *
   * @param {HTMLElement=} node Optional DOM node. If provided, it will only
   *     search inside this node.
   *
   * @return {Array.<HTMLElement>} Array of DOM nodes.
   */
  function getSelectedRows(node) {
    const elements = node ? [node] : containers.elements;
    const rows = [];

    elements.forEach(function (container) {
      const nodes = $(container).search(`${SELECTOR_ROW}.${CLASSNAME_SELECTED}`);
      if (nodes) Array.prototype.push.apply(rows, nodes);
    });

    return rows;
  }

  /**
   * Get the rows that should be selected, found inside the known containers.
   *
   * @param {HTMLElement=} node Optional DOM node. If provided, it will only
   *     search inside this node.
   *
   * @return {Array.<HTMLElement>} Array of DOM nodes.
   */
  function getRowsToSelect(node) {
    const rows = [];
    const containerElements = containers.elements;

    model.selections.forEach(function (keys, index) {
      if (!keys) return;

      const list = containers.getLiveList(index);
      if (!list) return;

      let container = containerElements[index];
      // If a node was passed, only check the container if it contains the node
      if (node && !containerElements[index].contains(node)) {
        container = null;
      }
      if (!container) {
        return;
      }

      const listNodes = $(container).search(SELECTOR_ROW);
      if (!listNodes) return;

      const nodes = listNodes.filter(function (listNode) {
        const nodeIndex = +listNode.getAttribute('data-index');
        const nodeRowId = list.keys[nodeIndex];
        return !!keys[nodeRowId];
      });

      Array.prototype.push.apply(rows, nodes);
    });
    return rows;
  }

  function isElementInViewport(el) {
    const rect = el.getBoundingClientRect();
    return rect.top >= 0 && rect.bottom <= document.documentElement.clientHeight;
  }

  exports.update = update;
  exports.getSelectedRows = getSelectedRows;

  },{"../../spotify-elements":460,"./containers":526,"./model":529,"./positions":530,"mout/array/difference":777}],534:[function(require,module,exports){
  (function (global){
  'use strict';

  var _frameUpdater = require('../frame-updater');

  const center = require('./center');

  const DEFAULT_STICKY_CLASS_NAME = 'sticky-top';

  let isAttached = false;
  let scrollListenerId = 0;
  let nodesGBCR = null;
  let rootGBCR = null;
  let timestamp;
  let lastTotalStickyHeight = 0;
  let isDragScrolling = false;
  let dragScrollingSpeed = 0;

  let scrollTopOffset = 0;
  let currentScrollX = 0;
  let currentScrollY = 0;
  let rects = null;
  let scrollNode = null;

  const getStickyClassName = function (stickyNode) {
    const root = document.documentElement;
    let classSticky;
    let node;

    for (node = stickyNode; node !== root; node = node.parentNode) {
      classSticky = node.getAttribute('data-class-sticky');

      if (classSticky) {
        return classSticky;
      }
    }

    return DEFAULT_STICKY_CLASS_NAME;
  };

  const getRects = function (ttl) {
    const reference = timestamp + ttl;
    const nodes = document.querySelectorAll('[data-sticky]');

    // Refresh timestamp (always).
    timestamp = Date.now();

    // If the reference time is still valid, and nodes are the same, then return data.
    if (reference > timestamp && nodesGBCR && nodes.length === nodesGBCR.length) {
      let equal = true;

      for (let i = 0; i < nodes.length; i++) {
        equal = equal && nodes[i] === nodesGBCR[i].node;
      }

      if (equal) {
        return {
          nodes: nodesGBCR,
          root: rootGBCR
        };
      }
    }

    // Otherwise, compute and cache.
    if (scrollNode === document) {
      rootGBCR = document.documentElement.getBoundingClientRect();
    } else {
      rootGBCR = scrollNode.getBoundingClientRect();
      rootGBCR = {
        top: rootGBCR.top - currentScrollY,
        right: rootGBCR.right,
        bottom: rootGBCR.bottom,
        left: rootGBCR.left,
        width: rootGBCR.width,
        height: rootGBCR.height
      };
    }
    nodesGBCR = Array.prototype.map.call(document.querySelectorAll('[data-sticky]'), function (node) {
      const parentRect = node.parentNode.getBoundingClientRect();
      const nodeRect = node.getBoundingClientRect();

      // Return a structure per node. Only some fields are stored in the rect object (the ones used).
      return {
        stickyClassName: getStickyClassName(node),
        node: node,
        rect: {
          top: parentRect.top,
          height: nodeRect.height,
          left: parentRect.left,
          right: parentRect.right
        }
      };
    });

    return {
      nodes: nodesGBCR,
      root: rootGBCR
    };
  };

  const removeClone = function (node) {
    const stickyClone = node.stickyClone;

    if (stickyClone.parentNode) {
      stickyClone.parentNode.removeChild(stickyClone);
    }

    if (node.stickyListSwapListener) {
      center.off('list-swap', node.stickyListSwapListener);
    }

    node.style.removeProperty('visibility');

    delete node.stickyClone;
    delete node.stickyListSwapListener;
  };

  const resetSticky = function (node) {
    // <THEAD>s can't be made sticky, so verify if we are using a clone and remove it from the DOM.
    if (node.nodeName.toLowerCase() === 'thead' && node.stickyClone) {
      removeClone(node);
    }

    node.classList.remove(getStickyClassName(node));

    const headerNode = node.closest('[data-glue-page-header]');
    if (headerNode) {
      headerNode.classList.remove('glue-page-header--with-active-sticky-header');
      if (global.onPageHeaderToggleStickyMode) {
        global.onPageHeaderToggleStickyMode(false);
      }
    }

    // Update styles accordingly.
    node.removeAttribute('data-sticky-active', '');
    node.style.right = '';
    node.style.left = '';
    node.style.position = '';
    node.style.top = '';
  };

  const resetOldStickies = function () {
    const selector = '[data-sticky-active]:not([data-sticky])';
    const nodes = document.querySelectorAll(selector);
    for (let i = 0, l = nodes.length; i < l; i++) {
      if (!nodes[i].isStickyClone) {
        resetSticky(nodes[i]);
      }
    }
  };

  const readValuesWithTTL = function (ttl) {
    const node = scrollNode === document ? document.body : scrollNode;
    const topBarHeight = node.getAttribute('data-top-bar-height');
    scrollTopOffset = parseInt(topBarHeight, 10) || 0;

    currentScrollY = scrollNode === document ? window.scrollY : scrollNode.scrollTop;

    rects = getRects(ttl);
  };

  const createClone = function (node) {
    const div = document.createElement('div');
    const thead = node.cloneNode(true);
    const table = node.parentNode.cloneNode(false);

    table.appendChild(thead).removeAttribute('data-sticky');
    div.appendChild(table);
    div.className = 'sticky-clone';
    div.isStickyClone = true;

    const onListSwap = function (data) {
      const theadParentTable = thead.parentNode;
      const uri = theadParentTable && theadParentTable.getAttribute('data-uri');

      // Update the "data-uri" of the cloned table, and the sort state of the original one.
      if (uri) {
        theadParentTable.setAttribute('data-uri', data.after);
        sort.update(node.parentNode);
      }
    };

    center.on('list-swap', onListSwap);

    node.parentNode.parentNode.appendChild(div);
    node.style.visibility = 'hidden';
    node.stickyListSwapListener = onListSwap;
    node.stickyClone = div;

    return div;
  };

  const updateStickies = function () {
    const scrollTop = currentScrollY + scrollTopOffset;
    const width = rects.root.width;
    let top = rects.root.top;
    let height = scrollTopOffset;
    const stickyNodes = rects.nodes;

    resetOldStickies();

    // This is to reset the video header for P2S if no stickies are found in the
    // DOM. Not finding any stickies means if we previously had a sticky P2S
    // video, it should not be sticky anymore. If a sticky header node re-appears
    // in the DOM, the next update of sticky events will call out to the video
    // with the new value.
    if (stickyNodes.length === 0) {
      if (global.onPageHeaderToggleStickyMode) {
        global.onPageHeaderToggleStickyMode(false);
      }
    }

    stickyNodes.forEach(function (nodeInfo, i) {
      const node = nodeInfo.node;
      const rect = nodeInfo.rect;
      const stickyClone = node.stickyClone;
      const stickyClassName = nodeInfo.stickyClassName;
      let stickyNode = stickyClone || node;

      // Check if the node should be sticked or not (if true, it should be).
      if (rect.top - top < scrollTop) {
        const previousNodeInfo = stickyNodes[i - 1];
        if (previousNodeInfo) {
          const previousNode = previousNodeInfo.node;
          const previousRect = previousNodeInfo.rect;
          if (previousNode.hasAttribute('data-sticky-single') && previousNode.classList.contains(stickyClassName)) {
            // This is the position of the current node relative to the bottom
            // edge of the stickies.
            const currentTopToEdge = Math.abs(rect.top - rects.root.top - (scrollTop + height));

            if (currentTopToEdge < previousRect.height) {
              const previousTop = height - previousRect.height;
              const newPreviousTop = previousTop - currentTopToEdge;
              previousNode.style.top = `${newPreviousTop}px`;
              top -= currentTopToEdge;
              height -= currentTopToEdge;
            } else {
              // Unstick the sticky above if it's pushed past its original spot
              resetSticky(previousNode);
              top -= previousRect.height;
              height -= previousRect.height;
            }
          }
        }

        // Offset the position by the offset of the root layer (an issue when a
        // custom scroll node is used).
        const left = rect.left - rects.root.left;
        const right = rect.right - rects.root.left;

        if (!stickyNode.classList.contains(stickyClassName)) {
          // <THEAD>s can't be made sticky, so we clone it and add it to the DOM.
          if (node.nodeName.toLowerCase() === 'thead' && !node.stickyClone) {
            stickyNode = createClone(node);
          }

          stickyNode.classList.add(stickyClassName);

          const headerNode = stickyNode.closest('[data-glue-page-header]');
          if (headerNode) {
            headerNode.classList.add('glue-page-header--with-active-sticky-header');
            if (global.onPageHeaderToggleStickyMode) {
              global.onPageHeaderToggleStickyMode(true);
            }
          }

          // Update styles accordingly.
          stickyNode.setAttribute('data-sticky-active', '');
          stickyNode.setAttribute('data-ta-id', 'sticky-node');
          stickyNode.style.right = `${width - right}px`;
          stickyNode.style.left = `${left}px`;
          stickyNode.style.position = 'fixed';
          stickyNode.style.top = `${height}px`;
        } else {
          stickyNode.style.right = `${width - right}px`;
          stickyNode.style.left = `${left}px`;
          stickyNode.style.top = `${height}px`;
        }

        // Increment the top reference and the height. Do it even if the element is already sticked.
        height += rect.height;
        top += rect.height;
      } else {
        if (stickyNode.classList.contains(stickyClassName)) {
          resetSticky(node);
        }
      }
    });

    lastTotalStickyHeight = height;
  };

  const handleResize = function () {
    readValuesWithTTL(0);
    updateStickies();
  };

  const dragScrollingTick = function () {
    if (isDragScrolling && currentScrollY > 0) {
      (0, _frameUpdater.requestFrame)(() => {
        currentScrollX = window.scrollX;
        currentScrollY = window.scrollY;
      }, () => {
        dragScrollingTick();
      });

      window.scrollTo(currentScrollX, currentScrollY - dragScrollingSpeed);
    }
  };

  const onPointerDragMove = function (event) {
    const distanceFromContentEdge = event.clientY - lastTotalStickyHeight;
    const scrollEdgeThickness = 20;
    const isBelowContentEdge = distanceFromContentEdge > 0;
    const isAboveScrollEdge = distanceFromContentEdge < scrollEdgeThickness;

    if (isBelowContentEdge && isAboveScrollEdge) {
      const speedFactor = (scrollEdgeThickness - Math.max(0, distanceFromContentEdge)) / scrollEdgeThickness;
      dragScrollingSpeed = speedFactor * 20;

      if (!isDragScrolling) {
        isDragScrolling = true;
        dragScrollingTick();
      }
    } else {
      isDragScrolling = false;
    }
  };

  const onPointerDragEnd = function () {
    isDragScrolling = false;

    document.removeEventListener('dragover', onPointerDragMove);
    document.removeEventListener('dragend', onPointerDragEnd);
    document.removeEventListener('mouseup', onPointerDragEnd);
  };

  const handleMouseDown = function () {
    document.addEventListener('dragover', onPointerDragMove);
    document.addEventListener('dragend', onPointerDragEnd);

    // Ideally we shouldn't need `mouseup`, but for some reason `dragend` is not
    // being triggered while scrolling. We can also not solely use mouseup, since
    // that is only triggered when releasing the pointer inside the iframe.
    document.addEventListener('mouseup', onPointerDragEnd);
  };

  exports.DEFAULT_STICKY_CLASS_NAME = DEFAULT_STICKY_CLASS_NAME;

  exports.attach = function attach() {
    if (!isAttached) {
      isAttached = true;

      if (!scrollNode) {
        scrollNode = document;
      }

      scrollListenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, () => {
        readValuesWithTTL(4000);
      }, () => {
        updateStickies();
      });

      window.addEventListener('resize', handleResize);
      document.addEventListener('mousedown', handleMouseDown);
      if (global.top && global.top.document) {
        // Register mousedown events from top document to catch cases when
        // drag was initiated from top document (ex. dragging track from now playing
        // to playlist)
        global.top.document.addEventListener('mousedown', handleMouseDown);
      }
    }
  };

  exports.detach = function detach() {
    if (isAttached) {
      isAttached = false;

      (0, _frameUpdater.removeDebouncedScrollListener)(scrollListenerId);
      window.removeEventListener('resize', handleResize);
      document.removeEventListener('mousedown', handleMouseDown);
      if (global.top && global.top.document) {
        global.top.document.removeEventListener('mousedown', handleMouseDown);
      }

      nodesGBCR = null;
      rootGBCR = null;
      lastTotalStickyHeight = 0;
      isDragScrolling = false;
      dragScrollingSpeed = 0;
      scrollNode = null;
    }
  };

  exports.update = function () {
    if (isAttached) {
      nodesGBCR = null;
      rootGBCR = null;

      readValuesWithTTL(4000);
      updateStickies();
    }
  };

  // A way to let an app override the node to listen for scroll events on.
  // This has to be called before `attach` is called.
  exports.setScrollNode = function setScrollNode(node) {
    scrollNode = node;
  };

  exports._getStickyClassName = getStickyClassName;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../frame-updater":132,"./center":471}],535:[function(require,module,exports){
  'use strict';

  const $ = require('../spotify-elements');
  const live = require('../live');
  const dom = require('./util/dom');

  const SELECTOR_THUMBS_DOWN_BUTTON = '[data-button=thumbs-down]';
  const SELECTOR_THUMBS_UP_BUTTON = '[data-button=thumbs-up]';

  /**
   * Handle the click on a Thumbs button.
   *
   * @param {MouseEvent} event An event object for a click event.
   * @param {HTMLElement} button A button DOM node.
   *
   * @private
   */
  function handleThumbsButtonClick(event, button) {
    const type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
    const trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
    const contextUri = dom.getContextFromNodeOrParent(button[0]);

    // Must use track uri
    if (!trackUri || !contextUri) return;

    // Emit thumb event on context
    if (type === 'thumbs-down') {
      live(contextUri).emit('thumb-down', trackUri);
    } else if (type === 'thumbs-up') {
      live(contextUri).emit('thumb-up', trackUri);
    }
  }

  let isAttached = false;

  /**
   * Attach the event listeners for the module.
   * Part of the spotify-events interface.
   */
  exports.attach = function () {
    if (isAttached) return;
    isAttached = true;

    const doc = $(document);
    doc.delegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
    doc.delegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
  };

  /**
   * Detach the event listeners for the module.
   * Part of the spotify-events interface.
   */
  exports.detach = function () {
    if (!isAttached) return;
    isAttached = false;

    const doc = $(document);
    doc.undelegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
    doc.undelegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
  };

  exports.update = function () {};

  },{"../live":413,"../spotify-elements":460,"./util/dom":541}],536:[function(require,module,exports){
  'use strict';

  const $ = require('../spotify-elements');

  const tooltipMargin = 8; // We want some spacing around the tooltip

  const tooltipNode = document.createElement('div');
  tooltipNode.id = 'tooltip';

  const tooltipTextNode = document.createElement('span');

  const tooltipArrowTop = document.createElement('div');
  tooltipArrowTop.className = 'tooltip-arrow-top';

  const tooltipArrowBottom = document.createElement('div');
  tooltipArrowBottom.className = 'tooltip-arrow-bottom';

  tooltipNode.appendChild(tooltipArrowTop);
  tooltipNode.appendChild(tooltipArrowBottom);
  tooltipNode.appendChild(tooltipTextNode);

  let attachedNode = null;
  let tooltipContainer = null;

  // tooltipArrow will point to the current visible tooltipArrow
  // that can be either tooltipArrowTop or tooltipArrowBottom
  let tooltipArrow = null;

  const addTooltipToDOM = function (container) {
    tooltipContainer = container;
    tooltipContainer.appendChild(tooltipNode);
  };

  const removeTooltipFromDOM = function () {
    attachedNode = null;
    if (tooltipNode.parentNode) {
      tooltipContainer.removeChild(tooltipNode);
    }

    tooltipContainer = null;
  };

  const getTooltipContainer = function (node) {
    const containerSelector = node.getAttribute('data-tooltip-container');
    let containerNode;

    if (containerSelector) {
      containerNode = document.querySelector(containerSelector);
    }

    return containerNode || document.body;
  };

  const setText = function (text) {
    tooltipTextNode.innerHTML = text;
  };

  const showTooltip = function (event, node) {
    const realNode = node[0];
    let top = 0;
    let left = 0;

    const tooltipText = node.data('tooltip') || node.getAttribute('title');
    if (!tooltipText) return;

    // Remember the node we set the text from so that text can be updated.
    attachedNode = node;

    if (!node.tooltipCheck) {
      node.removeAttribute('title');
      node.setAttribute('data-tooltip', tooltipText);
      node.tooltipCheck = true;
    }

    const container = getTooltipContainer(node);
    if (!tooltipContainer || container !== tooltipContainer) {
      addTooltipToDOM(container);
    }

    setText(tooltipText);

    const tooltipHeight = tooltipNode.clientHeight;
    const tooltipWidth = tooltipNode.offsetWidth;

    // Don't use window.scrollY because cross browser issues.
    // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
    const scrollY = window.pageYOffset;

    const bounds = realNode.getBoundingClientRect();
    const targetHeight = realNode.offsetHeight;
    const targetWidth = realNode.offsetWidth;
    const targetTop = parseInt(bounds.top, 10) + scrollY;
    const targetLeft = parseInt(bounds.left, 10);
    const targetCenter = targetLeft + targetWidth / 2;
    const targetBottom = targetTop + targetHeight;
    const viewportWidth = document.documentElement.clientWidth;
    const viewportHeight = document.documentElement.clientHeight;

    // Decide if the tooltip should be over or under the node
    if (targetBottom + tooltipHeight + tooltipMargin - scrollY > viewportHeight) {
      // On top
      top = targetTop - tooltipHeight - tooltipMargin;
      tooltipArrowTop.classList.remove('visible');
      tooltipArrowBottom.classList.add('visible');
      tooltipArrow = tooltipArrowBottom;
    } else {
      top = targetTop + targetHeight + tooltipMargin;
      if (top - scrollY > viewportHeight) {
        top = viewportHeight - tooltipHeight;
      }
      tooltipArrowTop.classList.add('visible');
      tooltipArrowBottom.classList.remove('visible');
      tooltipArrow = tooltipArrowTop;
    }

    const distanceToTheRight = viewportWidth - tooltipMargin - targetCenter;
    const distanceToTheLeft = targetCenter - tooltipMargin;
    const tooltipOffsetRight = Math.max(0, tooltipWidth / 2 - distanceToTheRight);
    const tooltipOffsetLeft = Math.max(0, tooltipWidth / 2 - distanceToTheLeft);

    left = targetCenter - tooltipWidth / 2 - (tooltipOffsetRight || -tooltipOffsetLeft);

    tooltipNode.style.top = `${top}px`;
    tooltipNode.style.left = `${left}px`;
    tooltipArrow.style.left = `${targetCenter - left}px`;

    if (node.hasAttribute('data-tooltip-instant')) {
      tooltipNode.classList.add('instant');
    } else {
      tooltipNode.classList.remove('instant');
    }

    tooltipNode.classList.add('visible');
  };

  const hideTooltip = function () {
    if (!attachedNode) {
      return;
    }
    attachedNode = null;
    setText('');
    tooltipNode.classList.remove('visible');
    tooltipNode.style.left = 0;
    tooltipNode.style.top = 0;
    if (tooltipArrow) {
      tooltipArrow.style.left = 0;
    }
  };

  let isAttached = false;

  exports.attach = function attach() {
    if (isAttached) return;
    isAttached = true;

    const doc = $(document);
    doc.delegate('mouseover', '[data-tooltip]', showTooltip);
    doc.delegate('mouseout', '[data-tooltip]', hideTooltip);
    doc.on('keydown', hideTooltip);
    doc.on('mousedown', hideTooltip);
  };

  exports.detach = function detach() {
    if (!isAttached) return;
    isAttached = false;

    removeTooltipFromDOM();
    const doc = $(document);
    doc.undelegate('mouseover', '[data-tooltip]', showTooltip);
    doc.undelegate('mouseout', '[data-tooltip]', hideTooltip);
    doc.off('keydown', hideTooltip);
    doc.off('mousedown', hideTooltip);
  };

  /** Forces an update of the tooltip text. */
  exports.update = function update() {
    if (!isAttached) return;

    if (!attachedNode) return;

    if (attachedNode.data('tooltip')) {
      showTooltip(null, attachedNode);
    } else {
      // The tooltip no longer has text and should be hidden.
      hideTooltip();
    }
  };

  // Export for testing purposes
  exports._setText = setText;

  },{"../spotify-elements":460}],537:[function(require,module,exports){
  'use strict';

  const prime = require('../../../libs/prime');
  const Emitter = require('../../../libs/prime/emitter');
  const Range = require('../../range2');

  const SYNC = Emitter.EMIT_SYNC;

  module.exports = prime({
    mixin: Emitter,

    constructor: function (container, params) {
      this.container = container;

      this.height = params.height || 0;
      this.length = params.length || 0;

      this.tag = params.tag || 'li';
      this.request = params.request;

      // Unique call identificator.
      this._id = 0;

      this.reset();
    },

    resetFrom: function (fromIndex, length, hiddenIndices) {
      const range = this._range;

      // Redirect the call to reset.
      if (fromIndex < range.end) {
        this.reset(length, hiddenIndices);
        this.show(range);
      }
    },

    reset: function (length, hiddenIndices) {
      const tag = this.tag;

      if (typeof length !== 'undefined') {
        this.length = length;
      }

      const totalHeight = this.length * this.height;

      // Hidden indices are not supported anymore (legacy).
      if (hiddenIndices) {
        throw new TypeError('Hidden indices are not supported anymore!');
      }

      this.container.innerHTML = `<${tag} style="height:${totalHeight}px"></${tag}>` + `<${tag} style="height:0px"></${tag}>`;

      this._range = new Range(0, 0);
      this._waitingRange = new Range(0, 0);

      // An array of ranges representing the visible nodes.
      this.emit('index-change', [], SYNC);
    },

    show: function (range) {
      const length = this.length;
      const actual = this._range;
      const waiting = this._waitingRange;

      // Limit range to the [0, length) interval.
      const bound = new Range(Math.max(0, range.start), Math.min(length, range.end));

      // If the range requested is the same, do nothing.
      if (bound.start === actual.start && bound.end === actual.end) {
        return;
      }

      // If the range requested is the same, do nothing.
      if (bound.start === waiting.start && bound.end === waiting.end) {
        return;
      }

      this._drawRange(bound);
    },

    _drawRange: function (range) {
      const container = this.container;
      const oldRange = this._range;
      const height = this.height;
      const length = this.length;
      const id = ++this._id;

      this._waitingRange = range;

      // Request the whole range. We will manually intersect later with the current one.
      this.request(range, (err, nodes) => {
        let diff = 0;
        let i;

        // If a new range has been requested in the meantime, don't draw/modify anything.
        if (id !== this._id) {
          return;
        }

        // Cache the range requested.
        this._range = range;
        this._waitingRange = new Range(0, 0);

        // Get first and last nodes as references. We will use them for removing/adding nodes.
        const first = container.firstChild;
        const last = container.lastChild;

        // Change heights of the paddings.
        first.style.height = `${range.start * height}px`;
        last.style.height = `${(length - range.end) * height}px`;

        // Remove old nodes. Since nodes change their position when removing them one by one,
        // we have to keep the cumulative sum of nodes removed cached.
        oldRange.subtract(range).forEach(function (subrange) {
          const subrangeLength = subrange.length;

          for (i = 0; i < subrangeLength; i++) {
            // We add one to the children index because the first child is not a row but the top padding.
            container.removeChild(container.children[subrange.start - oldRange.start - diff + 1]);
          }

          diff += subrangeLength;
        });

        // Add new nodes. If the new nodes are below the old range, insert them at the top;
        // otherwise, insert them at the bottom.
        range.subtract(oldRange).forEach(subrange => {
          const subrangeLength = subrange.length;
          const start = subrange.start - range.start;
          const subnodes = nodes.slice(start, start + subrangeLength);
          let ref;

          // Emit a change before.
          this.emit('before-show', subrange, subnodes, SYNC);

          // Get the reference node. If the range is below, then insert at the top.
          // Otherwise, insert at the bottom.
          if (subrange.below(oldRange)) {
            ref = first.nextSibling;
          } else {
            ref = last;
          }

          for (i = 0; i < subrangeLength; i++) {
            container.insertBefore(subnodes[i], ref);
          }

          // Emit a change after.
          this.emit('after-show', subrange, subnodes, SYNC);
        });

        this.emit('index-change', [range], SYNC);
      });
    }
  });

  },{"../../../libs/prime":452,"../../../libs/prime/emitter":451,"../../range2":454}],538:[function(require,module,exports){
  'use strict';

  const Position = function (containerIndex, index) {
    this.containerIndex = containerIndex;
    this.index = index;
  };

  Position.prototype.isSame = function (position) {
    return this.containerIndex === position.containerIndex && this.index === position.index;
  };

  module.exports = Position;

  },{}],539:[function(require,module,exports){
  'use strict';

  const live = require('../../live');

  function checkIfActive() {
    return live('spotify:application').get('active') || false;
  }

  function checkIfFocused() {
    // If the active element of the top frame has a contentWindow that matches
    // this window, it means the iframe of this app is in focus.
    const topActiveElement = window.top.document.activeElement;
    const activeWindow = topActiveElement && topActiveElement.contentWindow;
    if (activeWindow) {
      return activeWindow === window;
    }

    // Top frame (zlink)
    if (window.top === window) {
      return true;
    }

    return false;
  }

  exports.isActive = function () {
    return checkIfActive();
  };

  exports.isActiveAndFocused = function () {
    return checkIfActive() && checkIfFocused();
  };

  },{"../../live":413}],540:[function(require,module,exports){
  /**
   * @module spotify-events/util/cosmos
   * @private
   */

  'use strict';

  const live = require('../../live');
  const cosmos = require('spotify-cosmos-api');
  const liburi = require('spotify-liburi');

  const ASAP = live.ASAP;

  function DELETE(options, callback) {
    options.method = exports.cosmos.Action.DELETE;
    return request(options, callback);
  }

  function GET(options, callback) {
    options.method = exports.cosmos.Action.GET;
    return request(options, callback);
  }

  function SUB(options, callback) {
    options.method = exports.cosmos.Action.SUB;
    return request(options, callback);
  }

  function POST(options, callback) {
    options.method = exports.cosmos.Action.POST;
    return request(options, callback);
  }

  function PUT(options, callback) {
    options.method = exports.cosmos.Action.PUT;
    return request(options, callback);
  }

  function HEAD(options, callback) {
    options.method = exports.cosmos.Action.HEAD;
    return request(options, callback);
  }

  function request(options, callback) {
    const method = options.method;
    delete options.method;

    let subscription;
    let canceled;

    sanitizeURL(options.url, function (error, url) {
      if (error) {
        callback(error);
        return;
      }

      // if you cancel before the userName is replaced.
      if (canceled) return;

      const cosmosRequest = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
      subscription = exports.cosmos.resolver.resolve(cosmosRequest, function (cosmosError, response) {
        if (!callback) return;
        if (cosmosError) {
          callback(cosmosError);
          return;
        }
        try {
          callback(null, {
            body: JSON.parse(response.getBody() || '{}'),
            headers: response.getHeaders(),
            status: response.getStatusCode()
          });
        } catch (parseError) {
          parseError.response = response;
          callback(parseError);
        }
      });
    });

    return {
      cancel: function () {
        if (subscription && subscription.cancel) {
          // we already subscribed, cancel it.
          subscription.cancel();
          subscription = null;
        } else if (!canceled) {
          // not subscribed yet, don't even subscribe.
          canceled = true;
        }
        return null;
      }
    };
  }

  function sanitizeURL(url, callback) {
    if (url.indexOf('@') > -1) {
      live('spotify:client').query('currentUser(username)', function (error, data) {
        if (error) {
          callback(error);
          return;
        }
        callback(null, url.replace('@', liburi.getCanonicalUsername(data.currentUser.username)));
      }, ASAP);
    } else {
      callback(null, url);
    }
  }

  exports.request = request;
  exports.get = GET;
  exports.post = POST;
  exports.subscribe = SUB;
  exports.delete = DELETE;
  exports.put = PUT;
  exports.head = HEAD;
  exports.cosmos = cosmos;

  exports.sanitizeURL = sanitizeURL;

  },{"../../live":413,"spotify-cosmos-api":1272,"spotify-liburi":1282}],541:[function(require,module,exports){
  'use strict';

  /**
   * @public
   */

  /**
   * Get the context URI from the specified node or its parents.
   *
   * @param {HTMLElement} node A DOM node.
   *
   * @return {string} The context URI or empty string if not found.
   */

  function getContextFromNodeOrParent(node) {
    const contextNode = node.closest('[data-context]');
    return contextNode && contextNode.getAttribute('data-uri') || '';
  }

  /**
   * Get the value for the passed attribute name, either from the passed node
   * or from any parent node.
   *
   * @param {HTMLElement} node The node to start searching from.
   * @param {string} attributeName The name of the attribute.
   *
   * @return {string} The value, or empty string if not found.
   */
  function getAttributeFromNodeOrParent(node, attributeName) {
    const selector = `[${attributeName}]`;
    const attributeNode = node.closest(selector);
    return attributeNode && attributeNode.getAttribute(attributeName) || '';
  }

  exports.getContextFromNodeOrParent = getContextFromNodeOrParent;
  exports.getAttributeFromNodeOrParent = getAttributeFromNodeOrParent;

  },{}],542:[function(require,module,exports){
  'use strict';

  module.exports = function getLogContext(target) {
    let currentNode = target;
    const logContext = [];
    while (currentNode) {
      if (currentNode.matches && currentNode.matches('[data-log-context]')) {
        logContext.unshift(currentNode.getAttribute('data-log-context'));
      }
      currentNode = currentNode.parentNode;
    }
    return logContext.join('/') || null;
  };

  },{}],543:[function(require,module,exports){
  'use strict';

  const rAF = window.requestAnimationFrame || function (fn) {
    setTimeout(fn, 16);
  };

  /**
   * Throttle the function calls to only trigger once per tick.
   * This will return a new function that you will use when you want
   * to call your function. Calling it multiple times in the same
   * run loop will only really call it once.
   *
   * @param {function} fn A function.
   * @param {Object=} ctx The context to run the function in ('this').
   *
   * @return {function} A new function.
   */
  function throttle(fn, ctx) {
    let queued = false;
    let args;

    return function () {
      args = arguments;
      if (!queued) {
        queued = true;
        rAF(function () {
          queued = false;
          fn.apply(ctx, args);
        });
      }
    };
  }

  module.exports = throttle;

  },{}],544:[function(require,module,exports){
  'use strict';

  // Usage
  // Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
  // Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
  // Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

  const operators = {
    '==': function (a, b) {
      /* eslint eqeqeq: 0 */return a == b;
    },
    '===': function (a, b) {
      return a === b;
    },
    '!=': function (a, b) {
      /* eslint eqeqeq: 0 */return a != b;
    },
    '<': function (a, b) {
      return a < b;
    },
    '>': function (a, b) {
      return a > b;
    },
    '<=': function (a, b) {
      return a <= b;
    },
    '>=': function (a, b) {
      return a >= b;
    },
    'typeof': function (a, b) {
      return typeof a == b;
    }
  };

  function compare(a, b, s) {
    const options = arguments[arguments.length - 1];
    const soft = s !== options ? s : false;
    const operator = soft ? '==' : options.hash.operator || '===';

    const match = operators[operator](a, b);

    return match ? options.fn(this) : options.inverse(this);
  }

  compare.displayName = 'compare';

  module.exports = compare;

  },{}],545:[function(require,module,exports){
  'use strict';

  const duration = function (ms) {
    if (isNaN(ms)) return ms;

    const s = Math.round(ms / 1000);
    const oneMinute = 60;
    const oneHour = 60 * oneMinute;

    let hours = Math.floor(s / oneHour);
    let minutes = Math.floor(s % oneHour / oneMinute);
    let seconds = Math.round(s % oneHour % oneMinute);

    // Include hours if needed
    if (hours) {
      hours += ':';

      // If hours are specified, minutes should always be with two digits
      if (minutes < 10) minutes = `0${minutes}`;
    } else {
      hours = '';
    }

    // Since minutes should always be displayed, seconds should always be with two digits
    if (seconds < 10) seconds = `0${seconds}`;

    return `${hours + minutes}:${seconds}`;
  };

  duration.displayName = 'duration';

  module.exports = duration;

  },{}],546:[function(require,module,exports){
  'use strict';

  const nameListTooltip = require('./name-list-tooltip');

  const facepile = function (list, options) {
    if (!list) {
      return '';
    }

    const len = list.length;
    const thresh = Math.min(3, len);
    let ret = '';

    // Display faces.
    for (let i = 0; i < thresh; i++) {
      const obj = list[i];
      ret += options.fn(obj);
    }

    // Display badge count for hidden faces.
    if (len > thresh) {
      ret += options.inverse({
        badgeCount: len - thresh,
        badgeTooltip: nameListTooltip(list.slice(thresh), len - thresh)
      });
    }
    return ret;
  };

  facepile.displayName = 'facepile';

  module.exports = facepile;

  },{"./name-list-tooltip":553}],547:[function(require,module,exports){
  (function (global){
  'use strict';

  const getHTTPLink = require('../util/link');

  const isDesktop = !!global._getSpotifyModule;

  const href = function (uri) {
    if (isDesktop) return uri;
    return getHTTPLink(uri, 'https://play.spotify.com');
  };

  href.displayName = 'href';

  module.exports = href;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../util/link":560}],548:[function(require,module,exports){
  'use strict';

  const loc = require('./loc');

  const humanizeDuration = function (ms) {
    if (isNaN(ms)) return ms;

    const s = Math.round(ms / 1000);
    const oneMinute = 60;
    const oneHour = 60 * oneMinute;

    const hours = Math.floor(s / oneHour);
    const minutes = Math.floor(s % oneHour / oneMinute);
    const seconds = Math.round(s % oneHour % oneMinute);

    let formattedDuration = '';

    if (hours) {
      formattedDuration += loc('HoursShort', hours, {});
    }

    if (minutes) {
      formattedDuration += ' ';
      formattedDuration += loc('MinutesShort', minutes, {});
    }

    if (!hours && !minutes || hours === 0 && minutes < 10) {
      formattedDuration += ' ';
      formattedDuration += loc('SecondsShort', seconds, {});
    }

    return formattedDuration.trim();
  };

  humanizeDuration.displayName = 'humanizeDuration';

  module.exports = humanizeDuration;

  },{"./loc":552}],549:[function(require,module,exports){
  'use strict';

  exports.compare = require('./compare');
  exports.duration = require('./duration');
  exports.facepile = require('./facepile');
  exports.href = require('./href');
  exports.humanizeDuration = require('./humanize-duration');
  exports.loc = require('./loc');
  exports.nameListTooltip = require('./name-list-tooltip');
  exports.numeral = require('./numeral');
  exports.share = require('./share');
  exports.slice = require('./slice');
  exports.type = require('./type');
  exports.userReaction = require('./user-reaction');
  exports.json = require('./json');

  },{"./compare":544,"./duration":545,"./facepile":546,"./href":547,"./humanize-duration":548,"./json":550,"./loc":552,"./name-list-tooltip":553,"./numeral":554,"./share":555,"./slice":556,"./type":557,"./user-reaction":558}],550:[function(require,module,exports){
  'use strict';

  const json = function (context) {
    return JSON.stringify(context);
  };

  json.displayName = 'json';

  module.exports = json;

  },{}],551:[function(require,module,exports){
  'use strict';

  const map = require('mout/array/map');

  const Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

  const lists = {};

  const list = function (array) {
    if (!array) {
      return '';
    }

    const args = Array.prototype.slice.call(arguments);
    const options = args.pop();
    const listID = args[1];

    if (array === 'reset') {
      delete lists[listID];
      return '';
    }

    if (listID && lists[listID] === undefined) {
      lists[listID] = -1;
    }

    return map(array, function (item, i) {
      const data = Handlebars.createFrame(options.data || {});
      data.index = listID ? ++lists[listID] : i;
      data.number = data.index + 1;
      data.localIndex = i;
      data.localNumber = i + 1;
      return options.fn(item, { data: data });
    }).join(options.hash && options.hash.join || '');
  };

  list.displayName = 'list';

  module.exports = list;

  },{"handlebars/dist/cjs/handlebars.runtime":726,"mout/array/map":784}],552:[function(require,module,exports){
  'use strict';

  var _mixIn = require('mout/object/mixIn');

  var _mixIn2 = _interopRequireDefault(_mixIn);

  var _locales = require('../../locales');

  var _locales2 = _interopRequireDefault(_locales);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const slice_ = Array.prototype.slice;

  let locale = 'en';
  let numberFormat = new Intl.NumberFormat(locale);
  let pluralRules = new Intl.PluralRules(locale);
  const storage = {};

  const loc = function (key) {
    let args = slice_.call(arguments, 1);
    let options = {};

    const lastArg = args[args.length - 1];
    if (typeof lastArg === 'object' && 'hash' in lastArg) {
      options = args.pop();
    }

    const hash = options.hash;

    const value = typeof storage[key] === 'object' ? storage[key][pluralRules.select(args[0])] || storage[key].other : storage[key];

    if (!value) return '';

    // If we are passed an array, use that for replacements
    if (Array.isArray(args[0])) {
      args = args[0];
    }

    return value.replace(/\{([\w-]+)\}/g, function (full, match) {
      const n = +match;
      let interpolated;

      if (isNaN(n)) {
        interpolated = hash[match];
      } else {
        interpolated = args[n];
      }

      if (typeof interpolated === 'number') {
        interpolated = numberFormat.format(interpolated);
      }

      return interpolated !== null ? interpolated : '';
    });
  };

  loc.displayName = 'loc';

  loc.register = function (object) {
    (0, _mixIn2.default)(storage, object);
    return this;
  };

  loc.setLocale = function (newLocale) {
    locale = newLocale;
    numberFormat = new Intl.NumberFormat((0, _locales2.default)(locale, 'intl'));
    pluralRules = new Intl.PluralRules((0, _locales2.default)(locale, 'intl'));
  };

  module.exports = loc;

  },{"../../locales":419,"mout/object/mixIn":813}],553:[function(require,module,exports){
  'use strict';

  const loc = require('./loc');

  const nameListTooltip = function (users, totalCount) {
    if (totalCount === 0) {
      return undefined;
    }

    const len = users.length;
    const textTokens = users.map(function (user) {
      return user.name;
    });

    if (totalCount - len > 0) {
      const andMoreText = loc('AndMore', totalCount - len);
      textTokens.push(andMoreText);
    }

    return textTokens.join('<br>\n').replace(/'/g, '&#39;');
  };

  nameListTooltip.displayName = 'nameListTooltip';

  module.exports = nameListTooltip;

  },{"./loc":552}],554:[function(require,module,exports){
  'use strict';

  const isNumber = require('mout/lang/isNumber');

  /**
   * If the first argument is a number, pipe it through spotify-numeral with an
   * optional format propety in the options hash, otherwise return it untouched.
   *
   * Example usage – results when using fr locale:
   *
   * {{numeral 1000}} -> '1 000'
   * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
   * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
   *
   * @param {Number|String} number - The number to format (or string to leave
   *     untouched).
   * @param {Object} [options] - The handlebars options object.
   * @param {Object} [options.hash] - The handlebars options hash object.
   * @param {String} [options.hash.format] - The optional format to pass to
   *     numeraljs.
   * @return {String} The formatted (or untouched) string.
   */
  const numeralHelper = function (number, options) {
    const format = options && options.hash && options.hash.format;
    const numeral = numeralHelper._numeral;
    return isNumber(number) ? numeral(number).format(format) : number;
  };

  numeralHelper.displayName = 'numeral';

  module.exports = numeralHelper;

  // This is tricky, but is a way to allow for the locale to be injected
  // from the consuming app instead of from within spotify-numeral, removing
  // the dependency on spotify-quickstart.
  module.exports.setLocale = function (locale) {
    numeralHelper._numeral = require('../../spotify-numeral')(locale);
  };

  },{"../../spotify-numeral":564,"mout/lang/isNumber":799}],555:[function(require,module,exports){
  'use strict';

  const getHTTPLink = require('../util/link');

  const share = function (uri) {
    return getHTTPLink(uri, 'https://open.spotify.com');
  };

  share.displayName = 'share';

  module.exports = share;

  },{"../util/link":560}],556:[function(require,module,exports){
  'use strict';

  const kindOf = require('mout/lang/kindOf');
  const map = require('mout/array/map');
  const forEach = require('mout/array/forEach');

  const Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
  const slice_ = Array.prototype.slice;

  const slice = function (arr) {
    let array = arr;

    if (!array) {
      return '';
    }

    let sep;
    let begin;
    let end;
    let options;

    forEach(slice_.call(arguments, 1), function (arg) {
      switch (kindOf(arg)) {
        case 'String':
          sep = arg;
          break;

        case 'Number':
          if (begin === null) {
            begin = arg;
          } else if (end === null) {
            end = arg;
          }
          break;

        case 'Object':
          options = arg;
          break;

        default:
        // Do nothing.
      }
    });

    if (begin !== null) {
      array = array.slice(begin, end !== null ? end : array.length);
    }

    return map(array, function (item, index) {
      const data = Handlebars.createFrame(options.data || {});
      data.index = index;

      return options.fn(item, { data: data });
    }).join(sep || '');
  };

  slice.displayName = 'slice';

  module.exports = slice;

  },{"handlebars/dist/cjs/handlebars.runtime":726,"mout/array/forEach":781,"mout/array/map":784,"mout/lang/kindOf":803}],557:[function(require,module,exports){
  'use strict';

  const getType = require('../util/type');

  // This needs at least the uri param to get the type:
  // {{type uri}}
  //
  // If you pass more parameters you can use it like a matcher:
  // {{#type uri "track" "album"}}YAY{{/type}}
  // This will print 'YAY' for tracks or albums.

  const type = function (uri) {
    if (arguments.length <= 2) {
      // Simple get type.
      return getType(uri);
    }

    // Match type.
    const context = arguments[arguments.length - 1];
    let success = false;
    const uriType = getType(uri);

    for (let i = 1; i < arguments.length - 1; i++) {
      if (uriType === arguments[i]) {
        success = true;
        break;
      }
    }

    return success ? context.fn(this) : context.inverse(this);
  };

  type.displayName = 'type';

  module.exports = type;

  },{"../util/type":561}],558:[function(require,module,exports){
  'use strict';

  const loc = require('./loc');

  const userReaction = function (users, totalCount, reactionType) {
    if (!totalCount) return '';
    const key = `${reactionType}Reaction${totalCount > 1 ? 'Multi' : 'Single'}`;

    if (totalCount > 1) {
      return loc(key, totalCount);
    }

    if (!users.length) {
      return '';
    }

    const firstListener = users[0].name;
    return loc(key, firstListener);
  };

  userReaction.displayName = 'userReaction';

  module.exports = userReaction;

  },{"./loc":552}],559:[function(require,module,exports){
  'use strict';

  const kindOf = require('mout/lang/kindOf');

  const Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

  // Expose the runtime to make partials easier to register.
  exports.runtime = Handlebars;

  exports.register = function (helpers) {
    let list = {};

    if (kindOf(helpers) === 'Function') {
      list[helpers.displayName] = helpers;
    } else {
      list = helpers;
    }

    for (const key in list) {
      if (list.hasOwnProperty(key)) {
        Handlebars.registerHelper(key, list[key]);
      }
    }

    return this;
  };

  },{"handlebars/dist/cjs/handlebars.runtime":726,"mout/lang/kindOf":803}],560:[function(require,module,exports){
  'use strict';

  module.exports = function (uri, base) {
    const matches = (uri || '').match(/^spotify:(.+)$/);

    if (!matches) {
      return uri || '';
    }

    let parts = matches.pop().replace(/:$/, '').split(/:/);
    const type = parts.shift();

    if (type === 'search') {
      parts = [parts.join(':')];
    }

    parts.unshift(base, type);

    return parts.join('/');
  };

  },{}],561:[function(require,module,exports){
  'use strict';

  module.exports = function (uri) {
    if (!uri || !uri.split) {
      return null;
    }
    const timePart = uri.split('#');
    if (timePart.length > 1) {
      uri = timePart[0];
    }
    const parts = uri.split(':');
    const result = null;
    switch (parts[1]) {
      case 'album':
        // spotify:album:<id>:<disc>
        if (parts.length === 4) {
          return 'disc';
        } else if (parts.length === 3) {
          return 'album';
        }
        break;

      case 'artist':
        if (parts.length === 3) {
          return 'artist';
        }
        break;

      case 'track':
        if (parts.length === 3) {
          return 'track';
        }
        break;

      case 'playlist':
        // spotify:playlist:xxx
        if (parts.length === 3) {
          return 'playlist';
        }
        break;

      case 'genre':
        if (parts.length === 3) {
          return 'genre';
        }
        break;

      // spotify:show:<id>
      case 'show':
        if (parts.length === 3) {
          return 'show';
        }
        break;

      case 'station':
        // spotify:station:<station-type>:<id>
        if (parts.length > 3) {
          return 'station';
        }
        break;

      case 'episode':
        // spotify:episode:<id>
        if (parts.length === 3) {
          return 'episode';
        }
        break;

      case 'local':
        if (parts.length === 6) {
          return 'track';
        } else if (parts.length === 4) {
          return 'album';
        } else if (parts.length === 3) {
          return 'artist';
        }
        break;

      case 'user':
        // spotify:user:<username>:collection:album:<id>
        if (parts.length > 3 && parts[3] === 'collection' && parts[4] === 'album') {
          return 'collection-album';
        }
        // spotify:user:<username>:collection:artist:<id>
        if (parts.length > 3 && parts[3] === 'collection' && parts[4] === 'artist') {
          return 'collection-artist';
        }
        // spotify:user:<username>:collection
        if (parts.length > 3 && parts[3] === 'collection') {
          return 'collection';
        }

        // spotify:user:<username>:folder:<id>
        if (parts.length === 5 && parts[3] === 'folder') {
          return 'playlist-folder';
        }

        // spotify:user:<username>:cluster:<id>
        if (parts.length === 5 && parts[3] === 'cluster') {
          return 'cluster';
        }

        // spotify:user:<username>:playlist:<id>|starred|toplist>
        if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
          return 'playlist';
        } else if (parts.length === 3) {
          return 'user';
        }
        break;

      case 'internal':
        // spotify:internal:local-files
        return parts[2];

      case 'app':
        // spotify:app:collection:albums, spotify:app:radio
        return parts.slice(1).join('-');

      default:
      // Do nothing.
    }

    return result;
  };

  },{}],562:[function(require,module,exports){
  'use strict';

  var _strings = require('../glue/strings');

  var _strings2 = _interopRequireDefault(_strings);

  var _interpolateString = require('./src/interpolate-string');

  var _interpolateString2 = _interopRequireDefault(_interpolateString);

  var _locales = require('../locales');

  var _locales2 = _interopRequireDefault(_locales);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  module.exports = function (appStringsByLocale) {
    if (!appStringsByLocale || typeof appStringsByLocale !== 'object') {
      throw new Error('`appStringsByLocale` must be a plain object. See spotify-i18n/README.md');
    }

    function getClientLocale() {
      const preference = typeof window !== 'undefined' && window && window.__spotify && window.__spotify.locale;
      return preference in appStringsByLocale ? preference : 'en';
    }

    // Intl.PluralRules instances aren't super fast to create, so cache and re-use.
    const pluralRulesByLocale = {};
    function selectPluralRule(locale, count) {
      const pluralRules = pluralRulesByLocale[locale] || (pluralRulesByLocale[locale] = new Intl.PluralRules((0, _locales2.default)(locale, 'intl')));
      return pluralRules.select(count);
    }

    function get(stringsByLocale, key, ...parameters) {
      const locale = getClientLocale();
      const localised = stringsByLocale[locale][key];

      const string = typeof localised !== 'object' ? localised : localised[selectPluralRule(locale, parameters[0])] ||
      // This will mainly happen while waiting for translations to come back,
      // during which time the Polish lang file (for example) will contain the
      // English plural forms. Falling back to "other" covers this quite nicely.
      localised.other;

      if (typeof string === 'undefined') {
        return key;
      }
      return (0, _interpolateString2.default)(string, parameters, locale);
    }

    return {
      locale: getClientLocale,

      get: get.bind(null, appStringsByLocale),

      getGlueString: get.bind(null, _strings2.default),

      glueStrings: function () {
        return _strings2.default[getClientLocale()];
      },

      appStrings: function () {
        return appStringsByLocale[getClientLocale()];
      }
    };
  };

  },{"../glue/strings":163,"../locales":419,"./src/interpolate-string":563}],563:[function(require,module,exports){
  'use strict';

  /**
   * Replaces placeholders with their corresponding parameters
   *
   * This used to be a part of the spotify-translations lib. That package was
   * absorbed into spotify-i18n during the addition of pluralization.
   */

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = interpolateString;
  function interpolateString(string, parameters = [], locale) {
    const numberFormat = new Intl.NumberFormat(locale || 'en');

    return string.replace(/\{(\d+?)\}/g, function (str, num) {
      const value = parameters[num];

      if (typeof value === 'undefined') {
        return str;
      }

      if (typeof value === 'number') {
        return numberFormat.format(value);
      }

      return value;
    });
  }

  },{}],564:[function(require,module,exports){
  /* eslint-disable no-nested-ternary */

  'use strict';

  var _locales = require('../locales');

  var _locales2 = _interopRequireDefault(_locales);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function getOrdinalFunction(currentLanguage) {
    switch (currentLanguage) {
      case 'cs':
      case 'de':
      case 'el':
      case 'fi':
      case 'hu':
      case 'ja':
      case 'pl':
      case 'sv':
      case 'zsm':
        return n => `${n}.`;

      case 'it':
      case 'pt-BR':
        return n => `${n}º`;

      case 'fr':
      case 'fr-CA':
        return n => `${n}${n === 1 ? 'er' : 'e'}`;

      case 'es':
      case 'es-419':
        return (n, b = n % 10) => `${n}${b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to'}`;

      case 'id':
        // According to Spotify's internal Indonesian specialist,
        // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
        // they just use the word (equivalent to writing: first, second,
        // third, instead of 1st, 2nd, 3rd). And as we don't have such
        // capability to translate all numbers to words, this function
        // returns the cardinal number as a string.
        return n => `${n}`;

      case 'nl':
        return (n, b = n % 100) => `${n}${n !== 0 && b <= 1 || b === 8 || b >= 20 ? 'ste' : 'de'}`;

      case 'tr':
        return n => {
          if (n === 0) {
            // special case for zero
            return `${n}'ıncı`;
          }
          const suffixes = {
            1: "'inci",
            5: "'inci",
            8: "'inci",
            70: "'inci",
            80: "'inci",

            2: "'nci",
            7: "'nci",
            20: "'nci",
            50: "'nci",

            3: "'üncü",
            4: "'üncü",
            100: "'üncü",

            6: "'ncı",

            9: "'uncu",
            10: "'uncu",
            30: "'uncu",

            60: "'ıncı",
            90: "'ıncı"
          };
          const a = n % 10;
          const b = n % 100 - a;
          const c = n >= 100 ? 100 : null;

          return `${n}${suffixes[a] || suffixes[b] || suffixes[c]}`;
        };

      case 'zh-Hant':
        return n => `第${n}`;

      case 'en':
        return (n, b = n % 10) => `${n}${~~(n % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th'}`;

      case 'th':
        // There is no ordinal symbol in Thai (like st, nd, th, º, ª),
        // they just numbers 1,2,3. Suppose the '1st' album will be 'album number 1'.
        // And as we don't have such capability to reorder words,
        // this function just returns the cardinal number as a string.
        return n => `${n}`;

      case 'vi':
        return n => {
          if (n === 1) {
            // special case for 1st
            return 'thứ nhất';
          }
          return `thứ ${n}`;
        };

      default:
        console.warn(`No explicit ordinal formatter specified for "${currentLanguage}" locale – please add to spotify-numeral`);
        return n => `${n}.`;
    }
  }

  module.exports = function (currentLanguage) {
    const getOrdinal = getOrdinalFunction(currentLanguage);
    const numberFormat = new Intl.NumberFormat((0, _locales2.default)(currentLanguage, 'intl'));

    const getFormattedNumber = (number, format = '0,0') => {
      if (format === '0,0') return numberFormat.format(number);else if (format === '0o') return getOrdinal(number);
      throw new Error(`Unsupported format ${format}`);
    };

    return number => ({
      format: format => getFormattedNumber(number, format)
    });
  };

  },{"../locales":419}],565:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.watchSessionChange = exports.dispatchQBEUpdate = exports.dispatchQBEShowSuccessMessage = exports.dispatchQBEShowHighlight = exports.dispatchQBEShowModal = exports.dispatchUriAdded = exports.dispatchAppOpened = exports.subscribeToMessages = exports.sendQBEAction = exports.sendMessages = exports.QBE_BROWSE = exports.QBE_FOLLOW_FRIENDS = exports.QBE_SAVE_ENTITY = exports.QBE_ADD_TO_PLAYLIST = exports.QBE_CREATE_PLAYLIST = exports.QBE_SEARCH = exports.QBE_SIGNUP = exports.QBE_SHOW_SUCCESS_MESSAGE = exports.QBE_UPDATE = exports.QBE_SHOW_HIGHLIGHT = exports.QBE_SHOW_MODAL = exports.SESSION_ONLINE_STATUS_CHANGE = exports.ADD_URI = exports.OPEN_PLAYLIST = exports.OPEN_APP = undefined;

  var _bridge = require('../../libs/bridge');

  var _bridge2 = _interopRequireDefault(_bridge);

  var _live = require('../../libs/live');

  var _live2 = _interopRequireDefault(_live);

  var _kernel = require('./kernel');

  var _kernel2 = _interopRequireDefault(_kernel);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const sideEffects = {
    bridge: _bridge2.default,
    live: _live2.default
  };
  const shell = (0, _kernel2.default)(sideEffects);

  const {
    OPEN_APP,
    OPEN_PLAYLIST,
    ADD_URI,
    SESSION_ONLINE_STATUS_CHANGE,

    QBE_SHOW_MODAL,
    QBE_SHOW_HIGHLIGHT,
    QBE_UPDATE,
    QBE_SHOW_SUCCESS_MESSAGE,
    QBE_SIGNUP,
    QBE_SEARCH,
    QBE_CREATE_PLAYLIST,
    QBE_ADD_TO_PLAYLIST,
    QBE_SAVE_ENTITY,
    QBE_FOLLOW_FRIENDS,
    QBE_BROWSE,

    sendMessages,
    sendQBEAction,
    subscribeToMessages,
    dispatchAppOpened,
    dispatchUriAdded,
    dispatchQBEShowModal,
    dispatchQBEShowHighlight,
    dispatchQBEShowSuccessMessage,
    dispatchQBEUpdate,
    watchSessionChange
  } = shell;
  exports.OPEN_APP = OPEN_APP;
  exports.OPEN_PLAYLIST = OPEN_PLAYLIST;
  exports.ADD_URI = ADD_URI;
  exports.SESSION_ONLINE_STATUS_CHANGE = SESSION_ONLINE_STATUS_CHANGE;
  exports.QBE_SHOW_MODAL = QBE_SHOW_MODAL;
  exports.QBE_SHOW_HIGHLIGHT = QBE_SHOW_HIGHLIGHT;
  exports.QBE_UPDATE = QBE_UPDATE;
  exports.QBE_SHOW_SUCCESS_MESSAGE = QBE_SHOW_SUCCESS_MESSAGE;
  exports.QBE_SIGNUP = QBE_SIGNUP;
  exports.QBE_SEARCH = QBE_SEARCH;
  exports.QBE_CREATE_PLAYLIST = QBE_CREATE_PLAYLIST;
  exports.QBE_ADD_TO_PLAYLIST = QBE_ADD_TO_PLAYLIST;
  exports.QBE_SAVE_ENTITY = QBE_SAVE_ENTITY;
  exports.QBE_FOLLOW_FRIENDS = QBE_FOLLOW_FRIENDS;
  exports.QBE_BROWSE = QBE_BROWSE;
  exports.sendMessages = sendMessages;
  exports.sendQBEAction = sendQBEAction;
  exports.subscribeToMessages = subscribeToMessages;
  exports.dispatchAppOpened = dispatchAppOpened;
  exports.dispatchUriAdded = dispatchUriAdded;
  exports.dispatchQBEShowModal = dispatchQBEShowModal;
  exports.dispatchQBEShowHighlight = dispatchQBEShowHighlight;
  exports.dispatchQBEShowSuccessMessage = dispatchQBEShowSuccessMessage;
  exports.dispatchQBEUpdate = dispatchQBEUpdate;
  exports.watchSessionChange = watchSessionChange;

  },{"../../libs/bridge":121,"../../libs/live":413,"./kernel":566}],566:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = kernel;

  var _spotifyLiburi = require('spotify-liburi');

  var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function kernel({ bridge, live }) {
    const OPEN_APP = 'open_app';
    const OPEN_PLAYLIST = 'open_playlist';
    const ADD_URI = 'add_uri'; // add/follow an URI
    const QBE_SHOW_MODAL = 'qbe_show_modal';
    const QBE_SHOW_HIGHLIGHT = 'qbe_show_highlight';
    const QBE_UPDATE = 'qbe_update';
    const QBE_SHOW_SUCCESS_MESSAGE = 'qbe_show_success_message';
    const SESSION_ONLINE_STATUS_CHANGE = 'session_online_status_change';

    // string IDs are the same as on the backend (Activity Manager)
    const QBE_SIGNUP = 'signup';
    const QBE_SEARCH = 'search';
    const QBE_CREATE_PLAYLIST = 'create_playlist';
    const QBE_ADD_TO_PLAYLIST = 'add_to_playlist';
    const QBE_SAVE_ENTITY = 'save_entity';
    const QBE_FOLLOW_FRIENDS = 'follow_friends';
    const QBE_BROWSE = 'browse';

    // QBE specific messages

    function sendMessages(messages) {
      bridge.cosmosJSON({
        method: 'POST',
        uri: 'sp://messages/v1/surround',
        body: messages
      });
    }

    // The seconds parameter passed to `callback` is an array of messages that may
    // contain 1 or more messages.
    function subscribeToMessages(callback) {
      bridge.cosmosJSON({
        method: 'SUB',
        uri: 'sp://messages/v1/surround'
      }, callback);
    }

    function dispatchAppOpened(appId, appArguments) {
      const messages = [{
        action: OPEN_APP,
        appId: appId
      }];

      switch (appId) {
        case 'playlist':
        case 'chart':
          {
            const openPlaylistMessage = function createOpenPlaylistMessageFromAppArguments() {
              // args are the arguments passed to the playlist app and chart app.
              const args = appArguments;
              let playlistUri = null;

              if (args.length === 1) {
                if (args[0] === 'local-files') {
                  playlistUri = 'spotify:internal:local-files';
                } else {
                  playlistUri = _spotifyLiburi2.default.playlistV2URI(args[0]).toString();
                }
              } else if (args.length >= 2) {
                playlistUri = _spotifyLiburi2.default.playlistURI(args[0], args[1]).toString();
              }

              if (playlistUri) {
                return { action: OPEN_PLAYLIST, playlistUri: playlistUri };
              }
              return null;
            }();

            if (openPlaylistMessage) {
              messages.push(openPlaylistMessage);
            }
            break;
          }

        default:
          break;
      }

      sendMessages(messages);
    }

    function dispatchUriAdded(uri, data) {
      if (!data.added) {
        return;
      }

      sendMessages([{
        action: ADD_URI,
        uri: uri
      }]);
    }

    function dispatchQBEShowModal(title, content, id, buttons) {
      sendMessages([{
        action: QBE_SHOW_MODAL,
        modal: { title, content, id },
        buttons
      }]);
    }

    function dispatchQBEShowHighlight(highlight, taskId) {
      sendMessages([{
        action: QBE_SHOW_HIGHLIGHT,
        highlight,
        taskId
      }]);
    }

    function dispatchQBEShowSuccessMessage(text) {
      sendMessages([{
        action: QBE_SHOW_SUCCESS_MESSAGE,
        text
      }]);
    }

    function dispatchQBEUpdate({ enabled, tasks = [] }) {
      sendMessages([{
        action: QBE_UPDATE,
        enabled,
        tasks
      }]);
    }

    function watchSessionChange() {
      function subscribe() {
        live('spotify:client').get('session').on('update', data => {
          if ('online' in data) {
            sendMessages([{
              action: SESSION_ONLINE_STATUS_CHANGE,
              online: data.online
            }]);
          }
        });
      }
      live('spotify:client').query('session(online)', (error, data) => {
        sendMessages([{
          action: SESSION_ONLINE_STATUS_CHANGE,
          online: data.session.online
        }]);
        subscribe();
      });
    }

    function sendQBEAction(action) {
      sendMessages([{ action }]);
    }

    return {
      OPEN_APP,
      OPEN_PLAYLIST,
      ADD_URI,
      SESSION_ONLINE_STATUS_CHANGE,

      QBE_SHOW_MODAL,
      QBE_SHOW_HIGHLIGHT,
      QBE_UPDATE,
      QBE_SHOW_SUCCESS_MESSAGE,
      QBE_SIGNUP,
      QBE_SEARCH,
      QBE_CREATE_PLAYLIST,
      QBE_ADD_TO_PLAYLIST,
      QBE_SAVE_ENTITY,
      QBE_FOLLOW_FRIENDS,
      QBE_BROWSE,

      sendMessages,
      sendQBEAction,
      subscribeToMessages,
      dispatchAppOpened,
      dispatchUriAdded,
      dispatchQBEShowModal,
      dispatchQBEShowHighlight,
      dispatchQBEShowSuccessMessage,
      dispatchQBEUpdate,
      watchSessionChange
    };
  }

  },{"spotify-liburi":1282}],567:[function(require,module,exports){
  module.exports={
    "GLUE_COLOR_GREEN": "#1db954",
    "GLUE_COLOR_GREEN_LIGHT": "#1ed760",
    "GLUE_COLOR_GREEN_DARK": "#14833b",
    "GLUE_COLOR_BLACK": "#000000",
    "GLUE_COLOR_GRAY_7": "#121212",
    "GLUE_COLOR_GRAY_10": "#181818",
    "GLUE_COLOR_GRAY_15": "#282828",
    "GLUE_COLOR_GRAY_20": "#333333",
    "GLUE_COLOR_GRAY_25": "#404040",
    "GLUE_COLOR_GRAY_30": "#535353",
    "GLUE_COLOR_GRAY_60": "#a0a0a0",
    "GLUE_COLOR_GRAY_70": "#b3b3b3",
    "GLUE_COLOR_WHITE": "#ffffff",
    "GLUE_COLOR_UI_RED": "#cd1a2b",
    "GLUE_COLOR_UI_RED_LIGHT": "#e22134",
    "GLUE_COLOR_UI_RED_DARK": "#941320",
    "GLUE_COLOR_UI_BLUE": "#4687d6",
    "GLUE_COLOR_UI_BLUE_LIGHT": "#2e77d0",
    "GLUE_COLOR_UI_BLUE_DARK": "#1d4c85",
    "GLUE_COLOR_AQUAMARINE": "#9bf0e1",
    "GLUE_COLOR_AUBERGINE": "#503750",
    "GLUE_COLOR_AZURE": "#509bf5",
    "GLUE_COLOR_BOLE": "#c87d55",
    "GLUE_COLOR_BRIGHT_RED": "#eb1e32",
    "GLUE_COLOR_CHOCOLATE": "#7d4b32",
    "GLUE_COLOR_CITRIC": "#cdf564",
    "GLUE_COLOR_ELECTRIC_SEAFOAM": "#19e68c",
    "GLUE_COLOR_FACTORY_YELLOW": "#fae62d",
    "GLUE_COLOR_FOREST": "#006450",
    "GLUE_COLOR_FUCHSIA": "#f037a5",
    "GLUE_COLOR_GOLD": "#f59b23",
    "GLUE_COLOR_KLEIN_BLUE": "#4100f5",
    "GLUE_COLOR_LAVENDER": "#b49bc8",
    "GLUE_COLOR_MAROON": "#8c1932",
    "GLUE_COLOR_MIDNIGHT": "#1e3264",
    "GLUE_COLOR_NEON_GREEN": "#5ff550",
    "GLUE_COLOR_ORANGE": "#ff6437",
    "GLUE_COLOR_PINK": "#ffcdd2",
    "GLUE_COLOR_POWDER_GREEN": "#c3f0c8",
    "GLUE_COLOR_ROYAL_BLUE": "#2d46b9",
    "GLUE_COLOR_SALMON": "#dc2d73",
    "GLUE_COLOR_SPEARMINT": "#4b917d",
    "GLUE_COLOR_STORM": "#a0c3d2",
    "GLUE_COLOR_SUNFLOWER": "#ffc864",
    "GLUE_COLOR_TAN": "#c39687",
    "GLUE_COLOR_TANGERINE": "#ff4632",
    "GLUE_COLOR_VIOLET": "#af2896"
  }
  },{}],568:[function(require,module,exports){
  (function (Buffer){
  /* jshint browserify: true */

  /**
   *  Licensed to the Apache Software Foundation (ASF) under one
   *  or more contributor license agreements.  See the NOTICE file
   *  distributed with this work for additional information
   *  regarding copyright ownership.  The ASF licenses this file
   *  to you under the Apache License, Version 2.0 (the
   *  "License"); you may not use this file except in compliance
   *  with the License.  You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   *  distributed under the License is distributed on an "AS IS" BASIS,
   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *  See the License for the specific language governing permissions and
   *  limitations under the License.
   *
   */

  'use strict';

  /**
   * Shim entry point used when `avro` is `require`d from browserify.
   *
   * It doesn't expose any of the filesystem methods and patches a few others.
   *
   */

  var Tap = require('../../lib/utils').Tap,
      schemas = require('../../lib/schemas'),
      deprecated = require('../deprecated/validator');


  function parse(schema, opts) {
    var obj;
    if (typeof schema == 'string') {
      try {
        obj = JSON.parse(schema);
      } catch (err) {
        // Pass. No file reading from the browser.
      }
    }
    if (obj === undefined) {
      obj = schema;
    }
    return schemas.createType(obj, opts);
  }

  // No utf8 and binary functions on browserify's `Buffer`, we must patch in the
  // generic slice and write equivalents.

  Tap.prototype.readString = function () {
    var len = this.readLong();
    var pos = this.pos;
    var buf = this.buf;
    this.pos += len;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.slice(pos, pos + len).toString();
  };

  Tap.prototype.writeString = function (s) {
    var len = Buffer.byteLength(s);
    this.writeLong(len);
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    this.buf.write(s, pos);
  };

  Tap.prototype.writeBinary = function (s, len) {
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    this.buf.write(s, pos, len, 'binary');
  };


  module.exports = {
    parse: parse,
    types: schemas.types,
    Validator: deprecated.Validator,
    ProtocolValidator: deprecated.ProtocolValidator
  };

  }).call(this,require("buffer").Buffer)
  },{"../../lib/schemas":571,"../../lib/utils":572,"../deprecated/validator":570,"buffer":697}],569:[function(require,module,exports){
  /* jshint browserify: true */

  /**
   *  Licensed to the Apache Software Foundation (ASF) under one
   *  or more contributor license agreements.  See the NOTICE file
   *  distributed with this work for additional information
   *  regarding copyright ownership.  The ASF licenses this file
   *  to you under the Apache License, Version 2.0 (the
   *  "License"); you may not use this file except in compliance
   *  with the License.  You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   *  distributed under the License is distributed on an "AS IS" BASIS,
   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *  See the License for the specific language governing permissions and
   *  limitations under the License.
   *
   */

  'use strict';

  /**
   * Shim to disable schema fingerprint computation.
   *
   */

  function createHash() {
    throw new Error('fingerprinting not supported in the browser');
  }


  module.exports = {
    createHash: createHash
  };

  },{}],570:[function(require,module,exports){
  // Licensed to the Apache Software Foundation (ASF) under one or more
  // contributor license agreements.  See the NOTICE file distributed with
  // this work for additional information regarding copyright ownership.
  // The ASF licenses this file to You under the Apache License, Version 2.0
  // (the "License"); you may not use this file except in compliance with
  // the License.  You may obtain a copy of the License at
  //
  //     http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  var _ = require("underscore"),
      util = require('util');

  var WARNING = 'Validator API is deprecated. Please use the type API instead.';
  Validator = util.deprecate(Validator, WARNING);
  ProtocolValidator = util.deprecate(ProtocolValidator, WARNING);

  var AvroSpec = {
    PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
    ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
  };
  AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

  var InvalidSchemaError = function(msg) { return new Error('InvalidSchemaError: ' + msg); };
  var InvalidProtocolError = function(msg) { return new Error('InvalidProtocolError: ' + msg); };
  var ValidationError = function(msg) { return new Error('ValidationError: ' + msg); };
  var ProtocolValidationError = function(msg) { return new Error('ProtocolValidationError: ' + msg); };


  function Record(name, namespace, fields) {
    function validateArgs(name, namespace, fields) {
      if (!_.isString(name)) {
        throw new InvalidSchemaError('Record name must be string');
      }

      if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
        throw new InvalidSchemaError('Record namespace must be string or null');
      }

      if (!_.isArray(fields)) {
        throw new InvalidSchemaError('Record name must be string');
      }
    }

    validateArgs(name, namespace, fields);

    this.name = name;
    this.namespace = namespace;
    this.fields = fields;
  }

  function makeFullyQualifiedTypeName(schema, namespace) {
    var typeName = null;
    if (_.isString(schema)) {
      typeName = schema;
    } else if (_.isObject(schema)) {
      if (_.isString(schema.namespace)) {
        namespace = schema.namespace;
      }
      if (_.isString(schema.name)) {
        typeName = schema.name;
      } else if (_.isString(schema.type)) {
        typeName = schema.type;
      }
    } else {
      throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
    }

    if (!_.isString(typeName)) {
      throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
    }

    if (typeName.indexOf('.') !== -1) {
      return typeName;
    } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
      return typeName;
    } else if (_.isString(namespace)) {
      return namespace + '.' + typeName;
    } else {
      return typeName;
    }
  }

  function Union(typeSchemas, namespace) {
    this.branchNames = function() {
      return _.map(typeSchemas, function(typeSchema) { return makeFullyQualifiedTypeName(typeSchema, namespace); });
    };

    function validateArgs(typeSchemas) {
      if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
        throw new InvalidSchemaError('Union must have at least 1 branch');
      }
    }

    validateArgs(typeSchemas);

    this.typeSchemas = typeSchemas;
    this.namespace = namespace;
  }

  function Enum(symbols) {

    function validateArgs(symbols) {
      if (!_.isArray(symbols)) {
        throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
      }
      if (!_.all(symbols, function(symbol) { return _.isString(symbol); })) {
        throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
      }
    }

    validateArgs(symbols);

    this.symbols = symbols;
  }

  function AvroArray(itemSchema) {

    function validateArgs(itemSchema) {
      if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
        throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
      }
    }

    validateArgs(itemSchema);

    this.itemSchema = itemSchema;
  }

  function Map(valueSchema) {

    function validateArgs(valueSchema) {
      if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
        throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
      }
    }

    validateArgs(valueSchema);

    this.valueSchema = valueSchema;
  }

  function Field(name, schema) {
    function validateArgs(name, schema) {
      if (!_.isString(name)) {
        throw new InvalidSchemaError('Field name must be string');
      }
    }

    this.name = name;
    this.schema = schema;
  }

  function Primitive(type) {
    function validateArgs(type) {
      if (!_.isString(type)) {
        throw new InvalidSchemaError('Primitive type name must be a string');
      }

      if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
        throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
      }
    }

    validateArgs(type);

    this.type = type;
  }

  function Validator(schema, namespace, namedTypes) {
    this.validate = function(obj) {
      return _validate(this.schema, obj);
    };

    var _validate = function(schema, obj) {
      if (schema instanceof Record) {
        return _validateRecord(schema, obj);
      } else if (schema instanceof Union) {
        return _validateUnion(schema, obj);
      } else if (schema instanceof Enum) {
        return _validateEnum(schema, obj);
      } else if (schema instanceof AvroArray) {
        return _validateArray(schema, obj);
      } else if (schema instanceof Map) {
        return _validateMap(schema, obj);
      } else if (schema instanceof Primitive) {
        return _validatePrimitive(schema, obj);
      } else {
        throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
      }
    };

    var _validateRecord = function(schema, obj) {
      if (!_.isObject(obj) || _.isArray(obj)) {
        throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
      }

      var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
      var objFieldNames = _.keys(obj).sort();
      if (!_.isEqual(schemaFieldNames, objFieldNames)) {
        throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
      }

      return _.all(schema.fields, function(field) {
        return _validate(field.schema, obj[field.name]);
      });
    };

    var _validateUnion = function(schema, obj) {
      if (_.isObject(obj)) {
        if (_.isArray(obj)) {
          throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
        } else if (_.size(obj) !== 1) {
          throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
        } else {
          var unionBranch = _.keys(obj)[0];
          if (unionBranch === "") {
            throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
          }
          if (_.contains(schema.branchNames(), unionBranch)) {
            return true;
          } else {
            throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
          }
        }
      } else if (_.isNull(obj)) {
        if (_.contains(schema.branchNames(), 'null')) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
        }
      } else {
        throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
      }
    };

    var _validateEnum = function(schema, obj) {
      if (_.isString(obj)) {
        if (_.contains(schema.symbols, obj)) {
          return true;
        } else {
          throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
        }
      } else {
        throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
      }
    };

    var _validateArray = function(schema, obj) {
      if (_.isArray(obj)) {
        return _.all(obj, function(member) { return _validate(schema.itemSchema, member); });
      } else {
        throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
      }
    };

    var _validateMap = function(schema, obj) {
      if (_.isObject(obj) && !_.isArray(obj)) {
        return _.all(obj, function(value) { return _validate(schema.valueSchema, value); });
      } else if (_.isArray(obj)) {
        throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
      } else {
        throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
      }
    };

    var _validatePrimitive = function(schema, obj) {
      switch (schema.type) {
        case 'null':
          if (_.isNull(obj) || _.isUndefined(obj)) {
            return true;
          } else {
            throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
          }
          break;
        case 'boolean':
          if (_.isBoolean(obj)) {
            return true;
          } else {
            throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
          }
          break;
        case 'int':
          if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
            return true;
          } else {
            throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
          }
          break;
        case 'long':
          if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
            return true;
          } else {
            throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
          }
          break;
        case 'float':
          if (_.isNumber(obj)) { // TODO: handle NaN?
            return true;
          } else {
            throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
          }
          break;
        case 'double':
          if (_.isNumber(obj)) { // TODO: handle NaN?
            return true;
          } else {
            throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
          }
          break;
        case 'bytes':
          throw new InvalidSchemaError('not yet implemented: ' + schema.type);
        case 'string':
          if (_.isString(obj)) { // TODO: handle NaN?
            return true;
          } else {
            throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
          }
          break;
        default:
          throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
      }
    };

    // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
    // are probably buggy.
    var _namedTypes = namedTypes || {};
    var _saveNamedType = function(fullyQualifiedTypeName, schema) {
      if (_.has(_namedTypes, fullyQualifiedTypeName)) {
        if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
          throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
        }
      } else {
        _namedTypes[fullyQualifiedTypeName] = schema;
      }
    };

    var _lookupTypeByFullyQualifiedName = function(fullyQualifiedTypeName) {
      if (_.has(_namedTypes, fullyQualifiedTypeName)) {
        return _namedTypes[fullyQualifiedTypeName];
      } else {
        return null;
      }
    };

    var _parseNamedType = function(schema, namespace) {
      if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
        return new Primitive(schema);
      } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
        return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
      } else {
        throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
      }
    };

    var _parseSchema = function(schema, parentSchema, namespace) {
      if (_.isNull(schema) || _.isUndefined(schema)) {
        throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
      } else if (_.isString(schema)) {
        return _parseNamedType(schema, namespace);
      } else if (_.isObject(schema) && !_.isArray(schema)) {
        if (schema.type === 'record') {
          var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function(field) {
            return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
          }));
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
          return newRecord;
        } else if (schema.type === 'enum') {
          if (_.has(schema, 'symbols')) {
            var newEnum = new Enum(schema.symbols);
            _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
            return newEnum;
          } else {
            throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
          }
        } else if (schema.type === 'array') {
          if (_.has(schema, 'items')) {
            return new AvroArray(_parseSchema(schema.items, schema, namespace));
          } else {
            throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
          }
        } else if (schema.type === 'map') {
          if (_.has(schema, 'values')) {
            return new Map(_parseSchema(schema.values, schema, namespace));
          } else {
            throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
          }
        } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
          return _parseNamedType(schema.type, namespace);
        } else {
          throw new InvalidSchemaError('not yet implemented: ' + schema.type);
        }
      } else if (_.isArray(schema)) {
        if (_.isEmpty(schema)) {
          throw new InvalidSchemaError('unions must have at least 1 branch');
        }
        var branchTypes = _.map(schema, function(branchType) { return _parseSchema(branchType, schema, namespace); });
        return new Union(branchTypes, namespace);
      } else {
        throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema));
      }
    };

    this.rawSchema = schema;
    this.schema = _parseSchema(schema, null, namespace);
  }

  Validator.validate = function(schema, obj) {
    return (new Validator(schema)).validate(obj);
  }

  function ProtocolValidator(protocol) {
    this.validate = function(typeName, obj) {
      var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
      if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
        throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
      }
      return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
    };

    var _typeSchemaValidators = {};
    var _initSchemaValidators = function(protocol) {
      var namedTypes = {};
      if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
        throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
      }
      if (_.isArray(protocol.types)) {
        _.each(protocol.types, function(typeSchema) {
          var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
          var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
          _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
        });
      }
    };

    _initSchemaValidators(protocol);
  }

  ProtocolValidator.validate = function(protocol, typeName, obj) {
    return (new ProtocolValidator(protocol)).validate(typeName, obj);
  };

  if (typeof exports !== 'undefined') {
    exports['Validator'] = Validator;
    exports['ProtocolValidator'] = ProtocolValidator;
  }

  },{"underscore":1299,"util":1302}],571:[function(require,module,exports){
  (function (Buffer){
  /* jshint node: true */

  /**
   *  Licensed to the Apache Software Foundation (ASF) under one
   *  or more contributor license agreements.  See the NOTICE file
   *  distributed with this work for additional information
   *  regarding copyright ownership.  The ASF licenses this file
   *  to you under the Apache License, Version 2.0 (the
   *  "License"); you may not use this file except in compliance
   *  with the License.  You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   *  distributed under the License is distributed on an "AS IS" BASIS,
   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *  See the License for the specific language governing permissions and
   *  limitations under the License.
   *
   */

  'use strict';

  var utils = require('./utils'),
      buffer = require('buffer'), // For `SlowBuffer`.
      util = require('util');

  // Convenience imports.
  var Tap = utils.Tap;
  var f = util.format;

  // All Avro types.
  var TYPES = {
    'array': ArrayType,
    'boolean': BooleanType,
    'bytes': BytesType,
    'double': DoubleType,
    'enum': EnumType,
    'error': RecordType,
    'fixed': FixedType,
    'float': FloatType,
    'int': IntType,
    'long': LongType,
    'map': MapType,
    'null': NullType,
    'record': RecordType,
    'request': RecordType,
    'string': StringType,
    'union': UnionType
  };

  // Valid (field, type, and symbol) name regex.
  var NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;

  // Random generator.
  var RANDOM = new utils.Lcg();

  // Encoding tap (shared for performance).
  var TAP = new Tap(new buffer.SlowBuffer(1024));

  // Path prefix for validity checks (shared for performance).
  var PATH = [];

  // Currently active logical type, used for name redirection.
  var LOGICAL_TYPE = null;


  /**
   * Schema parsing entry point.
   *
   * It isn't exposed directly but called from `parse` inside `index.js` (node)
   * or `avro.js` (browserify) which each add convenience functionality.
   *
   */
  function createType(attrs, opts) {
    if (attrs instanceof Type) {
      return attrs;
    }

    opts = getOpts(attrs, opts);

    var type;
    if (typeof attrs == 'string') { // Type reference.
      if (opts.namespace && !~attrs.indexOf('.') && !isPrimitive(attrs)) {
        attrs = opts.namespace + '.' + attrs;
      }
      type = opts.registry[attrs];
      if (type) {
        // Type was already defined, return it.
        return type;
      }
      if (isPrimitive(attrs)) {
        // Reference to a primitive type. These are also defined names by default
        // so we create the appropriate type and it to the registry for future
        // reference.
        return opts.registry[attrs] = createType({type: attrs}, opts);
      }
      throw new Error(f('undefined type name: %s', attrs));
    }

    if (opts.typeHook && (type = opts.typeHook(attrs, opts))) {
      if (!(type instanceof Type)) {
        throw new Error(f('invalid typehook return value: %j', type));
      }
      return type;
    }

    if (attrs.logicalType && !LOGICAL_TYPE) {
      var DerivedType = opts.logicalTypes[attrs.logicalType];
      if (DerivedType) {
        var registry = {};
        Object.keys(opts.registry).forEach(function (key) {
          registry[key] = opts.registry[key];
        });
        try {
          return new DerivedType(attrs, opts);
        } catch (err) {
          if (opts.assertLogicalTypes) {
            throw err;
          }
          LOGICAL_TYPE = null;
          opts.registry = registry; // In case any names were registered.
        }
      }
    }

    if (attrs instanceof Array) { // Union.
      type = new UnionType(attrs, opts);
    } else { // New type definition.
      type = (function (typeName) {
        var Type = TYPES[typeName];
        if (Type === undefined) {
          throw new Error(f('unknown type: %j', typeName));
        }
        return new Type(attrs, opts);
      })(attrs.type);
    }
    return type;
  }

  /**
   * "Abstract" base Avro type class.
   *
   * This class' constructor will register any named types to support
   * recursive schemas.
   *
   * All type values are represented in memory similarly to their JSON
   * representation, except for `bytes` and `fixed` which are represented as
   * `Buffer`s. See individual subclasses for details.
   *
   */
  function Type(registry) {
    var name = this._name;
    var type = LOGICAL_TYPE || this;
    LOGICAL_TYPE = null;

    if (registry === undefined || name === undefined) {
      return;
    }

    var prev = registry[name];
    if (prev !== undefined) {
      throw new Error(f('duplicate type name: %s', name));
    }
    registry[name] = type;
  }

  Type.__reset = function (size) { TAP.buf = new buffer.SlowBuffer(size); };

  Type.prototype.createResolver = function (type, opts) {
    if (!(type instanceof Type)) {
      // More explicit error message than the "incompatible type" thrown
      // otherwise (especially because of the overridden `toJSON` method).
      throw new Error(f('not a type: %j', type));
    }

    if (type instanceof LogicalType && !(this instanceof LogicalType)) {
      // Trying to read a logical type as a built-in: unwrap the logical type.
      return this.createResolver(type._underlyingType, opts);
    }

    opts = opts || {};
    opts.registry = opts.registry || {};

    var resolver, key;
    if (this instanceof RecordType && type instanceof RecordType) {
      key = this._name + ':' + type._name; // ':' is illegal in Avro type names.
      resolver = opts.registry[key];
      if (resolver) {
        return resolver;
      }
    }

    resolver = new Resolver(this);
    if (key) { // Register resolver early for recursive schemas.
      opts.registry[key] = resolver;
    }

    if (type instanceof UnionType) {
      var resolvers = type._types.map(function (t) {
        return this.createResolver(t, opts);
      }, this);
      resolver._read = function (tap) {
        var index = tap.readLong();
        var resolver = resolvers[index];
        if (resolver === undefined) {
          throw new Error(f('invalid union index: %s', index));
        }
        return resolvers[index]._read(tap);
      };
    } else {
      this._updateResolver(resolver, type, opts);
    }

    if (!resolver._read) {
      throw new Error(f('cannot read %s as %s', type, this));
    }
    return resolver;
  };

  Type.prototype.decode = function (buf, pos, resolver) {
    var tap = new Tap(buf);
    tap.pos = pos | 0;
    var val = readValue(this, tap, resolver);
    if (!tap.isValid()) {
      return {value: undefined, offset: -1};
    }
    return {value: val, offset: tap.pos};
  };

  Type.prototype.encode = function (val, buf, pos) {
    var tap = new Tap(buf);
    tap.pos = pos | 0;
    this._write(tap, val);
    if (!tap.isValid()) {
      // Don't throw as there is no way to predict this. We also return the
      // number of missing bytes to ease resizing.
      return buf.length - tap.pos;
    }
    return tap.pos;
  };

  Type.prototype.fromBuffer = function (buf, resolver, noCheck) {
    var tap = new Tap(buf);
    var val = readValue(this, tap, resolver, noCheck);
    if (!tap.isValid()) {
      throw new Error('truncated buffer');
    }
    if (!noCheck && tap.pos < buf.length) {
      throw new Error('trailing data');
    }
    return val;
  };

  Type.prototype.toBuffer = function (val) {
    TAP.pos = 0;
    this._write(TAP, val);
    if (!TAP.isValid()) {
      Type.__reset(2 * TAP.pos);
      TAP.pos = 0;
      this._write(TAP, val);
    }
    var buf = new Buffer(TAP.pos);
    TAP.buf.copy(buf, 0, 0, TAP.pos);
    return buf;
  };

  Type.prototype.fromString = function (str) {
    return this._copy(JSON.parse(str), {coerce: 2});
  };

  Type.prototype.toString = function (val) {
    if (val === undefined) {
      // Consistent behavior with standard `toString` expectations.
      return this.getSchema(true);
    }
    return JSON.stringify(this._copy(val, {coerce: 3}));
  };

  Type.prototype.clone = function (val, opts) {
    if (opts) {
      opts = {
        coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.
        fieldHook: opts.fieldHook,
        wrap: !!opts.wrapUnions | 0 // Wrap first match into union.
      };
    }
    return this._copy(val, opts);
  };

  Type.prototype.isValid = function (val, opts) {
    while (PATH.length) {
      // In case the previous `isValid` call didn't complete successfully (e.g.
      // if an exception was thrown, but then caught in client code), `PATH`
      // might be non-empty, we must manually clear it.
      PATH.pop();
    }
    return this._check(val, opts && opts.errorHook);
  };

  Type.prototype.compareBuffers = function (buf1, buf2) {
    return this._match(new Tap(buf1), new Tap(buf2));
  };

  Type.prototype.getName = function (noRef) {
    return noRef ? getTypeName(this) : this._name;
  };

  Type.prototype.getSchema = function (noDeref) {
    return stringify(this, noDeref);
  };

  Type.prototype.getFingerprint = function (algorithm) {
    return utils.getHash(this.getSchema(), algorithm);
  };

  Type.prototype.inspect = function () {
    if (this instanceof PrimitiveType) {
      return f('<%s>', this.constructor.name);
    } else {
      var obj = JSON.parse(this.getSchema(true)); // Slow, only for debugging.
      if (typeof obj == 'object') {
        obj.type = undefined; // Would be redundant with constructor name.
      }
      return f('<%s %j>', this.constructor.name, obj);
    }
  };

  Type.prototype._check = utils.abstractFunction;
  Type.prototype._copy = utils.abstractFunction;
  Type.prototype._match = utils.abstractFunction;
  Type.prototype._read = utils.abstractFunction;
  Type.prototype._skip = utils.abstractFunction;
  Type.prototype._updateResolver = utils.abstractFunction;
  Type.prototype._write = utils.abstractFunction;
  Type.prototype.compare = utils.abstractFunction;
  Type.prototype.random = utils.abstractFunction;

  // Implementations.

  /**
   * Base primitive Avro type.
   *
   * Most of the primitive types share the same cloning and resolution
   * mechanisms, provided by this class. This class also lets us conveniently
   * check whether a type is a primitive using `instanceof`.
   *
   */
  function PrimitiveType() { Type.call(this); }
  util.inherits(PrimitiveType, Type);
  PrimitiveType.prototype._updateResolver = function (resolver, type) {
    if (type.constructor === this.constructor) {
      resolver._read = this._read;
    }
  };
  PrimitiveType.prototype._copy = function (val) {
    this._check(val, throwInvalidError);
    return val;
  };
  PrimitiveType.prototype.compare = utils.compare;

  /**
   * Nulls.
   *
   */
  function NullType() { PrimitiveType.call(this); }
  util.inherits(NullType, PrimitiveType);
  NullType.prototype._check = function (val, cb) {
    var b = val === null;
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  NullType.prototype._read = function () { return null; };
  NullType.prototype._skip = function () {};
  NullType.prototype._write = function (tap, val) {
    if (val !== null) {
      throwInvalidError(null, val, this);
    }
  };
  NullType.prototype._match = function () { return 0; };
  NullType.prototype.compare = NullType.prototype._match;
  NullType.prototype.random = NullType.prototype._read;
  NullType.prototype.toJSON = function () { return 'null'; };

  /**
   * Booleans.
   *
   */
  function BooleanType() { PrimitiveType.call(this); }
  util.inherits(BooleanType, PrimitiveType);
  BooleanType.prototype._check = function (val, cb) {
    var b = typeof val == 'boolean';
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  BooleanType.prototype._read = function (tap) { return tap.readBoolean(); };
  BooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };
  BooleanType.prototype._write = function (tap, val) {
    if (typeof val != 'boolean') {
      throwInvalidError(null, val, this);
    }
    tap.writeBoolean(val);
  };
  BooleanType.prototype._match = function (tap1, tap2) {
    return tap1.matchBoolean(tap2);
  };
  BooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };
  BooleanType.prototype.toJSON = function () { return 'boolean'; };

  /**
   * Integers.
   *
   */
  function IntType() { PrimitiveType.call(this); }
  util.inherits(IntType, PrimitiveType);
  IntType.prototype._check = function (val, cb) {
    var b = val === (val | 0);
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  IntType.prototype._read = function (tap) { return tap.readInt(); };
  IntType.prototype._skip = function (tap) { tap.skipInt(); };
  IntType.prototype._write = function (tap, val) {
    if (val !== (val | 0)) {
      throwInvalidError(null, val, this);
    }
    tap.writeInt(val);
  };
  IntType.prototype._match = function (tap1, tap2) {
    return tap1.matchInt(tap2);
  };
  IntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };
  IntType.prototype.toJSON = function () { return 'int'; };

  /**
   * Longs.
   *
   * We can't capture all the range unfortunately since JavaScript represents all
   * numbers internally as `double`s, so the default implementation plays safe
   * and throws rather than potentially silently change the data. See `using` or
   * `AbstractLongType` below for a way to implement a custom long type.
   *
   */
  function LongType() { PrimitiveType.call(this); }
  util.inherits(LongType, PrimitiveType);
  LongType.prototype._check = function (val, cb) {
    var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  LongType.prototype._read = function (tap) {
    var n = tap.readLong();
    if (!isSafeLong(n)) {
      throw new Error('potential precision loss');
    }
    return n;
  };
  LongType.prototype._skip = function (tap) { tap.skipLong(); };
  LongType.prototype._write = function (tap, val) {
    if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {
      throwInvalidError(null, val, this);
    }
    tap.writeLong(val);
  };
  LongType.prototype._match = function (tap1, tap2) {
    return tap1.matchLong(tap2);
  };
  LongType.prototype._updateResolver = function (resolver, type) {
    if (type instanceof LongType || type instanceof IntType) {
      resolver._read = type._read;
    }
  };
  LongType.prototype.random = function () { return RANDOM.nextInt(); };
  LongType.prototype.toJSON = function () { return 'long'; };
  LongType.using = function (methods, noUnpack) {
    methods = methods || {}; // Will give a more helpful error message.
    // We map some of the methods to a different name to be able to intercept
    // their input and output (otherwise we wouldn't be able to perform any
    // unpacking logic, and the type wouldn't work when nested).
    var mapping = {
      toBuffer: '_toBuffer',
      fromBuffer: '_fromBuffer',
      fromJSON: '_fromJSON',
      toJSON: '_toJSON',
      isValid: '_isValid',
      compare: 'compare'
    };
    var type = new AbstractLongType(noUnpack);
    Object.keys(mapping).forEach(function (name) {
      if (methods[name] === undefined) {
        throw new Error(f('missing method implementation: %s', name));
      }
      type[mapping[name]] = methods[name];
    });
    return type;
  };

  /**
   * Floats.
   *
   */
  function FloatType() { PrimitiveType.call(this); }
  util.inherits(FloatType, PrimitiveType);
  FloatType.prototype._check = function (val, cb) {
    var b = typeof val == 'number';
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  FloatType.prototype._read = function (tap) { return tap.readFloat(); };
  FloatType.prototype._skip = function (tap) { tap.skipFloat(); };
  FloatType.prototype._write = function (tap, val) {
    if (typeof val != 'number') {
      throwInvalidError(null, val, this);
    }
    tap.writeFloat(val);
  };
  FloatType.prototype._match = function (tap1, tap2) {
    return tap1.matchFloat(tap2);
  };
  FloatType.prototype._updateResolver = function (resolver, type) {
    if (
      type instanceof FloatType ||
      type instanceof LongType ||
      type instanceof IntType
    ) {
      resolver._read = type._read;
    }
  };
  FloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };
  FloatType.prototype.toJSON = function () { return 'float'; };

  /**
   * Doubles.
   *
   */
  function DoubleType() { PrimitiveType.call(this); }
  util.inherits(DoubleType, PrimitiveType);
  DoubleType.prototype._check = function (val, cb) {
    var b = typeof val == 'number';
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  DoubleType.prototype._read = function (tap) { return tap.readDouble(); };
  DoubleType.prototype._skip = function (tap) { tap.skipDouble(); };
  DoubleType.prototype._write = function (tap, val) {
    if (typeof val != 'number') {
      throwInvalidError(null, val, this);
    }
    tap.writeDouble(val);
  };
  DoubleType.prototype._match = function (tap1, tap2) {
    return tap1.matchDouble(tap2);
  };
  DoubleType.prototype._updateResolver = function (resolver, type) {
    if (
      type instanceof DoubleType ||
      type instanceof FloatType ||
      type instanceof LongType ||
      type instanceof IntType
    ) {
      resolver._read = type._read;
    }
  };
  DoubleType.prototype.random = function () { return RANDOM.nextFloat(); };
  DoubleType.prototype.toJSON = function () { return 'double'; };

  /**
   * Strings.
   *
   */
  function StringType() { PrimitiveType.call(this); }
  util.inherits(StringType, PrimitiveType);
  StringType.prototype._check = function (val, cb) {
    var b = typeof val == 'string';
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  StringType.prototype._read = function (tap) { return tap.readString(); };
  StringType.prototype._skip = function (tap) { tap.skipString(); };
  StringType.prototype._write = function (tap, val) {
    if (typeof val != 'string') {
      throwInvalidError(null, val, this);
    }
    tap.writeString(val);
  };
  StringType.prototype._match = function (tap1, tap2) {
    return tap1.matchString(tap2);
  };
  StringType.prototype._updateResolver = function (resolver, type) {
    if (type instanceof StringType || type instanceof BytesType) {
      resolver._read = this._read;
    }
  };
  StringType.prototype.random = function () {
    return RANDOM.nextString(RANDOM.nextInt(32));
  };
  StringType.prototype.toJSON = function () { return 'string'; };

  /**
   * Bytes.
   *
   * These are represented in memory as `Buffer`s rather than binary-encoded
   * strings. This is more efficient (when decoding/encoding from bytes, the
   * common use-case), idiomatic, and convenient.
   *
   * Note the coercion in `_copy`.
   *
   */
  function BytesType() { PrimitiveType.call(this); }
  util.inherits(BytesType, PrimitiveType);
  BytesType.prototype._check = function (val, cb) {
    var b = Buffer.isBuffer(val);
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };
  BytesType.prototype._read = function (tap) { return tap.readBytes(); };
  BytesType.prototype._skip = function (tap) { tap.skipBytes(); };
  BytesType.prototype._write = function (tap, val) {
    if (!Buffer.isBuffer(val)) {
      throwInvalidError(null, val, this);
    }
    tap.writeBytes(val);
  };
  BytesType.prototype._match = function (tap1, tap2) {
    return tap1.matchBytes(tap2);
  };
  BytesType.prototype._updateResolver = StringType.prototype._updateResolver;
  BytesType.prototype._copy = function (obj, opts) {
    var buf;
    switch ((opts && opts.coerce) | 0) {
      case 3: // Coerce buffers to strings.
        this._check(obj, throwInvalidError);
        return obj.toString('binary');
      case 2: // Coerce strings to buffers.
        if (typeof obj != 'string') {
          throw new Error(f('cannot coerce to buffer: %j', obj));
        }
        buf = new Buffer(obj, 'binary');
        this._check(buf, throwInvalidError);
        return buf;
      case 1: // Coerce buffer JSON representation to buffers.
        if (!obj || obj.type !== 'Buffer' || !(obj.data instanceof Array)) {
          throw new Error(f('cannot coerce to buffer: %j', obj));
        }
        buf = new Buffer(obj.data);
        this._check(buf, throwInvalidError);
        return buf;
      default: // Copy buffer.
        this._check(obj, throwInvalidError);
        return new Buffer(obj);
    }
  };
  BytesType.prototype.compare = Buffer.compare;
  BytesType.prototype.random = function () {
    return RANDOM.nextBuffer(RANDOM.nextInt(32));
  };
  BytesType.prototype.toJSON = function () { return 'bytes'; };

  /**
   * Avro unions.
   *
   * Unions are represented in memory similarly to their JSON representation
   * (i.e. inside an object with single key the name of the contained type).
   *
   * This is not ideal, but is the most efficient way to unambiguously support
   * all unions. Here are a few reasons why the wrapping object is necessary:
   *
   * + Unions with multiple number types would have undefined behavior, unless
   *   numbers are wrapped (either everywhere, leading to large performance and
   *   convenience costs; or only when necessary inside unions, making it hard to
   *   understand when numbers are wrapped or not).
   * + Fixed types would have to be wrapped to be distinguished from bytes.
   * + Using record's constructor names would work (after a slight change to use
   *   the fully qualified name), but would mean that generic objects could no
   *   longer be valid records (making it inconvenient to do simple things like
   *   creating new records).
   *
   * Lore: In the past (until d304cab), there used to be an "unwrapped union
   * type" which directly exposed its values, without the wrapping object
   * (similarly to Avro's python implementation). It was removed to keep all
   * representations consistent and make this library simpler to understand
   * (conversions, e.g. for schema evolution, between representations were
   * particularly confusing). Encoding was also much slower (worst case
   * complexity linear in the number of types in the union).
   *
   */
  function UnionType(attrs, opts) {
    if (!(attrs instanceof Array)) {
      throw new Error(f('non-array union schema: %j', attrs));
    }
    if (!attrs.length) {
      throw new Error('empty union');
    }

    opts = getOpts(attrs, opts);
    Type.call(this);
    this._types = attrs.map(function (obj) { return createType(obj, opts); });

    this._indices = {};
    this._types.forEach(function (type, i) {
      if (type instanceof UnionType) {
        throw new Error('unions cannot be directly nested');
      }
      var name = type._name || getTypeName(type);
      if (this._indices[name] !== undefined) {
        throw new Error(f('duplicate union name: %j', name));
      }
      this._indices[name] = i;
    }, this);

    this._constructors = this._types.map(function (type) {
      // jshint -W054
      var name = type._name || getTypeName(type);
      if (name === 'null') {
        return null;
      }
      var body;
      if (~name.indexOf('.')) { // Qualified name.
        body = 'this[\'' + name + '\'] = val;';
      } else {
        body = 'this.' + name + ' = val;';
      }
      return new Function('val', body);
    });
  }
  util.inherits(UnionType, Type);

  UnionType.prototype._check = function (val, cb) {
    var b = false;
    if (val === null) {
      // Shortcut type lookup in this case.
      b = this._indices['null'] !== undefined;
    } else if (typeof val == 'object') {
      var keys = Object.keys(val);
      if (keys.length === 1) {
        // We require a single key here to ensure that writes are correct and
        // efficient as soon as a record passes this check.
        var name = keys[0];
        var index = this._indices[name];
        if (index !== undefined) {
          PATH.push(name);
          b = this._types[index]._check(val[name], cb);
          PATH.pop();
          return b;
        }
      }
    }
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };

  UnionType.prototype._read = function (tap) {
    var index = tap.readLong();
    var Class = this._constructors[index];
    if (Class) {
      return new Class(this._types[index]._read(tap));
    } else if (Class === null) {
      return null;
    } else {
      throw new Error(f('invalid union index: %s', index));
    }
  };

  UnionType.prototype._skip = function (tap) {
    this._types[tap.readLong()]._skip(tap);
  };

  UnionType.prototype._write = function (tap, val) {
    var index, keys, name;
    if (val === null) {
      index = this._indices['null'];
      if (index === undefined) {
        throwInvalidError(null, val, this);
      }
      tap.writeLong(index);
    } else {
      keys = Object.keys(val);
      if (keys.length === 1) {
        name = keys[0];
        index = this._indices[name];
      }
      if (index === undefined) {
        throwInvalidError(null, val, this);
      }
      tap.writeLong(index);
      this._types[index]._write(tap, val[name]);
    }
  };

  UnionType.prototype._match = function (tap1, tap2) {
    var n1 = tap1.readLong();
    var n2 = tap2.readLong();
    if (n1 === n2) {
      return this._types[n1]._match(tap1, tap2);
    } else {
      return n1 < n2 ? -1 : 1;
    }
  };

  UnionType.prototype._updateResolver = function (resolver, type, opts) {
    // jshint -W083
    // (The loop exits after the first function is created.)
    var i, l, typeResolver, Class;
    for (i = 0, l = this._types.length; i < l; i++) {
      try {
        typeResolver = this._types[i].createResolver(type, opts);
      } catch (err) {
        continue;
      }
      Class = this._constructors[i];
      if (Class) {
        resolver._read = function (tap) {
          return new Class(typeResolver._read(tap));
        };
      } else {
        resolver._read = function () { return null; };
      }
      return;
    }
  };

  UnionType.prototype._copy = function (val, opts) {
    var wrap = opts && opts.wrap | 0;
    if (wrap === 2) {
      // Promote into first type (used for schema defaults).
      if (val === null && this._constructors[0] === null) {
        return null;
      }
      return new this._constructors[0](this._types[0]._copy(val, opts));
    }
    if (val === null && this._indices['null'] !== undefined) {
      return null;
    }

    var i, l, obj;
    if (typeof val == 'object') {
      var keys = Object.keys(val);
      if (keys.length === 1) {
        var name = keys[0];
        i = this._indices[name];
        if (i === undefined) {
          // We are a bit more flexible than in `_check` here since we have
          // to deal with other serializers being less strict, so we fall
          // back to looking up unqualified names.
          var j, type;
          for (j = 0, l = this._types.length; j < l; j++) {
            type = this._types[j];
            if (type._name && name === unqualify(type._name)) {
              i = j;
              break;
            }
          }
        }
        if (i !== undefined) {
          obj = this._types[i]._copy(val[name], opts);
        }
      }
    }
    if (wrap === 1 && obj === undefined) {
      // Try promoting into first match (convenience, slow).
      i = 0;
      l = this._types.length;
      while (i < l && obj === undefined) {
        try {
          obj = this._types[i]._copy(val, opts);
        } catch (err) {
          i++;
        }
      }
    }
    if (obj !== undefined) {
      return new this._constructors[i](obj);
    }
    throwInvalidError(null, val, this);
  };

  UnionType.prototype.compare = function (val1, val2) {
    var name1 = val1 === null ? 'null' : Object.keys(val1)[0];
    var name2 = val2 === null ? 'null' : Object.keys(val2)[0];
    var index = this._indices[name1];
    if (name1 === name2) {
      return name1 === 'null' ?
        0 :
        this._types[index].compare(val1[name1], val2[name1]);
    } else {
      return utils.compare(index, this._indices[name2]);
    }
  };

  UnionType.prototype.getTypes = function () { return this._types.slice(); };

  UnionType.prototype.random = function () {
    var index = RANDOM.nextInt(this._types.length);
    var Class = this._constructors[index];
    if (!Class) {
      return null;
    }
    return new Class(this._types[index].random());
  };

  UnionType.prototype.toJSON = function () { return this._types; };

  /**
   * Avro enum type.
   *
   * Represented as strings (with allowed values from the set of symbols). Using
   * integers would be a reasonable option, but the performance boost is arguably
   * offset by the legibility cost and the extra deviation from the JSON encoding
   * convention.
   *
   * An integer representation can still be used (e.g. for compatibility with
   * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via
   * `parse`'s registry).
   *
   */
  function EnumType(attrs, opts) {
    if (!(attrs.symbols instanceof Array) || !attrs.symbols.length) {
      throw new Error(f('invalid %j enum symbols: %j', attrs.name, attrs));
    }

    opts = getOpts(attrs, opts);
    var resolutions = resolveNames(attrs, opts.namespace);
    this._name = resolutions.name;
    this._symbols = attrs.symbols;
    this._aliases = resolutions.aliases;
    Type.call(this, opts.registry);

    this._indices = {};
    this._symbols.forEach(function (symbol, i) {
      if (!NAME_PATTERN.test(symbol)) {
        throw new Error(f('invalid %s symbol: %j', this, symbol));
      }
      if (this._indices[symbol] !== undefined) {
        throw new Error(f('duplicate %s symbol: %j', this, symbol));
      }
      this._indices[symbol] = i;
    }, this);
  }
  util.inherits(EnumType, Type);

  EnumType.prototype._check = function (val, cb) {
    var b = this._indices[val] !== undefined;
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };

  EnumType.prototype._read = function (tap) {
    var index = tap.readLong();
    var symbol = this._symbols[index];
    if (symbol === undefined) {
      throw new Error(f('invalid %s enum index: %s', this._name, index));
    }
    return symbol;
  };

  EnumType.prototype._skip = function (tap) { tap.skipLong(); };

  EnumType.prototype._write = function (tap, val) {
    var index = this._indices[val];
    if (index === undefined) {
      throwInvalidError(null, val, this);
    }
    tap.writeLong(index);
  };

  EnumType.prototype._match = function (tap1, tap2) {
    return tap1.matchLong(tap2);
  };

  EnumType.prototype.compare = function (val1, val2) {
    return utils.compare(this._indices[val1], this._indices[val2]);
  };

  EnumType.prototype._updateResolver = function (resolver, type) {
    var symbols = this._symbols;
    if (
      type instanceof EnumType &&
      ~getAliases(this).indexOf(type._name) &&
      type._symbols.every(function (s) { return ~symbols.indexOf(s); })
    ) {
      resolver._symbols = type._symbols;
      resolver._read = type._read;
    }
  };

  EnumType.prototype._copy = function (val) {
    this._check(val, throwInvalidError);
    return val;
  };

  EnumType.prototype.getAliases = function () { return this._aliases; };

  EnumType.prototype.getSymbols = function () { return this._symbols.slice(); };

  EnumType.prototype.random = function () {
    return RANDOM.choice(this._symbols);
  };

  EnumType.prototype.toJSON = function () {
    return {name: this._name, type: 'enum', symbols: this._symbols};
  };

  /**
   * Avro fixed type.
   *
   * Represented simply as a `Buffer`.
   *
   */
  function FixedType(attrs, opts) {
    if (attrs.size !== (attrs.size | 0) || attrs.size < 1) {
      throw new Error(f('invalid %j fixed size: %j', attrs.name, attrs.size));
    }

    opts = getOpts(attrs, opts);
    var resolutions = resolveNames(attrs, opts.namespace);
    this._name = resolutions.name;
    this._size = attrs.size | 0;
    this._aliases = resolutions.aliases;
    Type.call(this, opts.registry);
  }
  util.inherits(FixedType, Type);

  FixedType.prototype._check = function (val, cb) {
    var b = Buffer.isBuffer(val) && val.length === this._size;
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };

  FixedType.prototype._read = function (tap) {
    return tap.readFixed(this._size);
  };

  FixedType.prototype._skip = function (tap) {
    tap.skipFixed(this._size);
  };

  FixedType.prototype._write = function (tap, val) {
    if (!Buffer.isBuffer(val) || val.length !== this._size) {
      throwInvalidError(null, val, this);
    }
    tap.writeFixed(val, this._size);
  };

  FixedType.prototype._match = function (tap1, tap2) {
    return tap1.matchFixed(tap2, this._size);
  };

  FixedType.prototype.compare = Buffer.compare;

  FixedType.prototype._updateResolver = function (resolver, type) {
    if (
      type instanceof FixedType &&
      this._size === type._size &&
      ~getAliases(this).indexOf(type._name)
    ) {
      resolver._size = this._size;
      resolver._read = this._read;
    }
  };

  FixedType.prototype._copy = BytesType.prototype._copy;

  FixedType.prototype.getAliases = function () { return this._aliases; };

  FixedType.prototype.getSize = function () { return this._size; };

  FixedType.prototype.random = function () {
    return RANDOM.nextBuffer(this._size);
  };

  FixedType.prototype.toJSON = function () {
    return {name: this._name, type: 'fixed', size: this._size};
  };

  /**
   * Avro map.
   *
   * Represented as vanilla objects.
   *
   */
  function MapType(attrs, opts) {
    if (!attrs.values) {
      throw new Error(f('missing map values: %j', attrs));
    }

    opts = getOpts(attrs, opts);
    Type.call(this);
    this._values = createType(attrs.values, opts);
  }
  util.inherits(MapType, Type);

  MapType.prototype.getValuesType = function () { return this._values; };

  MapType.prototype._check = function (val, cb) {
    if (!val || typeof val != 'object' || val instanceof Array) {
      if (cb) {
        cb(PATH.slice(), val, this);
      }
      return false;
    }

    var keys = Object.keys(val);
    var b = true;
    var i, l, j, key;
    if (cb) {
      // Slow path.
      j = PATH.length;
      PATH.push('');
      for (i = 0, l = keys.length; i < l; i++) {
        key = PATH[j] = keys[i];
        if (!this._values._check(val[key], cb)) {
          b = false;
        }
      }
      PATH.pop();
    } else {
      for (i = 0, l = keys.length; i < l; i++) {
        if (!this._values._check(val[keys[i]], cb)) {
          return false;
        }
      }
    }
    return b;
  };

  MapType.prototype._read = function (tap) {
    var values = this._values;
    var val = {};
    var n;
    while ((n = readArraySize(tap))) {
      while (n--) {
        var key = tap.readString();
        val[key] = values._read(tap);
      }
    }
    return val;
  };

  MapType.prototype._skip = function (tap) {
    var values = this._values;
    var len, n;
    while ((n = tap.readLong())) {
      if (n < 0) {
        len = tap.readLong();
        tap.pos += len;
      } else {
        while (n--) {
          tap.skipString();
          values._skip(tap);
        }
      }
    }
  };

  MapType.prototype._write = function (tap, val) {
    if (!val || typeof val != 'object' || val instanceof Array) {
      throwInvalidError(null, val, this);
    }

    var values = this._values;
    var keys = Object.keys(val);
    var n = keys.length;
    var i, key;
    if (n) {
      tap.writeLong(n);
      for (i = 0; i < n; i++) {
        key = keys[i];
        tap.writeString(key);
        values._write(tap, val[key]);
      }
    }
    tap.writeLong(0);
  };

  MapType.prototype._match = function () {
    throw new Error('maps cannot be compared');
  };

  MapType.prototype._updateResolver = function (resolver, type, opts) {
    if (type instanceof MapType) {
      resolver._values = this._values.createResolver(type._values, opts);
      resolver._read = this._read;
    }
  };

  MapType.prototype._copy = function (val, opts) {
    if (val && typeof val == 'object' && !(val instanceof Array)) {
      var values = this._values;
      var keys = Object.keys(val);
      var i, l, key;
      var copy = {};
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        copy[key] = values._copy(val[key], opts);
      }
      return copy;
    }
    throwInvalidError(null, val, this);
  };

  MapType.prototype.compare = MapType.prototype._match;

  MapType.prototype.random = function () {
    var val = {};
    var i, l;
    for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
      val[RANDOM.nextString(RANDOM.nextInt(20))] = this._values.random();
    }
    return val;
  };

  MapType.prototype.toJSON = function () {
    return {type: 'map', values: this._values};
  };

  /**
   * Avro array.
   *
   * Represented as vanilla arrays.
   *
   */
  function ArrayType(attrs, opts) {
    if (!attrs.items) {
      throw new Error(f('missing array items: %j', attrs));
    }

    opts = getOpts(attrs, opts);

    this._items = createType(attrs.items, opts);
    Type.call(this);
  }
  util.inherits(ArrayType, Type);

  ArrayType.prototype._check = function (val, cb) {
    if (!(val instanceof Array)) {
      if (cb) {
        cb(PATH.slice(), val, this);
      }
      return false;
    }

    var b = true;
    var i, l, j;
    if (cb) {
      // Slow path.
      j = PATH.length;
      PATH.push('');
      for (i = 0, l = val.length; i < l; i++) {
        PATH[j] = '' + i;
        if (!this._items._check(val[i], cb)) {
          b = false;
        }
      }
      PATH.pop();
    } else {
      for (i = 0, l = val.length; i < l; i++) {
        if (!this._items._check(val[i], cb)) {
          return false;
        }
      }
    }
    return b;
  };

  ArrayType.prototype._read = function (tap) {
    var items = this._items;
    var val = [];
    var n;
    while ((n = tap.readLong())) {
      if (n < 0) {
        n = -n;
        tap.skipLong(); // Skip size.
      }
      while (n--) {
        val.push(items._read(tap));
      }
    }
    return val;
  };

  ArrayType.prototype._skip = function (tap) {
    var len, n;
    while ((n = tap.readLong())) {
      if (n < 0) {
        len = tap.readLong();
        tap.pos += len;
      } else {
        while (n--) {
          this._items._skip(tap);
        }
      }
    }
  };

  ArrayType.prototype._write = function (tap, val) {
    if (!(val instanceof Array)) {
      throwInvalidError(null, val, this);
    }

    var n = val.length;
    var i;
    if (n) {
      tap.writeLong(n);
      for (i = 0; i < n; i++) {
        this._items._write(tap, val[i]);
      }
    }
    tap.writeLong(0);
  };

  ArrayType.prototype._match = function (tap1, tap2) {
    var n1 = tap1.readLong();
    var n2 = tap2.readLong();
    var f;
    while (n1 && n2) {
      f = this._items._match(tap1, tap2);
      if (f) {
        return f;
      }
      if (!--n1) {
        n1 = readArraySize(tap1);
      }
      if (!--n2) {
        n2 = readArraySize(tap2);
      }
    }
    return utils.compare(n1, n2);
  };

  ArrayType.prototype._updateResolver = function (resolver, type, opts) {
    if (type instanceof ArrayType) {
      resolver._items = this._items.createResolver(type._items, opts);
      resolver._read = this._read;
    }
  };

  ArrayType.prototype._copy = function (val, opts) {
    if (!(val instanceof Array)) {
      throwInvalidError(null, val, this);
    }
    var items = [];
    var i, l;
    for (i = 0, l = val.length; i < l; i++) {
      items.push(this._items._copy(val[i], opts));
    }
    return items;
  };

  ArrayType.prototype.compare = function (val1, val2) {
    var n1 = val1.length;
    var n2 = val2.length;
    var i, l, f;
    for (i = 0, l = Math.min(n1, n2); i < l; i++) {
      if ((f = this._items.compare(val1[i], val2[i]))) {
        return f;
      }
    }
    return utils.compare(n1, n2);
  };

  ArrayType.prototype.getItemsType = function () { return this._items; };

  ArrayType.prototype.random = function () {
    var arr = [];
    var i, l;
    for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {
      arr.push(this._items.random());
    }
    return arr;
  };

  ArrayType.prototype.toJSON = function () {
    return {type: 'array', items: this._items};
  };

  /**
   * Avro record.
   *
   * Values are represented as instances of a programmatically generated
   * constructor (similar to a "specific record"), available via the
   * `getRecordConstructor` method. This "specific record class" gives
   * significant speedups over using generics objects.
   *
   * Note that vanilla objects are still accepted as valid as long as their
   * fields match (this makes it much more convenient to do simple things like
   * update nested records).
   *
   */
  function RecordType(attrs, opts) {
    opts = getOpts(attrs, opts);

    var resolutions = resolveNames(attrs, opts.namespace);
    this._name = resolutions.name;
    this._aliases = resolutions.aliases;
    this._type = attrs.type;
    // Requests shouldn't be registered since their name is only a placeholder.
    Type.call(this, this._type === 'request' ? undefined : opts.registry);

    if (!(attrs.fields instanceof Array)) {
      throw new Error(f('non-array %s fields', this._name));
    }
    this._fields = attrs.fields.map(function (f) {
      return new Field(f, opts);
    });
    if (utils.hasDuplicates(attrs.fields, function (f) { return f.name; })) {
      throw new Error(f('duplicate %s field name', this._name));
    }

    var isError = attrs.type === 'error';
    this._constructor = this._createConstructor(isError);
    this._read = this._createReader();
    this._skip = this._createSkipper();
    this._write = this._createWriter();
    this._check = this._createChecker();
  }
  util.inherits(RecordType, Type);

  RecordType.prototype._createConstructor = function (isError) {
    // jshint -W054
    var outerArgs = [];
    var innerArgs = [];
    var ds = []; // Defaults.
    var innerBody = isError ? '  Error.call(this);\n' : '';
    // Not calling `Error.captureStackTrace` because this wouldn't be compatible
    // with browsers other than Chrome.
    var i, l, field, name, getDefault;
    for (i = 0, l = this._fields.length; i < l; i++) {
      field = this._fields[i];
      getDefault = field.getDefault;
      name = field._name;
      innerArgs.push('v' + i);
      innerBody += '  ';
      if (getDefault() === undefined) {
        innerBody += 'this.' + name + ' = v' + i + ';\n';
      } else {
        innerBody += 'if (v' + i + ' === undefined) { ';
        innerBody += 'this.' + name + ' = d' + ds.length + '(); ';
        innerBody += '} else { this.' + name + ' = v' + i + '; }\n';
        outerArgs.push('d' + ds.length);
        ds.push(getDefault);
      }
    }
    var outerBody = 'return function ' + unqualify(this._name) + '(';
    outerBody += innerArgs.join() + ') {\n' + innerBody + '};';
    var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);

    var self = this;
    Record.getType = function () { return self; };
    Record.prototype = {
      constructor: Record,
      $clone: function (opts) { return self.clone(this, opts); },
      $compare: function (val) { return self.compare(this, val); },
      $getType: Record.getType,
      $isValid: function (opts) { return self.isValid(this, opts); },
      $toBuffer: function () { return self.toBuffer(this); },
      $toString: function (noCheck) { return self.toString(this, noCheck); }
    };
    // The names of these properties added to the prototype are prefixed with `$`
    // because it is an invalid property name in Avro but not in JavaScript.
    // (This way we are guaranteed not to be stepped over!)
    if (isError) {
      util.inherits(Record, Error);
      // Not setting the name on the prototype to be consistent with how object
      // fields are mapped to (only if defined in the schema as a field).
    }

    return Record;
  };

  RecordType.prototype._createChecker = function () {
    // jshint -W054
    var names = ['t', 'P'];
    var values = [this, PATH];
    var body = 'return function check' + unqualify(this._name) + '(val, cb) {\n';
    body += '  if (val === null || typeof val != \'object\') {\n';
    body += '    if (cb) { cb(P.slice(), val, t); }\n';
    body += '    return false;\n';
    body += '  }\n';
    if (!this._fields.length) {
      // Special case, empty record. We handle this directly.
      body += '  return true;\n';
    } else {
      for (i = 0, l = this._fields.length; i < l; i++) {
        field = this._fields[i];
        names.push('t' + i);
        values.push(field._type);
        if (field.getDefault() !== undefined) {
          body += '  var v' + i + ' = val.' + field._name + ';\n';
        }
      }
      body += '  if (cb) {\n';
      body += '    var b = 1;\n';
      body += '    var j = P.length;\n';
      body += '    P.push(\'\');\n';
      var i, l, field;
      for (i = 0, l = this._fields.length; i < l; i++) {
        field = this._fields[i];
        body += '    P[j] = \'' + field._name + '\';\n';
        if (field.getDefault() === undefined) {
          body += '    b &= t' + i + '._check(val.' + field._name + ', cb);\n';
        } else {
          body += '    b &= v' + i + ' === undefined || ';
          body += 't' + i + '._check(v' + i + ', cb);\n';
        }
      }
      body += '    P.pop();\n';
      body += '    return !!b;\n';
      body += '  } else {\n    return (\n      ';
      body += this._fields.map(function (field, i) {
        if (field.getDefault() === undefined) {
          return 't' + i + '._check(val.' + field._name + ')';
        } else {
          return '(v' + i + ' === undefined || t' + i + '._check(v' + i + '))';
        }
      }).join(' &&\n      ');
      body += '\n    );\n  }\n';
    }
    body += '};';
    return new Function(names.join(), body).apply(undefined, values);
  };

  RecordType.prototype._createReader = function () {
    // jshint -W054
    var uname = unqualify(this._name);
    var names = [];
    var values = [this._constructor];
    var i, l;
    for (i = 0, l = this._fields.length; i < l; i++) {
      names.push('t' + i);
      values.push(this._fields[i]._type);
    }
    var body = 'return function read' + uname + '(tap) {\n';
    body += '  return new ' + uname + '(';
    body += names.map(function (t) { return t + '._read(tap)'; }).join();
    body += ');\n};';
    names.unshift(uname);
    // We can do this since the JS spec guarantees that function arguments are
    // evaluated from left to right.
    return new Function(names.join(), body).apply(undefined, values);
  };

  RecordType.prototype._createSkipper = function () {
    // jshint -W054
    var args = [];
    var body = 'return function skip' + unqualify(this._name) + '(tap) {\n';
    var values = [];
    var i, l;
    for (i = 0, l = this._fields.length; i < l; i++) {
      args.push('t' + i);
      values.push(this._fields[i]._type);
      body += '  t' + i + '._skip(tap);\n';
    }
    body += '}';
    return new Function(args.join(), body).apply(undefined, values);
  };

  RecordType.prototype._createWriter = function () {
    // jshint -W054
    // We still do default handling here, in case a normal JS object is passed.
    var args = [];
    var body = 'return function write' + unqualify(this._name) + '(tap, val) {\n';
    var values = [];
    var i, l, field, value;
    for (i = 0, l = this._fields.length; i < l; i++) {
      field = this._fields[i];
      args.push('t' + i);
      values.push(field._type);
      body += '  ';
      if (field.getDefault() === undefined) {
        body += 't' + i + '._write(tap, val.' + field._name + ');\n';
      } else {
        value = field._type.toBuffer(field.getDefault()).toString('binary');
        // Convert the default value to a binary string ahead of time. We aren't
        // converting it to a buffer to avoid retaining too much memory. If we
        // had our own buffer pool, this could be an idea in the future.
        args.push('d' + i);
        values.push(value);
        body += 'var v' + i + ' = val.' + field._name + '; ';
        body += 'if (v' + i + ' === undefined) { ';
        body += 'tap.writeBinary(d' + i + ', ' + value.length + ');';
        body += ' } else { t' + i + '._write(tap, v' + i + '); }\n';
      }
    }
    body += '}';
    return new Function(args.join(), body).apply(undefined, values);
  };

  RecordType.prototype._updateResolver = function (resolver, type, opts) {
    // jshint -W054
    if (!~getAliases(this).indexOf(type._name)) {
      throw new Error(f('no alias for %s in %s', type._name, this._name));
    }

    var rFields = this._fields;
    var wFields = type._fields;
    var wFieldsMap = utils.toMap(wFields, function (f) { return f._name; });

    var innerArgs = []; // Arguments for reader constructor.
    var resolvers = {}; // Resolvers keyed by writer field name.
    var i, j, field, name, names, matches;
    for (i = 0; i < rFields.length; i++) {
      field = rFields[i];
      names = getAliases(field);
      matches = [];
      for (j = 0; j < names.length; j++) {
        name = names[j];
        if (wFieldsMap[name]) {
          matches.push(name);
        }
      }
      if (matches.length > 1) {
        throw new Error(f('multiple matches for %s', field.name));
      }
      if (!matches.length) {
        if (field.getDefault() === undefined) {
          throw new Error(f('no match for default-less %s', field.name));
        }
        innerArgs.push('undefined');
      } else {
        name = matches[0];
        resolvers[name] = {
          resolver: field._type.createResolver(wFieldsMap[name]._type, opts),
          name: field._name // Reader field name.
        };
        innerArgs.push(field._name);
      }
    }

    // See if we can add a bypass for unused fields at the end of the record.
    var lazyIndex = -1;
    i = wFields.length;
    while (i && resolvers[wFields[--i]._name] === undefined) {
      lazyIndex = i;
    }

    var uname = unqualify(this._name);
    var args = [uname];
    var values = [this._constructor];
    var body = '  return function read' + uname + '(tap,lazy) {\n';
    for (i = 0; i < wFields.length; i++) {
      if (i === lazyIndex) {
        body += '  if (!lazy) {\n';
      }
      field = type._fields[i];
      name = field._name;
      body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';
      if (resolvers[name] === undefined) {
        args.push('t' + i);
        values.push(field._type);
        body += 't' + i + '._skip(tap);\n';
      } else {
        args.push('t' + i);
        values.push(resolvers[name].resolver);
        body += 'var ' + resolvers[name].name + ' = ';
        body += 't' + i + '._read(tap);\n';
      }
    }
    if (~lazyIndex) {
      body += '  }\n';
    }
    body +=  '  return new ' + uname + '(' + innerArgs.join() + ');\n};';

    resolver._read = new Function(args.join(), body).apply(undefined, values);
  };

  RecordType.prototype._match = function (tap1, tap2) {
    var fields = this._fields;
    var i, l, field, order, type;
    for (i = 0, l = fields.length; i < l; i++) {
      field = fields[i];
      order = field._order;
      type = field._type;
      if (order) {
        order *= type._match(tap1, tap2);
        if (order) {
          return order;
        }
      } else {
        type._skip(tap1);
        type._skip(tap2);
      }
    }
    return 0;
  };

  RecordType.prototype._copy = function (val, opts) {
    // jshint -W058
    var hook = opts && opts.fieldHook;
    var values = [undefined];
    var i, l, field, value;
    for (i = 0, l = this._fields.length; i < l; i++) {
      field = this._fields[i];
      value = field._type._copy(val[field._name], opts);
      if (hook) {
        value = hook(field, value, this);
      }
      values.push(value);
    }
    return new (this._constructor.bind.apply(this._constructor, values));
  };

  RecordType.prototype.compare = function (val1, val2) {
    var fields = this._fields;
    var i, l, field, name, order, type;
    for (i = 0, l = fields.length; i < l; i++) {
      field = fields[i];
      name = field._name;
      order = field._order;
      type = field._type;
      if (order) {
        order *= type.compare(val1[name], val2[name]);
        if (order) {
          return order;
        }
      }
    }
    return 0;
  };

  RecordType.prototype.random = function () {
    // jshint -W058
    var fields = this._fields.map(function (f) { return f._type.random(); });
    fields.unshift(undefined);
    return new (this._constructor.bind.apply(this._constructor, fields));
  };

  RecordType.prototype.getAliases = function () { return this._aliases; };

  RecordType.prototype.getFields = function () { return this._fields.slice(); };

  RecordType.prototype.getRecordConstructor = function () {
    return this._constructor;
  };

  RecordType.prototype.toJSON = function () {
    return {name: this._name, type: 'record', fields: this._fields};
  };

  /**
   * Derived type abstract class.
   *
   */
  function LogicalType(attrs, opts, Types) {
    Type.call(this);
    LOGICAL_TYPE = this;
    this._underlyingType = createType(attrs, opts);

    // Convenience type check.
    if (Types && !~Types.indexOf(this._underlyingType.constructor)) {
      var lType = attrs.logicalType;
      var uType = this._underlyingType;
      throw new Error(f('invalid underlying type for %s: %s', lType, uType));
    }
  }
  util.inherits(LogicalType, Type);

  LogicalType.prototype.getUnderlyingType = function () {
    return this._underlyingType;
  };

  LogicalType.prototype._read = function (tap) {
    return this._fromValue(this._underlyingType._read(tap));
  };

  LogicalType.prototype._write = function (tap, any) {
    this._underlyingType._write(tap, this._toValue(any));
  };

  LogicalType.prototype._check = function (any, cb) {
    try {
      var val = this._toValue(any);
    } catch (err) {
      if (cb) {
        cb(PATH.slice(), any, this);
      }
      return false;
    }
    return this._underlyingType._check(val, cb);
  };

  LogicalType.prototype._copy = function (any, opts) {
    var type = this._underlyingType;
    switch (opts && opts.coerce) {
      case 3: // To string.
        return type._copy(this._toValue(any), opts);
      case 2: // From string.
        return this._fromValue(type._copy(any, opts));
      default: // Normal copy.
        return this._fromValue(type._copy(this._toValue(any), opts));
    }
  };

  LogicalType.prototype._updateResolver = function (resolver, type, opts) {
    var _fromValue = this._resolve(type, opts);
    if (_fromValue) {
      resolver._read = function (tap) { return _fromValue(type._read(tap)); };
    }
  };

  LogicalType.prototype.random = function () {
    return this._fromValue(this._underlyingType.random());
  };

  LogicalType.prototype.compare = function (obj1, obj2) {
    var val1 = this._toValue(obj1);
    var val2 = this._toValue(obj2);
    return this._underlyingType.compare(val1, val2);
  };

  LogicalType.prototype.toJSON = function () {
    return this._underlyingType.toJSON();
  };

  // Methods to be implemented.
  LogicalType.prototype._fromValue = utils.abstractFunction;
  LogicalType.prototype._toValue = utils.abstractFunction;
  LogicalType.prototype._resolve = utils.abstractFunction;


  // General helpers.

  /**
   * Customizable long.
   *
   * This allows support of arbitrarily large long (e.g. larger than
   * `Number.MAX_SAFE_INTEGER`). See `LongType.using` method above.
   *
   */
  function AbstractLongType(noUnpack) {
    LongType.call(this);
    this._noUnpack = !!noUnpack;
  }
  util.inherits(AbstractLongType, LongType);

  AbstractLongType.prototype._check = function (val, cb) {
    var b = this._isValid(val);
    if (!b && cb) {
      cb(PATH.slice(), val, this);
    }
    return b;
  };

  AbstractLongType.prototype._read = function (tap) {
    var buf, pos;
    if (this._noUnpack) {
      pos = tap.pos;
      tap.skipLong();
      buf = tap.buf.slice(pos, tap.pos);
    } else {
      buf = tap.unpackLongBytes(tap);
    }
    if (tap.isValid()) {
      return this._fromBuffer(buf);
    }
  };

  AbstractLongType.prototype._write = function (tap, val) {
    if (!this._isValid(val)) {
      throwInvalidError(null, val, this);
    }
    var buf = this._toBuffer(val);
    if (this._noUnpack) {
      tap.writeFixed(buf);
    } else {
      tap.packLongBytes(buf);
    }
  };

  AbstractLongType.prototype._copy = function (val, opts) {
    switch (opts && opts.coerce) {
      case 3: // To string.
        return this._toJSON(val);
      case 2: // From string.
        return this._fromJSON(val);
      default: // Normal copy.
        // Slow but guarantees most consistent results. Faster alternatives would
        // require assumptions on the long class used (e.g. immutability).
        return this._fromJSON(JSON.parse(JSON.stringify(this._toJSON(val))));
    }
  };

  AbstractLongType.prototype.random = function () {
    return this._fromJSON(LongType.prototype.random());
  };

  // Methods to be implemented by the user.
  AbstractLongType.prototype._fromBuffer = utils.abstractFunction;
  AbstractLongType.prototype._toBuffer = utils.abstractFunction;
  AbstractLongType.prototype._fromJSON = utils.abstractFunction;
  AbstractLongType.prototype._toJSON = utils.abstractFunction;
  AbstractLongType.prototype._isValid = utils.abstractFunction;
  AbstractLongType.prototype.compare = utils.abstractFunction;

  /**
   * Field.
   *
   * @param attrs {Object} The field's schema.
   * @para opts {Object} Schema parsing options (the same as `Type`s').
   *
   */
  function Field(attrs, opts) {
    var name = attrs.name;
    if (typeof name != 'string' || !NAME_PATTERN.test(name)) {
      throw new Error(f('invalid field name: %s', name));
    }

    this._name = name;
    this._type = createType(attrs.type, opts);
    this._aliases = attrs.aliases || [];

    this._order = (function (order) {
      switch (order) {
        case 'ascending':
          return 1;
        case 'descending':
          return -1;
        case 'ignore':
          return 0;
        default:
          throw new Error(f('invalid order: %j', order));
      }
    })(attrs.order === undefined ? 'ascending' : attrs.order);

    var value = attrs['default'];
    if (value !== undefined) {
      // We need to convert defaults back to a valid format (unions are
      // disallowed in default definitions, only the first type of each union is
      // allowed instead).
      // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html
      var type = this._type;
      var val = type._copy(value, {coerce: 2, wrap: 2});
      // The clone call above will throw an error if the default is invalid.
      if (type instanceof PrimitiveType && !(type instanceof BytesType)) {
        // These are immutable.
        this.getDefault = function () { return val; };
      } else {
        this.getDefault = function () { return type._copy(val); };
      }
    }
  }

  Field.prototype.getAliases = function () { return this._aliases; };

  Field.prototype.getDefault = function () {}; // Undefined default.

  Field.prototype.getName = function () { return this._name; };

  Field.prototype.getOrder = function () {
    return ['descending', 'ignore', 'ascending'][this._order + 1];
  };

  Field.prototype.getType = function () { return this._type; };

  Field.prototype.inspect = function () { return f('<Field %j>', this._name); };

  /**
   * Resolver to read a writer's schema as a new schema.
   *
   * @param readerType {Type} The type to convert to.
   *
   */
  function Resolver(readerType) {
    // Add all fields here so that all resolvers share the same hidden class.
    this._readerType = readerType;
    this._items = null;
    this._read = null;
    this._size = 0;
    this._symbols = null;
    this._values = null;
  }

  Resolver.prototype.inspect = function () { return '<Resolver>'; };

  /**
   * Read a value from a tap.
   *
   * @param type {Type} The type to decode.
   * @param tap {Tap} The tap to read from. No checks are performed here.
   * @param resolver {Resolver} Optional resolver. It must match the input type.
   * @param lazy {Boolean} Skip trailing fields when using a resolver.
   *
   */
  function readValue(type, tap, resolver, lazy) {
    if (resolver) {
      if (resolver._readerType !== type) {
        throw new Error('invalid resolver');
      }
      return resolver._read(tap, lazy);
    } else {
      return type._read(tap);
    }
  }

  /**
   * Create default parsing options.
   *
   * @param attrs {Object} Schema to populate options with.
   * @param opts {Object} Base options.
   *
   */
  function getOpts(attrs, opts) {
    if (attrs === null) {
      // Let's be helpful for this common error.
      throw new Error('invalid type: null (did you mean "null"?)');
    }
    opts = opts || {};
    opts.registry = opts.registry || {};
    opts.namespace = attrs.namespace || opts.namespace;
    opts.logicalTypes = opts.logicalTypes || {};
    return opts;
  }

  /**
   * Resolve a schema's name and aliases.
   *
   * @param attrs {Object} True schema (can't be a string).
   * @param namespace {String} Optional parent namespace.
   * @param key {String} Key where the name should be looked up (defaults to
   * `name`).
   *
   */
  function resolveNames(attrs, namespace, key) {
    namespace = attrs.namespace || namespace;
    key = key || 'name';

    var name = attrs[key];
    if (!name) {
      throw new Error(f('missing %s property in schema: %j', key, attrs));
    }
    return {
      name: qualify(name),
      aliases: attrs.aliases ? attrs.aliases.map(qualify) : []
    };

    function qualify(name) {
      if (!~name.indexOf('.') && namespace) {
        name = namespace + '.' + name;
      }
      var tail = unqualify(name);
      if (isPrimitive(tail)) {
        // Primitive types cannot be defined in any namespace.
        throw new Error(f('cannot rename primitive type: %j', tail));
      }
      name.split('.').forEach(function (part) {
        if (!NAME_PATTERN.test(part)) {
          throw new Error(f('invalid name: %j', name));
        }
      });
      return name;
    }
  }

  /**
   * Remove namespace from a name.
   *
   * @param name {String} Full or short name.
   *
   */
  function unqualify(name) {
    var parts = name.split('.');
    return parts[parts.length - 1];
  }

  /**
   * Get all aliases for a type (including its name).
   *
   * @param obj {Type|Object} Typically a type or a field. Its aliases property
   * must exist and be an array.
   *
   */
  function getAliases(obj) {
    var names = [obj._name];
    var aliases = obj._aliases;
    var i, l;
    for (i = 0, l = aliases.length; i < l; i++) {
      names.push(aliases[i]);
    }
    return names;
  }

  /**
   * Get a type's "type" (as a string, e.g. `'record'`, `'string'`).
   *
   * @param type {Type} Any type.
   *
   */
  function getTypeName(type) {
    var obj = type.toJSON();
    return typeof obj == 'string' ? obj : obj.type;
  }

  /**
   * Check whether a type's name is a primitive.
   *
   * @param name {String} Type name (e.g. `'string'`, `'array'`).
   *
   */
  function isPrimitive(name) {
    var type = TYPES[name];
    return type !== undefined && type.prototype instanceof PrimitiveType;
  }

  /**
   * Get the number of elements in an array block.
   *
   * @param tap {Tap} A tap positioned at the beginning of an array block.
   *
   */
  function readArraySize(tap) {
    var n = tap.readLong();
    if (n < 0) {
      n = -n;
      tap.skipLong(); // Skip size.
    }
    return n;
  }

  /**
   * Correctly stringify an object which contains types.
   *
   * @param obj {Object} The object to stringify. Typically, a type itself or an
   * object containing types. Any types inside will be expanded only once then
   * referenced by name.
   * @param noDeref {Boolean} Always reference types by name when possible,
   * rather than expand it the first time it is encountered.
   *
   */
  function stringify(obj, noDeref) {
    // Since JS objects are unordered, this implementation (unfortunately)
    // relies on engines returning properties in the same order that they are
    // inserted in. This is not in the JS spec, but can be "somewhat" safely
    // assumed (more here: http://stackoverflow.com/q/5525795/1062617).
    return (function (registry) {
      return JSON.stringify(obj, function (key, value) {
        if (value instanceof Field) {
          return {name: value._name, type: value._type};
        } else if (value && value.name) {
          var name = value.name;
          if (noDeref || registry[name]) {
            return name;
          }
          registry[name] = true;
        }
        return value;
      });
    })({});
  }

  /**
   * Check whether a long can be represented without precision loss.
   *
   * @param n {Number} The number.
   *
   * Two things to note:
   *
   * + We are not using the `Number` constants for compatibility with older
   *   browsers.
   * + We must remove one from each bound because of rounding errors.
   *
   */
  function isSafeLong(n) {
    return n >= -9007199254740990 && n <= 9007199254740990;
  }

  /**
   * Throw a somewhat helpful error on invalid object.
   *
   * @param path {Array} Passed from hook, but unused (because empty where this
   * function is used, since we aren't keeping track of it for effiency).
   * @param val {...} The object to reject.
   * @param type {Type} The type to check against.
   *
   * This method is mostly used from `_write` to signal an invalid object for a
   * given type. Note that this provides less information than calling `isValid`
   * with a hook since the path is not propagated (for efficiency reasons).
   *
   */
  function throwInvalidError(path, val, type) {
    throw new Error(f('invalid %s: %j', type, val));
  }


  module.exports = {
    createType: createType,
    resolveNames: resolveNames, // Protocols use the same name resolution logic.
    stringify: stringify,
    types: (function () {
      // Export the base types along with all concrete implementations.
      var obj = {Type: Type, LogicalType: LogicalType};
      var types = Object.keys(TYPES);
      var i, l, Class;
      for (i = 0, l = types.length; i < l; i++) {
        Class = TYPES[types[i]];
        obj[Class.name] = Class;
      }
      return obj;
    })()
  };

  }).call(this,require("buffer").Buffer)
  },{"./utils":572,"buffer":697,"util":1302}],572:[function(require,module,exports){
  (function (Buffer){
  /* jshint node: true */

  /**
   *  Licensed to the Apache Software Foundation (ASF) under one
   *  or more contributor license agreements.  See the NOTICE file
   *  distributed with this work for additional information
   *  regarding copyright ownership.  The ASF licenses this file
   *  to you under the Apache License, Version 2.0 (the
   *  "License"); you may not use this file except in compliance
   *  with the License.  You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software
   *  distributed under the License is distributed on an "AS IS" BASIS,
   *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   *  See the License for the specific language governing permissions and
   *  limitations under the License.
   *
   */

  'use strict';

  var crypto = require('crypto');


  /**
   * Uppercase the first letter of a string.
   *
   * @param s {String} The string.
   *
   */
  function capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

  /**
   * Compare two numbers.
   *
   * @param n1 {Number} The first one.
   * @param n2 {Number} The second one.
   *
   */
  function compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }

  /**
   * Compute a string's hash.
   *
   * @param str {String} The string to hash.
   * @param algorithm {String} The algorithm used. Defaults to MD5.
   *
   */
  function getHash(str, algorithm) {
    algorithm = algorithm || 'md5';
    var hash = crypto.createHash(algorithm);
    hash.end(str);
    return hash.read();
  }

  /**
   * Find index of value in array.
   *
   * @param arr {Array} Can also be a false-ish value.
   * @param v {Object} Value to find.
   *
   * Returns -1 if not found, -2 if found multiple times.
   *
   */
  function singleIndexOf(arr, v) {
    var pos = -1;
    var i, l;
    if (!arr) {
      return -1;
    }
    for (i = 0, l = arr.length; i < l; i++) {
      if (arr[i] === v) {
        if (pos >= 0) {
          return -2;
        }
        pos = i;
      }
    }
    return pos;
  }

  /**
   * Convert array to map.
   *
   * @param arr {Array} Elements.
   * @param fn {Function} Function returning an element's key.
   *
   */
  function toMap(arr, fn) {
    var obj = {};
    var i, elem;
    for (i = 0; i < arr.length; i++) {
      elem = arr[i];
      obj[fn(elem)] = elem;
    }
    return obj;
  }

  /**
   * Check whether an array has duplicates.
   *
   * @param arr {Array} The array.
   * @param fn {Function} Optional function to apply to each element.
   *
   */
  function hasDuplicates(arr, fn) {
    var obj = {};
    var i, l, elem;
    for (i = 0, l = arr.length; i < l; i++) {
      elem = arr[i];
      if (fn) {
        elem = fn(elem);
      }
      if (obj[elem]) {
        return true;
      }
      obj[elem] = true;
    }
    return false;
  }

  /**
   * "Abstract" function to help with "subclassing".
   *
   */
  function abstractFunction() { throw new Error('abstract'); }

  /**
   * Generator of random things.
   *
   * Inspired by: http://stackoverflow.com/a/424445/1062617
   *
   */
  function Lcg(seed) {
    var a = 1103515245;
    var c = 12345;
    var m = Math.pow(2, 31);
    var state = Math.floor(seed || Math.random() * (m - 1));

    this._max = m;
    this._nextInt = function () { return state = (a * state + c) % m; };
  }

  Lcg.prototype.nextBoolean = function () {
    // jshint -W018
    return !!(this._nextInt() % 2);
  };

  Lcg.prototype.nextInt = function (start, end) {
    if (end === undefined) {
      end = start;
      start = 0;
    }
    end = end === undefined ? this._max : end;
    return start + Math.floor(this.nextFloat() * (end - start));
  };

  Lcg.prototype.nextFloat = function (start, end) {
    if (end === undefined) {
      end = start;
      start = 0;
    }
    end = end === undefined ? 1 : end;
    return start + (end - start) * this._nextInt() / this._max;
  };

  Lcg.prototype.nextString = function(len, flags) {
    len |= 0;
    flags = flags || 'aA';
    var mask = '';
    if (flags.indexOf('a') > -1) {
      mask += 'abcdefghijklmnopqrstuvwxyz';
    }
    if (flags.indexOf('A') > -1) {
      mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    }
    if (flags.indexOf('#') > -1) {
      mask += '0123456789';
    }
    if (flags.indexOf('!') > -1) {
      mask += '~`!@#$%^&*()_+-={}[]:";\'<>?,./|\\';
    }
    var result = [];
    for (var i = 0; i < len; i++) {
      result.push(this.choice(mask));
    }
    return result.join('');
  };

  Lcg.prototype.nextBuffer = function (len) {
    var arr = [];
    var i;
    for (i = 0; i < len; i++) {
      arr.push(this.nextInt(256));
    }
    return new Buffer(arr);
  };

  Lcg.prototype.choice = function (arr) {
    var len = arr.length;
    if (!len) {
      throw new Error('choosing from empty array');
    }
    return arr[this.nextInt(len)];
  };

  /**
   * Ordered queue which returns items consecutively.
   *
   * This is actually a heap by index, with the added requirements that elements
   * can only be retrieved consecutively.
   *
   */
  function OrderedQueue() {
    this._index = 0;
    this._items = [];
  }

  OrderedQueue.prototype.push = function (item) {
    var items = this._items;
    var i = items.length | 0;
    var j;
    items.push(item);
    while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {
      item = items[i];
      items[i] = items[j];
      items[j] = item;
      i = j;
    }
  };

  OrderedQueue.prototype.pop = function () {
    var items = this._items;
    var len = (items.length - 1) | 0;
    var first = items[0];
    if (!first || first.index > this._index) {
      return null;
    }
    this._index++;
    if (!len) {
      items.pop();
      return first;
    }
    items[0] = items.pop();
    var mid = len >> 1;
    var i = 0;
    var i1, i2, j, item, c, c1, c2;
    while (i < mid) {
      item = items[i];
      i1 = (i << 1) + 1;
      i2 = (i + 1) << 1;
      c1 = items[i1];
      c2 = items[i2];
      if (!c2 || c1.index <= c2.index) {
        c = c1;
        j = i1;
      } else {
        c = c2;
        j = i2;
      }
      if (c.index >= item.index) {
        break;
      }
      items[j] = item;
      items[i] = c;
      i = j;
    }
    return first;
  };

  /**
   * A tap is a buffer which remembers what has been already read.
   *
   * It is optimized for performance, at the cost of failing silently when
   * overflowing the buffer. This is a purposeful trade-off given the expected
   * rarity of this case and the large performance hit necessary to enforce
   * validity. See `isValid` below for more information.
   *
   */
  function Tap(buf, pos) {
    this.buf = buf;
    this.pos = pos | 0;
  }

  /**
   * Check that the tap is in a valid state.
   *
   * For efficiency reasons, none of the methods below will fail if an overflow
   * occurs (either read, skip, or write). For this reason, it is up to the
   * caller to always check that the read, skip, or write was valid by calling
   * this method.
   *
   */
  Tap.prototype.isValid = function () { return this.pos <= this.buf.length; };

  /**
   * Returns the contents of the tap up to the current position.
   *
   */
  Tap.prototype.getValue = function () { return this.buf.slice(0, this.pos); };

  // Read, skip, write methods.
  //
  // These should fail silently when the buffer overflows. Note this is only
  // required to be true when the functions are decoding valid objects. For
  // example errors will still be thrown if a bad count is read, leading to a
  // negative position offset (which will typically cause a failure in
  // `readFixed`).

  Tap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };

  Tap.prototype.skipBoolean = function () { this.pos++; };

  Tap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };

  Tap.prototype.readInt = Tap.prototype.readLong = function () {
    var n = 0;
    var k = 0;
    var buf = this.buf;
    var b, h, f, fk;

    do {
      b = buf[this.pos++];
      h = b & 0x80;
      n |= (b & 0x7f) << k;
      k += 7;
    } while (h && k < 28);

    if (h) {
      // Switch to float arithmetic, otherwise we might overflow.
      f = n;
      fk = 268435456; // 2 ** 28.
      do {
        b = buf[this.pos++];
        f += (b & 0x7f) * fk;
        fk *= 128;
      } while (b & 0x80);
      return (f % 2 ? -(f + 1) : f) / 2;
    }

    return (n >> 1) ^ -(n & 1);
  };

  Tap.prototype.skipInt = Tap.prototype.skipLong = function () {
    var buf = this.buf;
    while (buf[this.pos++] & 0x80) {}
  };

  Tap.prototype.writeInt = Tap.prototype.writeLong = function (n) {
    var buf = this.buf;
    var f, m;

    if (n >= -1073741824 && n < 1073741824) {
      // Won't overflow, we can use integer arithmetic.
      m = n >= 0 ? n << 1 : (~n << 1) | 1;
      do {
        buf[this.pos] = m & 0x7f;
        m >>= 7;
      } while (m && (buf[this.pos++] |= 0x80));
    } else {
      // We have to use slower floating arithmetic.
      f = n >= 0 ? n * 2 : (-n * 2) - 1;
      do {
        buf[this.pos] = f & 0x7f;
        f /= 128;
      } while (f >= 1 && (buf[this.pos++] |= 0x80));
    }
    this.pos++;
  };

  Tap.prototype.readFloat = function () {
    var buf = this.buf;
    var pos = this.pos;
    this.pos += 4;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.readFloatLE(pos);
  };

  Tap.prototype.skipFloat = function () { this.pos += 4; };

  Tap.prototype.writeFloat = function (f) {
    var buf = this.buf;
    var pos = this.pos;
    this.pos += 4;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.writeFloatLE(f, pos);
  };

  Tap.prototype.readDouble = function () {
    var buf = this.buf;
    var pos = this.pos;
    this.pos += 8;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.readDoubleLE(pos);
  };

  Tap.prototype.skipDouble = function () { this.pos += 8; };

  Tap.prototype.writeDouble = function (d) {
    var buf = this.buf;
    var pos = this.pos;
    this.pos += 8;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.writeDoubleLE(d, pos);
  };

  Tap.prototype.readFixed = function (len) {
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    var fixed = new Buffer(len);
    this.buf.copy(fixed, 0, pos, pos + len);
    return fixed;
  };

  Tap.prototype.skipFixed = function (len) { this.pos += len; };

  Tap.prototype.writeFixed = function (buf, len) {
    len = len || buf.length;
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    buf.copy(this.buf, pos, 0, len);
  };

  Tap.prototype.readBytes = function () {
    return this.readFixed(this.readLong());
  };

  Tap.prototype.skipBytes = function () {
    var len = this.readLong();
    this.pos += len;
  };

  Tap.prototype.writeBytes = function (buf) {
    var len = buf.length;
    this.writeLong(len);
    this.writeFixed(buf, len);
  };

  Tap.prototype.readString = function () {
    var len = this.readLong();
    var pos = this.pos;
    var buf = this.buf;
    this.pos += len;
    if (this.pos > buf.length) {
      return;
    }
    return this.buf.utf8Slice(pos, pos + len);
  };

  Tap.prototype.skipString = function () {
    var len = this.readLong();
    this.pos += len;
  };

  Tap.prototype.writeString = function (s) {
    var len = Buffer.byteLength(s);
    this.writeLong(len);
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    this.buf.utf8Write(s, pos, len);
  };

  // Helper used to speed up writing defaults.

  Tap.prototype.writeBinary = function (str, len) {
    var pos = this.pos;
    this.pos += len;
    if (this.pos > this.buf.length) {
      return;
    }
    this.buf.binaryWrite(str, pos, len);
  };

  // Binary comparison methods.
  //
  // These are not guaranteed to consume the objects they are comparing when
  // returning a non-zero result (allowing for performance benefits), so no other
  // operations should be done on either tap after a compare returns a non-zero
  // value. Also, these methods do not have the same silent failure requirement
  // as read, skip, and write since they are assumed to be called on valid
  // buffers.

  Tap.prototype.matchBoolean = function (tap) {
    return this.buf[this.pos++] - tap.buf[tap.pos++];
  };

  Tap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {
    var n1 = this.readLong();
    var n2 = tap.readLong();
    return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
  };

  Tap.prototype.matchFloat = function (tap) {
    var n1 = this.readFloat();
    var n2 = tap.readFloat();
    return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
  };

  Tap.prototype.matchDouble = function (tap) {
    var n1 = this.readDouble();
    var n2 = tap.readDouble();
    return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);
  };

  Tap.prototype.matchFixed = function (tap, len) {
    return this.readFixed(len).compare(tap.readFixed(len));
  };

  Tap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {
    var l1 = this.readLong();
    var p1 = this.pos;
    this.pos += l1;
    var l2 = tap.readLong();
    var p2 = tap.pos;
    tap.pos += l2;
    var b1 = this.buf.slice(p1, this.pos);
    var b2 = tap.buf.slice(p2, tap.pos);
    return b1.compare(b2);
  };

  // Functions for supporting custom long classes.
  //
  // The two following methods allow the long implementations to not have to
  // worry about Avro's zigzag encoding, we directly expose longs as unpacked.

  Tap.prototype.unpackLongBytes = function () {
    var res = new Buffer(8);
    var n = 0;
    var i = 0; // Byte index in target buffer.
    var j = 6; // Bit offset in current target buffer byte.
    var buf = this.buf;
    var b, neg;

    b = buf[this.pos++];
    neg = b & 1;
    res.fill(0);

    n |= (b & 0x7f) >> 1;
    while (b & 0x80) {
      b = buf[this.pos++];
      n |= (b & 0x7f) << j;
      j += 7;
      if (j >= 8) {
        // Flush byte.
        j -= 8;
        res[i++] = n;
        n >>= 8;
      }
    }
    res[i] = n;

    if (neg) {
      invert(res, 8);
    }

    return res;
  };

  Tap.prototype.packLongBytes = function (buf) {
    var neg = (buf[7] & 0x80) >> 7;
    var res = this.buf;
    var j = 1;
    var k = 0;
    var m = 3;
    var n;

    if (neg) {
      invert(buf, 8);
      n = 1;
    } else {
      n = 0;
    }

    var parts = [
      buf.readUIntLE(0, 3),
      buf.readUIntLE(3, 3),
      buf.readUIntLE(6, 2)
    ];
    // Not reading more than 24 bits because we need to be able to combine the
    // "carry" bits from the previous part and JavaScript only supports bitwise
    // operations on 32 bit integers.
    while (m && !parts[--m]) {} // Skip trailing 0s.

    // Leading parts (if any), we never bail early here since we need the
    // continuation bit to be set.
    while (k < m) {
      n |= parts[k++] << j;
      j += 24;
      while (j > 7) {
        res[this.pos++] = (n & 0x7f) | 0x80;
        n >>= 7;
        j -= 7;
      }
    }

    // Final part, similar to normal packing aside from the initial offset.
    n |= parts[m] << j;
    do {
      res[this.pos] = n & 0x7f;
      n >>= 7;
    } while (n && (res[this.pos++] |= 0x80));
    this.pos++;

    // Restore original buffer (could make this optional?).
    if (neg) {
      invert(buf, 8);
    }
  };

  // Helpers.

  /**
   * Invert all bits in a buffer.
   *
   * @param buf {Buffer} Non-empty buffer to invert.
   * @param len {Number} Buffer length (must be positive).
   *
   */
  function invert(buf, len) {
    while (len--) {
      buf[len] = ~buf[len];
    }
  }


  module.exports = {
    abstractFunction: abstractFunction,
    capitalize: capitalize,
    compare: compare,
    getHash: getHash,
    toMap: toMap,
    singleIndexOf: singleIndexOf,
    hasDuplicates: hasDuplicates,
    Lcg: Lcg,
    OrderedQueue: OrderedQueue,
    Tap: Tap
  };

  }).call(this,require("buffer").Buffer)
  },{"buffer":697,"crypto":569}],573:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
  },{"core-js/library/fn/get-iterator":592}],574:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
  },{"core-js/library/fn/is-iterable":593}],575:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
  },{"core-js/library/fn/object/assign":594}],576:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
  },{"core-js/library/fn/object/create":595}],577:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
  },{"core-js/library/fn/object/define-property":596}],578:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
  },{"core-js/library/fn/object/get-own-property-descriptor":597}],579:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
  },{"core-js/library/fn/object/get-prototype-of":598}],580:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
  },{"core-js/library/fn/object/keys":599}],581:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
  },{"core-js/library/fn/object/set-prototype-of":600}],582:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
  },{"core-js/library/fn/symbol":601}],583:[function(require,module,exports){
  module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
  },{"core-js/library/fn/symbol/iterator":602}],584:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  exports.default = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  },{}],585:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  var _defineProperty = require("../core-js/object/define-property");

  var _defineProperty2 = _interopRequireDefault(_defineProperty);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        (0, _defineProperty2.default)(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  },{"../core-js/object/define-property":577}],586:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  var _assign = require("../core-js/object/assign");

  var _assign2 = _interopRequireDefault(_assign);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _assign2.default || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  },{"../core-js/object/assign":575}],587:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  var _setPrototypeOf = require("../core-js/object/set-prototype-of");

  var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

  var _create = require("../core-js/object/create");

  var _create2 = _interopRequireDefault(_create);

  var _typeof2 = require("../helpers/typeof");

  var _typeof3 = _interopRequireDefault(_typeof2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
    }

    subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
  };
  },{"../core-js/object/create":576,"../core-js/object/set-prototype-of":581,"../helpers/typeof":591}],588:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  exports.default = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };
  },{}],589:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  var _typeof2 = require("../helpers/typeof");

  var _typeof3 = _interopRequireDefault(_typeof2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
  };
  },{"../helpers/typeof":591}],590:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  var _isIterable2 = require("../core-js/is-iterable");

  var _isIterable3 = _interopRequireDefault(_isIterable2);

  var _getIterator2 = require("../core-js/get-iterator");

  var _getIterator3 = _interopRequireDefault(_getIterator2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if ((0, _isIterable3.default)(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  },{"../core-js/get-iterator":573,"../core-js/is-iterable":574}],591:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  var _iterator = require("../core-js/symbol/iterator");

  var _iterator2 = _interopRequireDefault(_iterator);

  var _symbol = require("../core-js/symbol");

  var _symbol2 = _interopRequireDefault(_symbol);

  var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof(obj);
  } : function (obj) {
    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
  };
  },{"../core-js/symbol":582,"../core-js/symbol/iterator":583}],592:[function(require,module,exports){
  require('../modules/web.dom.iterable');
  require('../modules/es6.string.iterator');
  module.exports = require('../modules/core.get-iterator');
  },{"../modules/core.get-iterator":664,"../modules/es6.string.iterator":675,"../modules/web.dom.iterable":679}],593:[function(require,module,exports){
  require('../modules/web.dom.iterable');
  require('../modules/es6.string.iterator');
  module.exports = require('../modules/core.is-iterable');
  },{"../modules/core.is-iterable":665,"../modules/es6.string.iterator":675,"../modules/web.dom.iterable":679}],594:[function(require,module,exports){
  require('../../modules/es6.object.assign');
  module.exports = require('../../modules/_core').Object.assign;
  },{"../../modules/_core":609,"../../modules/es6.object.assign":667}],595:[function(require,module,exports){
  require('../../modules/es6.object.create');
  var $Object = require('../../modules/_core').Object;
  module.exports = function create(P, D){
    return $Object.create(P, D);
  };
  },{"../../modules/_core":609,"../../modules/es6.object.create":668}],596:[function(require,module,exports){
  require('../../modules/es6.object.define-property');
  var $Object = require('../../modules/_core').Object;
  module.exports = function defineProperty(it, key, desc){
    return $Object.defineProperty(it, key, desc);
  };
  },{"../../modules/_core":609,"../../modules/es6.object.define-property":669}],597:[function(require,module,exports){
  require('../../modules/es6.object.get-own-property-descriptor');
  var $Object = require('../../modules/_core').Object;
  module.exports = function getOwnPropertyDescriptor(it, key){
    return $Object.getOwnPropertyDescriptor(it, key);
  };
  },{"../../modules/_core":609,"../../modules/es6.object.get-own-property-descriptor":670}],598:[function(require,module,exports){
  require('../../modules/es6.object.get-prototype-of');
  module.exports = require('../../modules/_core').Object.getPrototypeOf;
  },{"../../modules/_core":609,"../../modules/es6.object.get-prototype-of":671}],599:[function(require,module,exports){
  require('../../modules/es6.object.keys');
  module.exports = require('../../modules/_core').Object.keys;
  },{"../../modules/_core":609,"../../modules/es6.object.keys":672}],600:[function(require,module,exports){
  require('../../modules/es6.object.set-prototype-of');
  module.exports = require('../../modules/_core').Object.setPrototypeOf;
  },{"../../modules/_core":609,"../../modules/es6.object.set-prototype-of":673}],601:[function(require,module,exports){
  require('../../modules/es6.symbol');
  require('../../modules/es6.object.to-string');
  require('../../modules/es7.symbol.async-iterator');
  require('../../modules/es7.symbol.observable');
  module.exports = require('../../modules/_core').Symbol;
  },{"../../modules/_core":609,"../../modules/es6.object.to-string":674,"../../modules/es6.symbol":676,"../../modules/es7.symbol.async-iterator":677,"../../modules/es7.symbol.observable":678}],602:[function(require,module,exports){
  require('../../modules/es6.string.iterator');
  require('../../modules/web.dom.iterable');
  module.exports = require('../../modules/_wks-ext').f('iterator');
  },{"../../modules/_wks-ext":661,"../../modules/es6.string.iterator":675,"../../modules/web.dom.iterable":679}],603:[function(require,module,exports){
  module.exports = function(it){
    if(typeof it != 'function')throw TypeError(it + ' is not a function!');
    return it;
  };
  },{}],604:[function(require,module,exports){
  module.exports = function(){ /* empty */ };
  },{}],605:[function(require,module,exports){
  var isObject = require('./_is-object');
  module.exports = function(it){
    if(!isObject(it))throw TypeError(it + ' is not an object!');
    return it;
  };
  },{"./_is-object":625}],606:[function(require,module,exports){
  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = require('./_to-iobject')
    , toLength  = require('./_to-length')
    , toIndex   = require('./_to-index');
  module.exports = function(IS_INCLUDES){
    return function($this, el, fromIndex){
      var O      = toIObject($this)
        , length = toLength(O.length)
        , index  = toIndex(fromIndex, length)
        , value;
      // Array#includes uses SameValueZero equality algorithm
      if(IS_INCLUDES && el != el)while(length > index){
        value = O[index++];
        if(value != value)return true;
      // Array#toIndex ignores holes, Array#includes - not
      } else for(;length > index; index++)if(IS_INCLUDES || index in O){
        if(O[index] === el)return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };
  },{"./_to-index":653,"./_to-iobject":655,"./_to-length":656}],607:[function(require,module,exports){
  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = require('./_cof')
    , TAG = require('./_wks')('toStringTag')
    // ES3 wrong here
    , ARG = cof(function(){ return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function(it, key){
    try {
      return it[key];
    } catch(e){ /* empty */ }
  };

  module.exports = function(it){
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
      // builtinTag case
      : ARG ? cof(O)
      // ES3 arguments fallback
      : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  },{"./_cof":608,"./_wks":662}],608:[function(require,module,exports){
  var toString = {}.toString;

  module.exports = function(it){
    return toString.call(it).slice(8, -1);
  };
  },{}],609:[function(require,module,exports){
  var core = module.exports = {version: '2.4.0'};
  if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
  },{}],610:[function(require,module,exports){
  // optional / simple context binding
  var aFunction = require('./_a-function');
  module.exports = function(fn, that, length){
    aFunction(fn);
    if(that === undefined)return fn;
    switch(length){
      case 1: return function(a){
        return fn.call(that, a);
      };
      case 2: return function(a, b){
        return fn.call(that, a, b);
      };
      case 3: return function(a, b, c){
        return fn.call(that, a, b, c);
      };
    }
    return function(/* ...args */){
      return fn.apply(that, arguments);
    };
  };
  },{"./_a-function":603}],611:[function(require,module,exports){
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function(it){
    if(it == undefined)throw TypeError("Can't call method on  " + it);
    return it;
  };
  },{}],612:[function(require,module,exports){
  // Thank's IE8 for his funny defineProperty
  module.exports = !require('./_fails')(function(){
    return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
  });
  },{"./_fails":617}],613:[function(require,module,exports){
  var isObject = require('./_is-object')
    , document = require('./_global').document
    // in old IE typeof document.createElement is 'object'
    , is = isObject(document) && isObject(document.createElement);
  module.exports = function(it){
    return is ? document.createElement(it) : {};
  };
  },{"./_global":618,"./_is-object":625}],614:[function(require,module,exports){
  // IE 8- don't enum bug keys
  module.exports = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');
  },{}],615:[function(require,module,exports){
  // all enumerable object keys, includes symbols
  var getKeys = require('./_object-keys')
    , gOPS    = require('./_object-gops')
    , pIE     = require('./_object-pie');
  module.exports = function(it){
    var result     = getKeys(it)
      , getSymbols = gOPS.f;
    if(getSymbols){
      var symbols = getSymbols(it)
        , isEnum  = pIE.f
        , i       = 0
        , key;
      while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
    } return result;
  };
  },{"./_object-gops":640,"./_object-keys":643,"./_object-pie":644}],616:[function(require,module,exports){
  var global    = require('./_global')
    , core      = require('./_core')
    , ctx       = require('./_ctx')
    , hide      = require('./_hide')
    , PROTOTYPE = 'prototype';

  var $export = function(type, name, source){
    var IS_FORCED = type & $export.F
      , IS_GLOBAL = type & $export.G
      , IS_STATIC = type & $export.S
      , IS_PROTO  = type & $export.P
      , IS_BIND   = type & $export.B
      , IS_WRAP   = type & $export.W
      , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
      , expProto  = exports[PROTOTYPE]
      , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
      , key, own, out;
    if(IS_GLOBAL)source = name;
    for(key in source){
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if(own && key in exports)continue;
      // export native or passed
      out = own ? target[key] : source[key];
      // prevent global pollution for namespaces
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      // bind timers to global for call from export context
      : IS_BIND && own ? ctx(out, global)
      // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? (function(C){
        var F = function(a, b, c){
          if(this instanceof C){
            switch(arguments.length){
              case 0: return new C;
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      // make static versions for prototype methods
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
      if(IS_PROTO){
        (exports.virtual || (exports.virtual = {}))[key] = out;
        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
        if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
      }
    }
  };
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library`
  module.exports = $export;
  },{"./_core":609,"./_ctx":610,"./_global":618,"./_hide":620}],617:[function(require,module,exports){
  module.exports = function(exec){
    try {
      return !!exec();
    } catch(e){
      return true;
    }
  };
  },{}],618:[function(require,module,exports){
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
  },{}],619:[function(require,module,exports){
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key){
    return hasOwnProperty.call(it, key);
  };
  },{}],620:[function(require,module,exports){
  var dP         = require('./_object-dp')
    , createDesc = require('./_property-desc');
  module.exports = require('./_descriptors') ? function(object, key, value){
    return dP.f(object, key, createDesc(1, value));
  } : function(object, key, value){
    object[key] = value;
    return object;
  };
  },{"./_descriptors":612,"./_object-dp":635,"./_property-desc":646}],621:[function(require,module,exports){
  module.exports = require('./_global').document && document.documentElement;
  },{"./_global":618}],622:[function(require,module,exports){
  module.exports = !require('./_descriptors') && !require('./_fails')(function(){
    return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
  });
  },{"./_descriptors":612,"./_dom-create":613,"./_fails":617}],623:[function(require,module,exports){
  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = require('./_cof');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  },{"./_cof":608}],624:[function(require,module,exports){
  // 7.2.2 IsArray(argument)
  var cof = require('./_cof');
  module.exports = Array.isArray || function isArray(arg){
    return cof(arg) == 'Array';
  };
  },{"./_cof":608}],625:[function(require,module,exports){
  module.exports = function(it){
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  },{}],626:[function(require,module,exports){
  'use strict';
  var create         = require('./_object-create')
    , descriptor     = require('./_property-desc')
    , setToStringTag = require('./_set-to-string-tag')
    , IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

  module.exports = function(Constructor, NAME, next){
    Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  },{"./_hide":620,"./_object-create":634,"./_property-desc":646,"./_set-to-string-tag":649,"./_wks":662}],627:[function(require,module,exports){
  'use strict';
  var LIBRARY        = require('./_library')
    , $export        = require('./_export')
    , redefine       = require('./_redefine')
    , hide           = require('./_hide')
    , has            = require('./_has')
    , Iterators      = require('./_iterators')
    , $iterCreate    = require('./_iter-create')
    , setToStringTag = require('./_set-to-string-tag')
    , getPrototypeOf = require('./_object-gpo')
    , ITERATOR       = require('./_wks')('iterator')
    , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
    , FF_ITERATOR    = '@@iterator'
    , KEYS           = 'keys'
    , VALUES         = 'values';

  var returnThis = function(){ return this; };

  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind){
      if(!BUGGY && kind in proto)return proto[kind];
      switch(kind){
        case KEYS: return function keys(){ return new Constructor(this, kind); };
        case VALUES: return function values(){ return new Constructor(this, kind); };
      } return function entries(){ return new Constructor(this, kind); };
    };
    var TAG        = NAME + ' Iterator'
      , DEF_VALUES = DEFAULT == VALUES
      , VALUES_BUG = false
      , proto      = Base.prototype
      , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
      , $default   = $native || getMethod(DEFAULT)
      , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
      , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
      , methods, key, IteratorPrototype;
    // Fix native
    if($anyNative){
      IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
      if(IteratorPrototype !== Object.prototype){
        // Set @@toStringTag to native iterators
        setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
    // Define iterator
    if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
      hide(proto, ITERATOR, $default);
    }
    // Plug for library
    Iterators[NAME] = $default;
    Iterators[TAG]  = returnThis;
    if(DEFAULT){
      methods = {
        values:  DEF_VALUES ? $default : getMethod(VALUES),
        keys:    IS_SET     ? $default : getMethod(KEYS),
        entries: $entries
      };
      if(FORCED)for(key in methods){
        if(!(key in proto))redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  },{"./_export":616,"./_has":619,"./_hide":620,"./_iter-create":626,"./_iterators":629,"./_library":631,"./_object-gpo":641,"./_redefine":647,"./_set-to-string-tag":649,"./_wks":662}],628:[function(require,module,exports){
  module.exports = function(done, value){
    return {value: value, done: !!done};
  };
  },{}],629:[function(require,module,exports){
  module.exports = {};
  },{}],630:[function(require,module,exports){
  var getKeys   = require('./_object-keys')
    , toIObject = require('./_to-iobject');
  module.exports = function(object, el){
    var O      = toIObject(object)
      , keys   = getKeys(O)
      , length = keys.length
      , index  = 0
      , key;
    while(length > index)if(O[key = keys[index++]] === el)return key;
  };
  },{"./_object-keys":643,"./_to-iobject":655}],631:[function(require,module,exports){
  module.exports = true;
  },{}],632:[function(require,module,exports){
  var META     = require('./_uid')('meta')
    , isObject = require('./_is-object')
    , has      = require('./_has')
    , setDesc  = require('./_object-dp').f
    , id       = 0;
  var isExtensible = Object.isExtensible || function(){
    return true;
  };
  var FREEZE = !require('./_fails')(function(){
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function(it){
    setDesc(it, META, {value: {
      i: 'O' + ++id, // object ID
      w: {}          // weak collections IDs
    }});
  };
  var fastKey = function(it, create){
    // return primitive with prefix
    if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if(!has(it, META)){
      // can't set metadata to uncaught frozen object
      if(!isExtensible(it))return 'F';
      // not necessary to add metadata
      if(!create)return 'E';
      // add missing metadata
      setMeta(it);
    // return object ID
    } return it[META].i;
  };
  var getWeak = function(it, create){
    if(!has(it, META)){
      // can't set metadata to uncaught frozen object
      if(!isExtensible(it))return true;
      // not necessary to add metadata
      if(!create)return false;
      // add missing metadata
      setMeta(it);
    // return hash weak collections IDs
    } return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function(it){
    if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY:      META,
    NEED:     false,
    fastKey:  fastKey,
    getWeak:  getWeak,
    onFreeze: onFreeze
  };
  },{"./_fails":617,"./_has":619,"./_is-object":625,"./_object-dp":635,"./_uid":659}],633:[function(require,module,exports){
  'use strict';
  // 19.1.2.1 Object.assign(target, source, ...)
  var getKeys  = require('./_object-keys')
    , gOPS     = require('./_object-gops')
    , pIE      = require('./_object-pie')
    , toObject = require('./_to-object')
    , IObject  = require('./_iobject')
    , $assign  = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  module.exports = !$assign || require('./_fails')(function(){
    var A = {}
      , B = {}
      , S = Symbol()
      , K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k){ B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source){ // eslint-disable-line no-unused-vars
    var T     = toObject(target)
      , aLen  = arguments.length
      , index = 1
      , getSymbols = gOPS.f
      , isEnum     = pIE.f;
    while(aLen > index){
      var S      = IObject(arguments[index++])
        , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
        , length = keys.length
        , j      = 0
        , key;
      while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
    } return T;
  } : $assign;
  },{"./_fails":617,"./_iobject":623,"./_object-gops":640,"./_object-keys":643,"./_object-pie":644,"./_to-object":657}],634:[function(require,module,exports){
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var anObject    = require('./_an-object')
    , dPs         = require('./_object-dps')
    , enumBugKeys = require('./_enum-bug-keys')
    , IE_PROTO    = require('./_shared-key')('IE_PROTO')
    , Empty       = function(){ /* empty */ }
    , PROTOTYPE   = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function(){
    // Thrash, waste and sodomy: IE GC bug
    var iframe = require('./_dom-create')('iframe')
      , i      = enumBugKeys.length
      , lt     = '<'
      , gt     = '>'
      , iframeDocument;
    iframe.style.display = 'none';
    require('./_html').appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
  };

  module.exports = Object.create || function create(O, Properties){
    var result;
    if(O !== null){
      Empty[PROTOTYPE] = anObject(O);
      result = new Empty;
      Empty[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
  };

  },{"./_an-object":605,"./_dom-create":613,"./_enum-bug-keys":614,"./_html":621,"./_object-dps":636,"./_shared-key":650}],635:[function(require,module,exports){
  var anObject       = require('./_an-object')
    , IE8_DOM_DEFINE = require('./_ie8-dom-define')
    , toPrimitive    = require('./_to-primitive')
    , dP             = Object.defineProperty;

  exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if(IE8_DOM_DEFINE)try {
      return dP(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)O[P] = Attributes.value;
    return O;
  };
  },{"./_an-object":605,"./_descriptors":612,"./_ie8-dom-define":622,"./_to-primitive":658}],636:[function(require,module,exports){
  var dP       = require('./_object-dp')
    , anObject = require('./_an-object')
    , getKeys  = require('./_object-keys');

  module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
    anObject(O);
    var keys   = getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)dP.f(O, P = keys[i++], Properties[P]);
    return O;
  };
  },{"./_an-object":605,"./_descriptors":612,"./_object-dp":635,"./_object-keys":643}],637:[function(require,module,exports){
  var pIE            = require('./_object-pie')
    , createDesc     = require('./_property-desc')
    , toIObject      = require('./_to-iobject')
    , toPrimitive    = require('./_to-primitive')
    , has            = require('./_has')
    , IE8_DOM_DEFINE = require('./_ie8-dom-define')
    , gOPD           = Object.getOwnPropertyDescriptor;

  exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
    O = toIObject(O);
    P = toPrimitive(P, true);
    if(IE8_DOM_DEFINE)try {
      return gOPD(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
  };
  },{"./_descriptors":612,"./_has":619,"./_ie8-dom-define":622,"./_object-pie":644,"./_property-desc":646,"./_to-iobject":655,"./_to-primitive":658}],638:[function(require,module,exports){
  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  var toIObject = require('./_to-iobject')
    , gOPN      = require('./_object-gopn').f
    , toString  = {}.toString;

  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function(it){
    try {
      return gOPN(it);
    } catch(e){
      return windowNames.slice();
    }
  };

  module.exports.f = function getOwnPropertyNames(it){
    return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
  };

  },{"./_object-gopn":639,"./_to-iobject":655}],639:[function(require,module,exports){
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  var $keys      = require('./_object-keys-internal')
    , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

  exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
    return $keys(O, hiddenKeys);
  };
  },{"./_enum-bug-keys":614,"./_object-keys-internal":642}],640:[function(require,module,exports){
  exports.f = Object.getOwnPropertySymbols;
  },{}],641:[function(require,module,exports){
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var has         = require('./_has')
    , toObject    = require('./_to-object')
    , IE_PROTO    = require('./_shared-key')('IE_PROTO')
    , ObjectProto = Object.prototype;

  module.exports = Object.getPrototypeOf || function(O){
    O = toObject(O);
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(typeof O.constructor == 'function' && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };
  },{"./_has":619,"./_shared-key":650,"./_to-object":657}],642:[function(require,module,exports){
  var has          = require('./_has')
    , toIObject    = require('./_to-iobject')
    , arrayIndexOf = require('./_array-includes')(false)
    , IE_PROTO     = require('./_shared-key')('IE_PROTO');

  module.exports = function(object, names){
    var O      = toIObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(names.length > i)if(has(O, key = names[i++])){
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };
  },{"./_array-includes":606,"./_has":619,"./_shared-key":650,"./_to-iobject":655}],643:[function(require,module,exports){
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var $keys       = require('./_object-keys-internal')
    , enumBugKeys = require('./_enum-bug-keys');

  module.exports = Object.keys || function keys(O){
    return $keys(O, enumBugKeys);
  };
  },{"./_enum-bug-keys":614,"./_object-keys-internal":642}],644:[function(require,module,exports){
  exports.f = {}.propertyIsEnumerable;
  },{}],645:[function(require,module,exports){
  // most Object methods by ES6 should accept primitives
  var $export = require('./_export')
    , core    = require('./_core')
    , fails   = require('./_fails');
  module.exports = function(KEY, exec){
    var fn  = (core.Object || {})[KEY] || Object[KEY]
      , exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
  };
  },{"./_core":609,"./_export":616,"./_fails":617}],646:[function(require,module,exports){
  module.exports = function(bitmap, value){
    return {
      enumerable  : !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable    : !(bitmap & 4),
      value       : value
    };
  };
  },{}],647:[function(require,module,exports){
  module.exports = require('./_hide');
  },{"./_hide":620}],648:[function(require,module,exports){
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */
  var isObject = require('./_is-object')
    , anObject = require('./_an-object');
  var check = function(O, proto){
    anObject(O);
    if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
      function(test, buggy, set){
        try {
          set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
          set(test, []);
          buggy = !(test instanceof Array);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }({}, false) : undefined),
    check: check
  };
  },{"./_an-object":605,"./_ctx":610,"./_is-object":625,"./_object-gopd":637}],649:[function(require,module,exports){
  var def = require('./_object-dp').f
    , has = require('./_has')
    , TAG = require('./_wks')('toStringTag');

  module.exports = function(it, tag, stat){
    if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
  };
  },{"./_has":619,"./_object-dp":635,"./_wks":662}],650:[function(require,module,exports){
  var shared = require('./_shared')('keys')
    , uid    = require('./_uid');
  module.exports = function(key){
    return shared[key] || (shared[key] = uid(key));
  };
  },{"./_shared":651,"./_uid":659}],651:[function(require,module,exports){
  var global = require('./_global')
    , SHARED = '__core-js_shared__'
    , store  = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key){
    return store[key] || (store[key] = {});
  };
  },{"./_global":618}],652:[function(require,module,exports){
  var toInteger = require('./_to-integer')
    , defined   = require('./_defined');
  // true  -> String#at
  // false -> String#codePointAt
  module.exports = function(TO_STRING){
    return function(that, pos){
      var s = String(defined(that))
        , i = toInteger(pos)
        , l = s.length
        , a, b;
      if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  },{"./_defined":611,"./_to-integer":654}],653:[function(require,module,exports){
  var toInteger = require('./_to-integer')
    , max       = Math.max
    , min       = Math.min;
  module.exports = function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  },{"./_to-integer":654}],654:[function(require,module,exports){
  // 7.1.4 ToInteger
  var ceil  = Math.ceil
    , floor = Math.floor;
  module.exports = function(it){
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  },{}],655:[function(require,module,exports){
  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = require('./_iobject')
    , defined = require('./_defined');
  module.exports = function(it){
    return IObject(defined(it));
  };
  },{"./_defined":611,"./_iobject":623}],656:[function(require,module,exports){
  // 7.1.15 ToLength
  var toInteger = require('./_to-integer')
    , min       = Math.min;
  module.exports = function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };
  },{"./_to-integer":654}],657:[function(require,module,exports){
  // 7.1.13 ToObject(argument)
  var defined = require('./_defined');
  module.exports = function(it){
    return Object(defined(it));
  };
  },{"./_defined":611}],658:[function(require,module,exports){
  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = require('./_is-object');
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  module.exports = function(it, S){
    if(!isObject(it))return it;
    var fn, val;
    if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
    if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
    if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
    throw TypeError("Can't convert object to primitive value");
  };
  },{"./_is-object":625}],659:[function(require,module,exports){
  var id = 0
    , px = Math.random();
  module.exports = function(key){
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  },{}],660:[function(require,module,exports){
  var global         = require('./_global')
    , core           = require('./_core')
    , LIBRARY        = require('./_library')
    , wksExt         = require('./_wks-ext')
    , defineProperty = require('./_object-dp').f;
  module.exports = function(name){
    var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
    if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
  };
  },{"./_core":609,"./_global":618,"./_library":631,"./_object-dp":635,"./_wks-ext":661}],661:[function(require,module,exports){
  exports.f = require('./_wks');
  },{"./_wks":662}],662:[function(require,module,exports){
  var store      = require('./_shared')('wks')
    , uid        = require('./_uid')
    , Symbol     = require('./_global').Symbol
    , USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function(name){
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  };

  $exports.store = store;
  },{"./_global":618,"./_shared":651,"./_uid":659}],663:[function(require,module,exports){
  var classof   = require('./_classof')
    , ITERATOR  = require('./_wks')('iterator')
    , Iterators = require('./_iterators');
  module.exports = require('./_core').getIteratorMethod = function(it){
    if(it != undefined)return it[ITERATOR]
      || it['@@iterator']
      || Iterators[classof(it)];
  };
  },{"./_classof":607,"./_core":609,"./_iterators":629,"./_wks":662}],664:[function(require,module,exports){
  var anObject = require('./_an-object')
    , get      = require('./core.get-iterator-method');
  module.exports = require('./_core').getIterator = function(it){
    var iterFn = get(it);
    if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  },{"./_an-object":605,"./_core":609,"./core.get-iterator-method":663}],665:[function(require,module,exports){
  var classof   = require('./_classof')
    , ITERATOR  = require('./_wks')('iterator')
    , Iterators = require('./_iterators');
  module.exports = require('./_core').isIterable = function(it){
    var O = Object(it);
    return O[ITERATOR] !== undefined
      || '@@iterator' in O
      || Iterators.hasOwnProperty(classof(O));
  };
  },{"./_classof":607,"./_core":609,"./_iterators":629,"./_wks":662}],666:[function(require,module,exports){
  'use strict';
  var addToUnscopables = require('./_add-to-unscopables')
    , step             = require('./_iter-step')
    , Iterators        = require('./_iterators')
    , toIObject        = require('./_to-iobject');

  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
    this._t = toIObject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var O     = this._t
      , kind  = this._k
      , index = this._i++;
    if(!O || index >= O.length){
      this._t = undefined;
      return step(1);
    }
    if(kind == 'keys'  )return step(0, index);
    if(kind == 'values')return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators.Arguments = Iterators.Array;

  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  },{"./_add-to-unscopables":604,"./_iter-define":627,"./_iter-step":628,"./_iterators":629,"./_to-iobject":655}],667:[function(require,module,exports){
  // 19.1.3.1 Object.assign(target, source)
  var $export = require('./_export');

  $export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
  },{"./_export":616,"./_object-assign":633}],668:[function(require,module,exports){
  var $export = require('./_export')
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  $export($export.S, 'Object', {create: require('./_object-create')});
  },{"./_export":616,"./_object-create":634}],669:[function(require,module,exports){
  var $export = require('./_export');
  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  $export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
  },{"./_descriptors":612,"./_export":616,"./_object-dp":635}],670:[function(require,module,exports){
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  var toIObject                 = require('./_to-iobject')
    , $getOwnPropertyDescriptor = require('./_object-gopd').f;

  require('./_object-sap')('getOwnPropertyDescriptor', function(){
    return function getOwnPropertyDescriptor(it, key){
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  },{"./_object-gopd":637,"./_object-sap":645,"./_to-iobject":655}],671:[function(require,module,exports){
  // 19.1.2.9 Object.getPrototypeOf(O)
  var toObject        = require('./_to-object')
    , $getPrototypeOf = require('./_object-gpo');

  require('./_object-sap')('getPrototypeOf', function(){
    return function getPrototypeOf(it){
      return $getPrototypeOf(toObject(it));
    };
  });
  },{"./_object-gpo":641,"./_object-sap":645,"./_to-object":657}],672:[function(require,module,exports){
  // 19.1.2.14 Object.keys(O)
  var toObject = require('./_to-object')
    , $keys    = require('./_object-keys');

  require('./_object-sap')('keys', function(){
    return function keys(it){
      return $keys(toObject(it));
    };
  });
  },{"./_object-keys":643,"./_object-sap":645,"./_to-object":657}],673:[function(require,module,exports){
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  var $export = require('./_export');
  $export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
  },{"./_export":616,"./_set-proto":648}],674:[function(require,module,exports){

  },{}],675:[function(require,module,exports){
  'use strict';
  var $at  = require('./_string-at')(true);

  // 21.1.3.27 String.prototype[@@iterator]()
  require('./_iter-define')(String, 'String', function(iterated){
    this._t = String(iterated); // target
    this._i = 0;                // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var O     = this._t
      , index = this._i
      , point;
    if(index >= O.length)return {value: undefined, done: true};
    point = $at(O, index);
    this._i += point.length;
    return {value: point, done: false};
  });
  },{"./_iter-define":627,"./_string-at":652}],676:[function(require,module,exports){
  'use strict';
  // ECMAScript 6 symbols shim
  var global         = require('./_global')
    , has            = require('./_has')
    , DESCRIPTORS    = require('./_descriptors')
    , $export        = require('./_export')
    , redefine       = require('./_redefine')
    , META           = require('./_meta').KEY
    , $fails         = require('./_fails')
    , shared         = require('./_shared')
    , setToStringTag = require('./_set-to-string-tag')
    , uid            = require('./_uid')
    , wks            = require('./_wks')
    , wksExt         = require('./_wks-ext')
    , wksDefine      = require('./_wks-define')
    , keyOf          = require('./_keyof')
    , enumKeys       = require('./_enum-keys')
    , isArray        = require('./_is-array')
    , anObject       = require('./_an-object')
    , toIObject      = require('./_to-iobject')
    , toPrimitive    = require('./_to-primitive')
    , createDesc     = require('./_property-desc')
    , _create        = require('./_object-create')
    , gOPNExt        = require('./_object-gopn-ext')
    , $GOPD          = require('./_object-gopd')
    , $DP            = require('./_object-dp')
    , $keys          = require('./_object-keys')
    , gOPD           = $GOPD.f
    , dP             = $DP.f
    , gOPN           = gOPNExt.f
    , $Symbol        = global.Symbol
    , $JSON          = global.JSON
    , _stringify     = $JSON && $JSON.stringify
    , PROTOTYPE      = 'prototype'
    , HIDDEN         = wks('_hidden')
    , TO_PRIMITIVE   = wks('toPrimitive')
    , isEnum         = {}.propertyIsEnumerable
    , SymbolRegistry = shared('symbol-registry')
    , AllSymbols     = shared('symbols')
    , OPSymbols      = shared('op-symbols')
    , ObjectProto    = Object[PROTOTYPE]
    , USE_NATIVE     = typeof $Symbol == 'function'
    , QObject        = global.QObject;
  // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

  // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDesc = DESCRIPTORS && $fails(function(){
    return _create(dP({}, 'a', {
      get: function(){ return dP(this, 'a', {value: 7}).a; }
    })).a != 7;
  }) ? function(it, key, D){
    var protoDesc = gOPD(ObjectProto, key);
    if(protoDesc)delete ObjectProto[key];
    dP(it, key, D);
    if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
  } : dP;

  var wrap = function(tag){
    var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
    sym._k = tag;
    return sym;
  };

  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
    return typeof it == 'symbol';
  } : function(it){
    return it instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(it, key, D){
    if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
    anObject(it);
    key = toPrimitive(key, true);
    anObject(D);
    if(has(AllSymbols, key)){
      if(!D.enumerable){
        if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      } return setSymbolDesc(it, key, D);
    } return dP(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P){
    anObject(it);
    var keys = enumKeys(P = toIObject(P))
      , i    = 0
      , l = keys.length
      , key;
    while(l > i)$defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P){
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key){
    var E = isEnum.call(this, key = toPrimitive(key, true));
    if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
    it  = toIObject(it);
    key = toPrimitive(key, true);
    if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
    var D = gOPD(it, key);
    if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it){
    var names  = gOPN(toIObject(it))
      , result = []
      , i      = 0
      , key;
    while(names.length > i){
      if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
    } return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
    var IS_OP  = it === ObjectProto
      , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
      , result = []
      , i      = 0
      , key;
    while(names.length > i){
      if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
    } return result;
  };

  // 19.4.1.1 Symbol([description])
  if(!USE_NATIVE){
    $Symbol = function Symbol(){
      if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
      var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function(value){
        if(this === ObjectProto)$set.call(OPSymbols, value);
        if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      };
      if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
      return wrap(tag);
    };
    redefine($Symbol[PROTOTYPE], 'toString', function toString(){
      return this._k;
    });

    $GOPD.f = $getOwnPropertyDescriptor;
    $DP.f   = $defineProperty;
    require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
    require('./_object-pie').f  = $propertyIsEnumerable;
    require('./_object-gops').f = $getOwnPropertySymbols;

    if(DESCRIPTORS && !require('./_library')){
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }

    wksExt.f = function(name){
      return wrap(wks(name));
    }
  }

  $export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

  for(var symbols = (
    // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

  for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

  $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(key){
      if(isSymbol(key))return keyOf(SymbolRegistry, key);
      throw TypeError(key + ' is not a symbol!');
    },
    useSetter: function(){ setter = true; },
    useSimple: function(){ setter = false; }
  });

  $export($export.S + $export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  });

  // 24.3.2 JSON.stringify(value [, replacer [, space]])
  $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
    var S = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it){
      if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
      var args = [it]
        , i    = 1
        , replacer, $replacer;
      while(arguments.length > i)args.push(arguments[i++]);
      replacer = args[1];
      if(typeof replacer == 'function')$replacer = replacer;
      if($replacer || !isArray(replacer))replacer = function(key, value){
        if($replacer)value = $replacer.call(this, key, value);
        if(!isSymbol(value))return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  });

  // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
  $Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
  // 19.4.3.5 Symbol.prototype[@@toStringTag]
  setToStringTag($Symbol, 'Symbol');
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, 'Math', true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
  },{"./_an-object":605,"./_descriptors":612,"./_enum-keys":615,"./_export":616,"./_fails":617,"./_global":618,"./_has":619,"./_hide":620,"./_is-array":624,"./_keyof":630,"./_library":631,"./_meta":632,"./_object-create":634,"./_object-dp":635,"./_object-gopd":637,"./_object-gopn":639,"./_object-gopn-ext":638,"./_object-gops":640,"./_object-keys":643,"./_object-pie":644,"./_property-desc":646,"./_redefine":647,"./_set-to-string-tag":649,"./_shared":651,"./_to-iobject":655,"./_to-primitive":658,"./_uid":659,"./_wks":662,"./_wks-define":660,"./_wks-ext":661}],677:[function(require,module,exports){
  require('./_wks-define')('asyncIterator');
  },{"./_wks-define":660}],678:[function(require,module,exports){
  require('./_wks-define')('observable');
  },{"./_wks-define":660}],679:[function(require,module,exports){
  require('./es6.array.iterator');
  var global        = require('./_global')
    , hide          = require('./_hide')
    , Iterators     = require('./_iterators')
    , TO_STRING_TAG = require('./_wks')('toStringTag');

  for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
    var NAME       = collections[i]
      , Collection = global[NAME]
      , proto      = Collection && Collection.prototype;
    if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = Iterators.Array;
  }
  },{"./_global":618,"./_hide":620,"./_iterators":629,"./_wks":662,"./es6.array.iterator":666}],680:[function(require,module,exports){
  'use strict'

  exports.byteLength = byteLength
  exports.toByteArray = toByteArray
  exports.fromByteArray = fromByteArray

  var lookup = []
  var revLookup = []
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63

  function placeHoldersCount (b64) {
    var len = b64.length
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
  }

  function byteLength (b64) {
    // base64 is 4/3 + up to two characters of the original data
    return b64.length * 3 / 4 - placeHoldersCount(b64)
  }

  function toByteArray (b64) {
    var i, j, l, tmp, placeHolders, arr
    var len = b64.length
    placeHolders = placeHoldersCount(b64)

    arr = new Arr(len * 3 / 4 - placeHolders)

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len

    var L = 0

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
      arr[L++] = (tmp >> 16) & 0xFF
      arr[L++] = (tmp >> 8) & 0xFF
      arr[L++] = tmp & 0xFF
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
      arr[L++] = tmp & 0xFF
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
      arr[L++] = (tmp >> 8) & 0xFF
      arr[L++] = tmp & 0xFF
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp
    var output = []
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
      output.push(tripletToBase64(tmp))
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    var tmp
    var len = uint8.length
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    var output = ''
    var parts = []
    var maxChunkLength = 16383 // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1]
      output += lookup[tmp >> 2]
      output += lookup[(tmp << 4) & 0x3F]
      output += '=='
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
      output += lookup[tmp >> 10]
      output += lookup[(tmp >> 4) & 0x3F]
      output += lookup[(tmp << 2) & 0x3F]
      output += '='
    }

    parts.push(output)

    return parts.join('')
  }

  },{}],681:[function(require,module,exports){
  (function (global){
  var check = require('./check.js');
  var compare = require('./compare.js');

  /**
   * Throws an Error if there are differences between the two given instances. The
   * error message will contain the difference summary. Compares arrays, booleans,
   * numbers, objects and strings as well as null and undefined by value and other
   * types by reference.
   */
  var assert = function (one, two) {
    var summary;

    summary = compare(one, two, '');

    if (summary !== null) {
      throw new global.Error(summary);
    }
  };

  /**
   * Throws an Error if the given method does not throw when called with the given
   * args for the given instance.
   */
  assert.throws = function (instance, method, args) {
    var unexpected;

    check.function(method);
    check.array(args);

    unexpected = new Error('Expected an error to be thrown!');

    try {
      method.apply(instance, args);

      throw unexpected;
    } catch (error) {
      if (error === unexpected) {
        throw unexpected;
      }
    }
  };

  module.exports = assert;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./check.js":682,"./compare.js":684}],682:[function(require,module,exports){
  (function (global){
  var is = require('./is.js');

  /**
   * Throws a TypeError if the given instance is not an array.
   */
  exports.array = function (instance) {
    if (!is.array(instance)) {
      throw new global.TypeError('Expected array!');
    }
  };

  /**
   * Throws a TypeError if the given instance is not a boolean.
   */
  exports.boolean = function (instance) {
    if (!is.boolean(instance)) {
      throw new global.TypeError('Expected boolean!');
    }
  };

  /**
   * Throws a TypeError if the given instance is not a function.
   */
  exports.function = function (instance) {
    if (!is.function(instance)) {
      throw new global.TypeError('Expected function!');
    }
  };

  /**
   * Throws a TypeError if the given instance is not null.
   */
  exports.null = function (instance) {
    if (!is.null(instance)) {
      throw new global.TypeError('Expected null!');
    }
  };

  /**
   * Throws a TypeError if the given instance is not a number.
   */
  exports.number = function (instance) {
    if (!is.number(instance)) {
      throw new global.TypeError('Expected number!');
    }
  };

  /**
   * Throws a TypeError if the given instance is not an object.
   */
  exports.object = function (instance) {
    if (!is.object(instance)) {
      throw new global.TypeError('Expected object!');
    }
  };

  /**
   * Throws a TypeError if the given instance is not a string.
   */
  exports.string = function (instance) {
    if (!is.string(instance)) {
      throw new global.TypeError('Expected string!');
    }
  };

  /**
   * Throws a TypeError if the given instance does not descend from the given
   * constructor.
   */
  exports.type = function (instance, constructor) {
    if (!is.type(instance, constructor)) {
      throw new global.TypeError('Expected type!');
    }
  };

  /**
   * Throws a TypeError if the given instance is not undefined.
   */
  exports.undefined = function (instance) {
    if (!is.undefined(instance)) {
      throw new global.TypeError('Expected undefined!');
    }
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./is.js":692}],683:[function(require,module,exports){
  (function (global){
  var is = require('./is.js');
  var name = require('./name.js');

  /**
   * Attemps to clone the given instance. Only arrays, booleans, numbers, objects
   * and strings as well as null and undefined are accepted. If any other type is
   * encountered, a TypeError is thrown.
   */
  var clone = function (instance) {
    var array;
    var i;
    var k;
    var l;
    var object;

    if (is.array(instance)) {
      array = [];

      for (i = 0, l = instance.length; i < l; i++) {
        array[i] = clone(instance[i]);
      }

      return array;
    }

    if (is.boolean(instance)) {
      return instance;
    }

    if (is.null(instance)) {
      return instance;
    }

    if (is.number(instance)) {
      return instance;
    }

    if (is.object(instance)) {
      object = {};

      for (k in instance) {
        object[k] = clone(instance[k]);
      }

      return object;
    }

    if (is.string(instance)) {
      return instance;
    }

    if (is.undefined(instance)) {
      return instance;
    }

    throw new global.TypeError('Unexpected type "' + name(instance) + '"!');
  };

  module.exports = clone;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./is.js":692,"./name.js":694}],684:[function(require,module,exports){
  var is = require('./is.js');
  var name = require('./name.js');

  /**
   * Creates a difference summary between the two given instances. Compares
   * arrays, booleans, numbers, objects and strings as well as null and undefined
   * by value and other types by reference. Returns null if the two given
   * instances are identical.
   */
  var compare = function (one, two, prefix) {
    var i;
    var k;
    var l;
    var m;
    var result;
    var summary;

    result = '\n';

    if (!is.string(prefix)) {
      prefix = '';
    }

    if (is.array(one)) {
      if (!is.array(two)) {
        return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
      }

      for (i = 0, l = one.length, m = two.length; i < l && i < m; i++) {
        summary = compare(one[i], two[i], prefix + '    ');

        if (summary !== null) {
          result += prefix + '"' + i + '": ' + summary;
        }
      }

      for (; i < l; i++) {
        result += prefix + '"' + i + '": the item is missing\n';
      }

      for (; i < m; i++) {
        result += prefix + '"' + i + '": the item was not expected\n';
      }

      return result !== '\n' ? result : null;
    }

    if (is.boolean(one)) {
      if (!is.boolean(two)) {
        return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
      }

      if (one.valueOf() !== two.valueOf()) {
        return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
      }

      return null;
    }

    if (is.null(one)) {
      if (!is.null(two)) {
        return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
      }

      return null;
    }

    if (is.number(one)) {
      if (!is.number(two)) {
        return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
      }

      if (one.valueOf() !== two.valueOf()) {
        return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
      }

      return null;
    }

    if (is.object(one)) {
      if (!is.object(two)) {
        return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
      }

      for (k in one) {
        if (!(k in two)) {
          result += prefix + '"' + k + '": the item is missing\n';
        } else {
          summary = compare(one[k], two[k], prefix + '    ');

          if (summary !== null) {
            result += prefix + '"' + k + '": ' + summary;
          }
        }
      }

      for (k in two) {
        if (!(k in one)) {
          result += prefix + '"' + k + '": the item was not expected\n';
        }
      }

      return result !== '\n' ? result : null;
    }

    if (is.string(one)) {
      if (!is.string(two)) {
        return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
      }

      if (one.valueOf() !== two.valueOf()) {
        return 'expected "' + one.valueOf() + '" but found "' + two.valueOf() + '"\n';
      }

      return null;
    }

    if (is.undefined(one)) {
      if (!is.undefined(two)) {
        return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
      }

      return null;
    }

    if (two == null || two.constructor !== one.constructor) {
      return 'expected an instance of type "' + name(one) + '"\n';
    } else {
      if (one !== two) {
        return 'expected a different instance of type "' + name(one) + '"\n';
      }
    }

    return null;
  };

  module.exports = compare;

  },{"./is.js":692,"./name.js":694}],685:[function(require,module,exports){
  var is = require('./is.js');

  /**
   * Checks whether the given actual json conforms to the given schema. This
   * asserts that all required fields are present and have the correct types. It
   * also asserts that all optional fields either are present and have the correct
   * types or are missing in the given actual json.
   */
  var conforms = function (actual, schema, verbose, path) {
    var i;
    var l;
    var result;
    var k;
    var parts;

    if (!is.boolean(verbose)) {
      verbose = false;
    }

    if (!is.string(path)) {
      path = 'root';
    }

    if (is.array(schema)) {
      if (is.array(actual)) {
        if (schema.length === 0) {
          return true;
        }

        if (schema.length !== 1) {
          if (verbose) {
            console.warn(path + ': expected an array with exactly one element in the schema but found ' + schema.length + ' elements');
          }

          return false;
        }

        result = true;

        for (i = 0, l = actual.length; i < l; i++) {
          if (!conforms(actual[i], schema[0], verbose, path + '[' + i + ']')) {
            result = false;
          }
        }

        return result;
      } else {
        if (verbose) {
          console.warn(path + ': expected an array but found', actual);
        }

        return false;
      }
    }

    if (is.boolean(schema)) {
      if (is.boolean(actual)) {
        return true;
      } else {
        if (verbose) {
          console.warn(path + ': expected a boolean but found', actual);
        }

        return false;
      }
    }

    if (is.number(schema)) {
      if (is.number(actual)) {
        return true;
      } else {
        if (verbose) {
          console.warn(path + ': expected a number but found', actual);
        }

        return false;
      }
    }

    if (is.object(schema)) {
      if (is.object(actual)) {
        result = true;

        for (k in schema) {
          parts = /^([^?]+)\?$/.exec(k);

          if (parts === null) {
            if (!conforms(actual[k], schema[k], verbose, path + '.' + k)) {
              result = false;
            }
          } else {
            if (actual[parts[1]] != null) {
              if (!conforms(actual[parts[1]], schema[k], verbose, path + '.' + k)) {
                result = false;
              }
            }
          }
        }

        return result;
      } else {
        if (verbose) {
          console.warn(path + ': expected an object but found', actual);
        }

        return false;
      }
    }

    if (is.string(schema)) {
      if (is.string(actual)) {
        return true;
      } else {
        if (verbose) {
          console.warn(path + ': expected a string but found', actual);
        }

        return false;
      }
    }

    if (verbose) {
      console.warn(path + ': expected a supported type in the schema but found', schema);
    }

    return false;
  };

  module.exports = conforms;

  },{"./is.js":692}],686:[function(require,module,exports){
  (function (global){
  var check = require('./check.js');

  /**
   * Makes base a pure class.
   */
  var define = function (base) {
    check.function(base);

    base.prototype = global.Object.create(null);
    base.prototype.constructor = base;
  };

  module.exports = define;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./check.js":682}],687:[function(require,module,exports){
  var is = require('./is.js');
  var name = require('./name.js');

  /**
   * Determines if the two given instances are identical. Compares arrays,
   * booleans, numbers, objects and strings as well as null and undefined by value
   * and other types by reference.
   */
  var equals = function (one, two) {
    var i;
    var k;
    var l;

    if (is.array(one)) {
      if (!is.array(two)) {
        return false;
      }

      if (one.length !== two.length) {
        return false;
      }

      for (i = 0, l = one.length; i < l; i++) {
        if (!equals(one[i], two[i])) {
          return false;
        }
      }

      return true;
    }

    if (is.boolean(one)) {
      if (!is.boolean(two)) {
        return false;
      }

      if (one.valueOf() !== two.valueOf()) {
        return false;
      }

      return true;
    }

    if (is.null(one)) {
      if (!is.null(two)) {
        return false;
      }

      return true;
    }

    if (is.number(one)) {
      if (!is.number(two)) {
        return false;
      }

      if (one.valueOf() !== two.valueOf()) {
        return false;
      }

      return true;
    }

    if (is.object(one)) {
      if (!is.object(two)) {
        return false;
      }

      for (k in one) {
        if (!(k in two)) {
          return false;
        }

        if (!equals(one[k], two[k])) {
          return false;
        }
      }

      for (k in two) {
        if (!(k in one)) {
          return false;
        }
      }

      return true;
    }

    if (is.string(one)) {
      if (!is.string(two)) {
        return false;
      }

      if (one.valueOf() !== two.valueOf()) {
        return false;
      }

      return true;
    }

    if (is.undefined(one)) {
      if (!is.undefined(two)) {
        return false;
      }

      return true;
    }

    return one === two;
  };

  module.exports = equals;

  },{"./is.js":692,"./name.js":694}],688:[function(require,module,exports){
  (function (global){
  var check = require('./check.js');

  /**
   * Makes derived extend base.
   */
  var extend = function (derived, base) {
    check.function(derived);
    check.function(base);

    derived.prototype = global.Object.create(base.prototype);
    derived.prototype.constructor = derived;
  };

  module.exports = extend;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./check.js":682}],689:[function(require,module,exports){
  var is = require('./is.js');

  /**
   * Returns the given fallback if the given instance is not an array.
   */
  exports.array = function (instance, fallback) {
    return is.array(instance) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance is not a boolean.
   */
  exports.boolean = function (instance, fallback) {
    return is.boolean(instance) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance is not a function.
   */
  exports.function = function (instance, fallback) {
    return is.function(instance) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance is not null.
   */
  exports.null = function (instance, fallback) {
    return is.null(instance) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance is not a number.
   */
  exports.number = function (instance, fallback) {
    return is.number(instance) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance is not an object.
   */
  exports.object = function (instance, fallback) {
    return is.object(instance) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance is not a string.
   */
  exports.string = function (instance, fallback) {
    return is.string(instance) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance does not descend from the
   * given constructor.
   */
  exports.type = function (instance, constructor, fallback) {
    return is.type(instance, constructor) ? instance : fallback;
  };

  /**
   * Returns the given fallback if the given instance is not undefined.
   */
  exports.undefined = function (instance, fallback) {
    return is.undefined(instance) ? instance : fallback;
  };

  },{"./is.js":692}],690:[function(require,module,exports){
  /**
   * Creates a function wrapper that always returns the given value.
   */
  var fixture = function (value) {
    return function () {
      return value;
    };
  };

  module.exports = fixture;

  },{}],691:[function(require,module,exports){
  exports.assert = require('./assert.js');
  exports.check = require('./check.js');
  exports.clone = require('./clone.js');
  exports.compare = require('./compare.js');
  exports.conforms = require('./conforms.js');
  exports.define = require('./define.js');
  exports.equals = require('./equals.js');
  exports.extend = require('./extend.js');
  exports.fallback = require('./fallback.js');
  exports.fixture = require('./fixture.js');
  exports.is = require('./is.js');
  exports.mock = require('./mock.js');
  exports.name = require('./name.js');
  // exports.spy = require('./spy.js');
  exports.stub = require('./stub.js');

  },{"./assert.js":681,"./check.js":682,"./clone.js":683,"./compare.js":684,"./conforms.js":685,"./define.js":686,"./equals.js":687,"./extend.js":688,"./fallback.js":689,"./fixture.js":690,"./is.js":692,"./mock.js":693,"./name.js":694,"./spy.js":695,"./stub.js":696}],692:[function(require,module,exports){
  (function (global){
  /**
   * Determines if the given instance is an array.
   */
  exports.array = function (instance) {
    return instance != null && instance.constructor === global.Array;
  };

  /**
   * Determines if the given instance is a boolean.
   */
  exports.boolean = function (instance) {
    return instance != null && instance.constructor === global.Boolean;
  };

  /**
   * Determines if the given instance is a function.
   */
  exports.function = function (instance) {
    return instance != null && instance.constructor === global.Function;
  };

  /**
   * Determines if the given instance is null.
   */
  exports.null = function (instance) {
    return instance === null;
  };

  /**
   * Determines if the given instance is a number.
   */
  exports.number = function (instance) {
    return instance != null && instance.constructor === global.Number;
  };

  /**
   * Determines if the given instance is an object.
   */
  exports.object = function (instance) {
    return instance != null && instance.constructor === global.Object;
  };

  /**
   * Determines if the given instance is a string.
   */
  exports.string = function (instance) {
    return instance != null && instance.constructor === global.String;
  };

  /**
   * Determines if the given instance descends from the given constructor.
   */
  exports.type = function (instance, constructor) {
    return instance != null && constructor != null && instance instanceof constructor;
  };

  /**
   * Determines if the given instance is undefined.
   */
  exports.undefined = function (instance) {
    return instance === global.undefined;
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],693:[function(require,module,exports){
  (function (global){
  var check = require('./check.js');
  var extend = require('./extend.js');
  var is = require('./is.js');

  /**
   * Creates a mock for the given base class with the given implementation that
   * can be used for unit testing. The methods defined on implementation will be
   * used instead of the methods defined on the base class.
   */
  var mock = function (base, implementation) {
    var derived;
    var keys;
    var i;
    var key;

    check.function(base);

    derived = function () {
      base.apply(this, arguments);
    };

    extend(derived, base);

    derived.create = function () {
      var that;

      that = global.Object.create(derived.prototype);

      derived.apply(that, arguments);

      return that;
    };

    if (implementation != null) {
      check.object(implementation);

      keys = global.Object.getOwnPropertyNames(implementation);

      for (i = 0; i < keys.length; i++) {
        key = keys[i];

        if (key !== 'constructor' && is.function(implementation[key])) {
          if (is.function(base.prototype[key])) {
            derived.prototype[key] = implementation[key];
          } else {
            throw new global.Error('Method "' + key + '" doesn\'t override any method defined on the base class!');
          }
        }
      }
    }

    return derived;
  };

  module.exports = mock;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./check.js":682,"./extend.js":688,"./is.js":692}],694:[function(require,module,exports){
  var is = require('./is.js');

  /**
   * Attempts to read the type name for the given instance.
   */
  var name = function (instance) {
    if (is.null(instance)) {
      return 'Null';
    }

    if (is.undefined(instance)) {
      return 'Undefined';
    }

    if (is.function(instance.constructor) && is.string(instance.constructor.name)) {
      return instance.constructor.name;
    }

    return '';
  };

  module.exports = name;

  },{"./is.js":692}],695:[function(require,module,exports){
  (function (global){
  var check = require('./check.js');

  /**
   * Creates a spy function that records all function calls into the given calls
   * array.
   */
  var spy = function (calls) {
    check.array(calls);

    return function () {
      calls.push({ 'caller' : this, 'arguments' : global.Array.prototype.slice.call(arguments) });
    };
  };

  module.exports = spy;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./check.js":682}],696:[function(require,module,exports){
  (function (global){
  var check = require('./check.js');
  var extend = require('./extend.js');
  var is = require('./is.js');

  /**
   * Creates a stub for the given base class with the given implementation that
   * can be used for unit testing.
   */
  var stub = function (base, implementation) {
    var derived;
    var prototype;
    var keys;
    var i;
    var key;

    check.function(base);
    check.object(implementation);

    derived = function () {
      var key;

      for (key in implementation) {
        this[key] = implementation[key];
      }
    };

    extend(derived, base);

    derived.create = function () {
      var that;

      that = global.Object.create(derived.prototype);

      derived.apply(that, arguments);

      return that;
    };

    prototype = base.prototype;

    while (prototype != null && prototype !== global.Object.prototype) {
      keys = global.Object.getOwnPropertyNames(prototype);

      for (i = 0; i < keys.length; i++) {
        key = keys[i];

        if (key !== 'constructor' && is.function(prototype[key])) {
          if (is.function(implementation[key])) {
            derived.prototype[key] = implementation[key];
          } else {
            derived.prototype[key] = (function (key) {
              return function () {
                throw new global.Error('Method stub "' + key + '" called!');
              };
            })(key);
          }
        }
      }

      prototype = global.Object.getPrototypeOf(prototype);
    }

    return derived;
  };

  module.exports = stub;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./check.js":682,"./extend.js":688,"./is.js":692}],697:[function(require,module,exports){
  (function (global){
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict'

  var base64 = require('base64-js')
  var ieee754 = require('ieee754')
  var isArray = require('isarray')

  exports.Buffer = Buffer
  exports.SlowBuffer = SlowBuffer
  exports.INSPECT_MAX_BYTES = 50

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
    ? global.TYPED_ARRAY_SUPPORT
    : typedArraySupport()

  /*
   * Export kMaxLength after typed array support is determined.
   */
  exports.kMaxLength = kMaxLength()

  function typedArraySupport () {
    try {
      var arr = new Uint8Array(1)
      arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
      return arr.foo() === 42 && // typed array instances can be augmented
          typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
          arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
    } catch (e) {
      return false
    }
  }

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length)
      that.__proto__ = Buffer.prototype
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length)
      }
      that.length = length
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192 // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype
    return arr
  }

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype
    Buffer.__proto__ = Uint8Array
    if (typeof Symbol !== 'undefined' && Symbol.species &&
        Buffer[Symbol.species] === Buffer) {
      // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true
      })
    }
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size)
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  }

  function allocUnsafe (that, size) {
    assertSize(size)
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  }
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  }

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8'
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0
    that = createBuffer(that, length)

    var actual = that.write(string, encoding)

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual)
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0
    that = createBuffer(that, length)
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array)
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset)
    } else {
      array = new Uint8Array(array, byteOffset, length)
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array
      that.__proto__ = Buffer.prototype
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array)
    }
    return that
  }

  function fromObject (that, obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0
      that = createBuffer(that, len)

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len)
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }

  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0
    }
    return Buffer.alloc(+length)
  }

  Buffer.isBuffer = function isBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length
    var y = b.length

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i]
        y = b[i]
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  }

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  }

  Buffer.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i
    if (length === undefined) {
      length = 0
      for (i = 0; i < list.length; ++i) {
        length += list[i].length
      }
    }

    var buffer = Buffer.allocUnsafe(length)
    var pos = 0
    for (i = 0; i < list.length; ++i) {
      var buf = list[i]
      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos)
      pos += buf.length
    }
    return buffer
  }

  function byteLength (string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string
    }

    var len = string.length
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }
  Buffer.byteLength = byteLength

  function slowToString (encoding, start, end) {
    var loweredCase = false

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0
    start >>>= 0

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8'

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase()
          loweredCase = true
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true

  function swap (b, n, m) {
    var i = b[n]
    b[n] = b[m]
    b[m] = i
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1)
    }
    return this
  }

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3)
      swap(this, i + 1, i + 2)
    }
    return this
  }

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7)
      swap(this, i + 1, i + 6)
      swap(this, i + 2, i + 5)
      swap(this, i + 3, i + 4)
    }
    return this
  }

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  }

  Buffer.prototype.equals = function equals (b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  }

  Buffer.prototype.inspect = function inspect () {
    var str = ''
    var max = exports.INSPECT_MAX_BYTES
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
      if (this.length > max) str += ' ... '
    }
    return '<Buffer ' + str + '>'
  }

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0
    }
    if (end === undefined) {
      end = target ? target.length : 0
    }
    if (thisStart === undefined) {
      thisStart = 0
    }
    if (thisEnd === undefined) {
      thisEnd = this.length
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0
    end >>>= 0
    thisStart >>>= 0
    thisEnd >>>= 0

    if (this === target) return 0

    var x = thisEnd - thisStart
    var y = end - start
    var len = Math.min(x, y)

    var thisCopy = this.slice(thisStart, thisEnd)
    var targetCopy = target.slice(start, end)

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i]
        y = targetCopy[i]
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  }

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset
      byteOffset = 0
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000
    }
    byteOffset = +byteOffset  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1)
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding)
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1
    var arrLength = arr.length
    var valLength = val.length

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase()
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2
        arrLength /= 2
        valLength /= 2
        byteOffset /= 2
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i
    if (dir) {
      var foundIndex = -1
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex
          foundIndex = -1
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
      for (i = byteOffset; i >= 0; i--) {
        var found = true
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  }

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  }

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  }

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0
    var remaining = buf.length - offset
    if (!length) {
      length = remaining
    } else {
      length = Number(length)
      if (length > remaining) {
        length = remaining
      }
    }

    // must be an even number of digits
    var strLen = string.length
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16)
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8'
      length = this.length
      offset = 0
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset
      length = this.length
      offset = 0
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0
      if (isFinite(length)) {
        length = length | 0
        if (encoding === undefined) encoding = 'utf8'
      } else {
        encoding = length
        length = undefined
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset
    if (length === undefined || length > remaining) length = remaining

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8'

    var loweredCase = false
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase()
          loweredCase = true
      }
    }
  }

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  }

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf)
    } else {
      return base64.fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end)
    var res = []

    var i = start
    while (i < end) {
      var firstByte = buf[i]
      var codePoint = null
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte
            }
            break
          case 2:
            secondByte = buf[i + 1]
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint
              }
            }
            break
          case 3:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint
              }
            }
            break
          case 4:
            secondByte = buf[i + 1]
            thirdByte = buf[i + 2]
            fourthByte = buf[i + 3]
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD
        bytesPerSequence = 1
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000
        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
        codePoint = 0xDC00 | codePoint & 0x3FF
      }

      res.push(codePoint)
      i += bytesPerSequence
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = ''
    var i = 0
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      )
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = ''
    end = Math.min(buf.length, end)

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F)
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = ''
    end = Math.min(buf.length, end)

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i])
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length

    if (!start || start < 0) start = 0
    if (!end || end < 0 || end > len) end = len

    var out = ''
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i])
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end)
    var res = ''
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length
    start = ~~start
    end = end === undefined ? len : ~~end

    if (start < 0) {
      start += len
      if (start < 0) start = 0
    } else if (start > len) {
      start = len
    }

    if (end < 0) {
      end += len
      if (end < 0) end = 0
    } else if (end > len) {
      end = len
    }

    if (end < start) end = start

    var newBuf
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end)
      newBuf.__proto__ = Buffer.prototype
    } else {
      var sliceLen = end - start
      newBuf = new Buffer(sliceLen, undefined)
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start]
      }
    }

    return newBuf
  }

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0
    byteLength = byteLength | 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    var val = this[offset]
    var mul = 1
    var i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }

    return val
  }

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0
    byteLength = byteLength | 0
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length)
    }

    var val = this[offset + --byteLength]
    var mul = 1
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul
    }

    return val
  }

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length)
    return this[offset]
  }

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length)
    return this[offset] | (this[offset + 1] << 8)
  }

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length)
    return (this[offset] << 8) | this[offset + 1]
  }

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length)

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  }

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  }

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0
    byteLength = byteLength | 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    var val = this[offset]
    var mul = 1
    var i = 0
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul
    }
    mul *= 0x80

    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

    return val
  }

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0
    byteLength = byteLength | 0
    if (!noAssert) checkOffset(offset, byteLength, this.length)

    var i = byteLength
    var mul = 1
    var val = this[offset + --i]
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul
    }
    mul *= 0x80

    if (val >= mul) val -= Math.pow(2, 8 * byteLength)

    return val
  }

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length)
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  }

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length)
    var val = this[offset] | (this[offset + 1] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length)
    var val = this[offset + 1] | (this[offset] << 8)
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  }

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  }

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length)

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  }

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, true, 23, 4)
  }

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length)
    return ieee754.read(this, offset, false, 23, 4)
  }

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, true, 52, 8)
  }

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length)
    return ieee754.read(this, offset, false, 52, 8)
  }

  function checkInt (buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset | 0
    byteLength = byteLength | 0
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }

    var mul = 1
    var i = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset | 0
    byteLength = byteLength | 0
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1
      checkInt(this, value, offset, byteLength, maxBytes, 0)
    }

    var i = byteLength - 1
    var mul = 1
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
    this[offset] = (value & 0xff)
    return offset + 1
  }

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
    } else {
      objectWriteUInt16(this, value, offset, true)
    }
    return offset + 2
  }

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
    } else {
      objectWriteUInt16(this, value, offset, false)
    }
    return offset + 2
  }

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24)
      this[offset + 2] = (value >>> 16)
      this[offset + 1] = (value >>> 8)
      this[offset] = (value & 0xff)
    } else {
      objectWriteUInt32(this, value, offset, true)
    }
    return offset + 4
  }

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
    } else {
      objectWriteUInt32(this, value, offset, false)
    }
    return offset + 4
  }

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1)

      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }

    var i = 0
    var mul = 1
    var sub = 0
    this[offset] = value & 0xFF
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1)

      checkInt(this, value, offset, byteLength, limit - 1, -limit)
    }

    var i = byteLength - 1
    var mul = 1
    var sub = 0
    this[offset + i] = value & 0xFF
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
    }

    return offset + byteLength
  }

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
    if (value < 0) value = 0xff + value + 1
    this[offset] = (value & 0xff)
    return offset + 1
  }

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
    } else {
      objectWriteUInt16(this, value, offset, true)
    }
    return offset + 2
  }

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
    } else {
      objectWriteUInt16(this, value, offset, false)
    }
    return offset + 2
  }

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      this[offset + 2] = (value >>> 16)
      this[offset + 3] = (value >>> 24)
    } else {
      objectWriteUInt32(this, value, offset, true)
    }
    return offset + 4
  }

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value
    offset = offset | 0
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
    if (value < 0) value = 0xffffffff + value + 1
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
    } else {
      objectWriteUInt32(this, value, offset, false)
    }
    return offset + 4
  }

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4)
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  }

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  }

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8)
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  }

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  }

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0
    if (!end && end !== 0) end = this.length
    if (targetStart >= target.length) targetStart = target.length
    if (!targetStart) targetStart = 0
    if (end > 0 && end < start) end = start

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start
    }

    var len = end - start
    var i

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start]
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start]
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      )
    }

    return len
  }

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start
        start = 0
        end = this.length
      } else if (typeof end === 'string') {
        encoding = end
        end = this.length
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0)
        if (code < 256) {
          val = code
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0
    end = end === undefined ? this.length : end >>> 0

    if (!val) val = 0

    var i
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val
      }
    } else {
      var bytes = Buffer.isBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString())
      var len = bytes.length
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len]
      }
    }

    return this
  }

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '')
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '='
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity
    var codePoint
    var length = string.length
    var leadSurrogate = null
    var bytes = []

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i)

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            continue
          }

          // valid lead
          leadSurrogate = codePoint

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      }

      leadSurrogate = null

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint)
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        )
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = []
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF)
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo
    var byteArray = []
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i)
      hi = c >> 8
      lo = c % 256
      byteArray.push(lo)
      byteArray.push(hi)
    }

    return byteArray
  }

  function base64ToBytes (str) {
    return base64.toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i]
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"base64-js":680,"ieee754":747,"isarray":749}],698:[function(require,module,exports){
  /*!
    Copyright (c) 2016 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  /* global define */

  (function () {
    'use strict';

    var hasOwn = {}.hasOwnProperty;

    function classNames () {
      var classes = [];

      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg) continue;

        var argType = typeof arg;

        if (argType === 'string' || argType === 'number') {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          classes.push(classNames.apply(null, arg));
        } else if (argType === 'object') {
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }

      return classes.join(' ');
    }

    if (typeof module !== 'undefined' && module.exports) {
      module.exports = classNames;
    } else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
      // register as 'classnames', consistent with npm package name
      define('classnames', [], function () {
        return classNames;
      });
    } else {
      window.classNames = classNames;
    }
  }());

  },{}],699:[function(require,module,exports){
  'use strict';

  exports.message = require('./src/message');
  exports.request = require('./src/request');
  exports.response = require('./src/response');
  exports.playerstate = require('./src/player_state');

  },{"./src/message":700,"./src/player_state":701,"./src/request":702,"./src/response":703}],700:[function(require,module,exports){
  /**
   * A set of Message headers.
   *
   * @name exports.Headers
   * @typedef {Object.<string, string>}
   */
  exports.Headers;

  /**
   * A body of a Request-Response.
   *
   * @name exports.Body
   * @typedef {*}
   */
  exports.Body;

  /**
   * A serialized Message object.
   *
   * @name Spotify.Cosmos.SerializedMessage
   * @typedef {{
   *   uri: Spotify.Cosmos.URI,
   *   headers: Spotify.Cosmos.Headers,
   *   body: Spotify.Cosmos.Body
   * }}
   */
  exports.SerializedMessage;

  /**
   * Encapsulates a message.
   *
   * A message is an entity that has a URI, headers and a body.
   *
   * @constructs Spotify.Cosmos.Message
   * @param {Spotify.Cosmos.URI} uri The URI of the message
   * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
   *     message.
   * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
   */
  function Message(uri, opt_headers, opt_body) {
    if (uri == null)
      throw new TypeError('Invalid `uri` argument for Message.');

    /**
     * The URI of the Message.
     *
     * @type {Spotify.Cosmos.URI}
     * @protected
     */
    this._uri = uri;

    /**
     * The headers of the Message.
     *
     * @type {Spotify.Cosmos.Headers}
     * @protected
     */
    this._headers = {};

    /**
     * The body of the Message.
     *
     * @type {Spotify.Cosmos.Body}
     * @protected
     */
    this._body = this._encodeBody(opt_body || '');

    if (opt_headers) this._setHeaders(opt_headers);
  }
  exports.Message = Message;

  /**
   * Creates a new Message from a SerializedMessage object.
   *
   * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
   * @return {Spotify.Cosmos.Message|null} The new Message object or null.
   */
  Message.fromObject = function(object) {
    return (object && object.uri) ?
      new Message(
          object.uri,
          object.headers,
          object.body
      ) : null;
  };

  /**
   * Encodes a message body to a string.
   *
   * @param {*} body The value for the body.
   * @return {string} The body encoded as a string.
   */
  Message.prototype._encodeBody = function(body) {
    if (typeof body != 'string') {
      body = JSON.stringify(body);
    }
    return body;
  };

  /**
   * Returns the URI of the message.
   *
   * @return {Spotify.Cosmos.URI} The URI of the message.
   */
  Message.prototype.getURI = function() {
    return this._uri;
  };

  /**
   * Returns the mimetype of the message.
   *
   * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
   */
  Message.prototype.getMimeType = function() {
    return this._headers['accept'];
  };

  /**
   * Returns the value of a message's headers.
   *
   * @param {string} name The name of the header.
   * @return {string|null} The header value or null if the header wasn't set.
   */
  Message.prototype.getHeader = function(name) {
    return this._headers[name.toLowerCase()] || null;
  };

  /**
   * Returns the headers of the message.
   *
   * @return {Spotify.Cosmos.Headers} The headers of the message.
   */
  Message.prototype.getHeaders = function() {
    var _headers = this._headers;
    var headers = {};
    for (var name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    return headers;
  };

  /**
   * Sets a bunch of headers to the message's headers.
   *
   * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
   * @protected
   */
  Message.prototype._setHeaders = function(headers) {
    var _headers = this._headers;
    for (var name in headers) {
      if (!headers.hasOwnProperty(name)) continue;
      _headers[name.toLowerCase()] = headers[name];
    }
    return this;
  };

  /**
   * Returns the body of the message.
   *
   * @return {Spotify.Cosmos.Body} The body of the message.
   */
  Message.prototype.getBody = function() {
    return this._body;
  };

  /**
   * Returns the body as a JSON object.
   *
   * @return {Object|null} The body of the message parsed as a JSON value. Can
   *     be null if the body is not a proper JSON string.
   */
  Message.prototype.getJSONBody = function() {
    try {
      return JSON.parse(this._body);
    } catch(e) {
      return null;
    }
  };

  /**
   * Creates a new Message instance with data copied from the current instance.
   *
   * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
   *     message.
   * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
   */
  Message.prototype.copy = function(opt_headers, opt_body) {
    return new Message(
        this._uri,
        this._copyHeaders(opt_headers),
        typeof opt_body != 'undefined' ? opt_body : this._body
    );
  };

  /**
   * Copies the headers of the message.
   *
   * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
   *     message.
   * @return {Spotify.Cosmos.Headers} The headers of the message.
   */
  Message.prototype._copyHeaders = function(opt_headers) {
    var headers;
    if (opt_headers) {
      var _headers = this._headers;
      var name;
      headers = {};
      for (name in _headers) {
        if (!_headers.hasOwnProperty(name)) continue;
        headers[name] = _headers[name];
      }
      for (name in opt_headers) {
        if (!opt_headers.hasOwnProperty(name)) continue;
        headers[name.toLowerCase()] = opt_headers[name];
      }
    } else {
      headers = this._headers;
    }
    return headers;
  };

  /**
   * Serializes the message into a plain object.
   *
   * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
   */
  Message.prototype.serialize = function() {
    return this.toJSON();
  };

  /**
   * Returns a JSON-object representation of the message.
   *
   * @return {Object} The JSON representation of the message.
   */
  Message.prototype.toJSON = function() {
    return {
      uri: this._uri,
      headers: this._headers,
      body: this._body
    };
  };

  },{}],701:[function(require,module,exports){
  var inherit = require('spotify-inheritance').inherit;

  /**
   * PlayerState is used for two distinct purposes: Pushing new state to the
   * player (this is done when you request to play a completely new context with
   * 'play' method) and retrieving player state updates.
   *
   * Changing properties on PlayerState objects will not change the state of
   * the player unless you pass it to the 'play' method.
   *
   * @param {Object} stateData the data for the playerState.
   */
  function PlayerState(stateData) {
    Serializable.call(this, [
      'action',
      'context',
      'tracks',
      'index',
      'playing',
      'loading',
      'track',
      'position',
      'duration',
      'volume',
      'options',
      'play_origin',
      'next_page_url',
      'prev_page_url'
    ]);

    stateData = stateData || {};
    /**
     * What kind of the action player should perform.
     * It's set directly before sending the request.
     * @type {String}
     */
    this.action = stateData.action;

    /**
     * Spotify uri describing the context that
     * will be played e.g playlist, album or artist.
     * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
     * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
     * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
     *
     * @type {String}
     */
    this.context = stateData.context;

    /**
     * The list of tracks uris to play in the given context.
     * Example: [
     *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
     *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
     *    spotify:track:6rxEjkoar48SssZePbtb2x
     * ]
     *
     * @type {Array.<String>}
     */
    this.tracks = stateData.tracks;

    /**
     * Which element on the this.tracks list should
     * be played.
     *
     * @type {Number}
     */
    this.index = stateData.index;

    /**
     * Is the player currently playing
     */
    this.playing = stateData.playing;
    this.loading = stateData.loading;

    /**
     * Current track URI
     * @type {String}
     */
    this.track = stateData.track;


    this.position = stateData.position;

    this.volume = stateData.volume;

    /**
     * Current track duration in miliseconds?
     * @type {Number}
     */
    this.duration = stateData.duration;

    /**
     * See PlayOptions description
     * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
     */
    this.options = new PlayOptions(stateData.options);

    /**
     * See PlayOrigin description
     * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
     */
    this.play_origin = new PlayOrigin(stateData.play_origin);

    /**
     * Before the list of tracks that are to be played ends, a request will be sent
     * to this URL, which is supposed to return a list of tracks. That list of
     * tracks will then be appended to the list of tracks in the context.
     *
     * The response payload of the next_page_url should look like this:
     *
     * {
     *   "tracks": [
     *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
     *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
     *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
     *   ],
     *   "next_page_url": "...", // Optional
     *   "prev_page_url": "..." // Optional
     * }
     *
     * May be null, which is the same as a URL that would return an empty list
     * of tracks (but with null, no network request is made).
     */
    this.next_page_url = stateData.next_page_url;

    /**
     * Like `next_page_url`, but for going backwards in the context.
     */
    this.prev_page_url = stateData.prev_page_url;
  }
  inherit(PlayerState, Serializable);

  /**
   * Ovverides prototype method.
   * Converts play options and origin to
   * serializable to make sure only correct data
   * is returned.
   * @return {Object} Data associated with player state.
   */
  PlayerState.prototype.serialize = function() {
    if (this.options && !(this.options instanceof PlayOptions)) {
      this.options = new PlayOptions(this.options);
    }

    if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
      this.play_origin = new PlayOrigin(this.play_origin);
    }

    return this.constructor.prototype.serialize.call(this);
  };

  /**
   * Possible player actions.
   */
  PlayerState.ACTIONS = {
    UNKNOWN: 'unknown',
    PLAY: 'play',
    UPDATE: 'update',
    STOP: 'stop',
    RESUME: 'resume',
    PAUSE: 'pause',
    SKIP_PREV: 'skip_prev',
    SKIP_NEXT: 'skip_next'
  };

  function PlayOrigin(data) {
    Serializable.call(this, [
      'source',
      'source_context',
      'reason',
      'referrer',
      'referrer_version',
      'referrer_vendor'
    ]);

    data = data || {};

    /**
     * What kind of playlist did we play from?
     *
     * The default value of this property is "unknown". Must have a value.
     *
     * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
     * 'radio', 'search', 'unknown'.
     *
     * For an up to date list of valid values, see `PLAY_SOURCES` in
     * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
     */
    this.source = data.source || 'unknown';

    /**
     * The uri of the view that initiated the playback.
     */
    this.source_context = data.source_context || 'unknown';

    /**
     * Why was the song started?
     *
     * The default value of this property is "unknown". Must have a value.
     *
     * A list of valid values that might be used by features:
     *
     * unknown    = Client doesn't know
     * clickrow   = A row in the song list was clicked/opened
     * playbtn    = The play button was pressed
     * urlopen    = A Url was opened
     *
     * For a complete and up to date list of valid values, see `PLAY_REASONS` in
     * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
     */
    this.reason = data.reason || 'unknown';

    /**
     * Either a remote site or a spotify app which initiated the request.
     *
     * NOTE: This normally should be a readonly property and not be set
     * explicitly in the PlayerState as the Player will overwrite it when sending the request.
     */
    this.referrer = data.referrer || 'unknown';

    /**
     * The version of the referrer, where applicable. It usually makes sense to
     * set this value to the version of the JS app version, for instance "0.7.5".
     *
     * NOTE: This normally should be a readonly property and not be set
     * explicitly in the PlayerState as the Player will overwrite it when sending the request.
     */
    this.referrer_version = data.referrer_version || 'unknown';

    /**
     * The vendor of the referrer, where applicable.
     * For example com.soundrop, com.spotify.
     *
     * NOTE: This normally should be a readonly property and not be set
     * explicitly in the PlayerState as the Player will overwrite it when sending the request.
     */
    this.referrer_vendor = data.referrer_vendor || 'unknown';
  }
  inherit(PlayOrigin, Serializable);

  /**
   * What kind of options user has
   * with the player. By default
   * all 'can_*' properties are set to true.
   * You might want to restrict some of them
   * in the special cases like ads (no skipping)
   * or radio no skipping prev.
   * @constructor
   * @param {Object} options The options data.
   */
  function PlayOptions(options) {
    Serializable.call(this, [
      'repeat',
      'shuffle',
      'can_repeat',
      'can_shuffle',
      'can_skip_prev',
      'can_skip_next',
      'can_seek',
      'use_dmca_rules'
    ]);
    options = options || {};

    /**
     * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
     *
     * Default value is false
     */
    this.repeat = options.repeat !== undefined ? options.repeat : false;

    /**
     * True if shuffle is (or is to be) enabled.
     *
     * Default value is false
     */
    this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

    /**
     * True if this context can be repeated. This would be false for instance in the
     * case of radio.
     *
     * Default value is true.
     */
    this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

    /**
     * True if this context can be shuffled. This would be false for instance in the
     * case of radio.
     *
     * Default value is true.
     */
    this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

    /**
     * True if the user is (or should be) allowed to skip to the previous track.
     *
     * Default value is true.
     */
    this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

    /**
     * True if the user is (or should be) allowed to skip to the next track.
     *
     * Default value is true.
     */
    this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

    /**
     * True if the user is (or should be) allowed to seek to a certain time in the
     * currently playing track.
     *
     * Default value is true.
     */
    this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

    /**
     * True if the track player should automatically apply DMCA rules when playing.
     * DMCA rules should be enabled for users that have free radio in the US, and
     * controls how many tracks the user are allowed to skip etc.
     *
     * Default value is false.
     */
    this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
  }
  inherit(PlayOptions, Serializable);

  /**
   * The object accepting only defined properties.
   * To make sure only valid properties are passed
   * always use 'serialize()' when object value needed.
   * @constructor
   * @param {Array.<string>} allowedProps The list of the properties
   * that are supported for the object.
   */
  function Serializable(allowedProps) {
    this._props = allowedProps || [];
  }

  /**
   * The JSON representation of the object.
   * @return {Object} Data associated with current player state.
   */
  Serializable.prototype.serialize = function() {
    var data = {};
    var prop;

    for (var i = 0, l = this._props.length; i < l; i++) {
      prop = this._props[i];
      if (this[prop] !== undefined) {
        if (this[prop] instanceof Serializable) {
          data[prop] = this[prop].serialize();
        } else {
          data[prop] = this[prop];
        }
      }
    }

    return data;
  };

  exports.PlayerState = PlayerState;

  },{"spotify-inheritance":1279}],702:[function(require,module,exports){
  var inherit = require('spotify-inheritance').inherit;

  var Message = require('./message').Message;

  /**
   * Request actions.
   *
   * @name exports.Action
   * @enum {string}
   */
  exports.Action = {
    DELETE: 'DELETE',
    GET: 'GET',
    HEAD: 'HEAD',
    POST: 'POST',
    PUT: 'PUT',
    SUB: 'SUB',
    PATCH: 'PATCH'
  };

  /**
   * A serialized Request object.
   *
   * @name Spotify.Cosmos.SerializedRequest
   * @typedef {{
   *   uri: Spotify.Cosmos.URI,
   *   headers: Spotify.Cosmos.Headers,
   *   body: Spotify.Cosmos.Body
   * }}
   */
  exports.SerializedRequest;

  /**
   * Encapsulates a request to the handlers.
   *
   * Instances of this class are "immutable" and should not be changed.
   *
   * @constructs Spotify.Cosmos.Request
   * @extends Spotify.Cosmos.Message
   * @param {Spotify.Cosmos.Action} action The action of the request.
   * @param {Spotify.Cosmos.URI} uri The URI of the request
   * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
   *     request.
   * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
   */
  function Request(action, uri, opt_headers, opt_body) {
    if (!(this instanceof Request))
      return new Request(action, uri, opt_headers, opt_body);
    if (!action)
      throw new TypeError('Invalid `action` argument for Request.');
    Message.call(this, uri, opt_headers, opt_body);

    /**
     * The action of the request.
     *
     * @type {Spotify.Cosmos.Action}
     * @protected
     */
    this._action = action;
  }
  inherit(Request, Message);
  exports.Request = Request;

  /**
   * Creates a new Request from a SerializedRequest object.
   *
   * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
   * @return {Spotify.Cosmos.Request|null} The new Request object or null.
   */
  Request.fromObject = function(object) {
    return (object && object.action && object.uri) ?
      new Request(
          object.action,
          object.uri,
          object.headers,
          object.body
      ) : null;
  };

  /**
   * Returns the action of the request.
   *
   * @return {Spotify.Cosmos.Action} The action of the request.
   */
  Request.prototype.getAction = function() {
    return this._action;
  };

  /**
   * @inheritDoc
   */
  Request.prototype.copy = function(opt_headers, opt_body) {
    return new Request(
        this._action,
        this._uri,
        this._copyHeaders(opt_headers),
        typeof opt_body != 'undefined' ? opt_body : this._body
    );
  };

  /**
   * @inheritDoc
   */
  Request.prototype.toJSON = function() {
    return {
      action: this._action,
      uri: this._uri,
      headers: this._headers,
      body: this._body
    };
  };



  },{"./message":700,"spotify-inheritance":1279}],703:[function(require,module,exports){
  var inherit = require('spotify-inheritance').inherit;

  var Message = require('./message').Message;

  /**
   * Statuscode.
   * The statuses with negative numbers are reserved for
   * errors that originate within the cosmos library.
   *
   * @name exports.StatusCode
   * @enum {number}
   */
  exports.StatusCode = {
    OK: 200,
    CREATED: 201,
    ACCEPTED: 202,
    BAD_REQUEST: 400,
    UNAUTHORIZED: 401,
    FORBIDDEN: 403,
    NOT_FOUND: 404,
    METHOD_NOT_ALLOWED: 405,
    TIMED_OUT: 408,
    CONFLICT: 409,
    GONE: 410,
    INTERNAL_SERVER_ERROR: 500,
    NOT_IMPLEMENTED: 501,
    BAD_GATEWAY: 502,
    SERVICE_UNAVAILABLE: 503,

    /** Something went wrong, but the exact reason is not known. */
    ERROR_UNKNOWN: -100,

    /** A resource allocation required to complete the request failed. */
    ERROR_ALLOCATION_FAILED: -101,

    /** The body could not be decoded because it does
     not conform to the encoding header field. */
    ERROR_INVALID_ENCODING: -102,

    /** The router detected an infinite loop while processing the request. */
    ERROR_INFINITE_LOOP: -103,

    /** No endpoint resolver that could handle the request was found. */
    ERROR_RESOLVER_NOT_FOUND: -104
  };

  /**
   * A serialized Response object.
   *
   * @name Spotify.Cosmos.SerializedResponse
   * @typedef {{
   *   uri: Spotify.Cosmos.URI,
   *   status: Spotify.Cosmos.StatusCode,
   *   headers: Spotify.Cosmos.Headers,
   *   body: Spotify.Cosmos.Body
   * }}
   */
  exports.SerializedResponse;

  /**
   * Encapsulates a response from the handlers.
   *
   * @constructs Spotify.Cosmos.Response
   * @extends Spotify.Cosmos.Message
   * @param {Spotify.Cosmos.URI} uri The URI of the response
   * @param {Spotify.Cosmos.StatusCode} status The status of the response.
   * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
   *     response.
   * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
   */
  function Response(uri, status, opt_headers, opt_body) {
    if (!(this instanceof Response))
      return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
    if (typeof status == 'undefined' || status == null)
      throw new TypeError('Invalid `status` argument for Response.');

    Message.call(this, uri, opt_headers, opt_body);

    /**
     * The Status of the Response.
     *
     * @type {Spotify.Cosmos.StatusCode}
     * @protected
     */
    this._status = status;
  }
  inherit(Response, Message);
  exports.Response = Response;

  /**
   * Creates a new Response from a SerializedResponse object.
   *
   * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
   * @return {Spotify.Cosmos.Response|null} The new Response object or null.
   */
  Response.fromObject = function(object) {
    return (object && object.uri && object.status) ?
      new Response(
          object.uri,
          object.status,
          object.headers,
          object.body
      ) : null;
  };

  /**
   * @inheritDoc
   */
  Response.prototype.getMimeType = function() {
    return this._headers['content-type'];
  };

  /**
   * Returns the status code of the Response.
   *
   * @return {Spotify.Cosmos.StatusCode} The status code of the response.
   */
  Response.prototype.getStatusCode = function() {
    return this._status;
  };

  /**
   * @inheritDoc
   */
  Response.prototype.copy = function(opt_headers, opt_body) {
    return new Response(
        this._uri,
        this._status,
        this._copyHeaders(opt_headers),
        typeof opt_body != 'undefined' ? opt_body : this._body
    );
  };

  /**
   * @inheritDoc
   */
  Response.prototype.toJSON = function() {
    return {
      uri: this._uri,
      status: this._status,
      headers: this._headers,
      body: this._body
    };
  };


  },{"./message":700,"spotify-inheritance":1279}],704:[function(require,module,exports){
  (function (process){
  /**
   * This is the web browser implementation of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = require('./debug');
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = 'undefined' != typeof chrome
                 && 'undefined' != typeof chrome.storage
                    ? chrome.storage.local
                    : localstorage();

  /**
   * Colors.
   */

  exports.colors = [
    'lightseagreen',
    'forestgreen',
    'goldenrod',
    'dodgerblue',
    'darkorchid',
    'crimson'
  ];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
      return true;
    }

    // is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
      // is firebug? http://stackoverflow.com/a/398120/376773
      (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
      // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
      // double check webkit in userAgent just in case we are in a worker
      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return '[UnexpectedJSONParseError]: ' + err.message;
    }
  };


  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
    var useColors = this.useColors;

    args[0] = (useColors ? '%c' : '')
      + this.namespace
      + (useColors ? ' %c' : ' ')
      + args[0]
      + (useColors ? '%c ' : ' ')
      + '+' + exports.humanize(this.diff);

    if (!useColors) return;

    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit')

    // the final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if ('%%' === match) return;
      index++;
      if ('%c' === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });

    args.splice(lastC, 0, c);
  }

  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */

  function log() {
    // this hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return 'object' === typeof console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */

  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem('debug');
      } else {
        exports.storage.debug = namespaces;
      }
    } catch(e) {}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */

  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch(e) {}

    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }

  /**
   * Enable namespaces listed in `localStorage.debug` initially.
   */

  exports.enable(load());

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {}
  }

  }).call(this,require('_process'))
  },{"./debug":705,"_process":823}],705:[function(require,module,exports){

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   *
   * Expose `debug()` as the module.
   */

  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require('ms');

  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];

  /**
   * Map of special "%n" handling functions, for the debug "format" argument.
   *
   * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
   */

  exports.formatters = {};

  /**
   * Previous log timestamp.
   */

  var prevTime;

  /**
   * Select a color.
   * @param {String} namespace
   * @return {Number}
   * @api private
   */

  function selectColor(namespace) {
    var hash = 0, i;

    for (i in namespace) {
      hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return exports.colors[Math.abs(hash) % exports.colors.length];
  }

  /**
   * Create a debugger with the given `namespace`.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */

  function createDebug(namespace) {

    function debug() {
      // disabled?
      if (!debug.enabled) return;

      var self = debug;

      // set `diff` timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;

      // turn the `arguments` into a proper Array
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }

      args[0] = exports.coerce(args[0]);

      if ('string' !== typeof args[0]) {
        // anything else let's inspect with %O
        args.unshift('%O');
      }

      // apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        // if we encounter an escaped % then don't increase the array index
        if (match === '%%') return match;
        index++;
        var formatter = exports.formatters[format];
        if ('function' === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);

          // now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // apply env-specific formatting (colors, etc.)
      exports.formatArgs.call(self, args);

      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);

    // env-specific initialization logic for debug instances
    if ('function' === typeof exports.init) {
      exports.init(debug);
    }

    return debug;
  }

  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */

  function enable(namespaces) {
    exports.save(namespaces);

    exports.names = [];
    exports.skips = [];

    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (var i = 0; i < len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        exports.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
   * Disable debug output.
   *
   * @api public
   */

  function disable() {
    exports.enable('');
  }

  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */

  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Coerce `val`.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */

  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }

  },{"ms":821}],706:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  module.exports = exports['default'];
  },{}],707:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (recalc) {
    if (!size || recalc) {
      if (_inDOM2.default) {
        var scrollDiv = document.createElement('div');

        scrollDiv.style.position = 'absolute';
        scrollDiv.style.top = '-9999px';
        scrollDiv.style.width = '50px';
        scrollDiv.style.height = '50px';
        scrollDiv.style.overflow = 'scroll';

        document.body.appendChild(scrollDiv);
        size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
      }
    }

    return size;
  };

  var _inDOM = require('./inDOM');

  var _inDOM2 = _interopRequireDefault(_inDOM);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var size = void 0;

  module.exports = exports['default'];
  },{"./inDOM":706}],708:[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!isNumber(n) || n < 0 || isNaN(n))
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };

  EventEmitter.prototype.emit = function(type) {
    var er, handler, len, args, i, listeners;

    if (!this._events)
      this._events = {};

    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events.error ||
          (isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }
      }
    }

    handler = this._events[type];

    if (isUndefined(handler))
      return false;

    if (isFunction(handler)) {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          args = Array.prototype.slice.call(arguments, 1);
          handler.apply(this, args);
      }
    } else if (isObject(handler)) {
      args = Array.prototype.slice.call(arguments, 1);
      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }

    return true;
  };

  EventEmitter.prototype.addListener = function(type, listener) {
    var m;

    if (!isFunction(listener))
      throw TypeError('listener must be a function');

    if (!this._events)
      this._events = {};

    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (this._events.newListener)
      this.emit('newListener', type,
                isFunction(listener.listener) ?
                listener.listener : listener);

    if (!this._events[type])
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    else if (isObject(this._events[type]))
      // If we've already got an array, just append.
      this._events[type].push(listener);
    else
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];

    // Check for listener leak
    if (isObject(this._events[type]) && !this._events[type].warned) {
      if (!isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        if (typeof console.trace === 'function') {
          // not supported in IE 10
          console.trace();
        }
      }
    }

    return this;
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.once = function(type, listener) {
    if (!isFunction(listener))
      throw TypeError('listener must be a function');

    var fired = false;

    function g() {
      this.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }

    g.listener = listener;
    this.on(type, g);

    return this;
  };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list, position, length, i;

    if (!isFunction(listener))
      throw TypeError('listener must be a function');

    if (!this._events || !this._events[type])
      return this;

    list = this._events[type];
    length = list.length;
    position = -1;

    if (list === listener ||
        (isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);

    } else if (isObject(list)) {
      for (i = length; i-- > 0;) {
        if (list[i] === listener ||
            (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }

      if (position < 0)
        return this;

      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }

      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function(type) {
    var key, listeners;

    if (!this._events)
      return this;

    // not listening for removeListener, no need to emit
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }

    listeners = this._events[type];

    if (isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else if (listeners) {
      // LIFO order
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];

    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };

  EventEmitter.prototype.listenerCount = function(type) {
    if (this._events) {
      var evlistener = this._events[type];

      if (isFunction(evlistener))
        return 1;
      else if (evlistener)
        return evlistener.length;
    }
    return 0;
  };

  EventEmitter.listenerCount = function(emitter, type) {
    return emitter.listenerCount(type);
  };

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isUndefined(arg) {
    return arg === void 0;
  }

  },{}],709:[function(require,module,exports){
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var undefined;

  var isArray = function isArray(arr) {
    if (typeof Array.isArray === 'function') {
      return Array.isArray(arr);
    }

    return toStr.call(arr) === '[object Array]';
  };

  var isPlainObject = function isPlainObject(obj) {
    'use strict';
    if (!obj || toStr.call(obj) !== '[object Object]') {
      return false;
    }

    var has_own_constructor = hasOwn.call(obj, 'constructor');
    var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    // Not own constructor property must be Object
    if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.
    var key;
    for (key in obj) {}

    return key === undefined || hasOwn.call(obj, key);
  };

  module.exports = function extend() {
    'use strict';
    var options, name, src, copy, copyIsArray, clone,
      target = arguments[0],
      i = 1,
      length = arguments.length,
      deep = false;

    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      // skip the boolean and the target
      i = 2;
    } else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
      target = {};
    }

    for (; i < length; ++i) {
      options = arguments[i];
      // Only deal with non-null/undefined values
      if (options != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            target[name] = extend(deep, clone, copy);

          // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }

    // Return the modified object
    return target;
  };


  },{}],710:[function(require,module,exports){
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  var emptyFunction = require('./emptyFunction');

  /**
   * Upstream version of event listener. Does not take into account specific
   * nature of platform.
   */
  var EventListener = {
    /**
     * Listen to DOM events during the bubble phase.
     *
     * @param {DOMEventTarget} target DOM element to register listener on.
     * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
     * @param {function} callback Callback function.
     * @return {object} Object with a `remove` method.
     */
    listen: function listen(target, eventType, callback) {
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, false);
        return {
          remove: function remove() {
            target.removeEventListener(eventType, callback, false);
          }
        };
      } else if (target.attachEvent) {
        target.attachEvent('on' + eventType, callback);
        return {
          remove: function remove() {
            target.detachEvent('on' + eventType, callback);
          }
        };
      }
    },

    /**
     * Listen to DOM events during the capture phase.
     *
     * @param {DOMEventTarget} target DOM element to register listener on.
     * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
     * @param {function} callback Callback function.
     * @return {object} Object with a `remove` method.
     */
    capture: function capture(target, eventType, callback) {
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, true);
        return {
          remove: function remove() {
            target.removeEventListener(eventType, callback, true);
          }
        };
      } else {
        if ("production" !== 'production') {
          console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
        }
        return {
          remove: emptyFunction
        };
      }
    },

    registerDefault: function registerDefault() {}
  };

  module.exports = EventListener;
  },{"./emptyFunction":715}],711:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  'use strict';

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  /**
   * Simple, lightweight module assisting with the detection and context of
   * Worker. Helps avoid circular dependencies and allows code to reason about
   * whether or not they are in a Worker, even if they never include the main
   * `ReactWorker` dependency.
   */
  var ExecutionEnvironment = {

    canUseDOM: canUseDOM,

    canUseWorkers: typeof Worker !== 'undefined',

    canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

    canUseViewport: canUseDOM && !!window.screen,

    isInWorker: !canUseDOM // For now, this is true - might change in the future.

  };

  module.exports = ExecutionEnvironment;
  },{}],712:[function(require,module,exports){
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  var _hyphenPattern = /-(.)/g;

  /**
   * Camelcases a hyphenated string, for example:
   *
   *   > camelize('background-color')
   *   < "backgroundColor"
   *
   * @param {string} string
   * @return {string}
   */
  function camelize(string) {
    return string.replace(_hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  }

  module.exports = camelize;
  },{}],713:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  'use strict';

  var camelize = require('./camelize');

  var msPattern = /^-ms-/;

  /**
   * Camelcases a hyphenated CSS property name, for example:
   *
   *   > camelizeStyleName('background-color')
   *   < "backgroundColor"
   *   > camelizeStyleName('-moz-transition')
   *   < "MozTransition"
   *   > camelizeStyleName('-ms-transition')
   *   < "msTransition"
   *
   * As Andi Smith suggests
   * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
   * is converted to lowercase `ms`.
   *
   * @param {string} string
   * @return {string}
   */
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, 'ms-'));
  }

  module.exports = camelizeStyleName;
  },{"./camelize":712}],714:[function(require,module,exports){
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   *
   */

  var isTextNode = require('./isTextNode');

  /*eslint-disable no-bitwise */

  /**
   * Checks if a given DOM node contains or is another DOM node.
   */
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if ('contains' in outerNode) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }

  module.exports = containsNode;
  },{"./isTextNode":723}],715:[function(require,module,exports){
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   *
   */

  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */
  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  module.exports = emptyFunction;
  },{}],716:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  'use strict';

  var emptyObject = {};

  if ("production" !== 'production') {
    Object.freeze(emptyObject);
  }

  module.exports = emptyObject;
  },{}],717:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  'use strict';

  /**
   * @param {DOMElement} node input/textarea to focus
   */

  function focusNode(node) {
    // IE8 can throw "Can't move focus to the control because it is invisible,
    // not enabled, or of a type that does not accept the focus." for all kinds of
    // reasons that are too expensive and fragile to test.
    try {
      node.focus();
    } catch (e) {}
  }

  module.exports = focusNode;
  },{}],718:[function(require,module,exports){
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  /* eslint-disable fb-www/typeof-undefined */

  /**
   * Same as document.activeElement but wraps in a try-catch block. In IE it is
   * not safe to call document.activeElement if there is nothing focused.
   *
   * The activeElement will be null only if the document or document body is not
   * yet defined.
   *
   * @param {?DOMDocument} doc Defaults to current document.
   * @return {?DOMElement}
   */
  function getActiveElement(doc) /*?DOMElement*/{
    doc = doc || (typeof document !== 'undefined' ? document : undefined);
    if (typeof doc === 'undefined') {
      return null;
    }
    try {
      return doc.activeElement || doc.body;
    } catch (e) {
      return doc.body;
    }
  }

  module.exports = getActiveElement;
  },{}],719:[function(require,module,exports){
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  var _uppercasePattern = /([A-Z])/g;

  /**
   * Hyphenates a camelcased string, for example:
   *
   *   > hyphenate('backgroundColor')
   *   < "background-color"
   *
   * For CSS style names, use `hyphenateStyleName` instead which works properly
   * with all vendor prefixes, including `ms`.
   *
   * @param {string} string
   * @return {string}
   */
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }

  module.exports = hyphenate;
  },{}],720:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  'use strict';

  var hyphenate = require('./hyphenate');

  var msPattern = /^ms-/;

  /**
   * Hyphenates a camelcased CSS property name, for example:
   *
   *   > hyphenateStyleName('backgroundColor')
   *   < "background-color"
   *   > hyphenateStyleName('MozTransition')
   *   < "-moz-transition"
   *   > hyphenateStyleName('msTransition')
   *   < "-ms-transition"
   *
   * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
   * is converted to `-ms-`.
   *
   * @param {string} string
   * @return {string}
   */
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, '-ms-');
  }

  module.exports = hyphenateStyleName;
  },{"./hyphenate":719}],721:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var validateFormat = function validateFormat(format) {};

  if ("production" !== 'production') {
    validateFormat = function validateFormat(format) {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    };
  }

  function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  }

  module.exports = invariant;
  },{}],722:[function(require,module,exports){
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM node.
   */
  function isNode(object) {
    var doc = object ? object.ownerDocument || object : document;
    var defaultView = doc.defaultView || window;
    return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }

  module.exports = isNode;
  },{}],723:[function(require,module,exports){
  'use strict';

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  var isNode = require('./isNode');

  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM text node.
   */
  function isTextNode(object) {
    return isNode(object) && object.nodeType == 3;
  }

  module.exports = isTextNode;
  },{"./isNode":722}],724:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   *
   */

  /*eslint-disable no-self-compare */

  'use strict';

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      // Added the nonzero y check to make Flow happy, but it is redundant
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }

  /**
   * Performs equality by iterating through keys on an object and returning false
   * when any key has values which are not strictly equal between the arguments.
   * Returns true when the values of all keys are strictly equal.
   */
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    // Test for A's keys different from B.
    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }

  module.exports = shallowEqual;
  },{}],725:[function(require,module,exports){
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  'use strict';

  var emptyFunction = require('./emptyFunction');

  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var warning = emptyFunction;

  if ("production" !== 'production') {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  }

  module.exports = warning;
  },{"./emptyFunction":715}],726:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  // istanbul ignore next

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  var _handlebarsBase = require('./handlebars/base');

  var base = _interopRequireWildcard(_handlebarsBase);

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)

  var _handlebarsSafeString = require('./handlebars/safe-string');

  var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

  var _handlebarsException = require('./handlebars/exception');

  var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

  var _handlebarsUtils = require('./handlebars/utils');

  var Utils = _interopRequireWildcard(_handlebarsUtils);

  var _handlebarsRuntime = require('./handlebars/runtime');

  var runtime = _interopRequireWildcard(_handlebarsRuntime);

  var _handlebarsNoConflict = require('./handlebars/no-conflict');

  var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  function create() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = _handlebarsSafeString2['default'];
    hb.Exception = _handlebarsException2['default'];
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;

    hb.VM = runtime;
    hb.template = function (spec) {
      return runtime.template(spec, hb);
    };

    return hb;
  }

  var inst = create();
  inst.create = create;

  _handlebarsNoConflict2['default'](inst);

  inst['default'] = inst;

  exports['default'] = inst;
  module.exports = exports['default'];


  },{"./handlebars/base":727,"./handlebars/exception":730,"./handlebars/no-conflict":740,"./handlebars/runtime":741,"./handlebars/safe-string":742,"./handlebars/utils":743}],727:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.HandlebarsEnvironment = HandlebarsEnvironment;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _utils = require('./utils');

  var _exception = require('./exception');

  var _exception2 = _interopRequireDefault(_exception);

  var _helpers = require('./helpers');

  var _decorators = require('./decorators');

  var _logger = require('./logger');

  var _logger2 = _interopRequireDefault(_logger);

  var VERSION = '4.0.11';
  exports.VERSION = VERSION;
  var COMPILER_REVISION = 7;

  exports.COMPILER_REVISION = COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '== 1.x.x',
    5: '== 2.0.0-alpha.x',
    6: '>= 2.0.0-beta.1',
    7: '>= 4.0.0'
  };

  exports.REVISION_CHANGES = REVISION_CHANGES;
  var objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials, decorators) {
    this.helpers = helpers || {};
    this.partials = partials || {};
    this.decorators = decorators || {};

    _helpers.registerDefaultHelpers(this);
    _decorators.registerDefaultDecorators(this);
  }

  HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: _logger2['default'],
    log: _logger2['default'].log,

    registerHelper: function registerHelper(name, fn) {
      if (_utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2['default']('Arg not supported with multiple helpers');
        }
        _utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function unregisterHelper(name) {
      delete this.helpers[name];
    },

    registerPartial: function registerPartial(name, partial) {
      if (_utils.toString.call(name) === objectType) {
        _utils.extend(this.partials, name);
      } else {
        if (typeof partial === 'undefined') {
          throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
        }
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function unregisterPartial(name) {
      delete this.partials[name];
    },

    registerDecorator: function registerDecorator(name, fn) {
      if (_utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2['default']('Arg not supported with multiple decorators');
        }
        _utils.extend(this.decorators, name);
      } else {
        this.decorators[name] = fn;
      }
    },
    unregisterDecorator: function unregisterDecorator(name) {
      delete this.decorators[name];
    }
  };

  var log = _logger2['default'].log;

  exports.log = log;
  exports.createFrame = _utils.createFrame;
  exports.logger = _logger2['default'];


  },{"./decorators":728,"./exception":730,"./helpers":731,"./logger":739,"./utils":743}],728:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.registerDefaultDecorators = registerDefaultDecorators;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _decoratorsInline = require('./decorators/inline');

  var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

  function registerDefaultDecorators(instance) {
    _decoratorsInline2['default'](instance);
  }


  },{"./decorators/inline":729}],729:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _utils = require('../utils');

  exports['default'] = function (instance) {
    instance.registerDecorator('inline', function (fn, props, container, options) {
      var ret = fn;
      if (!props.partials) {
        props.partials = {};
        ret = function (context, options) {
          // Create a new partials stack frame prior to exec.
          var original = container.partials;
          container.partials = _utils.extend({}, original, props.partials);
          var ret = fn(context, options);
          container.partials = original;
          return ret;
        };
      }

      props.partials[options.args[0]] = options.fn;

      return ret;
    });
  };

  module.exports = exports['default'];


  },{"../utils":743}],730:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var loc = node && node.loc,
        line = undefined,
        column = undefined;
    if (loc) {
      line = loc.start.line;
      column = loc.start.column;

      message += ' - ' + line + ':' + column;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    /* istanbul ignore else */
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }

    try {
      if (loc) {
        this.lineNumber = line;

        // Work around issue under safari where we can't directly set the column value
        /* istanbul ignore next */
        if (Object.defineProperty) {
          Object.defineProperty(this, 'column', {
            value: column,
            enumerable: true
          });
        } else {
          this.column = column;
        }
      }
    } catch (nop) {
      /* Ignore if the browser is very particular */
    }
  }

  Exception.prototype = new Error();

  exports['default'] = Exception;
  module.exports = exports['default'];


  },{}],731:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.registerDefaultHelpers = registerDefaultHelpers;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

  var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

  var _helpersEach = require('./helpers/each');

  var _helpersEach2 = _interopRequireDefault(_helpersEach);

  var _helpersHelperMissing = require('./helpers/helper-missing');

  var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

  var _helpersIf = require('./helpers/if');

  var _helpersIf2 = _interopRequireDefault(_helpersIf);

  var _helpersLog = require('./helpers/log');

  var _helpersLog2 = _interopRequireDefault(_helpersLog);

  var _helpersLookup = require('./helpers/lookup');

  var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

  var _helpersWith = require('./helpers/with');

  var _helpersWith2 = _interopRequireDefault(_helpersWith);

  function registerDefaultHelpers(instance) {
    _helpersBlockHelperMissing2['default'](instance);
    _helpersEach2['default'](instance);
    _helpersHelperMissing2['default'](instance);
    _helpersIf2['default'](instance);
    _helpersLog2['default'](instance);
    _helpersLookup2['default'](instance);
    _helpersWith2['default'](instance);
  }


  },{"./helpers/block-helper-missing":732,"./helpers/each":733,"./helpers/helper-missing":734,"./helpers/if":735,"./helpers/log":736,"./helpers/lookup":737,"./helpers/with":738}],732:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _utils = require('../utils');

  exports['default'] = function (instance) {
    instance.registerHelper('blockHelperMissing', function (context, options) {
      var inverse = options.inverse,
          fn = options.fn;

      if (context === true) {
        return fn(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (_utils.isArray(context)) {
        if (context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }

          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
          options = { data: data };
        }

        return fn(context, options);
      }
    });
  };

  module.exports = exports['default'];


  },{"../utils":743}],733:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _utils = require('../utils');

  var _exception = require('../exception');

  var _exception2 = _interopRequireDefault(_exception);

  exports['default'] = function (instance) {
    instance.registerHelper('each', function (context, options) {
      if (!options) {
        throw new _exception2['default']('Must pass iterator to #each');
      }

      var fn = options.fn,
          inverse = options.inverse,
          i = 0,
          ret = '',
          data = undefined,
          contextPath = undefined;

      if (options.data && options.ids) {
        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }

      if (_utils.isFunction(context)) {
        context = context.call(this);
      }

      if (options.data) {
        data = _utils.createFrame(options.data);
      }

      function execIteration(field, index, last) {
        if (data) {
          data.key = field;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;

          if (contextPath) {
            data.contextPath = contextPath + field;
          }
        }

        ret = ret + fn(context[field], {
          data: data,
          blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
        });
      }

      if (context && typeof context === 'object') {
        if (_utils.isArray(context)) {
          for (var j = context.length; i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else {
          var priorKey = undefined;

          for (var key in context) {
            if (context.hasOwnProperty(key)) {
              // We're running the iterations one step out of sync so we can detect
              // the last iteration without have to scan the object twice and create
              // an itermediate keys array.
              if (priorKey !== undefined) {
                execIteration(priorKey, i - 1);
              }
              priorKey = key;
              i++;
            }
          }
          if (priorKey !== undefined) {
            execIteration(priorKey, i - 1, true);
          }
        }
      }

      if (i === 0) {
        ret = inverse(this);
      }

      return ret;
    });
  };

  module.exports = exports['default'];


  },{"../exception":730,"../utils":743}],734:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var _exception = require('../exception');

  var _exception2 = _interopRequireDefault(_exception);

  exports['default'] = function (instance) {
    instance.registerHelper('helperMissing', function () /* [args, ]options */{
      if (arguments.length === 1) {
        // A missing field in a {{foo}} construct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };

  module.exports = exports['default'];


  },{"../exception":730}],735:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _utils = require('../utils');

  exports['default'] = function (instance) {
    instance.registerHelper('if', function (conditional, options) {
      if (_utils.isFunction(conditional)) {
        conditional = conditional.call(this);
      }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function (conditional, options) {
      return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
    });
  };

  module.exports = exports['default'];


  },{"../utils":743}],736:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerHelper('log', function () /* message, options */{
      var args = [undefined],
          options = arguments[arguments.length - 1];
      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }

      var level = 1;
      if (options.hash.level != null) {
        level = options.hash.level;
      } else if (options.data && options.data.level != null) {
        level = options.data.level;
      }
      args[0] = level;

      instance.log.apply(instance, args);
    });
  };

  module.exports = exports['default'];


  },{}],737:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerHelper('lookup', function (obj, field) {
      return obj && obj[field];
    });
  };

  module.exports = exports['default'];


  },{}],738:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _utils = require('../utils');

  exports['default'] = function (instance) {
    instance.registerHelper('with', function (context, options) {
      if (_utils.isFunction(context)) {
        context = context.call(this);
      }

      var fn = options.fn;

      if (!_utils.isEmpty(context)) {
        var data = options.data;
        if (options.data && options.ids) {
          data = _utils.createFrame(options.data);
          data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
        }

        return fn(context, {
          data: data,
          blockParams: _utils.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options.inverse(this);
      }
    });
  };

  module.exports = exports['default'];


  },{"../utils":743}],739:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _utils = require('./utils');

  var logger = {
    methodMap: ['debug', 'info', 'warn', 'error'],
    level: 'info',

    // Maps a given level value to the `methodMap` indexes above.
    lookupLevel: function lookupLevel(level) {
      if (typeof level === 'string') {
        var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }

      return level;
    },

    // Can be overridden in the host environment
    log: function log(level) {
      level = logger.lookupLevel(level);

      if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
        var method = logger.methodMap[level];
        if (!console[method]) {
          // eslint-disable-line no-console
          method = 'log';
        }

        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }

        console[method].apply(console, message); // eslint-disable-line no-console
      }
    }
  };

  exports['default'] = logger;
  module.exports = exports['default'];


  },{"./utils":743}],740:[function(require,module,exports){
  (function (global){
  /* global window */
  'use strict';

  exports.__esModule = true;

  exports['default'] = function (Handlebars) {
    /* istanbul ignore next */
    var root = typeof global !== 'undefined' ? global : window,
        $Handlebars = root.Handlebars;
    /* istanbul ignore next */
    Handlebars.noConflict = function () {
      if (root.Handlebars === Handlebars) {
        root.Handlebars = $Handlebars;
      }
      return Handlebars;
    };
  };

  module.exports = exports['default'];


  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],741:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.checkRevision = checkRevision;
  exports.template = template;
  exports.wrapProgram = wrapProgram;
  exports.resolvePartial = resolvePartial;
  exports.invokePartial = invokePartial;
  exports.noop = noop;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  // istanbul ignore next

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  var _utils = require('./utils');

  var Utils = _interopRequireWildcard(_utils);

  var _exception = require('./exception');

  var _exception2 = _interopRequireDefault(_exception);

  var _base = require('./base');

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = _base.COMPILER_REVISION;

    if (compilerRevision !== currentRevision) {
      if (compilerRevision < currentRevision) {
        var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
            compilerVersions = _base.REVISION_CHANGES[compilerRevision];
        throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
      } else {
        // Use the embedded version info since the runtime doesn't know about this revision yet
        throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
      }
    }
  }

  function template(templateSpec, env) {
    /* istanbul ignore next */
    if (!env) {
      throw new _exception2['default']('No environment passed to template');
    }
    if (!templateSpec || !templateSpec.main) {
      throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
    }

    templateSpec.main.decorator = templateSpec.main_d;

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as psuedo-supported APIs.
    env.VM.checkRevision(templateSpec.compiler);

    function invokePartialWrapper(partial, context, options) {
      if (options.hash) {
        context = Utils.extend({}, context, options.hash);
        if (options.ids) {
          options.ids[0] = true;
        }
      }

      partial = env.VM.resolvePartial.call(this, partial, context, options);
      var result = env.VM.invokePartial.call(this, partial, context, options);

      if (result == null && env.compile) {
        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
        result = options.partials[options.name](context, options);
      }
      if (result != null) {
        if (options.indent) {
          var lines = result.split('\n');
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }

            lines[i] = options.indent + lines[i];
          }
          result = lines.join('\n');
        }
        return result;
      } else {
        throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
      }
    }

    // Just add water
    var container = {
      strict: function strict(obj, name) {
        if (!(name in obj)) {
          throw new _exception2['default']('"' + name + '" not defined in ' + obj);
        }
        return obj[name];
      },
      lookup: function lookup(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          if (depths[i] && depths[i][name] != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function lambda(current, context) {
        return typeof current === 'function' ? current.call(context) : current;
      },

      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,

      fn: function fn(i) {
        var ret = templateSpec[i];
        ret.decorator = templateSpec[i + '_d'];
        return ret;
      },

      programs: [],
      program: function program(i, data, declaredBlockParams, blockParams, depths) {
        var programWrapper = this.programs[i],
            fn = this.fn(i);
        if (data || depths || blockParams || declaredBlockParams) {
          programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = wrapProgram(this, i, fn);
        }
        return programWrapper;
      },

      data: function data(value, depth) {
        while (value && depth--) {
          value = value._parent;
        }
        return value;
      },
      merge: function merge(param, common) {
        var obj = param || common;

        if (param && common && param !== common) {
          obj = Utils.extend({}, common, param);
        }

        return obj;
      },
      // An empty object to use as replacement for null-contexts
      nullContext: Object.seal({}),

      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };

    function ret(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var data = options.data;

      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths = undefined,
          blockParams = templateSpec.useBlockParams ? [] : undefined;
      if (templateSpec.useDepths) {
        if (options.depths) {
          depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
        } else {
          depths = [context];
        }
      }

      function main(context /*, options*/) {
        return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
      }
      main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
      return main(context, options);
    }
    ret.isTop = true;

    ret._setup = function (options) {
      if (!options.partial) {
        container.helpers = container.merge(options.helpers, env.helpers);

        if (templateSpec.usePartial) {
          container.partials = container.merge(options.partials, env.partials);
        }
        if (templateSpec.usePartial || templateSpec.useDecorators) {
          container.decorators = container.merge(options.decorators, env.decorators);
        }
      } else {
        container.helpers = options.helpers;
        container.partials = options.partials;
        container.decorators = options.decorators;
      }
    };

    ret._child = function (i, data, blockParams, depths) {
      if (templateSpec.useBlockParams && !blockParams) {
        throw new _exception2['default']('must pass block params');
      }
      if (templateSpec.useDepths && !depths) {
        throw new _exception2['default']('must pass parent depths');
      }

      return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
    };
    return ret;
  }

  function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    function prog(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var currentDepths = depths;
      if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
        currentDepths = [context].concat(depths);
      }

      return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
    }

    prog = executeDecorators(fn, prog, container, depths, data, blockParams);

    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    prog.blockParams = declaredBlockParams || 0;
    return prog;
  }

  function resolvePartial(partial, context, options) {
    if (!partial) {
      if (options.name === '@partial-block') {
        partial = options.data['partial-block'];
      } else {
        partial = options.partials[options.name];
      }
    } else if (!partial.call && !options.name) {
      // This is a dynamic partial that returned a string
      options.name = partial;
      partial = options.partials[partial];
    }
    return partial;
  }

  function invokePartial(partial, context, options) {
    // Use the current closure context to save the partial-block if this partial
    var currentPartialBlock = options.data && options.data['partial-block'];
    options.partial = true;
    if (options.ids) {
      options.data.contextPath = options.ids[0] || options.data.contextPath;
    }

    var partialBlock = undefined;
    if (options.fn && options.fn !== noop) {
      (function () {
        options.data = _base.createFrame(options.data);
        // Wrapper function to get access to currentPartialBlock from the closure
        var fn = options.fn;
        partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          // Restore the partial-block from the closure for the execution of the block
          // i.e. the part inside the block of the partial call.
          options.data = _base.createFrame(options.data);
          options.data['partial-block'] = currentPartialBlock;
          return fn(context, options);
        };
        if (fn.partials) {
          options.partials = Utils.extend({}, options.partials, fn.partials);
        }
      })();
    }

    if (partial === undefined && partialBlock) {
      partial = partialBlock;
    }

    if (partial === undefined) {
      throw new _exception2['default']('The partial ' + options.name + ' could not be found');
    } else if (partial instanceof Function) {
      return partial(context, options);
    }
  }

  function noop() {
    return '';
  }

  function initData(context, data) {
    if (!data || !('root' in data)) {
      data = data ? _base.createFrame(data) : {};
      data.root = context;
    }
    return data;
  }

  function executeDecorators(fn, prog, container, depths, data, blockParams) {
    if (fn.decorator) {
      var props = {};
      prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
      Utils.extend(prog, props);
    }
    return prog;
  }


  },{"./base":727,"./exception":730,"./utils":743}],742:[function(require,module,exports){
  // Build out our basic SafeString type
  'use strict';

  exports.__esModule = true;
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
    return '' + this.string;
  };

  exports['default'] = SafeString;
  module.exports = exports['default'];


  },{}],743:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.extend = extend;
  exports.indexOf = indexOf;
  exports.escapeExpression = escapeExpression;
  exports.isEmpty = isEmpty;
  exports.createFrame = createFrame;
  exports.blockParams = blockParams;
  exports.appendContextPath = appendContextPath;
  var escape = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  var badChars = /[&<>"'`=]/g,
      possible = /[&<>"'`=]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  var toString = Object.prototype.toString;

  exports.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  /* eslint-disable func-style */
  var isFunction = function isFunction(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    exports.isFunction = isFunction = function (value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  exports.isFunction = isFunction;

  /* eslint-enable func-style */

  /* istanbul ignore next */
  var isArray = Array.isArray || function (value) {
    return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
  };

  exports.isArray = isArray;
  // Older IE versions do not directly support indexOf so we must implement our own, sadly.

  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }

  function escapeExpression(string) {
    if (typeof string !== 'string') {
      // don't escape SafeStrings, since they're already safe
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return '';
      } else if (!string) {
        return string + '';
      }

      // Force a string conversion as this will be done by the append regardless and
      // the regex test will do this transparently behind the scenes, causing issues if
      // an object's to string has escaped characters in it.
      string = '' + string;
    }

    if (!possible.test(string)) {
      return string;
    }
    return string.replace(badChars, escapeChar);
  }

  function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  function createFrame(object) {
    var frame = extend({}, object);
    frame._parent = object;
    return frame;
  }

  function blockParams(params, ids) {
    params.path = ids;
    return params;
  }

  function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }


  },{}],744:[function(require,module,exports){
  // Create a simple path alias to allow browserify to resolve
  // the runtime on a supported path.
  module.exports = require('./dist/cjs/handlebars.runtime')['default'];

  },{"./dist/cjs/handlebars.runtime":726}],745:[function(require,module,exports){
  module.exports = require("handlebars/runtime")["default"];

  },{"handlebars/runtime":744}],746:[function(require,module,exports){
  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */
  (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
      typeof define === 'function' && define.amd ? define(factory) :
      (global.hoistNonReactStatics = factory());
  }(this, (function () {
      'use strict';

      var REACT_STATICS = {
          childContextTypes: true,
          contextTypes: true,
          defaultProps: true,
          displayName: true,
          getDefaultProps: true,
          getDerivedStateFromProps: true,
          mixins: true,
          propTypes: true,
          type: true
      };

      var KNOWN_STATICS = {
          name: true,
          length: true,
          prototype: true,
          caller: true,
          callee: true,
          arguments: true,
          arity: true
      };

      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

      return function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
          if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

              if (objectPrototype) {
                  var inheritedComponent = getPrototypeOf(sourceComponent);
                  if (inheritedComponent && inheritedComponent !== objectPrototype) {
                      hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                  }
              }

              var keys = getOwnPropertyNames(sourceComponent);

              if (getOwnPropertySymbols) {
                  keys = keys.concat(getOwnPropertySymbols(sourceComponent));
              }

              for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                      var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                      try { // Avoid failures from read-only properties
                          defineProperty(targetComponent, key, descriptor);
                      } catch (e) {}
                  }
              }

              return targetComponent;
          }

          return targetComponent;
      };
  })));

  },{}],747:[function(require,module,exports){
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m
    var eLen = nBytes * 8 - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var nBits = -7
    var i = isLE ? (nBytes - 1) : 0
    var d = isLE ? -1 : 1
    var s = buffer[offset + i]

    i += d

    e = s & ((1 << (-nBits)) - 1)
    s >>= (-nBits)
    nBits += eLen
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1)
    e >>= (-nBits)
    nBits += mLen
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen)
      e = e - eBias
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c
    var eLen = nBytes * 8 - mLen - 1
    var eMax = (1 << eLen) - 1
    var eBias = eMax >> 1
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
    var i = isLE ? 0 : (nBytes - 1)
    var d = isLE ? 1 : -1
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

    value = Math.abs(value)

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0
      e = eMax
    } else {
      e = Math.floor(Math.log(value) / Math.LN2)
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--
        c *= 2
      }
      if (e + eBias >= 1) {
        value += rt / c
      } else {
        value += rt * Math.pow(2, 1 - eBias)
      }
      if (value * c >= 2) {
        e++
        c /= 2
      }

      if (e + eBias >= eMax) {
        m = 0
        e = eMax
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen)
        e = e + eBias
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
        e = 0
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m
    eLen += mLen
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128
  }

  },{}],748:[function(require,module,exports){
  /**
   * Copyright 2013-2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var invariant = function(condition, format, a, b, c, d, e, f) {
    if ("production" !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error(
          'Minified exception occurred; use the non-minified dev environment ' +
          'for the full error message and additional helpful warnings.'
        );
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(
          format.replace(/%s/g, function() { return args[argIndex++]; })
        );
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };

  module.exports = invariant;

  },{}],749:[function(require,module,exports){
  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  },{}],750:[function(require,module,exports){
  var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

  module.exports = function (obj, opts) {
      if (!opts) opts = {};
      if (typeof opts === 'function') opts = { cmp: opts };
      var space = opts.space || '';
      if (typeof space === 'number') space = Array(space+1).join(' ');
      var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
      var replacer = opts.replacer || function(key, value) { return value; };

      var cmp = opts.cmp && (function (f) {
          return function (node) {
              return function (a, b) {
                  var aobj = { key: a, value: node[a] };
                  var bobj = { key: b, value: node[b] };
                  return f(aobj, bobj);
              };
          };
      })(opts.cmp);

      var seen = [];
      return (function stringify (parent, key, node, level) {
          var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
          var colonSeparator = space ? ': ' : ':';

          if (node && node.toJSON && typeof node.toJSON === 'function') {
              node = node.toJSON();
          }

          node = replacer.call(parent, key, node);

          if (node === undefined) {
              return;
          }
          if (typeof node !== 'object' || node === null) {
              return json.stringify(node);
          }
          if (isArray(node)) {
              var out = [];
              for (var i = 0; i < node.length; i++) {
                  var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                  out.push(indent + space + item);
              }
              return '[' + out.join(',') + indent + ']';
          }
          else {
              if (seen.indexOf(node) !== -1) {
                  if (cycles) return json.stringify('__cycle__');
                  throw new TypeError('Converting circular structure to JSON');
              }
              else seen.push(node);

              var keys = objectKeys(node).sort(cmp && cmp(node));
              var out = [];
              for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  var value = stringify(node, key, node[key], level+1);

                  if(!value) continue;

                  var keyValue = json.stringify(key)
                      + colonSeparator
                      + value;
                  ;
                  out.push(indent + space + keyValue);
              }
              seen.splice(seen.indexOf(node), 1);
              return '{' + out.join(',') + indent + '}';
          }
      })({ '': obj }, '', obj, 0);
  };

  var isArray = Array.isArray || function (x) {
      return {}.toString.call(x) === '[object Array]';
  };

  var objectKeys = Object.keys || function (obj) {
      var has = Object.prototype.hasOwnProperty || function () { return true };
      var keys = [];
      for (var key in obj) {
          if (has.call(obj, key)) keys.push(key);
      }
      return keys;
  };

  },{"jsonify":751}],751:[function(require,module,exports){
  exports.parse = JSON.parse;
  exports.stringify = JSON.stringify;

  },{}],752:[function(require,module,exports){
  var root = require('./_root');

  /** Built-in value references. */
  var Symbol = root.Symbol;

  module.exports = Symbol;

  },{"./_root":759}],753:[function(require,module,exports){
  var Symbol = require('./_Symbol'),
      getRawTag = require('./_getRawTag'),
      objectToString = require('./_objectToString');

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  module.exports = baseGetTag;

  },{"./_Symbol":752,"./_getRawTag":756,"./_objectToString":757}],754:[function(require,module,exports){
  (function (global){
  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  module.exports = freeGlobal;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],755:[function(require,module,exports){
  var overArg = require('./_overArg');

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  module.exports = getPrototype;

  },{"./_overArg":758}],756:[function(require,module,exports){
  var Symbol = require('./_Symbol');

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  module.exports = getRawTag;

  },{"./_Symbol":752}],757:[function(require,module,exports){
  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  module.exports = objectToString;

  },{}],758:[function(require,module,exports){
  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  module.exports = overArg;

  },{}],759:[function(require,module,exports){
  var freeGlobal = require('./_freeGlobal');

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  module.exports = root;

  },{"./_freeGlobal":754}],760:[function(require,module,exports){
  var toInteger = require('./toInteger');

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that invokes `func`, with the `this` binding and arguments
   * of the created function, while it's called less than `n` times. Subsequent
   * calls to the created function return the result of the last `func` invocation.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {number} n The number of calls at which `func` is no longer invoked.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * jQuery(element).on('click', _.before(5, addContactToList));
   * // => Allows adding up to 4 contacts to the list.
   */
  function before(n, func) {
    var result;
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = undefined;
      }
      return result;
    };
  }

  module.exports = before;

  },{"./toInteger":773}],761:[function(require,module,exports){
  var isObject = require('./isObject'),
      now = require('./now'),
      toNumber = require('./toNumber');

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  module.exports = debounce;

  },{"./isObject":764,"./now":769,"./toNumber":774}],762:[function(require,module,exports){
  var root = require('./_root');

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsFinite = root.isFinite;

  /**
   * Checks if `value` is a finite primitive number.
   *
   * **Note:** This method is based on
   * [`Number.isFinite`](https://mdn.io/Number/isFinite).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(3);
   * // => true
   *
   * _.isFinite(Number.MIN_VALUE);
   * // => true
   *
   * _.isFinite(Infinity);
   * // => false
   *
   * _.isFinite('3');
   * // => false
   */
  function isFinite(value) {
    return typeof value == 'number' && nativeIsFinite(value);
  }

  module.exports = isFinite;

  },{"./_root":759}],763:[function(require,module,exports){
  var baseGetTag = require('./_baseGetTag'),
      isObject = require('./isObject');

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  module.exports = isFunction;

  },{"./_baseGetTag":753,"./isObject":764}],764:[function(require,module,exports){
  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  module.exports = isObject;

  },{}],765:[function(require,module,exports){
  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  module.exports = isObjectLike;

  },{}],766:[function(require,module,exports){
  var baseGetTag = require('./_baseGetTag'),
      getPrototype = require('./_getPrototype'),
      isObjectLike = require('./isObjectLike');

  /** `Object#toString` result references. */
  var objectTag = '[object Object]';

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  module.exports = isPlainObject;

  },{"./_baseGetTag":753,"./_getPrototype":755,"./isObjectLike":765}],767:[function(require,module,exports){
  var baseGetTag = require('./_baseGetTag'),
      isObjectLike = require('./isObjectLike');

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  module.exports = isSymbol;

  },{"./_baseGetTag":753,"./isObjectLike":765}],768:[function(require,module,exports){
  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  module.exports = noop;

  },{}],769:[function(require,module,exports){
  var root = require('./_root');

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  module.exports = now;

  },{"./_root":759}],770:[function(require,module,exports){
  var before = require('./before');

  /**
   * Creates a function that is restricted to invoking `func` once. Repeat calls
   * to the function return the value of the first invocation. The `func` is
   * invoked with the `this` binding and arguments of the created function.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // => `createApplication` is invoked once
   */
  function once(func) {
    return before(2, func);
  }

  module.exports = once;

  },{"./before":760}],771:[function(require,module,exports){
  var debounce = require('./debounce'),
      isObject = require('./isObject');

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  module.exports = throttle;

  },{"./debounce":761,"./isObject":764}],772:[function(require,module,exports){
  var toNumber = require('./toNumber');

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  module.exports = toFinite;

  },{"./toNumber":774}],773:[function(require,module,exports){
  var toFinite = require('./toFinite');

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  module.exports = toInteger;

  },{"./toFinite":772}],774:[function(require,module,exports){
  var isObject = require('./isObject'),
      isSymbol = require('./isSymbol');

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  module.exports = toNumber;

  },{"./isObject":764,"./isSymbol":767}],775:[function(require,module,exports){
  var indexOf = require('./indexOf');

      /**
       * Combines an array with all the items of another.
       * Does not allow duplicates and is case and type sensitive.
       */
      function combine(arr1, arr2) {
          if (arr2 == null) {
              return arr1;
          }

          var i = -1, len = arr2.length;
          while (++i < len) {
              if (indexOf(arr1, arr2[i]) === -1) {
                  arr1.push(arr2[i]);
              }
          }

          return arr1;
      }
      module.exports = combine;


  },{"./indexOf":782}],776:[function(require,module,exports){
  var indexOf = require('./indexOf');

      /**
       * If array contains values.
       */
      function contains(arr, val) {
          return indexOf(arr, val) !== -1;
      }
      module.exports = contains;


  },{"./indexOf":782}],777:[function(require,module,exports){
  var unique = require('./unique');
  var filter = require('./filter');
  var some = require('./some');
  var contains = require('./contains');
  var slice = require('./slice');


      /**
       * Return a new Array with elements that aren't present in the other Arrays.
       */
      function difference(arr) {
          var arrs = slice(arguments, 1),
              result = filter(unique(arr), function(needle){
                  return !some(arrs, function(haystack){
                      return contains(haystack, needle);
                  });
              });
          return result;
      }

      module.exports = difference;



  },{"./contains":776,"./filter":780,"./slice":786,"./some":787,"./unique":788}],778:[function(require,module,exports){
  var is = require('../lang/is');
  var isArray = require('../lang/isArray');
  var every = require('./every');

      /**
       * Compares if both arrays have the same elements
       */
      function equals(a, b, callback){
          callback = callback || is;

          if (!isArray(a) || !isArray(b)) {
              return callback(a, b);
          }

          if (a.length !== b.length) {
              return false;
          }

          return every(a, makeCompare(callback), b);
      }

      function makeCompare(callback) {
          return function(value, i) {
              return i in this && callback(value, this[i]);
          };
      }

      module.exports = equals;



  },{"../lang/is":796,"../lang/isArray":797,"./every":779}],779:[function(require,module,exports){
  var makeIterator = require('../function/makeIterator_');

      /**
       * Array every
       */
      function every(arr, callback, thisObj) {
          callback = makeIterator(callback, thisObj);
          var result = true;
          if (arr == null) {
              return result;
          }

          var i = -1, len = arr.length;
          while (++i < len) {
              // we iterate over sparse items since there is no way to make it
              // work properly on IE 7-8. see #64
              if (!callback(arr[i], i, arr) ) {
                  result = false;
                  break;
              }
          }

          return result;
      }

      module.exports = every;


  },{"../function/makeIterator_":790}],780:[function(require,module,exports){
  var makeIterator = require('../function/makeIterator_');

      /**
       * Array filter
       */
      function filter(arr, callback, thisObj) {
          callback = makeIterator(callback, thisObj);
          var results = [];
          if (arr == null) {
              return results;
          }

          var i = -1, len = arr.length, value;
          while (++i < len) {
              value = arr[i];
              if (callback(value, i, arr)) {
                  results.push(value);
              }
          }

          return results;
      }

      module.exports = filter;



  },{"../function/makeIterator_":790}],781:[function(require,module,exports){


      /**
       * Array forEach
       */
      function forEach(arr, callback, thisObj) {
          if (arr == null) {
              return;
          }
          var i = -1,
              len = arr.length;
          while (++i < len) {
              // we iterate over sparse items since there is no way to make it
              // work properly on IE 7-8. see #64
              if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                  break;
              }
          }
      }

      module.exports = forEach;



  },{}],782:[function(require,module,exports){


      /**
       * Array.indexOf
       */
      function indexOf(arr, item, fromIndex) {
          fromIndex = fromIndex || 0;
          if (arr == null) {
              return -1;
          }

          var len = arr.length,
              i = fromIndex < 0 ? len + fromIndex : fromIndex;
          while (i < len) {
              // we iterate over sparse items since there is no way to make it
              // work properly on IE 7-8. see #64
              if (arr[i] === item) {
                  return i;
              }

              i++;
          }

          return -1;
      }

      module.exports = indexOf;


  },{}],783:[function(require,module,exports){
  var unique = require('./unique');
  var filter = require('./filter');
  var every = require('./every');
  var contains = require('./contains');
  var slice = require('./slice');


      /**
       * Return a new Array with elements common to all Arrays.
       * - based on underscore.js implementation
       */
      function intersection(arr) {
          var arrs = slice(arguments, 1),
              result = filter(unique(arr), function(needle){
                  return every(arrs, function(haystack){
                      return contains(haystack, needle);
                  });
              });
          return result;
      }

      module.exports = intersection;



  },{"./contains":776,"./every":779,"./filter":780,"./slice":786,"./unique":788}],784:[function(require,module,exports){
  var makeIterator = require('../function/makeIterator_');

      /**
       * Array map
       */
      function map(arr, callback, thisObj) {
          callback = makeIterator(callback, thisObj);
          var results = [];
          if (arr == null){
              return results;
          }

          var i = -1, len = arr.length;
          while (++i < len) {
              results[i] = callback(arr[i], i, arr);
          }

          return results;
      }

       module.exports = map;


  },{"../function/makeIterator_":790}],785:[function(require,module,exports){
  var indexOf = require('./indexOf');

      /**
       * Remove a single item from the array.
       * (it won't remove duplicates, just a single item)
       */
      function remove(arr, item){
          var idx = indexOf(arr, item);
          if (idx !== -1) arr.splice(idx, 1);
      }

      module.exports = remove;


  },{"./indexOf":782}],786:[function(require,module,exports){


      /**
       * Create slice of source array or array-like object
       */
      function slice(arr, start, end){
          var len = arr.length;

          if (start == null) {
              start = 0;
          } else if (start < 0) {
              start = Math.max(len + start, 0);
          } else {
              start = Math.min(start, len);
          }

          if (end == null) {
              end = len;
          } else if (end < 0) {
              end = Math.max(len + end, 0);
          } else {
              end = Math.min(end, len);
          }

          var result = [];
          while (start < end) {
              result.push(arr[start++]);
          }

          return result;
      }

      module.exports = slice;



  },{}],787:[function(require,module,exports){
  var makeIterator = require('../function/makeIterator_');

      /**
       * Array some
       */
      function some(arr, callback, thisObj) {
          callback = makeIterator(callback, thisObj);
          var result = false;
          if (arr == null) {
              return result;
          }

          var i = -1, len = arr.length;
          while (++i < len) {
              // we iterate over sparse items since there is no way to make it
              // work properly on IE 7-8. see #64
              if ( callback(arr[i], i, arr) ) {
                  result = true;
                  break;
              }
          }

          return result;
      }

      module.exports = some;


  },{"../function/makeIterator_":790}],788:[function(require,module,exports){
  var filter = require('./filter');

      /**
       * @return {array} Array of unique items
       */
      function unique(arr, compare){
          compare = compare || isEqual;
          return filter(arr, function(item, i, arr){
              var n = arr.length;
              while (++i < n) {
                  if ( compare(item, arr[i]) ) {
                      return false;
                  }
              }
              return true;
          });
      }

      function isEqual(a, b){
          return a === b;
      }

      module.exports = unique;



  },{"./filter":780}],789:[function(require,module,exports){


      /**
       * Returns the first argument provided to it.
       */
      function identity(val){
          return val;
      }

      module.exports = identity;



  },{}],790:[function(require,module,exports){
  var identity = require('./identity');
  var prop = require('./prop');
  var deepMatches = require('../object/deepMatches');

      /**
       * Converts argument into a valid iterator.
       * Used internally on most array/object/collection methods that receives a
       * callback/iterator providing a shortcut syntax.
       */
      function makeIterator(src, thisObj){
          if (src == null) {
              return identity;
          }
          switch(typeof src) {
              case 'function':
                  // function is the first to improve perf (most common case)
                  // also avoid using `Function#call` if not needed, which boosts
                  // perf a lot in some cases
                  return (typeof thisObj !== 'undefined')? function(val, i, arr){
                      return src.call(thisObj, val, i, arr);
                  } : src;
              case 'object':
                  return function(val){
                      return deepMatches(val, src);
                  };
              case 'string':
              case 'number':
                  return prop(src);
          }
      }

      module.exports = makeIterator;



  },{"../object/deepMatches":805,"./identity":789,"./prop":791}],791:[function(require,module,exports){


      /**
       * Returns a function that gets a property of the passed object
       */
      function prop(name){
          return function(obj){
              return obj[name];
          };
      }

      module.exports = prop;



  },{}],792:[function(require,module,exports){
  var kindOf = require('./kindOf');
  var isPlainObject = require('./isPlainObject');
  var mixIn = require('../object/mixIn');

      /**
       * Clone native types.
       */
      function clone(val){
          switch (kindOf(val)) {
              case 'Object':
                  return cloneObject(val);
              case 'Array':
                  return cloneArray(val);
              case 'RegExp':
                  return cloneRegExp(val);
              case 'Date':
                  return cloneDate(val);
              default:
                  return val;
          }
      }

      function cloneObject(source) {
          if (isPlainObject(source)) {
              return mixIn({}, source);
          } else {
              return source;
          }
      }

      function cloneRegExp(r) {
          var flags = '';
          flags += r.multiline ? 'm' : '';
          flags += r.global ? 'g' : '';
          flags += r.ignoreCase ? 'i' : '';
          return new RegExp(r.source, flags);
      }

      function cloneDate(date) {
          return new Date(+date);
      }

      function cloneArray(arr) {
          return arr.slice();
      }

      module.exports = clone;



  },{"../object/mixIn":813,"./isPlainObject":801,"./kindOf":803}],793:[function(require,module,exports){
  var mixIn = require('../object/mixIn');

      /**
       * Create Object using prototypal inheritance and setting custom properties.
       * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
       * @param {object} parent    Parent Object.
       * @param {object} [props] Object properties.
       * @return {object} Created object.
       */
      function createObject(parent, props){
          function F(){}
          F.prototype = parent;
          return mixIn(new F(), props);

      }
      module.exports = createObject;



  },{"../object/mixIn":813}],794:[function(require,module,exports){
  var clone = require('./clone');
  var forOwn = require('../object/forOwn');
  var kindOf = require('./kindOf');
  var isPlainObject = require('./isPlainObject');

      /**
       * Recursively clone native types.
       */
      function deepClone(val, instanceClone) {
          switch ( kindOf(val) ) {
              case 'Object':
                  return cloneObject(val, instanceClone);
              case 'Array':
                  return cloneArray(val, instanceClone);
              default:
                  return clone(val);
          }
      }

      function cloneObject(source, instanceClone) {
          if (isPlainObject(source)) {
              var out = {};
              forOwn(source, function(val, key) {
                  this[key] = deepClone(val, instanceClone);
              }, out);
              return out;
          } else if (instanceClone) {
              return instanceClone(source);
          } else {
              return source;
          }
      }

      function cloneArray(arr, instanceClone) {
          var out = [],
              i = -1,
              n = arr.length,
              val;
          while (++i < n) {
              out[i] = deepClone(arr[i], instanceClone);
          }
          return out;
      }

      module.exports = deepClone;




  },{"../object/forOwn":810,"./clone":792,"./isPlainObject":801,"./kindOf":803}],795:[function(require,module,exports){
  var is = require('./is');
  var isObject = require('./isObject');
  var isArray = require('./isArray');
  var objEquals = require('../object/equals');
  var arrEquals = require('../array/equals');

      /**
       * Recursively checks for same properties and values.
       */
      function deepEquals(a, b, callback){
          callback = callback || is;

          var bothObjects = isObject(a) && isObject(b);
          var bothArrays = !bothObjects && isArray(a) && isArray(b);

          if (!bothObjects && !bothArrays) {
              return callback(a, b);
          }

          function compare(a, b){
              return deepEquals(a, b, callback);
          }

          var method = bothObjects ? objEquals : arrEquals;
          return method(a, b, compare);
      }

      module.exports = deepEquals;



  },{"../array/equals":778,"../object/equals":807,"./is":796,"./isArray":797,"./isObject":800}],796:[function(require,module,exports){


      /**
       * Check if both arguments are egal.
       */
      function is(x, y){
          // implementation borrowed from harmony:egal spec
          if (x === y) {
            // 0 === -0, but they are not identical
            return x !== 0 || 1 / x === 1 / y;
          }

          // NaN !== NaN, but they are identical.
          // NaNs are the only non-reflexive value, i.e., if x !== x,
          // then x is a NaN.
          // isNaN is broken: it converts its argument to number, so
          // isNaN("foo") => true
          return x !== x && y !== y;
      }

      module.exports = is;



  },{}],797:[function(require,module,exports){
  var isKind = require('./isKind');
      /**
       */
      var isArray = Array.isArray || function (val) {
          return isKind(val, 'Array');
      };
      module.exports = isArray;


  },{"./isKind":798}],798:[function(require,module,exports){
  var kindOf = require('./kindOf');
      /**
       * Check if value is from a specific "kind".
       */
      function isKind(val, kind){
          return kindOf(val) === kind;
      }
      module.exports = isKind;


  },{"./kindOf":803}],799:[function(require,module,exports){
  var isKind = require('./isKind');
      /**
       */
      function isNumber(val) {
          return isKind(val, 'Number');
      }
      module.exports = isNumber;


  },{"./isKind":798}],800:[function(require,module,exports){
  var isKind = require('./isKind');
      /**
       */
      function isObject(val) {
          return isKind(val, 'Object');
      }
      module.exports = isObject;


  },{"./isKind":798}],801:[function(require,module,exports){


      /**
       * Checks if the value is created by the `Object` constructor.
       */
      function isPlainObject(value) {
          return (!!value && typeof value === 'object' &&
              value.constructor === Object);
      }

      module.exports = isPlainObject;



  },{}],802:[function(require,module,exports){
  var isKind = require('./isKind');
      /**
       */
      function isRegExp(val) {
          return isKind(val, 'RegExp');
      }
      module.exports = isRegExp;


  },{"./isKind":798}],803:[function(require,module,exports){


      var _rKind = /^\[object (.*)\]$/,
          _toString = Object.prototype.toString,
          UNDEF;

      /**
       * Gets the "kind" of value. (e.g. "String", "Number", etc)
       */
      function kindOf(val) {
          if (val === null) {
              return 'Null';
          } else if (val === UNDEF) {
              return 'Undefined';
          } else {
              return _rKind.exec( _toString.call(val) )[1];
          }
      }
      module.exports = kindOf;


  },{}],804:[function(require,module,exports){


      /**
       * Typecast a value to a String, using an empty string value for null or
       * undefined.
       */
      function toString(val){
          return val == null ? '' : val.toString();
      }

      module.exports = toString;



  },{}],805:[function(require,module,exports){
  var forOwn = require('./forOwn');
  var isArray = require('../lang/isArray');

      function containsMatch(array, pattern) {
          var i = -1, length = array.length;
          while (++i < length) {
              if (deepMatches(array[i], pattern)) {
                  return true;
              }
          }

          return false;
      }

      function matchArray(target, pattern) {
          var i = -1, patternLength = pattern.length;
          while (++i < patternLength) {
              if (!containsMatch(target, pattern[i])) {
                  return false;
              }
          }

          return true;
      }

      function matchObject(target, pattern) {
          var result = true;
          forOwn(pattern, function(val, key) {
              if (!deepMatches(target[key], val)) {
                  // Return false to break out of forOwn early
                  return (result = false);
              }
          });

          return result;
      }

      /**
       * Recursively check if the objects match.
       */
      function deepMatches(target, pattern){
          if (target && typeof target === 'object') {
              if (isArray(target) && isArray(pattern)) {
                  return matchArray(target, pattern);
              } else {
                  return matchObject(target, pattern);
              }
          } else {
              return target === pattern;
          }
      }

      module.exports = deepMatches;



  },{"../lang/isArray":797,"./forOwn":810}],806:[function(require,module,exports){
  var forOwn = require('./forOwn');
  var isPlainObject = require('../lang/isPlainObject');

      /**
       * Mixes objects into the target object, recursively mixing existing child
       * objects.
       */
      function deepMixIn(target, objects) {
          var i = 0,
              n = arguments.length,
              obj;

          while(++i < n){
              obj = arguments[i];
              if (obj) {
                  forOwn(obj, copyProp, target);
              }
          }

          return target;
      }

      function copyProp(val, key) {
          var existing = this[key];
          if (isPlainObject(val) && isPlainObject(existing)) {
              deepMixIn(existing, val);
          } else {
              this[key] = val;
          }
      }

      module.exports = deepMixIn;



  },{"../lang/isPlainObject":801,"./forOwn":810}],807:[function(require,module,exports){
  var hasOwn = require('./hasOwn');
  var every = require('./every');
  var isObject = require('../lang/isObject');
  var is = require('../lang/is');

      // Makes a function to compare the object values from the specified compare
      // operation callback.
      function makeCompare(callback) {
          return function(value, key) {
              return hasOwn(this, key) && callback(value, this[key]);
          };
      }

      function checkProperties(value, key) {
          return hasOwn(this, key);
      }

      /**
       * Checks if two objects have the same keys and values.
       */
      function equals(a, b, callback) {
          callback = callback || is;

          if (!isObject(a) || !isObject(b)) {
              return callback(a, b);
          }

          return (every(a, makeCompare(callback), b) &&
                  every(b, checkProperties, a));
      }

      module.exports = equals;


  },{"../lang/is":796,"../lang/isObject":800,"./every":808,"./hasOwn":811}],808:[function(require,module,exports){
  var forOwn = require('./forOwn');
  var makeIterator = require('../function/makeIterator_');

      /**
       * Object every
       */
      function every(obj, callback, thisObj) {
          callback = makeIterator(callback, thisObj);
          var result = true;
          forOwn(obj, function(val, key) {
              // we consider any falsy values as "false" on purpose so shorthand
              // syntax can be used to check property existence
              if (!callback(val, key, obj)) {
                  result = false;
                  return false; // break
              }
          });
          return result;
      }

      module.exports = every;



  },{"../function/makeIterator_":790,"./forOwn":810}],809:[function(require,module,exports){
  var hasOwn = require('./hasOwn');

      var _hasDontEnumBug,
          _dontEnums;

      function checkDontEnum(){
          _dontEnums = [
                  'toString',
                  'toLocaleString',
                  'valueOf',
                  'hasOwnProperty',
                  'isPrototypeOf',
                  'propertyIsEnumerable',
                  'constructor'
              ];

          _hasDontEnumBug = true;

          for (var key in {'toString': null}) {
              _hasDontEnumBug = false;
          }
      }

      /**
       * Similar to Array/forEach but works over object properties and fixes Don't
       * Enum bug on IE.
       * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
       */
      function forIn(obj, fn, thisObj){
          var key, i = 0;
          // no need to check if argument is a real object that way we can use
          // it for arrays, functions, date, etc.

          //post-pone check till needed
          if (_hasDontEnumBug == null) checkDontEnum();

          for (key in obj) {
              if (exec(fn, obj, key, thisObj) === false) {
                  break;
              }
          }


          if (_hasDontEnumBug) {
              var ctor = obj.constructor,
                  isProto = !!ctor && obj === ctor.prototype;

              while (key = _dontEnums[i++]) {
                  // For constructor, if it is a prototype object the constructor
                  // is always non-enumerable unless defined otherwise (and
                  // enumerated above).  For non-prototype objects, it will have
                  // to be defined on this object, since it cannot be defined on
                  // any prototype objects.
                  //
                  // For other [[DontEnum]] properties, check if the value is
                  // different than Object prototype value.
                  if (
                      (key !== 'constructor' ||
                          (!isProto && hasOwn(obj, key))) &&
                      obj[key] !== Object.prototype[key]
                  ) {
                      if (exec(fn, obj, key, thisObj) === false) {
                          break;
                      }
                  }
              }
          }
      }

      function exec(fn, obj, key, thisObj){
          return fn.call(thisObj, obj[key], key, obj);
      }

      module.exports = forIn;



  },{"./hasOwn":811}],810:[function(require,module,exports){
  var hasOwn = require('./hasOwn');
  var forIn = require('./forIn');

      /**
       * Similar to Array/forEach but works over object properties and fixes Don't
       * Enum bug on IE.
       * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
       */
      function forOwn(obj, fn, thisObj){
          forIn(obj, function(val, key){
              if (hasOwn(obj, key)) {
                  return fn.call(thisObj, obj[key], key, obj);
              }
          });
      }

      module.exports = forOwn;



  },{"./forIn":809,"./hasOwn":811}],811:[function(require,module,exports){


      /**
       * Safer Object.hasOwnProperty
       */
       function hasOwn(obj, prop){
           return Object.prototype.hasOwnProperty.call(obj, prop);
       }

       module.exports = hasOwn;



  },{}],812:[function(require,module,exports){
  var hasOwn = require('./hasOwn');
  var deepClone = require('../lang/deepClone');
  var isObject = require('../lang/isObject');

      /**
       * Deep merge objects.
       */
      function merge() {
          var i = 1,
              key, val, obj, target;

          // make sure we don't modify source element and it's properties
          // objects are passed by reference
          target = deepClone( arguments[0] );

          while (obj = arguments[i++]) {
              for (key in obj) {
                  if ( ! hasOwn(obj, key) ) {
                      continue;
                  }

                  val = obj[key];

                  if ( isObject(val) && isObject(target[key]) ){
                      // inception, deep merge objects
                      target[key] = merge(target[key], val);
                  } else {
                      // make sure arrays, regexp, date, objects are cloned
                      target[key] = deepClone(val);
                  }

              }
          }

          return target;
      }

      module.exports = merge;



  },{"../lang/deepClone":794,"../lang/isObject":800,"./hasOwn":811}],813:[function(require,module,exports){
  var forOwn = require('./forOwn');

      /**
      * Combine properties from all the objects into first one.
      * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
      * @param {object} target    Target Object
      * @param {...object} objects    Objects to be combined (0...n objects).
      * @return {object} Target Object.
      */
      function mixIn(target, objects){
          var i = 0,
              n = arguments.length,
              obj;
          while(++i < n){
              obj = arguments[i];
              if (obj != null) {
                  forOwn(obj, copyProp, target);
              }
          }
          return target;
      }

      function copyProp(val, key){
          this[key] = val;
      }

      module.exports = mixIn;


  },{"./forOwn":810}],814:[function(require,module,exports){
  var slice = require('../array/slice');

      /**
       * Return a copy of the object, filtered to only have values for the whitelisted keys.
       */
      function pick(obj, var_keys){
          var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
              out = {},
              i = 0, key;
          while (key = keys[i++]) {
              out[key] = obj[key];
          }
          return out;
      }

      module.exports = pick;



  },{"../array/slice":786}],815:[function(require,module,exports){

      /**
       * Contains all Unicode white-spaces. Taken from
       * http://en.wikipedia.org/wiki/Whitespace_character.
       */
      module.exports = [
          ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
          '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
          '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
          '\u205F', '\u3000'
      ];


  },{}],816:[function(require,module,exports){
  var toString = require('../lang/toString');

      /**
       * Escape RegExp string chars.
       */
      function escapeRegExp(str) {
          return toString(str).replace(/\W/g,'\\$&');
      }

      module.exports = escapeRegExp;



  },{"../lang/toString":804}],817:[function(require,module,exports){
  var toString = require('../lang/toString');
  var WHITE_SPACES = require('./WHITE_SPACES');
      /**
       * Remove chars from beginning of string.
       */
      function ltrim(str, chars) {
          str = toString(str);
          chars = chars || WHITE_SPACES;

          var start = 0,
              len = str.length,
              charLen = chars.length,
              found = true,
              i, c;

          while (found && start < len) {
              found = false;
              i = -1;
              c = str.charAt(start);

              while (++i < charLen) {
                  if (c === chars[i]) {
                      found = true;
                      start++;
                      break;
                  }
              }
          }

          return (start >= len) ? '' : str.substr(start, len);
      }

      module.exports = ltrim;


  },{"../lang/toString":804,"./WHITE_SPACES":815}],818:[function(require,module,exports){
  var toString = require('../lang/toString');
  var WHITE_SPACES = require('./WHITE_SPACES');
      /**
       * Remove chars from end of string.
       */
      function rtrim(str, chars) {
          str = toString(str);
          chars = chars || WHITE_SPACES;

          var end = str.length - 1,
              charLen = chars.length,
              found = true,
              i, c;

          while (found && end >= 0) {
              found = false;
              i = -1;
              c = str.charAt(end);

              while (++i < charLen) {
                  if (c === chars[i]) {
                      found = true;
                      end--;
                      break;
                  }
              }
          }

          return (end >= 0) ? str.substring(0, end + 1) : '';
      }

      module.exports = rtrim;


  },{"../lang/toString":804,"./WHITE_SPACES":815}],819:[function(require,module,exports){
  var toString = require('../lang/toString');
  var WHITE_SPACES = require('./WHITE_SPACES');
  var ltrim = require('./ltrim');
  var rtrim = require('./rtrim');
      /**
       * Remove white-spaces from beginning and end of string.
       */
      function trim(str, chars) {
          str = toString(str);
          chars = chars || WHITE_SPACES;
          return ltrim(rtrim(str, chars), chars);
      }

      module.exports = trim;


  },{"../lang/toString":804,"./WHITE_SPACES":815,"./ltrim":817,"./rtrim":818}],820:[function(require,module,exports){


      /**
       * Get current time in miliseconds
       */
      function now(){
          // yes, we defer the work to another function to allow mocking it
          // during the tests
          return now.get();
      }

      now.get = (typeof Date.now === 'function')? Date.now : function(){
          return +(new Date());
      };

      module.exports = now;



  },{}],821:[function(require,module,exports){
  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val)
    );
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (ms >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (ms >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (ms >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    return plural(ms, d, 'day') ||
      plural(ms, h, 'hour') ||
      plural(ms, m, 'minute') ||
      plural(ms, s, 'second') ||
      ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + ' ' + name;
    }
    return Math.ceil(ms / n) + ' ' + name + 's';
  }

  },{}],822:[function(require,module,exports){
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */

  'use strict';
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }

      // Detect buggy property enumeration order in older V8 versions.

      // https://bugs.chromium.org/p/v8/issues/detail?id=4118
      var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
      test1[5] = 'de';
      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });
      if (order2.join('') !== '0123456789') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join('') !==
          'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }

  module.exports = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };

  },{}],823:[function(require,module,exports){
  // shim for using process in browser
  var process = module.exports = {};

  // cached from whatever global is present so that test runners that stub it
  // don't break things.  But we need to wrap it in a try catch in case it is
  // wrapped in strict mode code which doesn't define any globals.  It's inside a
  // function because try/catches deoptimize in certain engines.

  var cachedSetTimeout;
  var cachedClearTimeout;

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  (function () {
      try {
          if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
          } else {
              cachedSetTimeout = defaultSetTimout;
          }
      } catch (e) {
          cachedSetTimeout = defaultSetTimout;
      }
      try {
          if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
          } else {
              cachedClearTimeout = defaultClearTimeout;
          }
      } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
      }
  } ())
  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }

  process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  };

  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = ''; // empty string to avoid regexp issues
  process.versions = {};

  function noop() {}

  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;

  process.binding = function (name) {
      throw new Error('process.binding is not supported');
  };

  process.cwd = function () { return '/' };
  process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
  };
  process.umask = function() { return 0; };

  },{}],824:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  if ("production" !== 'production') {
    var invariant = require('fbjs/lib/invariant');
    var warning = require('fbjs/lib/warning');
    var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
    var loggedTypeFailures = {};
  }

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */
  function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if ("production" !== 'production') {
      for (var typeSpecName in typeSpecs) {
        if (typeSpecs.hasOwnProperty(typeSpecName)) {
          var error;
          // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.
          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
            error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
          } catch (ex) {
            error = ex;
          }
          warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
          if (error instanceof Error && !(error.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;

            var stack = getStack ? getStack() : '';

            warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
          }
        }
      }
    }
  }

  module.exports = checkPropTypes;

  },{"./lib/ReactPropTypesSecret":828,"fbjs/lib/invariant":721,"fbjs/lib/warning":725}],825:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  var emptyFunction = require('fbjs/lib/emptyFunction');
  var invariant = require('fbjs/lib/invariant');
  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

  module.exports = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        // It is still safe when called from React.
        return;
      }
      invariant(
        false,
        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
        'Use PropTypes.checkPropTypes() to call them. ' +
        'Read more at http://fb.me/use-check-prop-types'
      );
    };
    shim.isRequired = shim;
    function getShim() {
      return shim;
    };
    // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,

      any: shim,
      arrayOf: getShim,
      element: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim
    };

    ReactPropTypes.checkPropTypes = emptyFunction;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  },{"./lib/ReactPropTypesSecret":828,"fbjs/lib/emptyFunction":715,"fbjs/lib/invariant":721}],826:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  var emptyFunction = require('fbjs/lib/emptyFunction');
  var invariant = require('fbjs/lib/invariant');
  var warning = require('fbjs/lib/warning');
  var assign = require('object-assign');

  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
  var checkPropTypes = require('./checkPropTypes');

  module.exports = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */
    function getIteratorFn(maybeIterable) {
      var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */

    var ANONYMOUS = '<<anonymous>>';

    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),

      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker,
    };

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    /*eslint-disable no-self-compare*/
    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */
    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      if ("production" !== 'production') {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            invariant(
              false,
              'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
              'Use `PropTypes.checkPropTypes()` to call them. ' +
              'Read more at http://fb.me/use-check-prop-types'
            );
          } else if ("production" !== 'production' && typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;
            if (
              !manualPropTypeCallCache[cacheKey] &&
              // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3
            ) {
              warning(
                false,
                'You are manually calling a React.PropTypes validation ' +
                'function for the `%s` prop on `%s`. This is deprecated ' +
                'and will throw in the standalone `prop-types` package. ' +
                'You may be seeing this warning due to a third-party PropTypes ' +
                'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
                propFullName,
                componentName
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
            }
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
          }
          return null;
        } else {
          return validate(props, propName, componentName, location, propFullName);
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);

      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(props, propName, componentName, location, propFullName, secret) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);

          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunction.thatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(props, propName, componentName, location, propFullName) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
        return emptyFunction.thatReturnsNull;
      }

      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
      }
      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(props, propName, componentName, location, propFullName) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
        }
        for (var key in propValue) {
          if (propValue.hasOwnProperty(key)) {
            var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        "production" !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
        return emptyFunction.thatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== 'function') {
          warning(
            false,
            'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
            'received %s at index %s.',
            getPostfixForTypeWarning(checker),
            i
          );
          return emptyFunction.thatReturnsNull;
        }
      }

      function validate(props, propName, componentName, location, propFullName) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
            return null;
          }
        }

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
      }
      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(props, propName, componentName, location, propFullName) {
        if (!isNode(props[propName])) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (!checker) {
            continue;
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(props, propName, componentName, location, propFullName) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
        }
        // We need to check all keys in case some are required but missing from
        // props.
        var allKeys = assign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (!checker) {
            return new PropTypeError(
              'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
              '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
              '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
            );
          }
          var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error) {
            return error;
          }
        }
        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;
        case 'boolean':
          return !propValue;
        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;
        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      }

      // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      // Fallback for non-spec compliant Symbols which are polyfilled.
      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return 'array';
      }
      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }
      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }
      return propType;
    }

    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }
      return propType;
    }

    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;
        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;
        default:
          return type;
      }
    }

    // Returns class name of the object, if any.
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  },{"./checkPropTypes":824,"./lib/ReactPropTypesSecret":828,"fbjs/lib/emptyFunction":715,"fbjs/lib/invariant":721,"fbjs/lib/warning":725,"object-assign":822}],827:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  if ("production" !== 'production') {
    var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
      Symbol.for &&
      Symbol.for('react.element')) ||
      0xeac7;

    var isValidElement = function(object) {
      return typeof object === 'object' &&
        object !== null &&
        object.$$typeof === REACT_ELEMENT_TYPE;
    };

    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
  } else {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = require('./factoryWithThrowingShims')();
  }

  },{"./factoryWithThrowingShims":825,"./factoryWithTypeCheckers":826}],828:[function(require,module,exports){
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  module.exports = ReactPropTypesSecret;

  },{}],829:[function(require,module,exports){
  var always = /*#__PURE__*/require('./always');

  /**
   * A function that always returns `false`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.always, R.T
   * @example
   *
   *      R.F(); //=> false
   */


  var F = /*#__PURE__*/always(false);
  module.exports = F;
  },{"./always":837}],830:[function(require,module,exports){
  var always = /*#__PURE__*/require('./always');

  /**
   * A function that always returns `true`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.always, R.F
   * @example
   *
   *      R.T(); //=> true
   */


  var T = /*#__PURE__*/always(true);
  module.exports = T;
  },{"./always":837}],831:[function(require,module,exports){
  /**
   * A special placeholder value used to specify "gaps" within curried functions,
   * allowing partial application of any combination of arguments, regardless of
   * their positions.
   *
   * If `g` is a curried ternary function and `_` is `R.__`, the following are
   * equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2, _)(1, 3)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @constant
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @example
   *
   *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
   *      greet('Alice'); //=> 'Hello, Alice!'
   */
  module.exports = { '@@functional/placeholder': true };
  },{}],832:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Adds two values.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a
   * @param {Number} b
   * @return {Number}
   * @see R.subtract
   * @example
   *
   *      R.add(2, 3);       //=>  5
   *      R.add(7)(10);      //=> 17
   */


  var add = /*#__PURE__*/_curry2(function add(a, b) {
    return Number(a) + Number(b);
  });
  module.exports = add;
  },{"./internal/_curry2":934}],833:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var curryN = /*#__PURE__*/require('./curryN');

  /**
   * Creates a new list iteration function from an existing one by adding two new
   * parameters to its callback function: the current index, and the entire list.
   *
   * This would turn, for instance, [`R.map`](#map) function into one that
   * more closely resembles `Array.prototype.map`. Note that this will only work
   * for functions in which the iteration callback function is the first
   * parameter, and where the list is the last parameter. (This latter might be
   * unimportant if the list parameter is not used.)
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Function
   * @category List
   * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
   * @param {Function} fn A list iteration function that does not pass index or list to its callback
   * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
   * @example
   *
   *      var mapIndexed = R.addIndex(R.map);
   *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
   *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
   */


  var addIndex = /*#__PURE__*/_curry1(function addIndex(fn) {
    return curryN(fn.length, function () {
      var idx = 0;
      var origFn = arguments[0];
      var list = arguments[arguments.length - 1];
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = function () {
        var result = origFn.apply(this, _concat(arguments, [idx, list]));
        idx += 1;
        return result;
      };
      return fn.apply(this, args);
    });
  });
  module.exports = addIndex;
  },{"./curryN":870,"./internal/_concat":929,"./internal/_curry1":933}],834:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Applies a function to the value at the given index of an array, returning a
   * new copy of the array with the element at the given index replaced with the
   * result of the function application.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig (a -> a) -> Number -> [a] -> [a]
   * @param {Function} fn The function to apply.
   * @param {Number} idx The index.
   * @param {Array|Arguments} list An array-like object whose value
   *        at the supplied index will be replaced.
   * @return {Array} A copy of the supplied array-like object with
   *         the element at index `idx` replaced with the value
   *         returned by applying `fn` to the existing element.
   * @see R.update
   * @example
   *
   *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
   *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
   * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
   * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
   */


  var adjust = /*#__PURE__*/_curry3(function adjust(fn, idx, list) {
    if (idx >= list.length || idx < -list.length) {
      return list;
    }
    var start = idx < 0 ? list.length : 0;
    var _idx = start + idx;
    var _list = _concat(list);
    _list[_idx] = fn(list[_idx]);
    return _list;
  });
  module.exports = adjust;
  },{"./internal/_concat":929,"./internal/_curry3":935}],835:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xall = /*#__PURE__*/require('./internal/_xall');

  /**
   * Returns `true` if all elements of the list match the predicate, `false` if
   * there are any that don't.
   *
   * Dispatches to the `all` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
   *         otherwise.
   * @see R.any, R.none, R.transduce
   * @example
   *
   *      var equals3 = R.equals(3);
   *      R.all(equals3)([3, 3, 3, 3]); //=> true
   *      R.all(equals3)([3, 3, 1, 3]); //=> false
   */


  var all = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['all'], _xall, function all(fn, list) {
    var idx = 0;
    while (idx < list.length) {
      if (!fn(list[idx])) {
        return false;
      }
      idx += 1;
    }
    return true;
  }));
  module.exports = all;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xall":971}],836:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var curryN = /*#__PURE__*/require('./curryN');

  var max = /*#__PURE__*/require('./max');

  var pluck = /*#__PURE__*/require('./pluck');

  var reduce = /*#__PURE__*/require('./reduce');

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if every one of the provided predicates is satisfied
   * by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.anyPass
   * @example
   *
   *      var isQueen = R.propEq('rank', 'Q');
   *      var isSpade = R.propEq('suit', '♠︎');
   *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
   *
   *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
   *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
   */


  var allPass = /*#__PURE__*/_curry1(function allPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;
      while (idx < len) {
        if (!preds[idx].apply(this, arguments)) {
          return false;
        }
        idx += 1;
      }
      return true;
    });
  });
  module.exports = allPass;
  },{"./curryN":870,"./internal/_curry1":933,"./max":1022,"./pluck":1067,"./reduce":1078}],837:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Returns a function that always returns the given value. Note that for
   * non-primitives the value returned is a reference to the original value.
   *
   * This function is known as `const`, `constant`, or `K` (for K combinator) in
   * other languages and libraries.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> (* -> a)
   * @param {*} val The value to wrap in a function
   * @return {Function} A Function :: * -> val.
   * @example
   *
   *      var t = R.always('Tee');
   *      t(); //=> 'Tee'
   */


  var always = /*#__PURE__*/_curry1(function always(val) {
    return function () {
      return val;
    };
  });
  module.exports = always;
  },{"./internal/_curry1":933}],838:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns `true` if both arguments are `true`; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any} the first argument if it is falsy, otherwise the second argument.
   * @see R.both
   * @example
   *
   *      R.and(true, true); //=> true
   *      R.and(true, false); //=> false
   *      R.and(false, true); //=> false
   *      R.and(false, false); //=> false
   */


  var and = /*#__PURE__*/_curry2(function and(a, b) {
    return a && b;
  });
  module.exports = and;
  },{"./internal/_curry2":934}],839:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xany = /*#__PURE__*/require('./internal/_xany');

  /**
   * Returns `true` if at least one of elements of the list match the predicate,
   * `false` otherwise.
   *
   * Dispatches to the `any` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
   *         otherwise.
   * @see R.all, R.none, R.transduce
   * @example
   *
   *      var lessThan0 = R.flip(R.lt)(0);
   *      var lessThan2 = R.flip(R.lt)(2);
   *      R.any(lessThan0)([1, 2]); //=> false
   *      R.any(lessThan2)([1, 2]); //=> true
   */


  var any = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['any'], _xany, function any(fn, list) {
    var idx = 0;
    while (idx < list.length) {
      if (fn(list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }));
  module.exports = any;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xany":972}],840:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var curryN = /*#__PURE__*/require('./curryN');

  var max = /*#__PURE__*/require('./max');

  var pluck = /*#__PURE__*/require('./pluck');

  var reduce = /*#__PURE__*/require('./reduce');

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if at least one of the provided predicates is
   * satisfied by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.allPass
   * @example
   *
   *      var isClub = R.propEq('suit', '♣');
   *      var isSpade = R.propEq('suit', '♠');
   *      var isBlackCard = R.anyPass([isClub, isSpade]);
   *
   *      isBlackCard({rank: '10', suit: '♣'}); //=> true
   *      isBlackCard({rank: 'Q', suit: '♠'}); //=> true
   *      isBlackCard({rank: 'Q', suit: '♦'}); //=> false
   */


  var anyPass = /*#__PURE__*/_curry1(function anyPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;
      while (idx < len) {
        if (preds[idx].apply(this, arguments)) {
          return true;
        }
        idx += 1;
      }
      return false;
    });
  });
  module.exports = anyPass;
  },{"./curryN":870,"./internal/_curry1":933,"./max":1022,"./pluck":1067,"./reduce":1078}],841:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var map = /*#__PURE__*/require('./map');

  /**
   * ap applies a list of functions to a list of values.
   *
   * Dispatches to the `ap` method of the second argument, if present. Also
   * treats curried functions as applicatives.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig [a -> b] -> [a] -> [b]
   * @sig Apply f => f (a -> b) -> f a -> f b
   * @sig (a -> b -> c) -> (a -> b) -> (a -> c)
   * @param {*} applyF
   * @param {*} applyX
   * @return {*}
   * @example
   *
   *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
   *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
   *
   *      // R.ap can also be used as S combinator
   *      // when only two functions are passed
   *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
   * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
   */


  var ap = /*#__PURE__*/_curry2(function ap(applyF, applyX) {
    return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
      return applyF(x)(applyX(x));
    } :
    // else
    _reduce(function (acc, f) {
      return _concat(acc, map(f, applyX));
    }, [], applyF);
  });
  module.exports = ap;
  },{"./internal/_concat":929,"./internal/_curry2":934,"./internal/_reduce":966,"./map":1016}],842:[function(require,module,exports){
  var _aperture = /*#__PURE__*/require('./internal/_aperture');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xaperture = /*#__PURE__*/require('./internal/_xaperture');

  /**
   * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
   * greater than the length of the list, an empty list is returned.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @param {Number} n The size of the tuples to create
   * @param {Array} list The list to split into `n`-length tuples
   * @return {Array} The resulting list of `n`-length tuples
   * @see R.transduce
   * @example
   *
   *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
   *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
   *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
   */


  var aperture = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xaperture, _aperture));
  module.exports = aperture;
  },{"./internal/_aperture":921,"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xaperture":973}],843:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a new list containing the contents of the given list, followed by
   * the given element.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The element to add to the end of the new list.
   * @param {Array} list The list of elements to add a new item to.
   *        list.
   * @return {Array} A new list containing the elements of the old list followed by `el`.
   * @see R.prepend
   * @example
   *
   *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
   *      R.append('tests', []); //=> ['tests']
   *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
   */


  var append = /*#__PURE__*/_curry2(function append(el, list) {
    return _concat(list, [el]);
  });
  module.exports = append;
  },{"./internal/_concat":929,"./internal/_curry2":934}],844:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Applies function `fn` to the argument list `args`. This is useful for
   * creating a fixed-arity function from a variadic function. `fn` should be a
   * bound function if context is significant.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> a) -> [*] -> a
   * @param {Function} fn The function which will be called with `args`
   * @param {Array} args The arguments to call `fn` with
   * @return {*} result The result, equivalent to `fn(...args)`
   * @see R.call, R.unapply
   * @example
   *
   *      var nums = [1, 2, 3, -99, 42, 6, 7];
   *      R.apply(Math.max, nums); //=> 42
   * @symb R.apply(f, [a, b, c]) = f(a, b, c)
   */


  var apply = /*#__PURE__*/_curry2(function apply(fn, args) {
    return fn.apply(this, args);
  });
  module.exports = apply;
  },{"./internal/_curry2":934}],845:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var apply = /*#__PURE__*/require('./apply');

  var curryN = /*#__PURE__*/require('./curryN');

  var map = /*#__PURE__*/require('./map');

  var max = /*#__PURE__*/require('./max');

  var pluck = /*#__PURE__*/require('./pluck');

  var reduce = /*#__PURE__*/require('./reduce');

  var values = /*#__PURE__*/require('./values');

  /**
   * Given a spec object recursively mapping properties to functions, creates a
   * function producing an object of the same structure, by mapping each property
   * to the result of calling its associated function with the supplied arguments.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
   * @param {Object} spec an object recursively mapping properties to functions for
   *        producing the values for these properties.
   * @return {Function} A function that returns an object of the same structure
   * as `spec', with each property set to the value returned by calling its
   * associated function with the supplied arguments.
   * @see R.converge, R.juxt
   * @example
   *
   *      var getMetrics = R.applySpec({
   *        sum: R.add,
   *        nested: { mul: R.multiply }
   *      });
   *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
   * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
   */


  var applySpec = /*#__PURE__*/_curry1(function applySpec(spec) {
    spec = map(function (v) {
      return typeof v == 'function' ? v : applySpec(v);
    }, spec);
    return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
      var args = arguments;
      return map(function (f) {
        return apply(f, args);
      }, spec);
    });
  });
  module.exports = applySpec;
  },{"./apply":844,"./curryN":870,"./internal/_curry1":933,"./map":1016,"./max":1022,"./pluck":1067,"./reduce":1078,"./values":1137}],846:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
  * Takes a value and applies a function to it.
  *
  * This function is also known as the `thrush` combinator.
  *
  * @func
  * @memberOf R
   * @since v0.25.0
  * @category Function
  * @sig a -> (a -> b) -> b
  * @param {*} x The value
  * @param {Function} f The function to apply
  * @return {*} The result of applying `f` to `x`
  * @example
  *
  *      var t42 = R.applyTo(42);
  *      t42(R.identity); //=> 42
  *      t42(R.add(1)); //=> 43
  */


  var applyTo = /*#__PURE__*/_curry2(function applyTo(x, f) {
    return f(x);
  });
  module.exports = applyTo;
  },{"./internal/_curry2":934}],847:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Makes an ascending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
   * @see R.descend
   * @example
   *
   *      var byAge = R.ascend(R.prop('age'));
   *      var people = [
   *        // ...
   *      ];
   *      var peopleByYoungestFirst = R.sort(byAge, people);
   */


  var ascend = /*#__PURE__*/_curry3(function ascend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
  module.exports = ascend;
  },{"./internal/_curry3":935}],848:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @sig String -> a -> {k: v} -> {k: v}
   * @param {String} prop The property name to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except for the changed property.
   * @see R.dissoc
   * @example
   *
   *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
   */


  var assoc = /*#__PURE__*/_curry3(function assoc(prop, val, obj) {
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    result[prop] = val;
    return result;
  });
  module.exports = assoc;
  },{"./internal/_curry3":935}],849:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var _has = /*#__PURE__*/require('./internal/_has');

  var _isArray = /*#__PURE__*/require('./internal/_isArray');

  var _isInteger = /*#__PURE__*/require('./internal/_isInteger');

  var assoc = /*#__PURE__*/require('./assoc');

  var isNil = /*#__PURE__*/require('./isNil');

  /**
   * Makes a shallow clone of an object, setting or overriding the nodes required
   * to create the given path, and placing the specific value at the tail end of
   * that path. Note that this copies and flattens prototype properties onto the
   * new object as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig [Idx] -> a -> {a} -> {a}
   * @param {Array} path the path to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except along the specified path.
   * @see R.dissocPath
   * @example
   *
   *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
   *
   *      // Any missing or non-object keys in path will be overridden
   *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
   */


  var assocPath = /*#__PURE__*/_curry3(function assocPath(path, val, obj) {
    if (path.length === 0) {
      return val;
    }
    var idx = path[0];
    if (path.length > 1) {
      var nextObj = !isNil(obj) && _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
      val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
    }
    if (_isInteger(idx) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[idx] = val;
      return arr;
    } else {
      return assoc(idx, val, obj);
    }
  });
  module.exports = assocPath;
  },{"./assoc":848,"./internal/_curry3":935,"./internal/_has":945,"./internal/_isArray":949,"./internal/_isInteger":952,"./isNil":1000}],850:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var nAry = /*#__PURE__*/require('./nAry');

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 2 parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (* -> c) -> (a, b -> c)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 2.
   * @see R.nAry, R.unary
   * @example
   *
   *      var takesThreeArgs = function(a, b, c) {
   *        return [a, b, c];
   *      };
   *      takesThreeArgs.length; //=> 3
   *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
   *
   *      var takesTwoArgs = R.binary(takesThreeArgs);
   *      takesTwoArgs.length; //=> 2
   *      // Only 2 arguments are passed to the wrapped function
   *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
   * @symb R.binary(f)(a, b, c) = f(a, b)
   */


  var binary = /*#__PURE__*/_curry1(function binary(fn) {
    return nAry(2, fn);
  });
  module.exports = binary;
  },{"./internal/_curry1":933,"./nAry":1040}],851:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Creates a function that is bound to a context.
   * Note: `R.bind` does not provide the additional argument-binding capabilities of
   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @category Object
   * @sig (* -> *) -> {*} -> (* -> *)
   * @param {Function} fn The function to bind to context
   * @param {Object} thisObj The context to bind `fn` to
   * @return {Function} A function that will execute in the context of `thisObj`.
   * @see R.partial
   * @example
   *
   *      var log = R.bind(console.log, console);
   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
   *      // logs {a: 2}
   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
   */


  var bind = /*#__PURE__*/_curry2(function bind(fn, thisObj) {
    return _arity(fn.length, function () {
      return fn.apply(thisObj, arguments);
    });
  });
  module.exports = bind;
  },{"./internal/_arity":922,"./internal/_curry2":934}],852:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isFunction = /*#__PURE__*/require('./internal/_isFunction');

  var and = /*#__PURE__*/require('./and');

  var lift = /*#__PURE__*/require('./lift');

  /**
   * A function which calls the two provided functions and returns the `&&`
   * of the results.
   * It returns the result of the first function if it is false-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * false-y value.
   *
   * In addition to functions, `R.both` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f A predicate
   * @param {Function} g Another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
   * @see R.and
   * @example
   *
   *      var gt10 = R.gt(R.__, 10)
   *      var lt20 = R.lt(R.__, 20)
   *      var f = R.both(gt10, lt20);
   *      f(15); //=> true
   *      f(30); //=> false
   */


  var both = /*#__PURE__*/_curry2(function both(f, g) {
    return _isFunction(f) ? function _both() {
      return f.apply(this, arguments) && g.apply(this, arguments);
    } : lift(and)(f, g);
  });
  module.exports = both;
  },{"./and":838,"./internal/_curry2":934,"./internal/_isFunction":951,"./lift":1012}],853:[function(require,module,exports){
  var curry = /*#__PURE__*/require('./curry');

  /**
   * Returns the result of calling its first argument with the remaining
   * arguments. This is occasionally useful as a converging function for
   * [`R.converge`](#converge): the first branch can produce a function while the
   * remaining branches produce values to be passed to that function as its
   * arguments.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig (*... -> a),*... -> a
   * @param {Function} fn The function to apply to the remaining arguments.
   * @param {...*} args Any number of positional arguments.
   * @return {*}
   * @see R.apply
   * @example
   *
   *      R.call(R.add, 1, 2); //=> 3
   *
   *      var indentN = R.pipe(R.repeat(' '),
   *                           R.join(''),
   *                           R.replace(/^(?!$)/gm));
   *
   *      var format = R.converge(R.call, [
   *                                  R.pipe(R.prop('indent'), indentN),
   *                                  R.prop('value')
   *                              ]);
   *
   *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
   * @symb R.call(f, a, b) = f(a, b)
   */


  var call = /*#__PURE__*/curry(function call(fn) {
    return fn.apply(this, Array.prototype.slice.call(arguments, 1));
  });
  module.exports = call;
  },{"./curry":869}],854:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _makeFlat = /*#__PURE__*/require('./internal/_makeFlat');

  var _xchain = /*#__PURE__*/require('./internal/_xchain');

  var map = /*#__PURE__*/require('./map');

  /**
   * `chain` maps a function over a list and concatenates the results. `chain`
   * is also known as `flatMap` in some libraries
   *
   * Dispatches to the `chain` method of the second argument, if present,
   * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain m => (a -> m b) -> m a -> m b
   * @param {Function} fn The function to map with
   * @param {Array} list The list to map over
   * @return {Array} The result of flat-mapping `list` with `fn`
   * @example
   *
   *      var duplicate = n => [n, n];
   *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
   *
   *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
   */


  var chain = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/chain', 'chain'], _xchain, function chain(fn, monad) {
    if (typeof monad === 'function') {
      return function (x) {
        return fn(monad(x))(x);
      };
    }
    return _makeFlat(false)(map(fn, monad));
  }));
  module.exports = chain;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_makeFlat":959,"./internal/_xchain":974,"./map":1016}],855:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Restricts a number to be within a range.
   *
   * Also works for other ordered types such as Strings and Dates.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Relation
   * @sig Ord a => a -> a -> a -> a
   * @param {Number} minimum The lower limit of the clamp (inclusive)
   * @param {Number} maximum The upper limit of the clamp (inclusive)
   * @param {Number} value Value to be clamped
   * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
   * @example
   *
   *      R.clamp(1, 10, -5) // => 1
   *      R.clamp(1, 10, 15) // => 10
   *      R.clamp(1, 10, 4)  // => 4
   */


  var clamp = /*#__PURE__*/_curry3(function clamp(min, max, value) {
    if (min > max) {
      throw new Error('min must not be greater than max in clamp(min, max, value)');
    }
    return value < min ? min : value > max ? max : value;
  });
  module.exports = clamp;
  },{"./internal/_curry3":935}],856:[function(require,module,exports){
  var _clone = /*#__PURE__*/require('./internal/_clone');

  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Creates a deep copy of the value which may contain (nested) `Array`s and
   * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
   * assigned by reference rather than copied
   *
   * Dispatches to a `clone` method if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {*} -> {*}
   * @param {*} value The object or array to clone
   * @return {*} A deeply cloned copy of `val`
   * @example
   *
   *      var objects = [{}, {}, {}];
   *      var objectsClone = R.clone(objects);
   *      objects === objectsClone; //=> false
   *      objects[0] === objectsClone[0]; //=> false
   */


  var clone = /*#__PURE__*/_curry1(function clone(value) {
    return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
  });
  module.exports = clone;
  },{"./internal/_clone":926,"./internal/_curry1":933}],857:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Makes a comparator function out of a function that reports whether the first
   * element is less than the second.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
   * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
   * is less than the second, `false` otherwise
   * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
   * @example
   *
   *      var byAge = R.comparator((a, b) => a.age < b.age);
   *      var people = [
   *        // ...
   *      ];
   *      var peopleByIncreasingAge = R.sort(byAge, people);
   */


  var comparator = /*#__PURE__*/_curry1(function comparator(pred) {
    return function (a, b) {
      return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
    };
  });
  module.exports = comparator;
  },{"./internal/_curry1":933}],858:[function(require,module,exports){
  var lift = /*#__PURE__*/require('./lift');

  var not = /*#__PURE__*/require('./not');

  /**
   * Takes a function `f` and returns a function `g` such that if called with the same arguments
   * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
   *
   * `R.complement` may be applied to any functor
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> *) -> (*... -> Boolean)
   * @param {Function} f
   * @return {Function}
   * @see R.not
   * @example
   *
   *      var isNotNil = R.complement(R.isNil);
   *      isNil(null); //=> true
   *      isNotNil(null); //=> false
   *      isNil(7); //=> false
   *      isNotNil(7); //=> true
   */


  var complement = /*#__PURE__*/lift(not);
  module.exports = complement;
  },{"./lift":1012,"./not":1043}],859:[function(require,module,exports){
  var pipe = /*#__PURE__*/require('./pipe');

  var reverse = /*#__PURE__*/require('./reverse');

  /**
   * Performs right-to-left function composition. The rightmost function may have
   * any arity; the remaining functions must be unary.
   *
   * **Note:** The result of compose is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
   * @param {...Function} ...functions The functions to compose
   * @return {Function}
   * @see R.pipe
   * @example
   *
   *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
   *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
   *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
   *
   * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
   */


  function compose() {
    if (arguments.length === 0) {
      throw new Error('compose requires at least one argument');
    }
    return pipe.apply(this, reverse(arguments));
  }
  module.exports = compose;
  },{"./pipe":1064,"./reverse":1087}],860:[function(require,module,exports){
  var chain = /*#__PURE__*/require('./chain');

  var compose = /*#__PURE__*/require('./compose');

  var map = /*#__PURE__*/require('./map');

  /**
   * Returns the right-to-left Kleisli composition of the provided functions,
   * each of which must return a value of a type supported by [`chain`](#chain).
   *
   * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), f)`.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Function
   * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
   * @param {...Function} ...functions The functions to compose
   * @return {Function}
   * @see R.pipeK
   * @example
   *
   *       //  get :: String -> Object -> Maybe *
   *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
   *
   *       //  getStateCode :: Maybe String -> Maybe String
   *       var getStateCode = R.composeK(
   *         R.compose(Maybe.of, R.toUpper),
   *         get('state'),
   *         get('address'),
   *         get('user'),
   *       );
   *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
   *       getStateCode({}); //=> Maybe.Nothing()
   * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
   */


  function composeK() {
    if (arguments.length === 0) {
      throw new Error('composeK requires at least one argument');
    }
    var init = Array.prototype.slice.call(arguments);
    var last = init.pop();
    return compose(compose.apply(this, map(chain, init)), last);
  }
  module.exports = composeK;
  },{"./chain":854,"./compose":859,"./map":1016}],861:[function(require,module,exports){
  var pipeP = /*#__PURE__*/require('./pipeP');

  var reverse = /*#__PURE__*/require('./reverse');

  /**
   * Performs right-to-left composition of one or more Promise-returning
   * functions. The rightmost function may have any arity; the remaining
   * functions must be unary.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
   * @param {...Function} functions The functions to compose
   * @return {Function}
   * @see R.pipeP
   * @example
   *
   *      var db = {
   *        users: {
   *          JOE: {
   *            name: 'Joe',
   *            followers: ['STEVE', 'SUZY']
   *          }
   *        }
   *      }
   *
   *      // We'll pretend to do a db lookup which returns a promise
   *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
   *      var lookupFollowers = (user) => Promise.resolve(user.followers)
   *      lookupUser('JOE').then(lookupFollowers)
   *
   *      //  followersForUser :: String -> Promise [UserId]
   *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
   *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
   *      // Followers: ["STEVE","SUZY"]
   */


  function composeP() {
    if (arguments.length === 0) {
      throw new Error('composeP requires at least one argument');
    }
    return pipeP.apply(this, reverse(arguments));
  }
  module.exports = composeP;
  },{"./pipeP":1066,"./reverse":1087}],862:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isArray = /*#__PURE__*/require('./internal/_isArray');

  var _isFunction = /*#__PURE__*/require('./internal/_isFunction');

  var _isString = /*#__PURE__*/require('./internal/_isString');

  var toString = /*#__PURE__*/require('./toString');

  /**
   * Returns the result of concatenating the given lists or strings.
   *
   * Note: `R.concat` expects both arguments to be of the same type,
   * unlike the native `Array.prototype.concat` method. It will throw
   * an error if you `concat` an Array with a non-Array value.
   *
   * Dispatches to the `concat` method of the first argument, if present.
   * Can also concatenate two members of a [fantasy-land
   * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @sig String -> String -> String
   * @param {Array|String} firstList The first list
   * @param {Array|String} secondList The second list
   * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
   * `secondList`.
   *
   * @example
   *
   *      R.concat('ABC', 'DEF'); // 'ABCDEF'
   *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   *      R.concat([], []); //=> []
   */


  var concat = /*#__PURE__*/_curry2(function concat(a, b) {
    if (_isArray(a)) {
      if (_isArray(b)) {
        return a.concat(b);
      }
      throw new TypeError(toString(b) + ' is not an array');
    }
    if (_isString(a)) {
      if (_isString(b)) {
        return a + b;
      }
      throw new TypeError(toString(b) + ' is not a string');
    }
    if (a != null && _isFunction(a['fantasy-land/concat'])) {
      return a['fantasy-land/concat'](b);
    }
    if (a != null && _isFunction(a.concat)) {
      return a.concat(b);
    }
    throw new TypeError(toString(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
  });
  module.exports = concat;
  },{"./internal/_curry2":934,"./internal/_isArray":949,"./internal/_isFunction":951,"./internal/_isString":957,"./toString":1115}],863:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var map = /*#__PURE__*/require('./map');

  var max = /*#__PURE__*/require('./max');

  var reduce = /*#__PURE__*/require('./reduce');

  /**
   * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
   * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
   * to `fn` are applied to each of the predicates in turn until one returns a
   * "truthy" value, at which point `fn` returns the result of applying its
   * arguments to the corresponding transformer. If none of the predicates
   * matches, `fn` returns undefined.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Logic
   * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
   * @param {Array} pairs A list of [predicate, transformer]
   * @return {Function}
   * @example
   *
   *      var fn = R.cond([
   *        [R.equals(0),   R.always('water freezes at 0°C')],
   *        [R.equals(100), R.always('water boils at 100°C')],
   *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
   *      ]);
   *      fn(0); //=> 'water freezes at 0°C'
   *      fn(50); //=> 'nothing special happens at 50°C'
   *      fn(100); //=> 'water boils at 100°C'
   */


  var cond = /*#__PURE__*/_curry1(function cond(pairs) {
    var arity = reduce(max, 0, map(function (pair) {
      return pair[0].length;
    }, pairs));
    return _arity(arity, function () {
      var idx = 0;
      while (idx < pairs.length) {
        if (pairs[idx][0].apply(this, arguments)) {
          return pairs[idx][1].apply(this, arguments);
        }
        idx += 1;
      }
    });
  });
  module.exports = cond;
  },{"./internal/_arity":922,"./internal/_curry1":933,"./map":1016,"./max":1022,"./reduce":1078}],864:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var constructN = /*#__PURE__*/require('./constructN');

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> {*}) -> (* -> {*})
   * @param {Function} fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @see R.invoker
   * @example
   *
   *      // Constructor function
   *      function Animal(kind) {
   *        this.kind = kind;
   *      };
   *      Animal.prototype.sighting = function() {
   *        return "It's a " + this.kind + "!";
   *      }
   *
   *      var AnimalConstructor = R.construct(Animal)
   *
   *      // Notice we no longer need the 'new' keyword:
   *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
   *
   *      var animalTypes = ["Lion", "Tiger", "Bear"];
   *      var animalSighting = R.invoker(0, 'sighting');
   *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
   *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
   */


  var construct = /*#__PURE__*/_curry1(function construct(Fn) {
    return constructN(Fn.length, Fn);
  });
  module.exports = construct;
  },{"./constructN":865,"./internal/_curry1":933}],865:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var curry = /*#__PURE__*/require('./curry');

  var nAry = /*#__PURE__*/require('./nAry');

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type. The arity of the function
   * returned is specified to allow using variadic constructor functions.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Function
   * @sig Number -> (* -> {*}) -> (* -> {*})
   * @param {Number} n The arity of the constructor function.
   * @param {Function} Fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @example
   *
   *      // Variadic Constructor function
   *      function Salad() {
   *        this.ingredients = arguments;
   *      }
   *
   *      Salad.prototype.recipe = function() {
   *        var instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
   *        return R.join('\n', instructions);
   *      };
   *
   *      var ThreeLayerSalad = R.constructN(3, Salad);
   *
   *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
   *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
   *
   *      console.log(salad.recipe());
   *      // Add a dollop of Mayonnaise
   *      // Add a dollop of Potato Chips
   *      // Add a dollop of Ketchup
   */


  var constructN = /*#__PURE__*/_curry2(function constructN(n, Fn) {
    if (n > 10) {
      throw new Error('Constructor with greater than ten arguments');
    }
    if (n === 0) {
      return function () {
        return new Fn();
      };
    }
    return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
      switch (arguments.length) {
        case 1:
          return new Fn($0);
        case 2:
          return new Fn($0, $1);
        case 3:
          return new Fn($0, $1, $2);
        case 4:
          return new Fn($0, $1, $2, $3);
        case 5:
          return new Fn($0, $1, $2, $3, $4);
        case 6:
          return new Fn($0, $1, $2, $3, $4, $5);
        case 7:
          return new Fn($0, $1, $2, $3, $4, $5, $6);
        case 8:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
        case 9:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
        case 10:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
      }
    }));
  });
  module.exports = constructN;
  },{"./curry":869,"./internal/_curry2":934,"./nAry":1040}],866:[function(require,module,exports){
  var _contains = /*#__PURE__*/require('./internal/_contains');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
   * terms, to at least one element of the given list; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Boolean
   * @param {Object} a The item to compare against.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
   * @see R.any
   * @example
   *
   *      R.contains(3, [1, 2, 3]); //=> true
   *      R.contains(4, [1, 2, 3]); //=> false
   *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
   *      R.contains([42], [[42]]); //=> true
   */


  var contains = /*#__PURE__*/_curry2(_contains);
  module.exports = contains;
  },{"./internal/_contains":930,"./internal/_curry2":934}],867:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _map = /*#__PURE__*/require('./internal/_map');

  var curryN = /*#__PURE__*/require('./curryN');

  var max = /*#__PURE__*/require('./max');

  var pluck = /*#__PURE__*/require('./pluck');

  var reduce = /*#__PURE__*/require('./reduce');

  /**
   * Accepts a converging function and a list of branching functions and returns
   * a new function. When invoked, this new function is applied to some
   * arguments, each branching function is applied to those same arguments. The
   * results of each branching function are passed as arguments to the converging
   * function to produce the return value.
   *
   * @func
   * @memberOf R
   * @since v0.4.2
   * @category Function
   * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} after A function. `after` will be invoked with the return values of
   *        `fn1` and `fn2` as its arguments.
   * @param {Array} functions A list of functions.
   * @return {Function} A new function.
   * @see R.useWith
   * @example
   *
   *      var average = R.converge(R.divide, [R.sum, R.length])
   *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
   *
   *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
   *      strangeConcat("Yodel") //=> "YODELyodel"
   *
   * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
   */


  var converge = /*#__PURE__*/_curry2(function converge(after, fns) {
    return curryN(reduce(max, 0, pluck('length', fns)), function () {
      var args = arguments;
      var context = this;
      return after.apply(context, _map(function (fn) {
        return fn.apply(context, args);
      }, fns));
    });
  });
  module.exports = converge;
  },{"./curryN":870,"./internal/_curry2":934,"./internal/_map":960,"./max":1022,"./pluck":1067,"./reduce":1078}],868:[function(require,module,exports){
  var reduceBy = /*#__PURE__*/require('./reduceBy');

  /**
   * Counts the elements of a list according to how many match each value of a
   * key generated by the supplied function. Returns an object mapping the keys
   * produced by `fn` to the number of occurrences in the list. Note that all
   * keys are coerced to strings because of how JavaScript objects work.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig (a -> String) -> [a] -> {*}
   * @param {Function} fn The function used to map values to keys.
   * @param {Array} list The list to count elements from.
   * @return {Object} An object mapping keys to number of occurrences in the list.
   * @example
   *
   *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
   *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
   *
   *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
   *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
   */


  var countBy = /*#__PURE__*/reduceBy(function (acc, elem) {
    return acc + 1;
  }, 0);
  module.exports = countBy;
  },{"./reduceBy":1079}],869:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var curryN = /*#__PURE__*/require('./curryN');

  /**
   * Returns a curried equivalent of the provided function. The curried function
   * has two unusual capabilities. First, its arguments needn't be provided one
   * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> a) -> (* -> a)
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curryN
   * @example
   *
   *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
   *
   *      var curriedAddFourNumbers = R.curry(addFourNumbers);
   *      var f = curriedAddFourNumbers(1, 2);
   *      var g = f(3);
   *      g(4); //=> 10
   */


  var curry = /*#__PURE__*/_curry1(function curry(fn) {
    return curryN(fn.length, fn);
  });
  module.exports = curry;
  },{"./curryN":870,"./internal/_curry1":933}],870:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _curryN = /*#__PURE__*/require('./internal/_curryN');

  /**
   * Returns a curried equivalent of the provided function, with the specified
   * arity. The curried function has two unusual capabilities. First, its
   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curry
   * @example
   *
   *      var sumArgs = (...args) => R.sum(args);
   *
   *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
   *      var f = curriedAddFourNumbers(1, 2);
   *      var g = f(3);
   *      g(4); //=> 10
   */


  var curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }
    return _arity(length, _curryN(length, [], fn));
  });
  module.exports = curryN;
  },{"./internal/_arity":922,"./internal/_curry1":933,"./internal/_curry2":934,"./internal/_curryN":936}],871:[function(require,module,exports){
  var add = /*#__PURE__*/require('./add');

  /**
   * Decrements its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n - 1
   * @see R.inc
   * @example
   *
   *      R.dec(42); //=> 41
   */


  var dec = /*#__PURE__*/add(-1);
  module.exports = dec;
  },{"./add":832}],872:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns the second argument if it is not `null`, `undefined` or `NaN`;
   * otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {a} default The default value.
   * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
   * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
   * @example
   *
   *      var defaultTo42 = R.defaultTo(42);
   *
   *      defaultTo42(null);  //=> 42
   *      defaultTo42(undefined);  //=> 42
   *      defaultTo42('Ramda');  //=> 'Ramda'
   *      // parseInt('string') results in NaN
   *      defaultTo42(parseInt('string')); //=> 42
   */


  var defaultTo = /*#__PURE__*/_curry2(function defaultTo(d, v) {
    return v == null || v !== v ? d : v;
  });
  module.exports = defaultTo;
  },{"./internal/_curry2":934}],873:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Makes a descending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
   * @see R.ascend
   * @example
   *
   *      var byAge = R.descend(R.prop('age'));
   *      var people = [
   *        // ...
   *      ];
   *      var peopleByOldestFirst = R.sort(byAge, people);
   */


  var descend = /*#__PURE__*/_curry3(function descend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa > bb ? -1 : aa < bb ? 1 : 0;
  });
  module.exports = descend;
  },{"./internal/_curry3":935}],874:[function(require,module,exports){
  var _contains = /*#__PURE__*/require('./internal/_contains');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Objects and Arrays are compared in terms of
   * value equality, not reference equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
   * @example
   *
   *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
   *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
   *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
   */


  var difference = /*#__PURE__*/_curry2(function difference(first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;
    while (idx < firstLen) {
      if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
        out[out.length] = first[idx];
      }
      idx += 1;
    }
    return out;
  });
  module.exports = difference;
  },{"./internal/_contains":930,"./internal/_curry2":934}],875:[function(require,module,exports){
  var _containsWith = /*#__PURE__*/require('./internal/_containsWith');

  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Duplication is determined according to the
   * value returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
   * @example
   *
   *      var cmp = (x, y) => x.a === y.a;
   *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
   *      var l2 = [{a: 3}, {a: 4}];
   *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
   */


  var differenceWith = /*#__PURE__*/_curry3(function differenceWith(pred, first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;
    while (idx < firstLen) {
      if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
        out.push(first[idx]);
      }
      idx += 1;
    }
    return out;
  });
  module.exports = differenceWith;
  },{"./internal/_containsWith":931,"./internal/_curry3":935}],876:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a new object that does not contain a `prop` property.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Object
   * @sig String -> {k: v} -> {k: v}
   * @param {String} prop The name of the property to dissociate
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original but without the specified property
   * @see R.assoc
   * @example
   *
   *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
   */


  var dissoc = /*#__PURE__*/_curry2(function dissoc(prop, obj) {
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    delete result[prop];
    return result;
  });
  module.exports = dissoc;
  },{"./internal/_curry2":934}],877:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isInteger = /*#__PURE__*/require('./internal/_isInteger');

  var assoc = /*#__PURE__*/require('./assoc');

  var dissoc = /*#__PURE__*/require('./dissoc');

  var remove = /*#__PURE__*/require('./remove');

  var update = /*#__PURE__*/require('./update');

  /**
   * Makes a shallow clone of an object, omitting the property at the given path.
   * Note that this copies and flattens prototype properties onto the new object
   * as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.11.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig [Idx] -> {k: v} -> {k: v}
   * @param {Array} path The path to the value to omit
   * @param {Object} obj The object to clone
   * @return {Object} A new object without the property at path
   * @see R.assocPath
   * @example
   *
   *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
   */


  var dissocPath = /*#__PURE__*/_curry2(function dissocPath(path, obj) {
    switch (path.length) {
      case 0:
        return obj;
      case 1:
        return _isInteger(path[0]) ? remove(path[0], 1, obj) : dissoc(path[0], obj);
      default:
        var head = path[0];
        var tail = Array.prototype.slice.call(path, 1);
        if (obj[head] == null) {
          return obj;
        } else if (_isInteger(path[0])) {
          return update(head, dissocPath(tail, obj[head]), obj);
        } else {
          return assoc(head, dissocPath(tail, obj[head]), obj);
        }
    }
  });
  module.exports = dissocPath;
  },{"./assoc":848,"./dissoc":876,"./internal/_curry2":934,"./internal/_isInteger":952,"./remove":1084,"./update":1135}],878:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Divides two numbers. Equivalent to `a / b`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a / b`.
   * @see R.multiply
   * @example
   *
   *      R.divide(71, 100); //=> 0.71
   *
   *      var half = R.divide(R.__, 2);
   *      half(42); //=> 21
   *
   *      var reciprocal = R.divide(1);
   *      reciprocal(4);   //=> 0.25
   */


  var divide = /*#__PURE__*/_curry2(function divide(a, b) {
    return a / b;
  });
  module.exports = divide;
  },{"./internal/_curry2":934}],879:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xdrop = /*#__PURE__*/require('./internal/_xdrop');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Returns all but the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `drop` method).
   *
   * Dispatches to the `drop` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*} A copy of list without the first `n` elements
   * @see R.take, R.transduce, R.dropLast, R.dropWhile
   * @example
   *
   *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(3, 'ramda');               //=> 'da'
   */


  var drop = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['drop'], _xdrop, function drop(n, xs) {
    return slice(Math.max(0, n), Infinity, xs);
  }));
  module.exports = drop;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xdrop":975,"./slice":1091}],880:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _dropLast = /*#__PURE__*/require('./internal/_dropLast');

  var _xdropLast = /*#__PURE__*/require('./internal/_xdropLast');

  /**
   * Returns a list containing all but the last `n` elements of the given `list`.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements of `list` to skip.
   * @param {Array} list The list of elements to consider.
   * @return {Array} A copy of the list with only the first `list.length - n` elements
   * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
   * @example
   *
   *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(3, 'ramda');               //=> 'ra'
   */


  var dropLast = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xdropLast, _dropLast));
  module.exports = dropLast;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_dropLast":938,"./internal/_xdropLast":976}],881:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _dropLastWhile = /*#__PURE__*/require('./internal/_dropLastWhile');

  var _xdropLastWhile = /*#__PURE__*/require('./internal/_xdropLastWhile');

  /**
   * Returns a new list excluding all the tailing elements of a given list which
   * satisfy the supplied predicate function. It passes each value from the right
   * to the supplied predicate function, skipping elements until the predicate
   * function returns a `falsy` value. The predicate function is applied to one argument:
   * *(value)*.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} predicate The function to be called on each element
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
   * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
   * @example
   *
   *      var lteThree = x => x <= 3;
   *
   *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
   *
   *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
   */


  var dropLastWhile = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xdropLastWhile, _dropLastWhile));
  module.exports = dropLastWhile;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_dropLastWhile":939,"./internal/_xdropLastWhile":977}],882:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xdropRepeatsWith = /*#__PURE__*/require('./internal/_xdropRepeatsWith');

  var dropRepeatsWith = /*#__PURE__*/require('./dropRepeatsWith');

  var equals = /*#__PURE__*/require('./equals');

  /**
   * Returns a new list without any consecutively repeating elements.
   * [`R.equals`](#equals) is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
   */


  var dropRepeats = /*#__PURE__*/_curry1( /*#__PURE__*/_dispatchable([], /*#__PURE__*/_xdropRepeatsWith(equals), /*#__PURE__*/dropRepeatsWith(equals)));
  module.exports = dropRepeats;
  },{"./dropRepeatsWith":883,"./equals":890,"./internal/_curry1":933,"./internal/_dispatchable":937,"./internal/_xdropRepeatsWith":978}],883:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xdropRepeatsWith = /*#__PURE__*/require('./internal/_xdropRepeatsWith');

  var last = /*#__PURE__*/require('./last');

  /**
   * Returns a new list without any consecutively repeating elements. Equality is
   * determined by applying the supplied predicate to each pair of consecutive elements. The
   * first element in a series of equal elements will be preserved.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig ((a, a) -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
   *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
   */


  var dropRepeatsWith = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
    var result = [];
    var idx = 1;
    var len = list.length;
    if (len !== 0) {
      result[0] = list[0];
      while (idx < len) {
        if (!pred(last(result), list[idx])) {
          result[result.length] = list[idx];
        }
        idx += 1;
      }
    }
    return result;
  }));
  module.exports = dropRepeatsWith;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xdropRepeatsWith":978,"./last":1005}],884:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xdropWhile = /*#__PURE__*/require('./internal/_xdropWhile');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Returns a new list excluding the leading elements of a given list which
   * satisfy the supplied predicate function. It passes each value to the supplied
   * predicate function, skipping elements while the predicate function returns
   * `true`. The predicate function is applied to one argument: *(value)*.
   *
   * Dispatches to the `dropWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.takeWhile, R.transduce, R.addIndex
   * @example
   *
   *      var lteTwo = x => x <= 2;
   *
   *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
   *
   *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
   */


  var dropWhile = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, xs) {
    var idx = 0;
    var len = xs.length;
    while (idx < len && pred(xs[idx])) {
      idx += 1;
    }
    return slice(idx, Infinity, xs);
  }));
  module.exports = dropWhile;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xdropWhile":979,"./slice":1091}],885:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isFunction = /*#__PURE__*/require('./internal/_isFunction');

  var lift = /*#__PURE__*/require('./lift');

  var or = /*#__PURE__*/require('./or');

  /**
   * A function wrapping calls to the two functions in an `||` operation,
   * returning the result of the first function if it is truth-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * truth-y value.
   *
   * In addition to functions, `R.either` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f a predicate
   * @param {Function} g another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
   * @see R.or
   * @example
   *
   *      var gt10 = x => x > 10;
   *      var even = x => x % 2 === 0;
   *      var f = R.either(gt10, even);
   *      f(101); //=> true
   *      f(8); //=> true
   */


  var either = /*#__PURE__*/_curry2(function either(f, g) {
    return _isFunction(f) ? function _either() {
      return f.apply(this, arguments) || g.apply(this, arguments);
    } : lift(or)(f, g);
  });
  module.exports = either;
  },{"./internal/_curry2":934,"./internal/_isFunction":951,"./lift":1012,"./or":1051}],886:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _isArguments = /*#__PURE__*/require('./internal/_isArguments');

  var _isArray = /*#__PURE__*/require('./internal/_isArray');

  var _isObject = /*#__PURE__*/require('./internal/_isObject');

  var _isString = /*#__PURE__*/require('./internal/_isString');

  /**
   * Returns the empty value of its argument's type. Ramda defines the empty
   * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
   * types are supported if they define `<Type>.empty`,
   * `<Type>.prototype.empty` or implement the
   * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
   *
   * Dispatches to the `empty` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> a
   * @param {*} x
   * @return {*}
   * @example
   *
   *      R.empty(Just(42));      //=> Nothing()
   *      R.empty([1, 2, 3]);     //=> []
   *      R.empty('unicorns');    //=> ''
   *      R.empty({x: 1, y: 2});  //=> {}
   */


  var empty = /*#__PURE__*/_curry1(function empty(x) {
    return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
      return arguments;
    }() :
    // else
    void 0;
  });
  module.exports = empty;
  },{"./internal/_curry1":933,"./internal/_isArguments":948,"./internal/_isArray":949,"./internal/_isObject":954,"./internal/_isString":957}],887:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var equals = /*#__PURE__*/require('./equals');

  var takeLast = /*#__PURE__*/require('./takeLast');

  /**
   * Checks if a list ends with the provided values
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category List
   * @sig [a] -> Boolean
   * @sig String -> Boolean
   * @param {*} suffix
   * @param {*} list
   * @return {Boolean}
   * @example
   *
   *      R.endsWith('c', 'abc')                //=> true
   *      R.endsWith('b', 'abc')                //=> false
   *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
   *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
   */


  var endsWith = /*#__PURE__*/_curry2(function (suffix, list) {
    return equals(takeLast(suffix.length, list), suffix);
  });
  module.exports = endsWith;
  },{"./equals":890,"./internal/_curry2":934,"./takeLast":1106}],888:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var equals = /*#__PURE__*/require('./equals');

  /**
   * Takes a function and two values in its domain and returns `true` if the
   * values map to the same value in the codomain; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Relation
   * @sig (a -> b) -> a -> a -> Boolean
   * @param {Function} f
   * @param {*} x
   * @param {*} y
   * @return {Boolean}
   * @example
   *
   *      R.eqBy(Math.abs, 5, -5); //=> true
   */


  var eqBy = /*#__PURE__*/_curry3(function eqBy(f, x, y) {
    return equals(f(x), f(y));
  });
  module.exports = eqBy;
  },{"./equals":890,"./internal/_curry3":935}],889:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var equals = /*#__PURE__*/require('./equals');

  /**
   * Reports whether two objects have the same value, in [`R.equals`](#equals)
   * terms, for the specified property. Useful as a curried predicate.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig k -> {k: v} -> {k: v} -> Boolean
   * @param {String} prop The name of the property to compare
   * @param {Object} obj1
   * @param {Object} obj2
   * @return {Boolean}
   *
   * @example
   *
   *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
   *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
   *      R.eqProps('a', o1, o2); //=> false
   *      R.eqProps('c', o1, o2); //=> true
   */


  var eqProps = /*#__PURE__*/_curry3(function eqProps(prop, obj1, obj2) {
    return equals(obj1[prop], obj2[prop]);
  });
  module.exports = eqProps;
  },{"./equals":890,"./internal/_curry3":935}],890:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _equals = /*#__PURE__*/require('./internal/_equals');

  /**
   * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
   * cyclical data structures.
   *
   * Dispatches symmetrically to the `equals` methods of both arguments, if
   * present.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> b -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      R.equals(1, 1); //=> true
   *      R.equals(1, '1'); //=> false
   *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
   *
   *      var a = {}; a.v = a;
   *      var b = {}; b.v = b;
   *      R.equals(a, b); //=> true
   */


  var equals = /*#__PURE__*/_curry2(function equals(a, b) {
    return _equals(a, b, [], []);
  });
  module.exports = equals;
  },{"./internal/_curry2":934,"./internal/_equals":940}],891:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Creates a new object by recursively evolving a shallow copy of `object`,
   * according to the `transformation` functions. All non-primitive properties
   * are copied by reference.
   *
   * A `transformation` function will not be invoked if its corresponding key
   * does not exist in the evolved object.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {k: (v -> v)} -> {k: v} -> {k: v}
   * @param {Object} transformations The object specifying transformation functions to apply
   *        to the object.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
   *      var transformations = {
   *        firstName: R.trim,
   *        lastName: R.trim, // Will not get invoked.
   *        data: {elapsed: R.add(1), remaining: R.add(-1)}
   *      };
   *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
   */


  var evolve = /*#__PURE__*/_curry2(function evolve(transformations, object) {
    var result = {};
    var transformation, key, type;
    for (key in object) {
      transformation = transformations[key];
      type = typeof transformation;
      result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
    }
    return result;
  });
  module.exports = evolve;
  },{"./internal/_curry2":934}],892:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _filter = /*#__PURE__*/require('./internal/_filter');

  var _isObject = /*#__PURE__*/require('./internal/_isObject');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var _xfilter = /*#__PURE__*/require('./internal/_xfilter');

  var keys = /*#__PURE__*/require('./keys');

  /**
   * Takes a predicate and a `Filterable`, and returns a new filterable of the
   * same type containing the members of the given filterable which satisfy the
   * given predicate. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * Dispatches to the `filter` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array} Filterable
   * @see R.reject, R.transduce, R.addIndex
   * @example
   *
   *      var isEven = n => n % 2 === 0;
   *
   *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */


  var filter = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['filter'], _xfilter, function (pred, filterable) {
    return _isObject(filterable) ? _reduce(function (acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }
      return acc;
    }, {}, keys(filterable)) :
    // else
    _filter(pred, filterable);
  }));
  module.exports = filter;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_filter":941,"./internal/_isObject":954,"./internal/_reduce":966,"./internal/_xfilter":981,"./keys":1003}],893:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xfind = /*#__PURE__*/require('./internal/_xfind');

  /**
   * Returns the first element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Dispatches to the `find` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   *        desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
   *      R.find(R.propEq('a', 4))(xs); //=> undefined
   */


  var find = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['find'], _xfind, function find(fn, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn(list[idx])) {
        return list[idx];
      }
      idx += 1;
    }
  }));
  module.exports = find;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xfind":982}],894:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xfindIndex = /*#__PURE__*/require('./internal/_xfindIndex');

  /**
   * Returns the index of the first element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
   *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
   */


  var findIndex = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xfindIndex, function findIndex(fn, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn(list[idx])) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }));
  module.exports = findIndex;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xfindIndex":983}],895:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xfindLast = /*#__PURE__*/require('./internal/_xfindLast');

  /**
   * Returns the last element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
   *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
   */


  var findLast = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xfindLast, function findLast(fn, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn(list[idx])) {
        return list[idx];
      }
      idx -= 1;
    }
  }));
  module.exports = findLast;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xfindLast":984}],896:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xfindLastIndex = /*#__PURE__*/require('./internal/_xfindLastIndex');

  /**
   * Returns the index of the last element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
   *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
   */


  var findLastIndex = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn(list[idx])) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }));
  module.exports = findLastIndex;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xfindLastIndex":985}],897:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _makeFlat = /*#__PURE__*/require('./internal/_makeFlat');

  /**
   * Returns a new list by pulling every item out of it (and all its sub-arrays)
   * and putting them in a new array, depth-first.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b]
   * @param {Array} list The array to consider.
   * @return {Array} The flattened list.
   * @see R.unnest
   * @example
   *
   *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
   *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
   */


  var flatten = /*#__PURE__*/_curry1( /*#__PURE__*/_makeFlat(true));
  module.exports = flatten;
  },{"./internal/_curry1":933,"./internal/_makeFlat":959}],898:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var curryN = /*#__PURE__*/require('./curryN');

  /**
   * Returns a new function much like the supplied one, except that the first two
   * arguments' order is reversed.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
   * @param {Function} fn The function to invoke with its first two parameters reversed.
   * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
   * @example
   *
   *      var mergeThree = (a, b, c) => [].concat(a, b, c);
   *
   *      mergeThree(1, 2, 3); //=> [1, 2, 3]
   *
   *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
   * @symb R.flip(f)(a, b, c) = f(b, a, c)
   */


  var flip = /*#__PURE__*/_curry1(function flip(fn) {
    return curryN(fn.length, function (a, b) {
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = b;
      args[1] = a;
      return fn.apply(this, args);
    });
  });
  module.exports = flip;
  },{"./curryN":870,"./internal/_curry1":933}],899:[function(require,module,exports){
  var _checkForMethod = /*#__PURE__*/require('./internal/_checkForMethod');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Iterate over an input `list`, calling a provided function `fn` for each
   * element in the list.
   *
   * `fn` receives one argument: *(value)*.
   *
   * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.forEach` method. For more
   * details on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
   *
   * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
   * the original array. In some libraries this function is named `each`.
   *
   * Dispatches to the `forEach` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> *) -> [a] -> [a]
   * @param {Function} fn The function to invoke. Receives one argument, `value`.
   * @param {Array} list The list to iterate over.
   * @return {Array} The original list.
   * @see R.addIndex
   * @example
   *
   *      var printXPlusFive = x => console.log(x + 5);
   *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
   *      // logs 6
   *      // logs 7
   *      // logs 8
   * @symb R.forEach(f, [a, b, c]) = [a, b, c]
   */


  var forEach = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('forEach', function forEach(fn, list) {
    var len = list.length;
    var idx = 0;
    while (idx < len) {
      fn(list[idx]);
      idx += 1;
    }
    return list;
  }));
  module.exports = forEach;
  },{"./internal/_checkForMethod":925,"./internal/_curry2":934}],900:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var keys = /*#__PURE__*/require('./keys');

  /**
   * Iterate over an input `object`, calling a provided function `fn` for each
   * key and value in the object.
   *
   * `fn` receives three argument: *(value, key, obj)*.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Object
   * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
   * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
   * @param {Object} obj The object to iterate over.
   * @return {Object} The original object.
   * @example
   *
   *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
   *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
   *      // logs x:1
   *      // logs y:2
   * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
   */


  var forEachObjIndexed = /*#__PURE__*/_curry2(function forEachObjIndexed(fn, obj) {
    var keyList = keys(obj);
    var idx = 0;
    while (idx < keyList.length) {
      var key = keyList[idx];
      fn(obj[key], key, obj);
      idx += 1;
    }
    return obj;
  });
  module.exports = forEachObjIndexed;
  },{"./internal/_curry2":934,"./keys":1003}],901:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Creates a new object from a list key-value pairs. If a key appears in
   * multiple pairs, the rightmost pair is included in the object.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [[k,v]] -> {k: v}
   * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
   * @return {Object} The object made by pairing up `keys` and `values`.
   * @see R.toPairs, R.pair
   * @example
   *
   *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
   */


  var fromPairs = /*#__PURE__*/_curry1(function fromPairs(pairs) {
    var result = {};
    var idx = 0;
    while (idx < pairs.length) {
      result[pairs[idx][0]] = pairs[idx][1];
      idx += 1;
    }
    return result;
  });
  module.exports = fromPairs;
  },{"./internal/_curry1":933}],902:[function(require,module,exports){
  var _checkForMethod = /*#__PURE__*/require('./internal/_checkForMethod');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var reduceBy = /*#__PURE__*/require('./reduceBy');

  /**
   * Splits a list into sub-lists stored in an object, based on the result of
   * calling a String-returning function on each element, and grouping the
   * results according to values returned.
   *
   * Dispatches to the `groupBy` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> String) -> [a] -> {String: [a]}
   * @param {Function} fn Function :: a -> String
   * @param {Array} list The array to group
   * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
   *         that produced that key when passed to `fn`.
   * @see R.transduce
   * @example
   *
   *      var byGrade = R.groupBy(function(student) {
   *        var score = student.score;
   *        return score < 65 ? 'F' :
   *               score < 70 ? 'D' :
   *               score < 80 ? 'C' :
   *               score < 90 ? 'B' : 'A';
   *      });
   *      var students = [{name: 'Abby', score: 84},
   *                      {name: 'Eddy', score: 58},
   *                      // ...
   *                      {name: 'Jack', score: 69}];
   *      byGrade(students);
   *      // {
   *      //   'A': [{name: 'Dianne', score: 99}],
   *      //   'B': [{name: 'Abby', score: 84}]
   *      //   // ...,
   *      //   'F': [{name: 'Eddy', score: 58}]
   *      // }
   */


  var groupBy = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('groupBy', /*#__PURE__*/reduceBy(function (acc, item) {
    if (acc == null) {
      acc = [];
    }
    acc.push(item);
    return acc;
  }, null)));
  module.exports = groupBy;
  },{"./internal/_checkForMethod":925,"./internal/_curry2":934,"./reduceBy":1079}],903:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Takes a list and returns a list of lists where each sublist's elements are
   * all satisfied pairwise comparison according to the provided function.
   * Only adjacent elements are passed to the comparison function.
   *
   * @func
   * @memberOf R
   * @since v0.21.0
   * @category List
   * @sig ((a, a) → Boolean) → [a] → [[a]]
   * @param {Function} fn Function for determining whether two given (adjacent)
   *        elements should be in the same group
   * @param {Array} list The array to group. Also accepts a string, which will be
   *        treated as a list of characters.
   * @return {List} A list that contains sublists of elements,
   *         whose concatenations are equal to the original list.
   * @example
   *
   * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
   *
   * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
   *
   * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
   *
   * R.groupWith(R.eqBy(isVowel), 'aestiou')
   * //=> ['ae', 'st', 'iou']
   */


  var groupWith = /*#__PURE__*/_curry2(function (fn, list) {
    var res = [];
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      var nextidx = idx + 1;
      while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
        nextidx += 1;
      }
      res.push(list.slice(idx, nextidx));
      idx = nextidx;
    }
    return res;
  });
  module.exports = groupWith;
  },{"./internal/_curry2":934}],904:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is greater than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.lt
   * @example
   *
   *      R.gt(2, 1); //=> true
   *      R.gt(2, 2); //=> false
   *      R.gt(2, 3); //=> false
   *      R.gt('a', 'z'); //=> false
   *      R.gt('z', 'a'); //=> true
   */


  var gt = /*#__PURE__*/_curry2(function gt(a, b) {
    return a > b;
  });
  module.exports = gt;
  },{"./internal/_curry2":934}],905:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is greater than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.lte
   * @example
   *
   *      R.gte(2, 1); //=> true
   *      R.gte(2, 2); //=> true
   *      R.gte(2, 3); //=> false
   *      R.gte('a', 'z'); //=> false
   *      R.gte('z', 'a'); //=> true
   */


  var gte = /*#__PURE__*/_curry2(function gte(a, b) {
    return a >= b;
  });
  module.exports = gte;
  },{"./internal/_curry2":934}],906:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _has = /*#__PURE__*/require('./internal/_has');

  /**
   * Returns whether or not an object has an own property with the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      var hasName = R.has('name');
   *      hasName({name: 'alice'});   //=> true
   *      hasName({name: 'bob'});     //=> true
   *      hasName({});                //=> false
   *
   *      var point = {x: 0, y: 0};
   *      var pointHas = R.has(R.__, point);
   *      pointHas('x');  //=> true
   *      pointHas('y');  //=> true
   *      pointHas('z');  //=> false
   */


  var has = /*#__PURE__*/_curry2(_has);
  module.exports = has;
  },{"./internal/_curry2":934,"./internal/_has":945}],907:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns whether or not an object or its prototype chain has a property with
   * the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      function Rectangle(width, height) {
   *        this.width = width;
   *        this.height = height;
   *      }
   *      Rectangle.prototype.area = function() {
   *        return this.width * this.height;
   *      };
   *
   *      var square = new Rectangle(2, 2);
   *      R.hasIn('width', square);  //=> true
   *      R.hasIn('area', square);  //=> true
   */


  var hasIn = /*#__PURE__*/_curry2(function hasIn(prop, obj) {
    return prop in obj;
  });
  module.exports = hasIn;
  },{"./internal/_curry2":934}],908:[function(require,module,exports){
  var nth = /*#__PURE__*/require('./nth');

  /**
   * Returns the first element of the given list or string. In some libraries
   * this function is named `first`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {Array|String} list
   * @return {*}
   * @see R.tail, R.init, R.last
   * @example
   *
   *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
   *      R.head([]); //=> undefined
   *
   *      R.head('abc'); //=> 'a'
   *      R.head(''); //=> ''
   */


  var head = /*#__PURE__*/nth(0);
  module.exports = head;
  },{"./nth":1044}],909:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns true if its arguments are identical, false otherwise. Values are
   * identical if they reference the same memory. `NaN` is identical to `NaN`;
   * `0` and `-0` are not identical.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      var o = {};
   *      R.identical(o, o); //=> true
   *      R.identical(1, 1); //=> true
   *      R.identical(1, '1'); //=> false
   *      R.identical([], []); //=> false
   *      R.identical(0, -0); //=> false
   *      R.identical(NaN, NaN); //=> true
   */


  var identical = /*#__PURE__*/_curry2(function identical(a, b) {
    // SameValue algorithm
    if (a === b) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return a !== 0 || 1 / a === 1 / b;
    } else {
      // Step 6.a: NaN == NaN
      return a !== a && b !== b;
    }
  });
  module.exports = identical;
  },{"./internal/_curry2":934}],910:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _identity = /*#__PURE__*/require('./internal/_identity');

  /**
   * A function that does nothing but return the parameter supplied to it. Good
   * as a default or placeholder function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> a
   * @param {*} x The value to return.
   * @return {*} The input value, `x`.
   * @example
   *
   *      R.identity(1); //=> 1
   *
   *      var obj = {};
   *      R.identity(obj) === obj; //=> true
   * @symb R.identity(a) = a
   */


  var identity = /*#__PURE__*/_curry1(_identity);
  module.exports = identity;
  },{"./internal/_curry1":933,"./internal/_identity":946}],911:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var curryN = /*#__PURE__*/require('./curryN');

  /**
   * Creates a function that will process either the `onTrue` or the `onFalse`
   * function depending upon the result of the `condition` predicate.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
   * @param {Function} condition A predicate function
   * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
   * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
   * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
   *                    function depending upon the result of the `condition` predicate.
   * @see R.unless, R.when
   * @example
   *
   *      var incCount = R.ifElse(
   *        R.has('count'),
   *        R.over(R.lensProp('count'), R.inc),
   *        R.assoc('count', 1)
   *      );
   *      incCount({});           //=> { count: 1 }
   *      incCount({ count: 1 }); //=> { count: 2 }
   */


  var ifElse = /*#__PURE__*/_curry3(function ifElse(condition, onTrue, onFalse) {
    return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
      return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
    });
  });
  module.exports = ifElse;
  },{"./curryN":870,"./internal/_curry3":935}],912:[function(require,module,exports){
  var add = /*#__PURE__*/require('./add');

  /**
   * Increments its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n + 1
   * @see R.dec
   * @example
   *
   *      R.inc(42); //=> 43
   */


  var inc = /*#__PURE__*/add(1);
  module.exports = inc;
  },{"./add":832}],913:[function(require,module,exports){
  module.exports = {};
  module.exports.F = /*#__PURE__*/require('./F');
  module.exports.T = /*#__PURE__*/require('./T');
  module.exports.__ = /*#__PURE__*/require('./__');
  module.exports.add = /*#__PURE__*/require('./add');
  module.exports.addIndex = /*#__PURE__*/require('./addIndex');
  module.exports.adjust = /*#__PURE__*/require('./adjust');
  module.exports.all = /*#__PURE__*/require('./all');
  module.exports.allPass = /*#__PURE__*/require('./allPass');
  module.exports.always = /*#__PURE__*/require('./always');
  module.exports.and = /*#__PURE__*/require('./and');
  module.exports.any = /*#__PURE__*/require('./any');
  module.exports.anyPass = /*#__PURE__*/require('./anyPass');
  module.exports.ap = /*#__PURE__*/require('./ap');
  module.exports.aperture = /*#__PURE__*/require('./aperture');
  module.exports.append = /*#__PURE__*/require('./append');
  module.exports.apply = /*#__PURE__*/require('./apply');
  module.exports.applySpec = /*#__PURE__*/require('./applySpec');
  module.exports.applyTo = /*#__PURE__*/require('./applyTo');
  module.exports.ascend = /*#__PURE__*/require('./ascend');
  module.exports.assoc = /*#__PURE__*/require('./assoc');
  module.exports.assocPath = /*#__PURE__*/require('./assocPath');
  module.exports.binary = /*#__PURE__*/require('./binary');
  module.exports.bind = /*#__PURE__*/require('./bind');
  module.exports.both = /*#__PURE__*/require('./both');
  module.exports.call = /*#__PURE__*/require('./call');
  module.exports.chain = /*#__PURE__*/require('./chain');
  module.exports.clamp = /*#__PURE__*/require('./clamp');
  module.exports.clone = /*#__PURE__*/require('./clone');
  module.exports.comparator = /*#__PURE__*/require('./comparator');
  module.exports.complement = /*#__PURE__*/require('./complement');
  module.exports.compose = /*#__PURE__*/require('./compose');
  module.exports.composeK = /*#__PURE__*/require('./composeK');
  module.exports.composeP = /*#__PURE__*/require('./composeP');
  module.exports.concat = /*#__PURE__*/require('./concat');
  module.exports.cond = /*#__PURE__*/require('./cond');
  module.exports.construct = /*#__PURE__*/require('./construct');
  module.exports.constructN = /*#__PURE__*/require('./constructN');
  module.exports.contains = /*#__PURE__*/require('./contains');
  module.exports.converge = /*#__PURE__*/require('./converge');
  module.exports.countBy = /*#__PURE__*/require('./countBy');
  module.exports.curry = /*#__PURE__*/require('./curry');
  module.exports.curryN = /*#__PURE__*/require('./curryN');
  module.exports.dec = /*#__PURE__*/require('./dec');
  module.exports.defaultTo = /*#__PURE__*/require('./defaultTo');
  module.exports.descend = /*#__PURE__*/require('./descend');
  module.exports.difference = /*#__PURE__*/require('./difference');
  module.exports.differenceWith = /*#__PURE__*/require('./differenceWith');
  module.exports.dissoc = /*#__PURE__*/require('./dissoc');
  module.exports.dissocPath = /*#__PURE__*/require('./dissocPath');
  module.exports.divide = /*#__PURE__*/require('./divide');
  module.exports.drop = /*#__PURE__*/require('./drop');
  module.exports.dropLast = /*#__PURE__*/require('./dropLast');
  module.exports.dropLastWhile = /*#__PURE__*/require('./dropLastWhile');
  module.exports.dropRepeats = /*#__PURE__*/require('./dropRepeats');
  module.exports.dropRepeatsWith = /*#__PURE__*/require('./dropRepeatsWith');
  module.exports.dropWhile = /*#__PURE__*/require('./dropWhile');
  module.exports.either = /*#__PURE__*/require('./either');
  module.exports.empty = /*#__PURE__*/require('./empty');
  module.exports.endsWith = /*#__PURE__*/require('./endsWith');
  module.exports.eqBy = /*#__PURE__*/require('./eqBy');
  module.exports.eqProps = /*#__PURE__*/require('./eqProps');
  module.exports.equals = /*#__PURE__*/require('./equals');
  module.exports.evolve = /*#__PURE__*/require('./evolve');
  module.exports.filter = /*#__PURE__*/require('./filter');
  module.exports.find = /*#__PURE__*/require('./find');
  module.exports.findIndex = /*#__PURE__*/require('./findIndex');
  module.exports.findLast = /*#__PURE__*/require('./findLast');
  module.exports.findLastIndex = /*#__PURE__*/require('./findLastIndex');
  module.exports.flatten = /*#__PURE__*/require('./flatten');
  module.exports.flip = /*#__PURE__*/require('./flip');
  module.exports.forEach = /*#__PURE__*/require('./forEach');
  module.exports.forEachObjIndexed = /*#__PURE__*/require('./forEachObjIndexed');
  module.exports.fromPairs = /*#__PURE__*/require('./fromPairs');
  module.exports.groupBy = /*#__PURE__*/require('./groupBy');
  module.exports.groupWith = /*#__PURE__*/require('./groupWith');
  module.exports.gt = /*#__PURE__*/require('./gt');
  module.exports.gte = /*#__PURE__*/require('./gte');
  module.exports.has = /*#__PURE__*/require('./has');
  module.exports.hasIn = /*#__PURE__*/require('./hasIn');
  module.exports.head = /*#__PURE__*/require('./head');
  module.exports.identical = /*#__PURE__*/require('./identical');
  module.exports.identity = /*#__PURE__*/require('./identity');
  module.exports.ifElse = /*#__PURE__*/require('./ifElse');
  module.exports.inc = /*#__PURE__*/require('./inc');
  module.exports.indexBy = /*#__PURE__*/require('./indexBy');
  module.exports.indexOf = /*#__PURE__*/require('./indexOf');
  module.exports.init = /*#__PURE__*/require('./init');
  module.exports.innerJoin = /*#__PURE__*/require('./innerJoin');
  module.exports.insert = /*#__PURE__*/require('./insert');
  module.exports.insertAll = /*#__PURE__*/require('./insertAll');
  module.exports.intersection = /*#__PURE__*/require('./intersection');
  module.exports.intersperse = /*#__PURE__*/require('./intersperse');
  module.exports.into = /*#__PURE__*/require('./into');
  module.exports.invert = /*#__PURE__*/require('./invert');
  module.exports.invertObj = /*#__PURE__*/require('./invertObj');
  module.exports.invoker = /*#__PURE__*/require('./invoker');
  module.exports.is = /*#__PURE__*/require('./is');
  module.exports.isEmpty = /*#__PURE__*/require('./isEmpty');
  module.exports.isNil = /*#__PURE__*/require('./isNil');
  module.exports.join = /*#__PURE__*/require('./join');
  module.exports.juxt = /*#__PURE__*/require('./juxt');
  module.exports.keys = /*#__PURE__*/require('./keys');
  module.exports.keysIn = /*#__PURE__*/require('./keysIn');
  module.exports.last = /*#__PURE__*/require('./last');
  module.exports.lastIndexOf = /*#__PURE__*/require('./lastIndexOf');
  module.exports.length = /*#__PURE__*/require('./length');
  module.exports.lens = /*#__PURE__*/require('./lens');
  module.exports.lensIndex = /*#__PURE__*/require('./lensIndex');
  module.exports.lensPath = /*#__PURE__*/require('./lensPath');
  module.exports.lensProp = /*#__PURE__*/require('./lensProp');
  module.exports.lift = /*#__PURE__*/require('./lift');
  module.exports.liftN = /*#__PURE__*/require('./liftN');
  module.exports.lt = /*#__PURE__*/require('./lt');
  module.exports.lte = /*#__PURE__*/require('./lte');
  module.exports.map = /*#__PURE__*/require('./map');
  module.exports.mapAccum = /*#__PURE__*/require('./mapAccum');
  module.exports.mapAccumRight = /*#__PURE__*/require('./mapAccumRight');
  module.exports.mapObjIndexed = /*#__PURE__*/require('./mapObjIndexed');
  module.exports.match = /*#__PURE__*/require('./match');
  module.exports.mathMod = /*#__PURE__*/require('./mathMod');
  module.exports.max = /*#__PURE__*/require('./max');
  module.exports.maxBy = /*#__PURE__*/require('./maxBy');
  module.exports.mean = /*#__PURE__*/require('./mean');
  module.exports.median = /*#__PURE__*/require('./median');
  module.exports.memoize = /*#__PURE__*/require('./memoize');
  module.exports.memoizeWith = /*#__PURE__*/require('./memoizeWith');
  module.exports.merge = /*#__PURE__*/require('./merge');
  module.exports.mergeAll = /*#__PURE__*/require('./mergeAll');
  module.exports.mergeDeepLeft = /*#__PURE__*/require('./mergeDeepLeft');
  module.exports.mergeDeepRight = /*#__PURE__*/require('./mergeDeepRight');
  module.exports.mergeDeepWith = /*#__PURE__*/require('./mergeDeepWith');
  module.exports.mergeDeepWithKey = /*#__PURE__*/require('./mergeDeepWithKey');
  module.exports.mergeWith = /*#__PURE__*/require('./mergeWith');
  module.exports.mergeWithKey = /*#__PURE__*/require('./mergeWithKey');
  module.exports.min = /*#__PURE__*/require('./min');
  module.exports.minBy = /*#__PURE__*/require('./minBy');
  module.exports.modulo = /*#__PURE__*/require('./modulo');
  module.exports.multiply = /*#__PURE__*/require('./multiply');
  module.exports.nAry = /*#__PURE__*/require('./nAry');
  module.exports.negate = /*#__PURE__*/require('./negate');
  module.exports.none = /*#__PURE__*/require('./none');
  module.exports.not = /*#__PURE__*/require('./not');
  module.exports.nth = /*#__PURE__*/require('./nth');
  module.exports.nthArg = /*#__PURE__*/require('./nthArg');
  module.exports.o = /*#__PURE__*/require('./o');
  module.exports.objOf = /*#__PURE__*/require('./objOf');
  module.exports.of = /*#__PURE__*/require('./of');
  module.exports.omit = /*#__PURE__*/require('./omit');
  module.exports.once = /*#__PURE__*/require('./once');
  module.exports.or = /*#__PURE__*/require('./or');
  module.exports.over = /*#__PURE__*/require('./over');
  module.exports.pair = /*#__PURE__*/require('./pair');
  module.exports.partial = /*#__PURE__*/require('./partial');
  module.exports.partialRight = /*#__PURE__*/require('./partialRight');
  module.exports.partition = /*#__PURE__*/require('./partition');
  module.exports.path = /*#__PURE__*/require('./path');
  module.exports.pathEq = /*#__PURE__*/require('./pathEq');
  module.exports.pathOr = /*#__PURE__*/require('./pathOr');
  module.exports.pathSatisfies = /*#__PURE__*/require('./pathSatisfies');
  module.exports.pick = /*#__PURE__*/require('./pick');
  module.exports.pickAll = /*#__PURE__*/require('./pickAll');
  module.exports.pickBy = /*#__PURE__*/require('./pickBy');
  module.exports.pipe = /*#__PURE__*/require('./pipe');
  module.exports.pipeK = /*#__PURE__*/require('./pipeK');
  module.exports.pipeP = /*#__PURE__*/require('./pipeP');
  module.exports.pluck = /*#__PURE__*/require('./pluck');
  module.exports.prepend = /*#__PURE__*/require('./prepend');
  module.exports.product = /*#__PURE__*/require('./product');
  module.exports.project = /*#__PURE__*/require('./project');
  module.exports.prop = /*#__PURE__*/require('./prop');
  module.exports.propEq = /*#__PURE__*/require('./propEq');
  module.exports.propIs = /*#__PURE__*/require('./propIs');
  module.exports.propOr = /*#__PURE__*/require('./propOr');
  module.exports.propSatisfies = /*#__PURE__*/require('./propSatisfies');
  module.exports.props = /*#__PURE__*/require('./props');
  module.exports.range = /*#__PURE__*/require('./range');
  module.exports.reduce = /*#__PURE__*/require('./reduce');
  module.exports.reduceBy = /*#__PURE__*/require('./reduceBy');
  module.exports.reduceRight = /*#__PURE__*/require('./reduceRight');
  module.exports.reduceWhile = /*#__PURE__*/require('./reduceWhile');
  module.exports.reduced = /*#__PURE__*/require('./reduced');
  module.exports.reject = /*#__PURE__*/require('./reject');
  module.exports.remove = /*#__PURE__*/require('./remove');
  module.exports.repeat = /*#__PURE__*/require('./repeat');
  module.exports.replace = /*#__PURE__*/require('./replace');
  module.exports.reverse = /*#__PURE__*/require('./reverse');
  module.exports.scan = /*#__PURE__*/require('./scan');
  module.exports.sequence = /*#__PURE__*/require('./sequence');
  module.exports.set = /*#__PURE__*/require('./set');
  module.exports.slice = /*#__PURE__*/require('./slice');
  module.exports.sort = /*#__PURE__*/require('./sort');
  module.exports.sortBy = /*#__PURE__*/require('./sortBy');
  module.exports.sortWith = /*#__PURE__*/require('./sortWith');
  module.exports.split = /*#__PURE__*/require('./split');
  module.exports.splitAt = /*#__PURE__*/require('./splitAt');
  module.exports.splitEvery = /*#__PURE__*/require('./splitEvery');
  module.exports.splitWhen = /*#__PURE__*/require('./splitWhen');
  module.exports.startsWith = /*#__PURE__*/require('./startsWith');
  module.exports.subtract = /*#__PURE__*/require('./subtract');
  module.exports.sum = /*#__PURE__*/require('./sum');
  module.exports.symmetricDifference = /*#__PURE__*/require('./symmetricDifference');
  module.exports.symmetricDifferenceWith = /*#__PURE__*/require('./symmetricDifferenceWith');
  module.exports.tail = /*#__PURE__*/require('./tail');
  module.exports.take = /*#__PURE__*/require('./take');
  module.exports.takeLast = /*#__PURE__*/require('./takeLast');
  module.exports.takeLastWhile = /*#__PURE__*/require('./takeLastWhile');
  module.exports.takeWhile = /*#__PURE__*/require('./takeWhile');
  module.exports.tap = /*#__PURE__*/require('./tap');
  module.exports.test = /*#__PURE__*/require('./test');
  module.exports.times = /*#__PURE__*/require('./times');
  module.exports.toLower = /*#__PURE__*/require('./toLower');
  module.exports.toPairs = /*#__PURE__*/require('./toPairs');
  module.exports.toPairsIn = /*#__PURE__*/require('./toPairsIn');
  module.exports.toString = /*#__PURE__*/require('./toString');
  module.exports.toUpper = /*#__PURE__*/require('./toUpper');
  module.exports.transduce = /*#__PURE__*/require('./transduce');
  module.exports.transpose = /*#__PURE__*/require('./transpose');
  module.exports.traverse = /*#__PURE__*/require('./traverse');
  module.exports.trim = /*#__PURE__*/require('./trim');
  module.exports.tryCatch = /*#__PURE__*/require('./tryCatch');
  module.exports.type = /*#__PURE__*/require('./type');
  module.exports.unapply = /*#__PURE__*/require('./unapply');
  module.exports.unary = /*#__PURE__*/require('./unary');
  module.exports.uncurryN = /*#__PURE__*/require('./uncurryN');
  module.exports.unfold = /*#__PURE__*/require('./unfold');
  module.exports.union = /*#__PURE__*/require('./union');
  module.exports.unionWith = /*#__PURE__*/require('./unionWith');
  module.exports.uniq = /*#__PURE__*/require('./uniq');
  module.exports.uniqBy = /*#__PURE__*/require('./uniqBy');
  module.exports.uniqWith = /*#__PURE__*/require('./uniqWith');
  module.exports.unless = /*#__PURE__*/require('./unless');
  module.exports.unnest = /*#__PURE__*/require('./unnest');
  module.exports.until = /*#__PURE__*/require('./until');
  module.exports.update = /*#__PURE__*/require('./update');
  module.exports.useWith = /*#__PURE__*/require('./useWith');
  module.exports.values = /*#__PURE__*/require('./values');
  module.exports.valuesIn = /*#__PURE__*/require('./valuesIn');
  module.exports.view = /*#__PURE__*/require('./view');
  module.exports.when = /*#__PURE__*/require('./when');
  module.exports.where = /*#__PURE__*/require('./where');
  module.exports.whereEq = /*#__PURE__*/require('./whereEq');
  module.exports.without = /*#__PURE__*/require('./without');
  module.exports.xprod = /*#__PURE__*/require('./xprod');
  module.exports.zip = /*#__PURE__*/require('./zip');
  module.exports.zipObj = /*#__PURE__*/require('./zipObj');
  module.exports.zipWith = /*#__PURE__*/require('./zipWith');
  },{"./F":829,"./T":830,"./__":831,"./add":832,"./addIndex":833,"./adjust":834,"./all":835,"./allPass":836,"./always":837,"./and":838,"./any":839,"./anyPass":840,"./ap":841,"./aperture":842,"./append":843,"./apply":844,"./applySpec":845,"./applyTo":846,"./ascend":847,"./assoc":848,"./assocPath":849,"./binary":850,"./bind":851,"./both":852,"./call":853,"./chain":854,"./clamp":855,"./clone":856,"./comparator":857,"./complement":858,"./compose":859,"./composeK":860,"./composeP":861,"./concat":862,"./cond":863,"./construct":864,"./constructN":865,"./contains":866,"./converge":867,"./countBy":868,"./curry":869,"./curryN":870,"./dec":871,"./defaultTo":872,"./descend":873,"./difference":874,"./differenceWith":875,"./dissoc":876,"./dissocPath":877,"./divide":878,"./drop":879,"./dropLast":880,"./dropLastWhile":881,"./dropRepeats":882,"./dropRepeatsWith":883,"./dropWhile":884,"./either":885,"./empty":886,"./endsWith":887,"./eqBy":888,"./eqProps":889,"./equals":890,"./evolve":891,"./filter":892,"./find":893,"./findIndex":894,"./findLast":895,"./findLastIndex":896,"./flatten":897,"./flip":898,"./forEach":899,"./forEachObjIndexed":900,"./fromPairs":901,"./groupBy":902,"./groupWith":903,"./gt":904,"./gte":905,"./has":906,"./hasIn":907,"./head":908,"./identical":909,"./identity":910,"./ifElse":911,"./inc":912,"./indexBy":914,"./indexOf":915,"./init":916,"./innerJoin":917,"./insert":918,"./insertAll":919,"./intersection":992,"./intersperse":993,"./into":994,"./invert":995,"./invertObj":996,"./invoker":997,"./is":998,"./isEmpty":999,"./isNil":1000,"./join":1001,"./juxt":1002,"./keys":1003,"./keysIn":1004,"./last":1005,"./lastIndexOf":1006,"./length":1007,"./lens":1008,"./lensIndex":1009,"./lensPath":1010,"./lensProp":1011,"./lift":1012,"./liftN":1013,"./lt":1014,"./lte":1015,"./map":1016,"./mapAccum":1017,"./mapAccumRight":1018,"./mapObjIndexed":1019,"./match":1020,"./mathMod":1021,"./max":1022,"./maxBy":1023,"./mean":1024,"./median":1025,"./memoize":1026,"./memoizeWith":1027,"./merge":1028,"./mergeAll":1029,"./mergeDeepLeft":1030,"./mergeDeepRight":1031,"./mergeDeepWith":1032,"./mergeDeepWithKey":1033,"./mergeWith":1034,"./mergeWithKey":1035,"./min":1036,"./minBy":1037,"./modulo":1038,"./multiply":1039,"./nAry":1040,"./negate":1041,"./none":1042,"./not":1043,"./nth":1044,"./nthArg":1045,"./o":1046,"./objOf":1047,"./of":1048,"./omit":1049,"./once":1050,"./or":1051,"./over":1052,"./pair":1053,"./partial":1054,"./partialRight":1055,"./partition":1056,"./path":1057,"./pathEq":1058,"./pathOr":1059,"./pathSatisfies":1060,"./pick":1061,"./pickAll":1062,"./pickBy":1063,"./pipe":1064,"./pipeK":1065,"./pipeP":1066,"./pluck":1067,"./prepend":1068,"./product":1069,"./project":1070,"./prop":1071,"./propEq":1072,"./propIs":1073,"./propOr":1074,"./propSatisfies":1075,"./props":1076,"./range":1077,"./reduce":1078,"./reduceBy":1079,"./reduceRight":1080,"./reduceWhile":1081,"./reduced":1082,"./reject":1083,"./remove":1084,"./repeat":1085,"./replace":1086,"./reverse":1087,"./scan":1088,"./sequence":1089,"./set":1090,"./slice":1091,"./sort":1092,"./sortBy":1093,"./sortWith":1094,"./split":1095,"./splitAt":1096,"./splitEvery":1097,"./splitWhen":1098,"./startsWith":1099,"./subtract":1100,"./sum":1101,"./symmetricDifference":1102,"./symmetricDifferenceWith":1103,"./tail":1104,"./take":1105,"./takeLast":1106,"./takeLastWhile":1107,"./takeWhile":1108,"./tap":1109,"./test":1110,"./times":1111,"./toLower":1112,"./toPairs":1113,"./toPairsIn":1114,"./toString":1115,"./toUpper":1116,"./transduce":1117,"./transpose":1118,"./traverse":1119,"./trim":1120,"./tryCatch":1121,"./type":1122,"./unapply":1123,"./unary":1124,"./uncurryN":1125,"./unfold":1126,"./union":1127,"./unionWith":1128,"./uniq":1129,"./uniqBy":1130,"./uniqWith":1131,"./unless":1132,"./unnest":1133,"./until":1134,"./update":1135,"./useWith":1136,"./values":1137,"./valuesIn":1138,"./view":1139,"./when":1140,"./where":1141,"./whereEq":1142,"./without":1143,"./xprod":1144,"./zip":1145,"./zipObj":1146,"./zipWith":1147}],914:[function(require,module,exports){
  var reduceBy = /*#__PURE__*/require('./reduceBy');

  /**
   * Given a function that generates a key, turns a list of objects into an
   * object indexing the objects by the given key. Note that if multiple
   * objects generate the same value for the indexing key only the last value
   * will be included in the generated object.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
   * @param {Function} fn Function :: a -> String
   * @param {Array} array The array of objects to index
   * @return {Object} An object indexing each array element by the given property.
   * @example
   *
   *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
   *      R.indexBy(R.prop('id'), list);
   *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
   */


  var indexBy = /*#__PURE__*/reduceBy(function (acc, elem) {
    return elem;
  }, null);
  module.exports = indexBy;
  },{"./reduceBy":1079}],915:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _indexOf = /*#__PURE__*/require('./internal/_indexOf');

  var _isArray = /*#__PURE__*/require('./internal/_isArray');

  /**
   * Returns the position of the first occurrence of an item in an array, or -1
   * if the item is not included in the array. [`R.equals`](#equals) is used to
   * determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.lastIndexOf
   * @example
   *
   *      R.indexOf(3, [1,2,3,4]); //=> 2
   *      R.indexOf(10, [1,2,3,4]); //=> -1
   */


  var indexOf = /*#__PURE__*/_curry2(function indexOf(target, xs) {
    return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
  });
  module.exports = indexOf;
  },{"./internal/_curry2":934,"./internal/_indexOf":947,"./internal/_isArray":949}],916:[function(require,module,exports){
  var slice = /*#__PURE__*/require('./slice');

  /**
   * Returns all but the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.last, R.head, R.tail
   * @example
   *
   *      R.init([1, 2, 3]);  //=> [1, 2]
   *      R.init([1, 2]);     //=> [1]
   *      R.init([1]);        //=> []
   *      R.init([]);         //=> []
   *
   *      R.init('abc');  //=> 'ab'
   *      R.init('ab');   //=> 'a'
   *      R.init('a');    //=> ''
   *      R.init('');     //=> ''
   */


  var init = /*#__PURE__*/slice(0, -1);
  module.exports = init;
  },{"./slice":1091}],917:[function(require,module,exports){
  var _containsWith = /*#__PURE__*/require('./internal/_containsWith');

  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var _filter = /*#__PURE__*/require('./internal/_filter');

  /**
   * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
   * `xs'` comprising each of the elements of `xs` which is equal to one or more
   * elements of `ys` according to `pred`.
   *
   * `pred` must be a binary function expecting an element from each list.
   *
   * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
   * not be significant, but since `xs'` is ordered the implementation guarantees
   * that its values are in the same order as they appear in `xs`. Duplicates are
   * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Relation
   * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
   * @param {Function} pred
   * @param {Array} xs
   * @param {Array} ys
   * @return {Array}
   * @see R.intersection
   * @example
   *
   *      R.innerJoin(
   *        (record, id) => record.id === id,
   *        [{id: 824, name: 'Richie Furay'},
   *         {id: 956, name: 'Dewey Martin'},
   *         {id: 313, name: 'Bruce Palmer'},
   *         {id: 456, name: 'Stephen Stills'},
   *         {id: 177, name: 'Neil Young'}],
   *        [177, 456, 999]
   *      );
   *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
   */


  var innerJoin = /*#__PURE__*/_curry3(function innerJoin(pred, xs, ys) {
    return _filter(function (x) {
      return _containsWith(pred, x, ys);
    }, xs);
  });
  module.exports = innerJoin;
  },{"./internal/_containsWith":931,"./internal/_curry3":935,"./internal/_filter":941}],918:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Inserts the supplied element into the list, at the specified `index`. _Note that

   * this is not destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} index The position to insert the element
   * @param {*} elt The element to insert into the Array
   * @param {Array} list The list to insert into
   * @return {Array} A new Array with `elt` inserted at `index`.
   * @example
   *
   *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
   */


  var insert = /*#__PURE__*/_curry3(function insert(idx, elt, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    var result = Array.prototype.slice.call(list, 0);
    result.splice(idx, 0, elt);
    return result;
  });
  module.exports = insert;
  },{"./internal/_curry3":935}],919:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
   * destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig Number -> [a] -> [a] -> [a]
   * @param {Number} index The position to insert the sub-list
   * @param {Array} elts The sub-list to insert into the Array
   * @param {Array} list The list to insert the sub-list into
   * @return {Array} A new Array with `elts` inserted starting at `index`.
   * @example
   *
   *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
   */


  var insertAll = /*#__PURE__*/_curry3(function insertAll(idx, elts, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
  });
  module.exports = insertAll;
  },{"./internal/_curry3":935}],920:[function(require,module,exports){
  var _contains = /*#__PURE__*/require('./_contains');

  var _Set = /*#__PURE__*/function () {

    function _Set() {
      /* globals Set */
      this._nativeSet = typeof Set === 'function' ? new Set() : null;
      this._items = {};
    }

    // until we figure out why jsdoc chokes on this
    // @param item The item to add to the Set
    // @returns {boolean} true if the item did not exist prior, otherwise false
    //
    _Set.prototype.add = function (item) {
      return !hasOrAdd(item, true, this);
    };

    //
    // @param item The item to check for existence in the Set
    // @returns {boolean} true if the item exists in the Set, otherwise false
    //
    _Set.prototype.has = function (item) {
      return hasOrAdd(item, false, this);
    };

    //
    // Combines the logic for checking whether an item is a member of the set and
    // for adding a new item to the set.
    //
    // @param item       The item to check or add to the Set instance.
    // @param shouldAdd  If true, the item will be added to the set if it doesn't
    //                   already exist.
    // @param set        The set instance to check or add to.
    // @return {boolean} true if the item already existed, otherwise false.
    //
    return _Set;
  }();

  function hasOrAdd(item, shouldAdd, set) {
    var type = typeof item;
    var prevSize, newSize;
    switch (type) {
      case 'string':
      case 'number':
        // distinguish between +0 and -0
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items['-0']) {
            return true;
          } else {
            if (shouldAdd) {
              set._items['-0'] = true;
            }
            return false;
          }
        }
        // these types can all utilise the native Set
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = {};
              set._items[type][item] = true;
            }
            return false;
          } else if (item in set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][item] = true;
            }
            return false;
          }
        }

      case 'boolean':
        // set._items['boolean'] holds a two element array
        // representing [ falseExists, trueExists ]
        if (type in set._items) {
          var bIdx = item ? 1 : 0;
          if (set._items[type][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type] = item ? [false, true] : [true, false];
          }
          return false;
        }

      case 'function':
        // compare functions for reference equality
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;
            set._nativeSet.add(item);
            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }
            return false;
          }
          if (!_contains(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }
            return false;
          }
          return true;
        }

      case 'undefined':
        if (set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type] = true;
          }
          return false;
        }

      case 'object':
        if (item === null) {
          if (!set._items['null']) {
            if (shouldAdd) {
              set._items['null'] = true;
            }
            return false;
          }
          return true;
        }
      /* falls through */
      default:
        // reduce the search size of heterogeneous sets by creating buckets
        // for each type.
        type = Object.prototype.toString.call(item);
        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }
          return false;
        }
        // scan through all previously applied items
        if (!_contains(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }
          return false;
        }
        return true;
    }
  }

  // A simple Set type that honours R.equals semantics
  module.exports = _Set;
  },{"./_contains":930}],921:[function(require,module,exports){
  function _aperture(n, list) {
    var idx = 0;
    var limit = list.length - (n - 1);
    var acc = new Array(limit >= 0 ? limit : 0);
    while (idx < limit) {
      acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
      idx += 1;
    }
    return acc;
  }
  module.exports = _aperture;
  },{}],922:[function(require,module,exports){
  function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
      case 0:
        return function () {
          return fn.apply(this, arguments);
        };
      case 1:
        return function (a0) {
          return fn.apply(this, arguments);
        };
      case 2:
        return function (a0, a1) {
          return fn.apply(this, arguments);
        };
      case 3:
        return function (a0, a1, a2) {
          return fn.apply(this, arguments);
        };
      case 4:
        return function (a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };
      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };
      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };
      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };
      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };
      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };
      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };
      default:
        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
  }
  module.exports = _arity;
  },{}],923:[function(require,module,exports){
  function _arrayFromIterator(iter) {
    var list = [];
    var next;
    while (!(next = iter.next()).done) {
      list.push(next.value);
    }
    return list;
  }
  module.exports = _arrayFromIterator;
  },{}],924:[function(require,module,exports){
  var _objectAssign = /*#__PURE__*/require('./_objectAssign');

  module.exports = typeof Object.assign === 'function' ? Object.assign : _objectAssign;
  },{"./_objectAssign":961}],925:[function(require,module,exports){
  var _isArray = /*#__PURE__*/require('./_isArray');

  /**
   * This checks whether a function has a [methodname] function. If it isn't an
   * array it will execute that function otherwise it will default to the ramda
   * implementation.
   *
   * @private
   * @param {Function} fn ramda implemtation
   * @param {String} methodname property to check for a custom implementation
   * @return {Object} Whatever the return value of the method is.
   */


  function _checkForMethod(methodname, fn) {
    return function () {
      var length = arguments.length;
      if (length === 0) {
        return fn();
      }
      var obj = arguments[length - 1];
      return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
    };
  }
  module.exports = _checkForMethod;
  },{"./_isArray":949}],926:[function(require,module,exports){
  var _cloneRegExp = /*#__PURE__*/require('./_cloneRegExp');

  var type = /*#__PURE__*/require('../type');

  /**
   * Copies an object.
   *
   * @private
   * @param {*} value The value to be copied
   * @param {Array} refFrom Array containing the source references
   * @param {Array} refTo Array containing the copied source references
   * @param {Boolean} deep Whether or not to perform deep cloning.
   * @return {*} The copied value.
   */


  function _clone(value, refFrom, refTo, deep) {
    var copy = function copy(copiedValue) {
      var len = refFrom.length;
      var idx = 0;
      while (idx < len) {
        if (value === refFrom[idx]) {
          return refTo[idx];
        }
        idx += 1;
      }
      refFrom[idx + 1] = value;
      refTo[idx + 1] = copiedValue;
      for (var key in value) {
        copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
      }
      return copiedValue;
    };
    switch (type(value)) {
      case 'Object':
        return copy({});
      case 'Array':
        return copy([]);
      case 'Date':
        return new Date(value.valueOf());
      case 'RegExp':
        return _cloneRegExp(value);
      default:
        return value;
    }
  }
  module.exports = _clone;
  },{"../type":1122,"./_cloneRegExp":927}],927:[function(require,module,exports){
  function _cloneRegExp(pattern) {
                                    return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
  }
  module.exports = _cloneRegExp;
  },{}],928:[function(require,module,exports){
  function _complement(f) {
    return function () {
      return !f.apply(this, arguments);
    };
  }
  module.exports = _complement;
  },{}],929:[function(require,module,exports){
  /**
   * Private `concat` function to merge two array-like objects.
   *
   * @private
   * @param {Array|Arguments} [set1=[]] An array-like object.
   * @param {Array|Arguments} [set2=[]] An array-like object.
   * @return {Array} A new, merged array.
   * @example
   *
   *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   */
  function _concat(set1, set2) {
    set1 = set1 || [];
    set2 = set2 || [];
    var idx;
    var len1 = set1.length;
    var len2 = set2.length;
    var result = [];

    idx = 0;
    while (idx < len1) {
      result[result.length] = set1[idx];
      idx += 1;
    }
    idx = 0;
    while (idx < len2) {
      result[result.length] = set2[idx];
      idx += 1;
    }
    return result;
  }
  module.exports = _concat;
  },{}],930:[function(require,module,exports){
  var _indexOf = /*#__PURE__*/require('./_indexOf');

  function _contains(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }
  module.exports = _contains;
  },{"./_indexOf":947}],931:[function(require,module,exports){
  function _containsWith(pred, x, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }
  module.exports = _containsWith;
  },{}],932:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./_arity');

  var _curry2 = /*#__PURE__*/require('./_curry2');

  function _createPartialApplicator(concat) {
    return _curry2(function (fn, args) {
      return _arity(Math.max(0, fn.length - args.length), function () {
        return fn.apply(this, concat(args, arguments));
      });
    });
  }
  module.exports = _createPartialApplicator;
  },{"./_arity":922,"./_curry2":934}],933:[function(require,module,exports){
  var _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');

  /**
   * Optimized internal one-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */


  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }
  module.exports = _curry1;
  },{"./_isPlaceholder":955}],934:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./_curry1');

  var _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');

  /**
   * Optimized internal two-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */


  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }
  module.exports = _curry2;
  },{"./_curry1":933,"./_isPlaceholder":955}],935:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./_curry1');

  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');

  /**
   * Optimized internal three-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */


  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;
        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          });
        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function (_c) {
            return fn(a, b, _c);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function (_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }
  module.exports = _curry3;
  },{"./_curry1":933,"./_curry2":934,"./_isPlaceholder":955}],936:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./_arity');

  var _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');

  /**
   * Internal curryN function.
   *
   * @private
   * @category Function
   * @param {Number} length The arity of the curried function.
   * @param {Array} received An array of arguments received thus far.
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */


  function _curryN(length, received, fn) {
    return function () {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;
      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;
        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }
        combined[combinedIdx] = result;
        if (!_isPlaceholder(result)) {
          left -= 1;
        }
        combinedIdx += 1;
      }
      return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
    };
  }
  module.exports = _curryN;
  },{"./_arity":922,"./_isPlaceholder":955}],937:[function(require,module,exports){
  var _isArray = /*#__PURE__*/require('./_isArray');

  var _isTransformer = /*#__PURE__*/require('./_isTransformer');

  /**
   * Returns a function that dispatches with different strategies based on the
   * object in list position (last argument). If it is an array, executes [fn].
   * Otherwise, if it has a function with one of the given method names, it will
   * execute that function (functor case). Otherwise, if it is a transformer,
   * uses transducer [xf] to return a new transformer (transducer case).
   * Otherwise, it will default to executing [fn].
   *
   * @private
   * @param {Array} methodNames properties to check for a custom implementation
   * @param {Function} xf transducer to initialize if object is transformer
   * @param {Function} fn default ramda implementation
   * @return {Function} A function that dispatches on object in list position
   */


  function _dispatchable(methodNames, xf, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn();
      }
      var args = Array.prototype.slice.call(arguments, 0);
      var obj = args.pop();
      if (!_isArray(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, args);
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = xf.apply(null, args);
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }
  module.exports = _dispatchable;
  },{"./_isArray":949,"./_isTransformer":958}],938:[function(require,module,exports){
  var take = /*#__PURE__*/require('../take');

  function dropLast(n, xs) {
    return take(n < xs.length ? xs.length - n : 0, xs);
  }
  module.exports = dropLast;
  },{"../take":1105}],939:[function(require,module,exports){
  var slice = /*#__PURE__*/require('../slice');

  function dropLastWhile(pred, xs) {
    var idx = xs.length - 1;
    while (idx >= 0 && pred(xs[idx])) {
      idx -= 1;
    }
    return slice(0, idx + 1, xs);
  }
  module.exports = dropLastWhile;
  },{"../slice":1091}],940:[function(require,module,exports){
  var _arrayFromIterator = /*#__PURE__*/require('./_arrayFromIterator');

  var _containsWith = /*#__PURE__*/require('./_containsWith');

  var _functionName = /*#__PURE__*/require('./_functionName');

  var _has = /*#__PURE__*/require('./_has');

  var identical = /*#__PURE__*/require('../identical');

  var keys = /*#__PURE__*/require('../keys');

  var type = /*#__PURE__*/require('../type');

  /**
   * private _uniqContentEquals function.
   * That function is checking equality of 2 iterator contents with 2 assumptions
   * - iterators lengths are the same
   * - iterators values are unique
   *
   * false-positive result will be returned for comparision of, e.g.
   * - [1,2,3] and [1,2,3,4]
   * - [1,1,1] and [1,2,3]
   * */

  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);
    var b = _arrayFromIterator(bIterator);

    function eq(_a, _b) {
      return _equals(_a, _b, stackA.slice(), stackB.slice());
    }

    // if *a* array contains any element that is not included in *b*
    return !_containsWith(function (b, aItem) {
      return !_containsWith(eq, aItem, b);
    }, b, a);
  }

  function _equals(a, b, stackA, stackB) {
    if (identical(a, b)) {
      return true;
    }

    var typeA = type(a);

    if (typeA !== type(b)) {
      return false;
    }

    if (a == null || b == null) {
      return false;
    }

    if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
      return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
    }

    if (typeof a.equals === 'function' || typeof b.equals === 'function') {
      return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
    }

    switch (typeA) {
      case 'Arguments':
      case 'Array':
      case 'Object':
        if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
          return a === b;
        }
        break;
      case 'Boolean':
      case 'Number':
      case 'String':
        if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case 'Date':
        if (!identical(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case 'Error':
        return a.name === b.name && a.message === b.message;
      case 'RegExp':
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
    }

    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }

    switch (typeA) {
      case 'Map':
        if (a.size !== b.size) {
          return false;
        }

        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
      case 'Set':
        if (a.size !== b.size) {
          return false;
        }

        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
      case 'Arguments':
      case 'Array':
      case 'Object':
      case 'Boolean':
      case 'Number':
      case 'String':
      case 'Date':
      case 'Error':
      case 'RegExp':
      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'ArrayBuffer':
        break;
      default:
        // Values of other types are only equal if identical.
        return false;
    }

    var keysA = keys(a);
    if (keysA.length !== keys(b).length) {
      return false;
    }

    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);

    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }
      idx -= 1;
    }
    return true;
  }
  module.exports = _equals;
  },{"../identical":909,"../keys":1003,"../type":1122,"./_arrayFromIterator":923,"./_containsWith":931,"./_functionName":944,"./_has":945}],941:[function(require,module,exports){
  function _filter(fn, list) {
    var idx = 0;
    var len = list.length;
    var result = [];

    while (idx < len) {
      if (fn(list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  }
  module.exports = _filter;
  },{}],942:[function(require,module,exports){
  var _forceReduced = /*#__PURE__*/require('./_forceReduced');

  var _isArrayLike = /*#__PURE__*/require('./_isArrayLike');

  var _reduce = /*#__PURE__*/require('./_reduce');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var preservingReduced = function (xf) {
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function (result) {
        return xf['@@transducer/result'](result);
      },
      '@@transducer/step': function (result, input) {
        var ret = xf['@@transducer/step'](result, input);
        return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
      }
    };
  };

  var _flatCat = function _xcat(xf) {
    var rxf = preservingReduced(xf);
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function (result) {
        return rxf['@@transducer/result'](result);
      },
      '@@transducer/step': function (result, input) {
        return !_isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
      }
    };
  };

  module.exports = _flatCat;
  },{"./_forceReduced":943,"./_isArrayLike":950,"./_reduce":966,"./_xfBase":980}],943:[function(require,module,exports){
  function _forceReduced(x) {
    return {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  }
  module.exports = _forceReduced;
  },{}],944:[function(require,module,exports){
  function _functionName(f) {
    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var match = String(f).match(/^function (\w*)/);
    return match == null ? '' : match[1];
  }
  module.exports = _functionName;
  },{}],945:[function(require,module,exports){
  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  module.exports = _has;
  },{}],946:[function(require,module,exports){
  function _identity(x) {
    return x;
  }
  module.exports = _identity;
  },{}],947:[function(require,module,exports){
  var equals = /*#__PURE__*/require('../equals');

  function _indexOf(list, a, idx) {
    var inf, item;
    // Array.prototype.indexOf doesn't exist below IE9
    if (typeof list.indexOf === 'function') {
      switch (typeof a) {
        case 'number':
          if (a === 0) {
            // manually crawl the list to distinguish between +0 and -0
            inf = 1 / a;
            while (idx < list.length) {
              item = list[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            // NaN
            while (idx < list.length) {
              item = list[idx];
              if (typeof item === 'number' && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          // non-zero numbers can utilise Set
          return list.indexOf(a, idx);

        // all these types can utilise Set
        case 'string':
        case 'boolean':
        case 'function':
        case 'undefined':
          return list.indexOf(a, idx);

        case 'object':
          if (a === null) {
            // null can utilise Set
            return list.indexOf(a, idx);
          }
      }
    }
    // anything else not covered above, defer to R.equals
    while (idx < list.length) {
      if (equals(list[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }
  module.exports = _indexOf;
  },{"../equals":890}],948:[function(require,module,exports){
  var _has = /*#__PURE__*/require('./_has');

  var toString = Object.prototype.toString;
  var _isArguments = function () {
    return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
      return toString.call(x) === '[object Arguments]';
    } : function _isArguments(x) {
      return _has('callee', x);
    };
  };

  module.exports = _isArguments;
  },{"./_has":945}],949:[function(require,module,exports){
  /**
   * Tests whether or not an object is an array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is an array, `false` otherwise.
   * @example
   *
   *      _isArray([]); //=> true
   *      _isArray(null); //=> false
   *      _isArray({}); //=> false
   */
  module.exports = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
  };
  },{}],950:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./_curry1');

  var _isArray = /*#__PURE__*/require('./_isArray');

  var _isString = /*#__PURE__*/require('./_isString');

  /**
   * Tests whether or not an object is similar to an array.
   *
   * @private
   * @category Type
   * @category List
   * @sig * -> Boolean
   * @param {*} x The object to test.
   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
   * @example
   *
   *      _isArrayLike([]); //=> true
   *      _isArrayLike(true); //=> false
   *      _isArrayLike({}); //=> false
   *      _isArrayLike({length: 10}); //=> false
   *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
   */


  var _isArrayLike = /*#__PURE__*/_curry1(function isArrayLike(x) {
    if (_isArray(x)) {
      return true;
    }
    if (!x) {
      return false;
    }
    if (typeof x !== 'object') {
      return false;
    }
    if (_isString(x)) {
      return false;
    }
    if (x.nodeType === 1) {
      return !!x.length;
    }
    if (x.length === 0) {
      return true;
    }
    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }
    return false;
  });
  module.exports = _isArrayLike;
  },{"./_curry1":933,"./_isArray":949,"./_isString":957}],951:[function(require,module,exports){
  function _isFunction(x) {
    return Object.prototype.toString.call(x) === '[object Function]';
  }
  module.exports = _isFunction;
  },{}],952:[function(require,module,exports){
  /**
   * Determine if the passed argument is an integer.
   *
   * @private
   * @param {*} n
   * @category Type
   * @return {Boolean}
   */
  module.exports = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };
  },{}],953:[function(require,module,exports){
  function _isNumber(x) {
    return Object.prototype.toString.call(x) === '[object Number]';
  }
  module.exports = _isNumber;
  },{}],954:[function(require,module,exports){
  function _isObject(x) {
    return Object.prototype.toString.call(x) === '[object Object]';
  }
  module.exports = _isObject;
  },{}],955:[function(require,module,exports){
  function _isPlaceholder(a) {
         return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
  }
  module.exports = _isPlaceholder;
  },{}],956:[function(require,module,exports){
  function _isRegExp(x) {
    return Object.prototype.toString.call(x) === '[object RegExp]';
  }
  module.exports = _isRegExp;
  },{}],957:[function(require,module,exports){
  function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
  }
  module.exports = _isString;
  },{}],958:[function(require,module,exports){
  function _isTransformer(obj) {
    return typeof obj['@@transducer/step'] === 'function';
  }
  module.exports = _isTransformer;
  },{}],959:[function(require,module,exports){
  var _isArrayLike = /*#__PURE__*/require('./_isArrayLike');

  /**
   * `_makeFlat` is a helper function that returns a one-level or fully recursive
   * function based on the flag passed in.
   *
   * @private
   */


  function _makeFlat(recursive) {
    return function flatt(list) {
      var value, jlen, j;
      var result = [];
      var idx = 0;
      var ilen = list.length;

      while (idx < ilen) {
        if (_isArrayLike(list[idx])) {
          value = recursive ? flatt(list[idx]) : list[idx];
          j = 0;
          jlen = value.length;
          while (j < jlen) {
            result[result.length] = value[j];
            j += 1;
          }
        } else {
          result[result.length] = list[idx];
        }
        idx += 1;
      }
      return result;
    };
  }
  module.exports = _makeFlat;
  },{"./_isArrayLike":950}],960:[function(require,module,exports){
  function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);
    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }
    return result;
  }
  module.exports = _map;
  },{}],961:[function(require,module,exports){
  var _has = /*#__PURE__*/require('./_has');

  // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign


  function _objectAssign(target) {
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);
    var idx = 1;
    var length = arguments.length;
    while (idx < length) {
      var source = arguments[idx];
      if (source != null) {
        for (var nextKey in source) {
          if (_has(nextKey, source)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
      idx += 1;
    }
    return output;
  }
  module.exports = _objectAssign;
  },{"./_has":945}],962:[function(require,module,exports){
  function _of(x) {
    return [x];
  }
  module.exports = _of;
  },{}],963:[function(require,module,exports){
  function _pipe(f, g) {
    return function () {
      return g.call(this, f.apply(this, arguments));
    };
  }
  module.exports = _pipe;
  },{}],964:[function(require,module,exports){
  function _pipeP(f, g) {
    return function () {
      var ctx = this;
      return f.apply(ctx, arguments).then(function (x) {
        return g.call(ctx, x);
      });
    };
  }
  module.exports = _pipeP;
  },{}],965:[function(require,module,exports){
  function _quote(s) {
    var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');

    return '"' + escaped.replace(/"/g, '\\"') + '"';
  }
  module.exports = _quote;
  },{}],966:[function(require,module,exports){
  var _isArrayLike = /*#__PURE__*/require('./_isArrayLike');

  var _xwrap = /*#__PURE__*/require('./_xwrap');

  var bind = /*#__PURE__*/require('../bind');

  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      idx += 1;
    }
    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      step = iter.next();
    }
    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

  function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }
    if (_isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }
    if (typeof list['fantasy-land/reduce'] === 'function') {
      return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
    }
    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }
    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }
    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list, 'reduce');
    }

    throw new TypeError('reduce: list must be array or iterable');
  }
  module.exports = _reduce;
  },{"../bind":851,"./_isArrayLike":950,"./_xwrap":991}],967:[function(require,module,exports){
  function _reduced(x) {
    return x && x['@@transducer/reduced'] ? x : {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  }
  module.exports = _reduced;
  },{}],968:[function(require,module,exports){
  var _assign = /*#__PURE__*/require('./_assign');

  var _identity = /*#__PURE__*/require('./_identity');

  var _isArrayLike = /*#__PURE__*/require('./_isArrayLike');

  var _isTransformer = /*#__PURE__*/require('./_isTransformer');

  var objOf = /*#__PURE__*/require('../objOf');

  var _stepCatArray = {
    '@@transducer/init': Array,
    '@@transducer/step': function (xs, x) {
      xs.push(x);
      return xs;
    },
    '@@transducer/result': _identity
  };
  var _stepCatString = {
    '@@transducer/init': String,
    '@@transducer/step': function (a, b) {
      return a + b;
    },
    '@@transducer/result': _identity
  };
  var _stepCatObject = {
    '@@transducer/init': Object,
    '@@transducer/step': function (result, input) {
      return _assign(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);
    },
    '@@transducer/result': _identity
  };

  function _stepCat(obj) {
    if (_isTransformer(obj)) {
      return obj;
    }
    if (_isArrayLike(obj)) {
      return _stepCatArray;
    }
    if (typeof obj === 'string') {
      return _stepCatString;
    }
    if (typeof obj === 'object') {
      return _stepCatObject;
    }
    throw new Error('Cannot create transformer for ' + obj);
  }
  module.exports = _stepCat;
  },{"../objOf":1047,"./_assign":924,"./_identity":946,"./_isArrayLike":950,"./_isTransformer":958}],969:[function(require,module,exports){
  /**
   * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
   */
  var pad = function pad(n) {
    return (n < 10 ? '0' : '') + n;
  };

  var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
    return d.toISOString();
  } : function _toISOString(d) {
    return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
  };

  module.exports = _toISOString;
  },{}],970:[function(require,module,exports){
  var _contains = /*#__PURE__*/require('./_contains');

  var _map = /*#__PURE__*/require('./_map');

  var _quote = /*#__PURE__*/require('./_quote');

  var _toISOString = /*#__PURE__*/require('./_toISOString');

  var keys = /*#__PURE__*/require('../keys');

  var reject = /*#__PURE__*/require('../reject');

  function _toString(x, seen) {
    var recur = function recur(y) {
      var xs = seen.concat([x]);
      return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var mapPairs = function (obj, keys) {
      return _map(function (k) {
        return _quote(k) + ': ' + recur(obj[k]);
      }, keys.slice().sort());
    };

    switch (Object.prototype.toString.call(x)) {
      case '[object Arguments]':
        return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
      case '[object Array]':
        return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
          return (/^\d+$/.test(k)
          );
        }, keys(x)))).join(', ') + ']';
      case '[object Boolean]':
        return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
      case '[object Date]':
        return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
      case '[object Null]':
        return 'null';
      case '[object Number]':
        return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
      case '[object String]':
        return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
      case '[object Undefined]':
        return 'undefined';
      default:
        if (typeof x.toString === 'function') {
          var repr = x.toString();
          if (repr !== '[object Object]') {
            return repr;
          }
        }
        return '{' + mapPairs(x, keys(x)).join(', ') + '}';
    }
  }
  module.exports = _toString;
  },{"../keys":1003,"../reject":1083,"./_contains":930,"./_map":960,"./_quote":965,"./_toISOString":969}],971:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _reduced = /*#__PURE__*/require('./_reduced');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XAll = /*#__PURE__*/function () {

    function XAll(f, xf) {
      this.xf = xf;
      this.f = f;
      this.all = true;
    }
    XAll.prototype['@@transducer/init'] = _xfBase.init;
    XAll.prototype['@@transducer/result'] = function (result) {
      if (this.all) {
        result = this.xf['@@transducer/step'](result, true);
      }
      return this.xf['@@transducer/result'](result);
    };
    XAll.prototype['@@transducer/step'] = function (result, input) {
      if (!this.f(input)) {
        this.all = false;
        result = _reduced(this.xf['@@transducer/step'](result, false));
      }
      return result;
    };

    return XAll;
  }();

  var _xall = /*#__PURE__*/_curry2(function _xall(f, xf) {
    return new XAll(f, xf);
  });
  module.exports = _xall;
  },{"./_curry2":934,"./_reduced":967,"./_xfBase":980}],972:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _reduced = /*#__PURE__*/require('./_reduced');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XAny = /*#__PURE__*/function () {

    function XAny(f, xf) {
      this.xf = xf;
      this.f = f;
      this.any = false;
    }
    XAny.prototype['@@transducer/init'] = _xfBase.init;
    XAny.prototype['@@transducer/result'] = function (result) {
      if (!this.any) {
        result = this.xf['@@transducer/step'](result, false);
      }
      return this.xf['@@transducer/result'](result);
    };
    XAny.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.any = true;
        result = _reduced(this.xf['@@transducer/step'](result, true));
      }
      return result;
    };

    return XAny;
  }();

  var _xany = /*#__PURE__*/_curry2(function _xany(f, xf) {
    return new XAny(f, xf);
  });
  module.exports = _xany;
  },{"./_curry2":934,"./_reduced":967,"./_xfBase":980}],973:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./_concat');

  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XAperture = /*#__PURE__*/function () {

    function XAperture(n, xf) {
      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }
    XAperture.prototype['@@transducer/init'] = _xfBase.init;
    XAperture.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };
    XAperture.prototype['@@transducer/step'] = function (result, input) {
      this.store(input);
      return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
    };
    XAperture.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;
      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };
    XAperture.prototype.getCopy = function () {
      return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
    };

    return XAperture;
  }();

  var _xaperture = /*#__PURE__*/_curry2(function _xaperture(n, xf) {
    return new XAperture(n, xf);
  });
  module.exports = _xaperture;
  },{"./_concat":929,"./_curry2":934,"./_xfBase":980}],974:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _flatCat = /*#__PURE__*/require('./_flatCat');

  var map = /*#__PURE__*/require('../map');

  var _xchain = /*#__PURE__*/_curry2(function _xchain(f, xf) {
    return map(f, _flatCat(xf));
  });
  module.exports = _xchain;
  },{"../map":1016,"./_curry2":934,"./_flatCat":942}],975:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XDrop = /*#__PURE__*/function () {

    function XDrop(n, xf) {
      this.xf = xf;
      this.n = n;
    }
    XDrop.prototype['@@transducer/init'] = _xfBase.init;
    XDrop.prototype['@@transducer/result'] = _xfBase.result;
    XDrop.prototype['@@transducer/step'] = function (result, input) {
      if (this.n > 0) {
        this.n -= 1;
        return result;
      }
      return this.xf['@@transducer/step'](result, input);
    };

    return XDrop;
  }();

  var _xdrop = /*#__PURE__*/_curry2(function _xdrop(n, xf) {
    return new XDrop(n, xf);
  });
  module.exports = _xdrop;
  },{"./_curry2":934,"./_xfBase":980}],976:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XDropLast = /*#__PURE__*/function () {

    function XDropLast(n, xf) {
      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }
    XDropLast.prototype['@@transducer/init'] = _xfBase.init;
    XDropLast.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };
    XDropLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.full) {
        result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
      }
      this.store(input);
      return result;
    };
    XDropLast.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;
      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };

    return XDropLast;
  }();

  var _xdropLast = /*#__PURE__*/_curry2(function _xdropLast(n, xf) {
    return new XDropLast(n, xf);
  });
  module.exports = _xdropLast;
  },{"./_curry2":934,"./_xfBase":980}],977:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _reduce = /*#__PURE__*/require('./_reduce');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XDropLastWhile = /*#__PURE__*/function () {

    function XDropLastWhile(fn, xf) {
      this.f = fn;
      this.retained = [];
      this.xf = xf;
    }
    XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
    XDropLastWhile.prototype['@@transducer/result'] = function (result) {
      this.retained = null;
      return this.xf['@@transducer/result'](result);
    };
    XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.retain(result, input) : this.flush(result, input);
    };
    XDropLastWhile.prototype.flush = function (result, input) {
      result = _reduce(this.xf['@@transducer/step'], result, this.retained);
      this.retained = [];
      return this.xf['@@transducer/step'](result, input);
    };
    XDropLastWhile.prototype.retain = function (result, input) {
      this.retained.push(input);
      return result;
    };

    return XDropLastWhile;
  }();

  var _xdropLastWhile = /*#__PURE__*/_curry2(function _xdropLastWhile(fn, xf) {
    return new XDropLastWhile(fn, xf);
  });
  module.exports = _xdropLastWhile;
  },{"./_curry2":934,"./_reduce":966,"./_xfBase":980}],978:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XDropRepeatsWith = /*#__PURE__*/function () {

    function XDropRepeatsWith(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.lastValue = undefined;
      this.seenFirstValue = false;
    }

    XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
    XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;
    XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
      var sameAsLast = false;
      if (!this.seenFirstValue) {
        this.seenFirstValue = true;
      } else if (this.pred(this.lastValue, input)) {
        sameAsLast = true;
      }
      this.lastValue = input;
      return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
    };

    return XDropRepeatsWith;
  }();

  var _xdropRepeatsWith = /*#__PURE__*/_curry2(function _xdropRepeatsWith(pred, xf) {
    return new XDropRepeatsWith(pred, xf);
  });
  module.exports = _xdropRepeatsWith;
  },{"./_curry2":934,"./_xfBase":980}],979:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XDropWhile = /*#__PURE__*/function () {

    function XDropWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
    XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
    XDropWhile.prototype['@@transducer/step'] = function (result, input) {
      if (this.f) {
        if (this.f(input)) {
          return result;
        }
        this.f = null;
      }
      return this.xf['@@transducer/step'](result, input);
    };

    return XDropWhile;
  }();

  var _xdropWhile = /*#__PURE__*/_curry2(function _xdropWhile(f, xf) {
    return new XDropWhile(f, xf);
  });
  module.exports = _xdropWhile;
  },{"./_curry2":934,"./_xfBase":980}],980:[function(require,module,exports){
  module.exports = {
    init: function () {
      return this.xf['@@transducer/init']();
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result);
    }
  };
  },{}],981:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XFilter = /*#__PURE__*/function () {

    function XFilter(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XFilter.prototype['@@transducer/init'] = _xfBase.init;
    XFilter.prototype['@@transducer/result'] = _xfBase.result;
    XFilter.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
    };

    return XFilter;
  }();

  var _xfilter = /*#__PURE__*/_curry2(function _xfilter(f, xf) {
    return new XFilter(f, xf);
  });
  module.exports = _xfilter;
  },{"./_curry2":934,"./_xfBase":980}],982:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _reduced = /*#__PURE__*/require('./_reduced');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XFind = /*#__PURE__*/function () {

    function XFind(f, xf) {
      this.xf = xf;
      this.f = f;
      this.found = false;
    }
    XFind.prototype['@@transducer/init'] = _xfBase.init;
    XFind.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, void 0);
      }
      return this.xf['@@transducer/result'](result);
    };
    XFind.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, input));
      }
      return result;
    };

    return XFind;
  }();

  var _xfind = /*#__PURE__*/_curry2(function _xfind(f, xf) {
    return new XFind(f, xf);
  });
  module.exports = _xfind;
  },{"./_curry2":934,"./_reduced":967,"./_xfBase":980}],983:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _reduced = /*#__PURE__*/require('./_reduced');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XFindIndex = /*#__PURE__*/function () {

    function XFindIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.found = false;
    }
    XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
    XFindIndex.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, -1);
      }
      return this.xf['@@transducer/result'](result);
    };
    XFindIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;
      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, this.idx));
      }
      return result;
    };

    return XFindIndex;
  }();

  var _xfindIndex = /*#__PURE__*/_curry2(function _xfindIndex(f, xf) {
    return new XFindIndex(f, xf);
  });
  module.exports = _xfindIndex;
  },{"./_curry2":934,"./_reduced":967,"./_xfBase":980}],984:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XFindLast = /*#__PURE__*/function () {

    function XFindLast(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XFindLast.prototype['@@transducer/init'] = _xfBase.init;
    XFindLast.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
    };
    XFindLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.last = input;
      }
      return result;
    };

    return XFindLast;
  }();

  var _xfindLast = /*#__PURE__*/_curry2(function _xfindLast(f, xf) {
    return new XFindLast(f, xf);
  });
  module.exports = _xfindLast;
  },{"./_curry2":934,"./_xfBase":980}],985:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XFindLastIndex = /*#__PURE__*/function () {

    function XFindLastIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.lastIdx = -1;
    }
    XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
    XFindLastIndex.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
    };
    XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;
      if (this.f(input)) {
        this.lastIdx = this.idx;
      }
      return result;
    };

    return XFindLastIndex;
  }();

  var _xfindLastIndex = /*#__PURE__*/_curry2(function _xfindLastIndex(f, xf) {
    return new XFindLastIndex(f, xf);
  });
  module.exports = _xfindLastIndex;
  },{"./_curry2":934,"./_xfBase":980}],986:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XMap = /*#__PURE__*/function () {

    function XMap(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XMap.prototype['@@transducer/init'] = _xfBase.init;
    XMap.prototype['@@transducer/result'] = _xfBase.result;
    XMap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, this.f(input));
    };

    return XMap;
  }();

  var _xmap = /*#__PURE__*/_curry2(function _xmap(f, xf) {
    return new XMap(f, xf);
  });
  module.exports = _xmap;
  },{"./_curry2":934,"./_xfBase":980}],987:[function(require,module,exports){
  var _curryN = /*#__PURE__*/require('./_curryN');

  var _has = /*#__PURE__*/require('./_has');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XReduceBy = /*#__PURE__*/function () {

    function XReduceBy(valueFn, valueAcc, keyFn, xf) {
      this.valueFn = valueFn;
      this.valueAcc = valueAcc;
      this.keyFn = keyFn;
      this.xf = xf;
      this.inputs = {};
    }
    XReduceBy.prototype['@@transducer/init'] = _xfBase.init;
    XReduceBy.prototype['@@transducer/result'] = function (result) {
      var key;
      for (key in this.inputs) {
        if (_has(key, this.inputs)) {
          result = this.xf['@@transducer/step'](result, this.inputs[key]);
          if (result['@@transducer/reduced']) {
            result = result['@@transducer/value'];
            break;
          }
        }
      }
      this.inputs = null;
      return this.xf['@@transducer/result'](result);
    };
    XReduceBy.prototype['@@transducer/step'] = function (result, input) {
      var key = this.keyFn(input);
      this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
      this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
      return result;
    };

    return XReduceBy;
  }();

  var _xreduceBy = /*#__PURE__*/_curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
    return new XReduceBy(valueFn, valueAcc, keyFn, xf);
  });
  module.exports = _xreduceBy;
  },{"./_curryN":936,"./_has":945,"./_xfBase":980}],988:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _reduced = /*#__PURE__*/require('./_reduced');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XTake = /*#__PURE__*/function () {

    function XTake(n, xf) {
      this.xf = xf;
      this.n = n;
      this.i = 0;
    }
    XTake.prototype['@@transducer/init'] = _xfBase.init;
    XTake.prototype['@@transducer/result'] = _xfBase.result;
    XTake.prototype['@@transducer/step'] = function (result, input) {
      this.i += 1;
      var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
      return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
    };

    return XTake;
  }();

  var _xtake = /*#__PURE__*/_curry2(function _xtake(n, xf) {
    return new XTake(n, xf);
  });
  module.exports = _xtake;
  },{"./_curry2":934,"./_reduced":967,"./_xfBase":980}],989:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _reduced = /*#__PURE__*/require('./_reduced');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XTakeWhile = /*#__PURE__*/function () {

    function XTakeWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
    XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
    XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
    };

    return XTakeWhile;
  }();

  var _xtakeWhile = /*#__PURE__*/_curry2(function _xtakeWhile(f, xf) {
    return new XTakeWhile(f, xf);
  });
  module.exports = _xtakeWhile;
  },{"./_curry2":934,"./_reduced":967,"./_xfBase":980}],990:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./_curry2');

  var _xfBase = /*#__PURE__*/require('./_xfBase');

  var XTap = /*#__PURE__*/function () {

    function XTap(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XTap.prototype['@@transducer/init'] = _xfBase.init;
    XTap.prototype['@@transducer/result'] = _xfBase.result;
    XTap.prototype['@@transducer/step'] = function (result, input) {
      this.f(input);
      return this.xf['@@transducer/step'](result, input);
    };

    return XTap;
  }();

  var _xtap = /*#__PURE__*/_curry2(function _xtap(f, xf) {
    return new XTap(f, xf);
  });
  module.exports = _xtap;
  },{"./_curry2":934,"./_xfBase":980}],991:[function(require,module,exports){
  var XWrap = /*#__PURE__*/function () {
    function XWrap(fn) {
      this.f = fn;
    }
    XWrap.prototype['@@transducer/init'] = function () {
      throw new Error('init not implemented on XWrap');
    };
    XWrap.prototype['@@transducer/result'] = function (acc) {
      return acc;
    };
    XWrap.prototype['@@transducer/step'] = function (acc, x) {
      return this.f(acc, x);
    };

    return XWrap;
  }();

  function _xwrap(fn) {
    return new XWrap(fn);
  }
  module.exports = _xwrap;
  },{}],992:[function(require,module,exports){
  var _contains = /*#__PURE__*/require('./internal/_contains');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _filter = /*#__PURE__*/require('./internal/_filter');

  var flip = /*#__PURE__*/require('./flip');

  var uniq = /*#__PURE__*/require('./uniq');

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of those
   * elements common to both lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The list of elements found in both `list1` and `list2`.
   * @see R.innerJoin
   * @example
   *
   *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
   */


  var intersection = /*#__PURE__*/_curry2(function intersection(list1, list2) {
    var lookupList, filteredList;
    if (list1.length > list2.length) {
      lookupList = list1;
      filteredList = list2;
    } else {
      lookupList = list2;
      filteredList = list1;
    }
    return uniq(_filter(flip(_contains)(lookupList), filteredList));
  });
  module.exports = intersection;
  },{"./flip":898,"./internal/_contains":930,"./internal/_curry2":934,"./internal/_filter":941,"./uniq":1129}],993:[function(require,module,exports){
  var _checkForMethod = /*#__PURE__*/require('./internal/_checkForMethod');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Creates a new list with the separator interposed between elements.
   *
   * Dispatches to the `intersperse` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} separator The element to add to the list.
   * @param {Array} list The list to be interposed.
   * @return {Array} The new list.
   * @example
   *
   *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
   */


  var intersperse = /*#__PURE__*/_curry2( /*#__PURE__*/_checkForMethod('intersperse', function intersperse(separator, list) {
    var out = [];
    var idx = 0;
    var length = list.length;
    while (idx < length) {
      if (idx === length - 1) {
        out.push(list[idx]);
      } else {
        out.push(list[idx], separator);
      }
      idx += 1;
    }
    return out;
  }));
  module.exports = intersperse;
  },{"./internal/_checkForMethod":925,"./internal/_curry2":934}],994:[function(require,module,exports){
  var _clone = /*#__PURE__*/require('./internal/_clone');

  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var _isTransformer = /*#__PURE__*/require('./internal/_isTransformer');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var _stepCat = /*#__PURE__*/require('./internal/_stepCat');

  /**
   * Transforms the items of the list with the transducer and appends the
   * transformed items to the accumulator using an appropriate iterator function
   * based on the accumulator type.
   *
   * The accumulator can be an array, string, object or a transformer. Iterated
   * items will be appended to arrays and concatenated to strings. Objects will
   * be merged directly or 2-item arrays will be merged as key, value pairs.
   *
   * The accumulator can also be a transformer object that provides a 2-arity
   * reducing iterator function, step, 0-arity initial value function, init, and
   * 1-arity result extraction function result. The step function is used as the
   * iterator function in reduce. The result function is used to convert the
   * final accumulator into the return type and in most cases is R.identity. The
   * init function is used to provide the initial accumulator.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the
   * transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig a -> (b -> b) -> [c] -> a
   * @param {*} acc The initial accumulator value.
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @example
   *
   *      var numbers = [1, 2, 3, 4];
   *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
   *
   *      R.into([], transducer, numbers); //=> [2, 3]
   *
   *      var intoArray = R.into([]);
   *      intoArray(transducer, numbers); //=> [2, 3]
   */


  var into = /*#__PURE__*/_curry3(function into(acc, xf, list) {
    return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
  });
  module.exports = into;
  },{"./internal/_clone":926,"./internal/_curry3":935,"./internal/_isTransformer":958,"./internal/_reduce":966,"./internal/_stepCat":968}],995:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _has = /*#__PURE__*/require('./internal/_has');

  var keys = /*#__PURE__*/require('./keys');

  /**
   * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
   * duplicate values by putting the values into an array.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: [ s, ... ]}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object with keys in an array.
   * @see R.invertObj
   * @example
   *
   *      var raceResultsByFirstName = {
   *        first: 'alice',
   *        second: 'jake',
   *        third: 'alice',
   *      };
   *      R.invert(raceResultsByFirstName);
   *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
   */


  var invert = /*#__PURE__*/_curry1(function invert(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      var val = obj[key];
      var list = _has(val, out) ? out[val] : out[val] = [];
      list[list.length] = key;
      idx += 1;
    }
    return out;
  });
  module.exports = invert;
  },{"./internal/_curry1":933,"./internal/_has":945,"./keys":1003}],996:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var keys = /*#__PURE__*/require('./keys');

  /**
   * Returns a new object with the keys of the given object as values, and the
   * values of the given object, which are coerced to strings, as keys. Note
   * that the last key found is preferred when handling the same value.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: s}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object
   * @see R.invert
   * @example
   *
   *      var raceResults = {
   *        first: 'alice',
   *        second: 'jake'
   *      };
   *      R.invertObj(raceResults);
   *      //=> { 'alice': 'first', 'jake':'second' }
   *
   *      // Alternatively:
   *      var raceResults = ['alice', 'jake'];
   *      R.invertObj(raceResults);
   *      //=> { 'alice': '0', 'jake':'1' }
   */


  var invertObj = /*#__PURE__*/_curry1(function invertObj(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      out[obj[key]] = key;
      idx += 1;
    }
    return out;
  });
  module.exports = invertObj;
  },{"./internal/_curry1":933,"./keys":1003}],997:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isFunction = /*#__PURE__*/require('./internal/_isFunction');

  var curryN = /*#__PURE__*/require('./curryN');

  var toString = /*#__PURE__*/require('./toString');

  /**
   * Turns a named method with a specified arity into a function that can be
   * called directly supplied with arguments and a target object.
   *
   * The returned function is curried and accepts `arity + 1` parameters where
   * the final parameter is the target object.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
   * @param {Number} arity Number of arguments the returned function should take
   *        before the target object.
   * @param {String} method Name of the method to call.
   * @return {Function} A new curried function.
   * @see R.construct
   * @example
   *
   *      var sliceFrom = R.invoker(1, 'slice');
   *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
   *      var sliceFrom6 = R.invoker(2, 'slice')(6);
   *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
   * @symb R.invoker(0, 'method')(o) = o['method']()
   * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
   * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
   */


  var invoker = /*#__PURE__*/_curry2(function invoker(arity, method) {
    return curryN(arity + 1, function () {
      var target = arguments[arity];
      if (target != null && _isFunction(target[method])) {
        return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
      }
      throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
    });
  });
  module.exports = invoker;
  },{"./curryN":870,"./internal/_curry2":934,"./internal/_isFunction":951,"./toString":1115}],998:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * See if an object (`val`) is an instance of the supplied constructor. This
   * function will check up the inheritance chain, if any.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Type
   * @sig (* -> {*}) -> a -> Boolean
   * @param {Object} ctor A constructor
   * @param {*} val The value to test
   * @return {Boolean}
   * @example
   *
   *      R.is(Object, {}); //=> true
   *      R.is(Number, 1); //=> true
   *      R.is(Object, 1); //=> false
   *      R.is(String, 's'); //=> true
   *      R.is(String, new String('')); //=> true
   *      R.is(Object, new String('')); //=> true
   *      R.is(Object, 's'); //=> false
   *      R.is(Number, {}); //=> false
   */


  var is = /*#__PURE__*/_curry2(function is(Ctor, val) {
    return val != null && val.constructor === Ctor || val instanceof Ctor;
  });
  module.exports = is;
  },{"./internal/_curry2":934}],999:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var empty = /*#__PURE__*/require('./empty');

  var equals = /*#__PURE__*/require('./equals');

  /**
   * Returns `true` if the given value is its type's empty value; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> Boolean
   * @param {*} x
   * @return {Boolean}
   * @see R.empty
   * @example
   *
   *      R.isEmpty([1, 2, 3]);   //=> false
   *      R.isEmpty([]);          //=> true
   *      R.isEmpty('');          //=> true
   *      R.isEmpty(null);        //=> false
   *      R.isEmpty({});          //=> true
   *      R.isEmpty({length: 0}); //=> false
   */


  var isEmpty = /*#__PURE__*/_curry1(function isEmpty(x) {
    return x != null && equals(x, empty(x));
  });
  module.exports = isEmpty;
  },{"./empty":886,"./equals":890,"./internal/_curry1":933}],1000:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Checks if the input value is `null` or `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Type
   * @sig * -> Boolean
   * @param {*} x The value to test.
   * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
   * @example
   *
   *      R.isNil(null); //=> true
   *      R.isNil(undefined); //=> true
   *      R.isNil(0); //=> false
   *      R.isNil([]); //=> false
   */


  var isNil = /*#__PURE__*/_curry1(function isNil(x) {
    return x == null;
  });
  module.exports = isNil;
  },{"./internal/_curry1":933}],1001:[function(require,module,exports){
  var invoker = /*#__PURE__*/require('./invoker');

  /**
   * Returns a string made by inserting the `separator` between each element and
   * concatenating all the elements into a single string.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig String -> [a] -> String
   * @param {Number|String} separator The string used to separate the elements.
   * @param {Array} xs The elements to join into a string.
   * @return {String} str The string made by concatenating `xs` with `separator`.
   * @see R.split
   * @example
   *
   *      var spacer = R.join(' ');
   *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
   *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
   */


  var join = /*#__PURE__*/invoker(1, 'join');
  module.exports = join;
  },{"./invoker":997}],1002:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var converge = /*#__PURE__*/require('./converge');

  /**
   * juxt applies a list of functions to a list of values.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Function
   * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
   * @param {Array} fns An array of functions
   * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
   * @see R.applySpec
   * @example
   *
   *      var getRange = R.juxt([Math.min, Math.max]);
   *      getRange(3, 4, 9, -3); //=> [-3, 9]
   * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
   */


  var juxt = /*#__PURE__*/_curry1(function juxt(fns) {
    return converge(function () {
      return Array.prototype.slice.call(arguments, 0);
    }, fns);
  });
  module.exports = juxt;
  },{"./converge":867,"./internal/_curry1":933}],1003:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _has = /*#__PURE__*/require('./internal/_has');

  var _isArguments = /*#__PURE__*/require('./internal/_isArguments');

  // cover IE < 9 keys issues


  var hasEnumBug = ! /*#__PURE__*/{ toString: null }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  // Safari bug
  var hasArgsEnumBug = /*#__PURE__*/function () {
    'use strict';

    return arguments.propertyIsEnumerable('length');
  }();

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  /**
   * Returns a list containing the names of all the enumerable own properties of
   * the supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own properties.
   * @see R.keysIn, R.values
   * @example
   *
   *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
   */
  var _keys = typeof Object.keys === 'function' && !hasArgsEnumBug ? function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  } : function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  };
  var keys = /*#__PURE__*/_curry1(_keys);
  module.exports = keys;
  },{"./internal/_curry1":933,"./internal/_has":945,"./internal/_isArguments":948}],1004:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Returns a list containing the names of all the properties of the supplied
   * object, including prototype properties.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own and prototype properties.
   * @see R.keys, R.valuesIn
   * @example
   *
   *      var F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      var f = new F();
   *      R.keysIn(f); //=> ['x', 'y']
   */


  var keysIn = /*#__PURE__*/_curry1(function keysIn(obj) {
    var prop;
    var ks = [];
    for (prop in obj) {
      ks[ks.length] = prop;
    }
    return ks;
  });
  module.exports = keysIn;
  },{"./internal/_curry1":933}],1005:[function(require,module,exports){
  var nth = /*#__PURE__*/require('./nth');

  /**
   * Returns the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.init, R.head, R.tail
   * @example
   *
   *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
   *      R.last([]); //=> undefined
   *
   *      R.last('abc'); //=> 'c'
   *      R.last(''); //=> ''
   */


  var last = /*#__PURE__*/nth(-1);
  module.exports = last;
  },{"./nth":1044}],1006:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isArray = /*#__PURE__*/require('./internal/_isArray');

  var equals = /*#__PURE__*/require('./equals');

  /**
   * Returns the position of the last occurrence of an item in an array, or -1 if
   * the item is not included in the array. [`R.equals`](#equals) is used to
   * determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.indexOf
   * @example
   *
   *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
   *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
   */


  var lastIndexOf = /*#__PURE__*/_curry2(function lastIndexOf(target, xs) {
    if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
      return xs.lastIndexOf(target);
    } else {
      var idx = xs.length - 1;
      while (idx >= 0) {
        if (equals(xs[idx], target)) {
          return idx;
        }
        idx -= 1;
      }
      return -1;
    }
  });
  module.exports = lastIndexOf;
  },{"./equals":890,"./internal/_curry2":934,"./internal/_isArray":949}],1007:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _isNumber = /*#__PURE__*/require('./internal/_isNumber');

  /**
   * Returns the number of elements in the array by returning `list.length`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [a] -> Number
   * @param {Array} list The array to inspect.
   * @return {Number} The length of the array.
   * @example
   *
   *      R.length([]); //=> 0
   *      R.length([1, 2, 3]); //=> 3
   */


  var length = /*#__PURE__*/_curry1(function length(list) {
    return list != null && _isNumber(list.length) ? list.length : NaN;
  });
  module.exports = length;
  },{"./internal/_curry1":933,"./internal/_isNumber":953}],1008:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var map = /*#__PURE__*/require('./map');

  /**
   * Returns a lens for the given getter and setter functions. The getter "gets"
   * the value of the focus; the setter "sets" the value of the focus. The setter
   * should not mutate the data structure.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
   * @param {Function} getter
   * @param {Function} setter
   * @return {Lens}
   * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
   * @example
   *
   *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */


  var lens = /*#__PURE__*/_curry2(function lens(getter, setter) {
    return function (toFunctorFn) {
      return function (target) {
        return map(function (focus) {
          return setter(focus, target);
        }, toFunctorFn(getter(target)));
      };
    };
  });
  module.exports = lens;
  },{"./internal/_curry2":934,"./map":1016}],1009:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var lens = /*#__PURE__*/require('./lens');

  var nth = /*#__PURE__*/require('./nth');

  var update = /*#__PURE__*/require('./update');

  /**
   * Returns a lens whose focus is the specified index.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Number -> Lens s a
   * @param {Number} n
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      var headLens = R.lensIndex(0);
   *
   *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
   *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
   *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
   */


  var lensIndex = /*#__PURE__*/_curry1(function lensIndex(n) {
    return lens(nth(n), update(n));
  });
  module.exports = lensIndex;
  },{"./internal/_curry1":933,"./lens":1008,"./nth":1044,"./update":1135}],1010:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var assocPath = /*#__PURE__*/require('./assocPath');

  var lens = /*#__PURE__*/require('./lens');

  var path = /*#__PURE__*/require('./path');

  /**
   * Returns a lens whose focus is the specified path.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @typedefn Idx = String | Int
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig [Idx] -> Lens s a
   * @param {Array} path The path to use.
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
   *
   *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> 2
   *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
   *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
   */


  var lensPath = /*#__PURE__*/_curry1(function lensPath(p) {
    return lens(path(p), assocPath(p));
  });
  module.exports = lensPath;
  },{"./assocPath":849,"./internal/_curry1":933,"./lens":1008,"./path":1057}],1011:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var assoc = /*#__PURE__*/require('./assoc');

  var lens = /*#__PURE__*/require('./lens');

  var prop = /*#__PURE__*/require('./prop');

  /**
   * Returns a lens whose focus is the specified property.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig String -> Lens s a
   * @param {String} k
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      var xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */


  var lensProp = /*#__PURE__*/_curry1(function lensProp(k) {
    return lens(prop(k), assoc(k));
  });
  module.exports = lensProp;
  },{"./assoc":848,"./internal/_curry1":933,"./lens":1008,"./prop":1071}],1012:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var liftN = /*#__PURE__*/require('./liftN');

  /**
   * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
   * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.liftN
   * @example
   *
   *      var madd3 = R.lift((a, b, c) => a + b + c);
   *
   *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
   *
   *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
   *
   *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
   */


  var lift = /*#__PURE__*/_curry1(function lift(fn) {
    return liftN(fn.length, fn);
  });
  module.exports = lift;
  },{"./internal/_curry1":933,"./liftN":1013}],1013:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var ap = /*#__PURE__*/require('./ap');

  var curryN = /*#__PURE__*/require('./curryN');

  var map = /*#__PURE__*/require('./map');

  /**
   * "lifts" a function to be the specified arity, so that it may "map over" that
   * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig Number -> (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.lift, R.ap
   * @example
   *
   *      var madd3 = R.liftN(3, (...args) => R.sum(args));
   *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
   */


  var liftN = /*#__PURE__*/_curry2(function liftN(arity, fn) {
    var lifted = curryN(arity, fn);
    return curryN(arity, function () {
      return _reduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
    });
  });
  module.exports = liftN;
  },{"./ap":841,"./curryN":870,"./internal/_curry2":934,"./internal/_reduce":966,"./map":1016}],1014:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is less than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.gt
   * @example
   *
   *      R.lt(2, 1); //=> false
   *      R.lt(2, 2); //=> false
   *      R.lt(2, 3); //=> true
   *      R.lt('a', 'z'); //=> true
   *      R.lt('z', 'a'); //=> false
   */


  var lt = /*#__PURE__*/_curry2(function lt(a, b) {
    return a < b;
  });
  module.exports = lt;
  },{"./internal/_curry2":934}],1015:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is less than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.gte
   * @example
   *
   *      R.lte(2, 1); //=> false
   *      R.lte(2, 2); //=> true
   *      R.lte(2, 3); //=> true
   *      R.lte('a', 'z'); //=> true
   *      R.lte('z', 'a'); //=> false
   */


  var lte = /*#__PURE__*/_curry2(function lte(a, b) {
    return a <= b;
  });
  module.exports = lte;
  },{"./internal/_curry2":934}],1016:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _map = /*#__PURE__*/require('./internal/_map');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var _xmap = /*#__PURE__*/require('./internal/_xmap');

  var curryN = /*#__PURE__*/require('./curryN');

  var keys = /*#__PURE__*/require('./keys');

  /**
   * Takes a function and
   * a [functor](https://github.com/fantasyland/fantasy-land#functor),
   * applies the function to each of the functor's values, and returns
   * a functor of the same shape.
   *
   * Ramda provides suitable `map` implementations for `Array` and `Object`,
   * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
   *
   * Dispatches to the `map` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * Also treats functions as functors and will compose them together.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => (a -> b) -> f a -> f b
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {Array} list The list to be iterated over.
   * @return {Array} The new list.
   * @see R.transduce, R.addIndex
   * @example
   *
   *      var double = x => x * 2;
   *
   *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
   *
   *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
   * @symb R.map(f, [a, b]) = [f(a), f(b)]
   * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
   * @symb R.map(f, functor_o) = functor_o.map(f)
   */


  var map = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case '[object Function]':
        return curryN(functor.length, function () {
          return fn.call(this, functor.apply(this, arguments));
        });
      case '[object Object]':
        return _reduce(function (acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys(functor));
      default:
        return _map(fn, functor);
    }
  }));
  module.exports = map;
  },{"./curryN":870,"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_map":960,"./internal/_reduce":966,"./internal/_xmap":986,"./keys":1003}],1017:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * The `mapAccum` function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from left to right, and returning a final value of this
   * accumulator together with the new list.
   *
   * The iterator function receives two arguments, *acc* and *value*, and should
   * return a tuple *[acc, value]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.addIndex, R.mapAccumRight
   * @example
   *
   *      var digits = ['1', '2', '3', '4'];
   *      var appender = (a, b) => [a + b, a + b];
   *
   *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
   * @symb R.mapAccum(f, a, [b, c, d]) = [
   *   f(f(f(a, b)[0], c)[0], d)[0],
   *   [
   *     f(a, b)[1],
   *     f(f(a, b)[0], c)[1],
   *     f(f(f(a, b)[0], c)[0], d)[1]
   *   ]
   * ]
   */


  var mapAccum = /*#__PURE__*/_curry3(function mapAccum(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var tuple = [acc];
    while (idx < len) {
      tuple = fn(tuple[0], list[idx]);
      result[idx] = tuple[1];
      idx += 1;
    }
    return [tuple[0], result];
  });
  module.exports = mapAccum;
  },{"./internal/_curry3":935}],1018:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * The `mapAccumRight` function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from right to left, and returning a final value of this
   * accumulator together with the new list.
   *
   * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
   * the right to the left.
   *
   * The iterator function receives two arguments, *value* and *acc*, and should
   * return a tuple *[value, acc]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((x, acc) -> (y, acc)) -> acc -> [x] -> ([y], acc)
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.addIndex, R.mapAccum
   * @example
   *
   *      var digits = ['1', '2', '3', '4'];
   *      var append = (a, b) => [a + b, a + b];
   *
   *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
   * @symb R.mapAccumRight(f, a, [b, c, d]) = [
   *   [
   *     f(b, f(c, f(d, a)[0])[0])[1],
   *     f(c, f(d, a)[0])[1],
   *     f(d, a)[1],
   *   ]
   *   f(b, f(c, f(d, a)[0])[0])[0],
   * ]
   */


  var mapAccumRight = /*#__PURE__*/_curry3(function mapAccumRight(fn, acc, list) {
    var idx = list.length - 1;
    var result = [];
    var tuple = [acc];
    while (idx >= 0) {
      tuple = fn(list[idx], tuple[0]);
      result[idx] = tuple[1];
      idx -= 1;
    }
    return [result, tuple[0]];
  });
  module.exports = mapAccumRight;
  },{"./internal/_curry3":935}],1019:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var keys = /*#__PURE__*/require('./keys');

  /**
   * An Object-specific version of [`map`](#map). The function is applied to three
   * arguments: *(value, key, obj)*. If only the value is significant, use
   * [`map`](#map) instead.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig ((*, String, Object) -> *) -> Object -> Object
   * @param {Function} fn
   * @param {Object} obj
   * @return {Object}
   * @see R.map
   * @example
   *
   *      var values = { x: 1, y: 2, z: 3 };
   *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
   *
   *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
   */


  var mapObjIndexed = /*#__PURE__*/_curry2(function mapObjIndexed(fn, obj) {
    return _reduce(function (acc, key) {
      acc[key] = fn(obj[key], key, obj);
      return acc;
    }, {}, keys(obj));
  });
  module.exports = mapObjIndexed;
  },{"./internal/_curry2":934,"./internal/_reduce":966,"./keys":1003}],1020:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Tests a regular expression against a String. Note that this function will
   * return an empty array when there are no matches. This differs from
   * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
   * which returns `null` when there are no matches.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig RegExp -> String -> [String | Undefined]
   * @param {RegExp} rx A regular expression.
   * @param {String} str The string to match against
   * @return {Array} The list of matches or empty array.
   * @see R.test
   * @example
   *
   *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
   *      R.match(/a/, 'b'); //=> []
   *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
   */


  var match = /*#__PURE__*/_curry2(function match(rx, str) {
    return str.match(rx) || [];
  });
  module.exports = match;
  },{"./internal/_curry2":934}],1021:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isInteger = /*#__PURE__*/require('./internal/_isInteger');

  /**
   * `mathMod` behaves like the modulo operator should mathematically, unlike the
   * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
   * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
   * arguments, and returns NaN when the modulus is zero or negative.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} m The dividend.
   * @param {Number} p the modulus.
   * @return {Number} The result of `b mod a`.
   * @see R.modulo
   * @example
   *
   *      R.mathMod(-17, 5);  //=> 3
   *      R.mathMod(17, 5);   //=> 2
   *      R.mathMod(17, -5);  //=> NaN
   *      R.mathMod(17, 0);   //=> NaN
   *      R.mathMod(17.2, 5); //=> NaN
   *      R.mathMod(17, 5.3); //=> NaN
   *
   *      var clock = R.mathMod(R.__, 12);
   *      clock(15); //=> 3
   *      clock(24); //=> 0
   *
   *      var seventeenMod = R.mathMod(17);
   *      seventeenMod(3);  //=> 2
   *      seventeenMod(4);  //=> 1
   *      seventeenMod(10); //=> 7
   */


  var mathMod = /*#__PURE__*/_curry2(function mathMod(m, p) {
    if (!_isInteger(m)) {
      return NaN;
    }
    if (!_isInteger(p) || p < 1) {
      return NaN;
    }
    return (m % p + p) % p;
  });
  module.exports = mathMod;
  },{"./internal/_curry2":934,"./internal/_isInteger":952}],1022:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns the larger of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.maxBy, R.min
   * @example
   *
   *      R.max(789, 123); //=> 789
   *      R.max('a', 'b'); //=> 'b'
   */


  var max = /*#__PURE__*/_curry2(function max(a, b) {
    return b > a ? b : a;
  });
  module.exports = max;
  },{"./internal/_curry2":934}],1023:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Takes a function and two values, and returns whichever value produces the
   * larger result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.max, R.minBy
   * @example
   *
   *      //  square :: Number -> Number
   *      var square = n => n * n;
   *
   *      R.maxBy(square, -3, 2); //=> -3
   *
   *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
   *      R.reduce(R.maxBy(square), 0, []); //=> 0
   */


  var maxBy = /*#__PURE__*/_curry3(function maxBy(f, a, b) {
    return f(b) > f(a) ? b : a;
  });
  module.exports = maxBy;
  },{"./internal/_curry3":935}],1024:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var sum = /*#__PURE__*/require('./sum');

  /**
   * Returns the mean of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @see R.median
   * @example
   *
   *      R.mean([2, 7, 9]); //=> 6
   *      R.mean([]); //=> NaN
   */


  var mean = /*#__PURE__*/_curry1(function mean(list) {
    return sum(list) / list.length;
  });
  module.exports = mean;
  },{"./internal/_curry1":933,"./sum":1101}],1025:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var mean = /*#__PURE__*/require('./mean');

  /**
   * Returns the median of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @see R.mean
   * @example
   *
   *      R.median([2, 9, 7]); //=> 7
   *      R.median([7, 2, 10, 9]); //=> 8
   *      R.median([]); //=> NaN
   */


  var median = /*#__PURE__*/_curry1(function median(list) {
    var len = list.length;
    if (len === 0) {
      return NaN;
    }
    var width = 2 - len % 2;
    var idx = (len - width) / 2;
    return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }).slice(idx, idx + width));
  });
  module.exports = median;
  },{"./internal/_curry1":933,"./mean":1024}],1026:[function(require,module,exports){
  var memoizeWith = /*#__PURE__*/require('./memoizeWith');

  var toString = /*#__PURE__*/require('./toString');

  /**
   * Creates a new function that, when invoked, caches the result of calling `fn`
   * for a given argument set and returns the result. Subsequent calls to the
   * memoized `fn` with the same argument set will not result in an additional
   * call to `fn`; instead, the cached result for that set of arguments will be
   * returned.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (*... -> a) -> (*... -> a)
   * @param {Function} fn The function to memoize.
   * @return {Function} Memoized version of `fn`.
   * @see R.memoizeWith
   * @deprecated since v0.25.0
   * @example
   *
   *      let count = 0;
   *      const factorial = R.memoize(n => {
   *        count += 1;
   *        return R.product(R.range(1, n + 1));
   *      });
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      count; //=> 1
   */


  var memoize = /*#__PURE__*/memoizeWith(function () {
    return toString(arguments);
  });
  module.exports = memoize;
  },{"./memoizeWith":1027,"./toString":1115}],1027:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _has = /*#__PURE__*/require('./internal/_has');

  /**
   * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an
   * additional function that will be applied to a given argument set and used to
   * create the cache key under which the results of the function to be memoized
   * will be stored. Care must be taken when implementing key generation to avoid
   * clashes that may overwrite previous entries erroneously.
   *
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Function
   * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
   * @param {Function} fn The function to generate the cache key.
   * @param {Function} fn The function to memoize.
   * @return {Function} Memoized version of `fn`.
   * @see R.memoize
   * @example
   *
   *      let count = 0;
   *      const factorial = R.memoizeWith(R.identity, n => {
   *        count += 1;
   *        return R.product(R.range(1, n + 1));
   *      });
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      count; //=> 1
   */


  var memoizeWith = /*#__PURE__*/_curry2(function memoizeWith(mFn, fn) {
    var cache = {};
    return _arity(fn.length, function () {
      var key = mFn.apply(this, arguments);
      if (!_has(key, cache)) {
        cache[key] = fn.apply(this, arguments);
      }
      return cache[key];
    });
  });
  module.exports = memoizeWith;
  },{"./internal/_arity":922,"./internal/_curry2":934,"./internal/_has":945}],1028:[function(require,module,exports){
  var _assign = /*#__PURE__*/require('./internal/_assign');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Create a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects,
   * the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> {k: v} -> {k: v}
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepRight, R.mergeWith, R.mergeWithKey
   * @example
   *
   *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
   *      //=> { 'name': 'fred', 'age': 40 }
   *
   *      var resetToDefault = R.merge(R.__, {x: 0});
   *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
   * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
   */


  var merge = /*#__PURE__*/_curry2(function merge(l, r) {
    return _assign({}, l, r);
  });
  module.exports = merge;
  },{"./internal/_assign":924,"./internal/_curry2":934}],1029:[function(require,module,exports){
  var _assign = /*#__PURE__*/require('./internal/_assign');

  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Merges a list of objects together into one object.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig [{k: v}] -> {k: v}
   * @param {Array} list An array of objects
   * @return {Object} A merged object.
   * @see R.reduce
   * @example
   *
   *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
   *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
   * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
   */


  var mergeAll = /*#__PURE__*/_curry1(function mergeAll(list) {
    return _assign.apply(null, [{}].concat(list));
  });
  module.exports = mergeAll;
  },{"./internal/_assign":924,"./internal/_curry1":933}],1030:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var mergeDeepWithKey = /*#__PURE__*/require('./mergeDeepWithKey');

  /**
   * Creates a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects:
   * - and both values are objects, the two values will be recursively merged
   * - otherwise the value from the first object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig {a} -> {a} -> {a}
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
   *                      { age: 40, contact: { email: 'baa@example.com' }});
   *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
   */


  var mergeDeepLeft = /*#__PURE__*/_curry2(function mergeDeepLeft(lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return lVal;
    }, lObj, rObj);
  });
  module.exports = mergeDeepLeft;
  },{"./internal/_curry2":934,"./mergeDeepWithKey":1033}],1031:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var mergeDeepWithKey = /*#__PURE__*/require('./mergeDeepWithKey');

  /**
   * Creates a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects:
   * - and both values are objects, the two values will be recursively merged
   * - otherwise the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig {a} -> {a} -> {a}
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
   *                       { age: 40, contact: { email: 'baa@example.com' }});
   *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
   */


  var mergeDeepRight = /*#__PURE__*/_curry2(function mergeDeepRight(lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return rVal;
    }, lObj, rObj);
  });
  module.exports = mergeDeepRight;
  },{"./internal/_curry2":934,"./mergeDeepWithKey":1033}],1032:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var mergeDeepWithKey = /*#__PURE__*/require('./mergeDeepWithKey');

  /**
   * Creates a new object with the own properties of the two provided objects.
   * If a key exists in both objects:
   * - and both associated values are also objects then the values will be
   *   recursively merged.
   * - otherwise the provided function is applied to associated values using the
   *   resulting value as the new value associated with the key.
   * If a key only exists in one object, the value will be associated with the key
   * of the resulting object.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.mergeWith, R.mergeDeep, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepWith(R.concat,
   *                      { a: true, c: { values: [10, 20] }},
   *                      { b: true, c: { values: [15, 35] }});
   *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
   */


  var mergeDeepWith = /*#__PURE__*/_curry3(function mergeDeepWith(fn, lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return fn(lVal, rVal);
    }, lObj, rObj);
  });
  module.exports = mergeDeepWith;
  },{"./internal/_curry3":935,"./mergeDeepWithKey":1033}],1033:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var _isObject = /*#__PURE__*/require('./internal/_isObject');

  var mergeWithKey = /*#__PURE__*/require('./mergeWithKey');

  /**
   * Creates a new object with the own properties of the two provided objects.
   * If a key exists in both objects:
   * - and both associated values are also objects then the values will be
   *   recursively merged.
   * - otherwise the provided function is applied to the key and associated values
   *   using the resulting value as the new value associated with the key.
   * If a key only exists in one object, the value will be associated with the key
   * of the resulting object.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.mergeWithKey, R.mergeDeep, R.mergeDeepWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeDeepWithKey(concatValues,
   *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
   *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
   *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
   */


  var mergeDeepWithKey = /*#__PURE__*/_curry3(function mergeDeepWithKey(fn, lObj, rObj) {
    return mergeWithKey(function (k, lVal, rVal) {
      if (_isObject(lVal) && _isObject(rVal)) {
        return mergeDeepWithKey(fn, lVal, rVal);
      } else {
        return fn(k, lVal, rVal);
      }
    }, lObj, rObj);
  });
  module.exports = mergeDeepWithKey;
  },{"./internal/_curry3":935,"./internal/_isObject":954,"./mergeWithKey":1035}],1034:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var mergeWithKey = /*#__PURE__*/require('./mergeWithKey');

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the values
   * associated with the key in each object, with the result being used as the
   * value associated with the key in the returned object.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepWith, R.merge, R.mergeWithKey
   * @example
   *
   *      R.mergeWith(R.concat,
   *                  { a: true, values: [10, 20] },
   *                  { b: true, values: [15, 35] });
   *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
   */


  var mergeWith = /*#__PURE__*/_curry3(function mergeWith(fn, l, r) {
    return mergeWithKey(function (_, _l, _r) {
      return fn(_l, _r);
    }, l, r);
  });
  module.exports = mergeWith;
  },{"./internal/_curry3":935,"./mergeWithKey":1035}],1035:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var _has = /*#__PURE__*/require('./internal/_has');

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the key
   * and the values associated with the key in each object, with the result being
   * used as the value associated with the key in the returned object.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepWithKey, R.merge, R.mergeWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeWithKey(concatValues,
   *                     { a: true, thing: 'foo', values: [10, 20] },
   *                     { b: true, thing: 'bar', values: [15, 35] });
   *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
   * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
   */


  var mergeWithKey = /*#__PURE__*/_curry3(function mergeWithKey(fn, l, r) {
    var result = {};
    var k;

    for (k in l) {
      if (_has(k, l)) {
        result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
      }
    }

    for (k in r) {
      if (_has(k, r) && !_has(k, result)) {
        result[k] = r[k];
      }
    }

    return result;
  });
  module.exports = mergeWithKey;
  },{"./internal/_curry3":935,"./internal/_has":945}],1036:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns the smaller of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.minBy, R.max
   * @example
   *
   *      R.min(789, 123); //=> 123
   *      R.min('a', 'b'); //=> 'a'
   */


  var min = /*#__PURE__*/_curry2(function min(a, b) {
    return b < a ? b : a;
  });
  module.exports = min;
  },{"./internal/_curry2":934}],1037:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Takes a function and two values, and returns whichever value produces the
   * smaller result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.min, R.maxBy
   * @example
   *
   *      //  square :: Number -> Number
   *      var square = n => n * n;
   *
   *      R.minBy(square, -3, 2); //=> 2
   *
   *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
   *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
   */


  var minBy = /*#__PURE__*/_curry3(function minBy(f, a, b) {
    return f(b) < f(a) ? b : a;
  });
  module.exports = minBy;
  },{"./internal/_curry3":935}],1038:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Divides the first parameter by the second and returns the remainder. Note
   * that this function preserves the JavaScript-style behavior for modulo. For
   * mathematical modulo see [`mathMod`](#mathMod).
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The value to the divide.
   * @param {Number} b The pseudo-modulus
   * @return {Number} The result of `b % a`.
   * @see R.mathMod
   * @example
   *
   *      R.modulo(17, 3); //=> 2
   *      // JS behavior:
   *      R.modulo(-17, 3); //=> -2
   *      R.modulo(17, -3); //=> 2
   *
   *      var isOdd = R.modulo(R.__, 2);
   *      isOdd(42); //=> 0
   *      isOdd(21); //=> 1
   */


  var modulo = /*#__PURE__*/_curry2(function modulo(a, b) {
    return a % b;
  });
  module.exports = modulo;
  },{"./internal/_curry2":934}],1039:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Multiplies two numbers. Equivalent to `a * b` but curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a * b`.
   * @see R.divide
   * @example
   *
   *      var double = R.multiply(2);
   *      var triple = R.multiply(3);
   *      double(3);       //=>  6
   *      triple(4);       //=> 12
   *      R.multiply(2, 5);  //=> 10
   */


  var multiply = /*#__PURE__*/_curry2(function multiply(a, b) {
    return a * b;
  });
  module.exports = multiply;
  },{"./internal/_curry2":934}],1040:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly `n` parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} n The desired arity of the new function.
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity `n`.
   * @see R.binary, R.unary
   * @example
   *
   *      var takesTwoArgs = (a, b) => [a, b];
   *
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      var takesOneArg = R.nAry(1, takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only `n` arguments are passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.nAry(0, f)(a, b) = f()
   * @symb R.nAry(1, f)(a, b) = f(a)
   * @symb R.nAry(2, f)(a, b) = f(a, b)
   */


  var nAry = /*#__PURE__*/_curry2(function nAry(n, fn) {
    switch (n) {
      case 0:
        return function () {
          return fn.call(this);
        };
      case 1:
        return function (a0) {
          return fn.call(this, a0);
        };
      case 2:
        return function (a0, a1) {
          return fn.call(this, a0, a1);
        };
      case 3:
        return function (a0, a1, a2) {
          return fn.call(this, a0, a1, a2);
        };
      case 4:
        return function (a0, a1, a2, a3) {
          return fn.call(this, a0, a1, a2, a3);
        };
      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.call(this, a0, a1, a2, a3, a4);
        };
      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.call(this, a0, a1, a2, a3, a4, a5);
        };
      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
        };
      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
        };
      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
        };
      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
        };
      default:
        throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
    }
  });
  module.exports = nAry;
  },{"./internal/_curry2":934}],1041:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Negates its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number}
   * @example
   *
   *      R.negate(42); //=> -42
   */


  var negate = /*#__PURE__*/_curry1(function negate(n) {
    return -n;
  });
  module.exports = negate;
  },{"./internal/_curry1":933}],1042:[function(require,module,exports){
  var _complement = /*#__PURE__*/require('./internal/_complement');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xany = /*#__PURE__*/require('./internal/_xany');

  var any = /*#__PURE__*/require('./any');

  /**
   * Returns `true` if no elements of the list match the predicate, `false`
   * otherwise.
   *
   * Dispatches to the `any` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
   * @see R.all, R.any
   * @example
   *
   *      var isEven = n => n % 2 === 0;
   *      var isOdd = n => n % 2 === 1;
   *
   *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
   *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
   */


  var none = /*#__PURE__*/_curry2( /*#__PURE__*/_complement( /*#__PURE__*/_dispatchable(['any'], _xany, any)));
  module.exports = none;
  },{"./any":839,"./internal/_complement":928,"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xany":972}],1043:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * A function that returns the `!` of its argument. It will return `true` when
   * passed false-y value, and `false` when passed a truth-y one.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig * -> Boolean
   * @param {*} a any value
   * @return {Boolean} the logical inverse of passed argument.
   * @see R.complement
   * @example
   *
   *      R.not(true); //=> false
   *      R.not(false); //=> true
   *      R.not(0); //=> true
   *      R.not(1); //=> false
   */


  var not = /*#__PURE__*/_curry1(function not(a) {
    return !a;
  });
  module.exports = not;
  },{"./internal/_curry1":933}],1044:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isString = /*#__PURE__*/require('./internal/_isString');

  /**
   * Returns the nth element of the given list or string. If n is negative the
   * element at index length + n is returned.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> a | Undefined
   * @sig Number -> String -> String
   * @param {Number} offset
   * @param {*} list
   * @return {*}
   * @example
   *
   *      var list = ['foo', 'bar', 'baz', 'quux'];
   *      R.nth(1, list); //=> 'bar'
   *      R.nth(-1, list); //=> 'quux'
   *      R.nth(-99, list); //=> undefined
   *
   *      R.nth(2, 'abc'); //=> 'c'
   *      R.nth(3, 'abc'); //=> ''
   * @symb R.nth(-1, [a, b, c]) = c
   * @symb R.nth(0, [a, b, c]) = a
   * @symb R.nth(1, [a, b, c]) = b
   */


  var nth = /*#__PURE__*/_curry2(function nth(offset, list) {
    var idx = offset < 0 ? list.length + offset : offset;
    return _isString(list) ? list.charAt(idx) : list[idx];
  });
  module.exports = nth;
  },{"./internal/_curry2":934,"./internal/_isString":957}],1045:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var curryN = /*#__PURE__*/require('./curryN');

  var nth = /*#__PURE__*/require('./nth');

  /**
   * Returns a function which returns its nth argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig Number -> *... -> *
   * @param {Number} n
   * @return {Function}
   * @example
   *
   *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
   *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
   * @symb R.nthArg(-1)(a, b, c) = c
   * @symb R.nthArg(0)(a, b, c) = a
   * @symb R.nthArg(1)(a, b, c) = b
   */


  var nthArg = /*#__PURE__*/_curry1(function nthArg(n) {
    var arity = n < 0 ? 1 : n + 1;
    return curryN(arity, function () {
      return nth(n, arguments);
    });
  });
  module.exports = nthArg;
  },{"./curryN":870,"./internal/_curry1":933,"./nth":1044}],1046:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * `o` is a curried composition function that returns a unary function.
   * Like [`compose`](#compose), `o` performs right-to-left function composition.
   * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
   * invoked with only one argument.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Function
   * @sig (b -> c) -> (a -> b) -> a -> c
   * @param {Function} f
   * @param {Function} g
   * @return {Function}
   * @see R.compose, R.pipe
   * @example
   *
   *      var classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
   *      var yellGreeting = R.o(R.toUpper, classyGreeting);
   *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
   *
   * @symb R.o(f, g, x) = f(g(x))
   */


  var o = /*#__PURE__*/_curry3(function o(f, g, x) {
    return f(g(x));
  });
  module.exports = o;
  },{"./internal/_curry3":935}],1047:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Creates an object containing a single key:value pair.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @sig String -> a -> {String:a}
   * @param {String} key
   * @param {*} val
   * @return {Object}
   * @see R.pair
   * @example
   *
   *      var matchPhrases = R.compose(
   *        R.objOf('must'),
   *        R.map(R.objOf('match_phrase'))
   *      );
   *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
   */


  var objOf = /*#__PURE__*/_curry2(function objOf(key, val) {
    var obj = {};
    obj[key] = val;
    return obj;
  });
  module.exports = objOf;
  },{"./internal/_curry2":934}],1048:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _of = /*#__PURE__*/require('./internal/_of');

  /**
   * Returns a singleton array containing the value provided.
   *
   * Note this `of` is different from the ES6 `of`; See
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> [a]
   * @param {*} x any value
   * @return {Array} An array wrapping `x`.
   * @example
   *
   *      R.of(null); //=> [null]
   *      R.of([42]); //=> [[42]]
   */


  var of = /*#__PURE__*/_curry1(_of);
  module.exports = of;
  },{"./internal/_curry1":933,"./internal/_of":962}],1049:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a partial copy of an object omitting the keys specified.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [String] -> {String: *} -> {String: *}
   * @param {Array} names an array of String property names to omit from the new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with properties from `names` not on it.
   * @see R.pick
   * @example
   *
   *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
   */


  var omit = /*#__PURE__*/_curry2(function omit(names, obj) {
    var result = {};
    var index = {};
    var idx = 0;
    var len = names.length;

    while (idx < len) {
      index[names[idx]] = 1;
      idx += 1;
    }

    for (var prop in obj) {
      if (!index.hasOwnProperty(prop)) {
        result[prop] = obj[prop];
      }
    }
    return result;
  });
  module.exports = omit;
  },{"./internal/_curry2":934}],1050:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Accepts a function `fn` and returns a function that guards invocation of
   * `fn` such that `fn` can only ever be called once, no matter how many times
   * the returned function is invoked. The first value calculated is returned in
   * subsequent invocations.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a... -> b) -> (a... -> b)
   * @param {Function} fn The function to wrap in a call-only-once wrapper.
   * @return {Function} The wrapped function.
   * @example
   *
   *      var addOneOnce = R.once(x => x + 1);
   *      addOneOnce(10); //=> 11
   *      addOneOnce(addOneOnce(50)); //=> 11
   */


  var once = /*#__PURE__*/_curry1(function once(fn) {
    var called = false;
    var result;
    return _arity(fn.length, function () {
      if (called) {
        return result;
      }
      called = true;
      result = fn.apply(this, arguments);
      return result;
    });
  });
  module.exports = once;
  },{"./internal/_arity":922,"./internal/_curry1":933}],1051:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns `true` if one or both of its arguments are `true`. Returns `false`
   * if both arguments are `false`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any} the first argument if truthy, otherwise the second argument.
   * @see R.either
   * @example
   *
   *      R.or(true, true); //=> true
   *      R.or(true, false); //=> true
   *      R.or(false, true); //=> true
   *      R.or(false, false); //=> false
   */


  var or = /*#__PURE__*/_curry2(function or(a, b) {
    return a || b;
  });
  module.exports = or;
  },{"./internal/_curry2":934}],1052:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  // `Identity` is a functor that holds a single value, where `map` simply
  // transforms the held value with the provided function.


  var Identity = function (x) {
    return { value: x, map: function (f) {
        return Identity(f(x));
      } };
  };

  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the result of applying the given function to
   * the focused value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> (a -> a) -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.prop, R.lensIndex, R.lensProp
   * @example
   *
   *      var headLens = R.lensIndex(0);
   *
   *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
   */
  var over = /*#__PURE__*/_curry3(function over(lens, f, x) {
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    return lens(function (y) {
      return Identity(f(y));
    })(x).value;
  });
  module.exports = over;
  },{"./internal/_curry3":935}],1053:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category List
   * @sig a -> b -> (a,b)
   * @param {*} fst
   * @param {*} snd
   * @return {Array}
   * @see R.objOf, R.of
   * @example
   *
   *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
   */


  var pair = /*#__PURE__*/_curry2(function pair(fst, snd) {
    return [fst, snd];
  });
  module.exports = pair;
  },{"./internal/_curry2":934}],1054:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _createPartialApplicator = /*#__PURE__*/require('./internal/_createPartialApplicator');

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided initially followed by the arguments provided to `g`.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partialRight
   * @example
   *
   *      var multiply2 = (a, b) => a * b;
   *      var double = R.partial(multiply2, [2]);
   *      double(2); //=> 4
   *
   *      var greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      var sayHello = R.partial(greet, ['Hello']);
   *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
   *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
   */


  var partial = /*#__PURE__*/_createPartialApplicator(_concat);
  module.exports = partial;
  },{"./internal/_concat":929,"./internal/_createPartialApplicator":932}],1055:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _createPartialApplicator = /*#__PURE__*/require('./internal/_createPartialApplicator');

  var flip = /*#__PURE__*/require('./flip');

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided to `g` followed by the arguments provided initially.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partial
   * @example
   *
   *      var greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
   *
   *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
   */


  var partialRight = /*#__PURE__*/_createPartialApplicator( /*#__PURE__*/flip(_concat));
  module.exports = partialRight;
  },{"./flip":898,"./internal/_concat":929,"./internal/_createPartialApplicator":932}],1056:[function(require,module,exports){
  var filter = /*#__PURE__*/require('./filter');

  var juxt = /*#__PURE__*/require('./juxt');

  var reject = /*#__PURE__*/require('./reject');

  /**
   * Takes a predicate and a list or other `Filterable` object and returns the
   * pair of filterable objects of the same type of elements which do and do not
   * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
   * @param {Function} pred A predicate to determine which side the element belongs to.
   * @param {Array} filterable the list (or other filterable) to partition.
   * @return {Array} An array, containing first the subset of elements that satisfy the
   *         predicate, and second the subset of elements that do not satisfy.
   * @see R.filter, R.reject
   * @example
   *
   *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
   *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
   *
   *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
   *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
   */


  var partition = /*#__PURE__*/juxt([filter, reject]);
  module.exports = partition;
  },{"./filter":892,"./juxt":1002,"./reject":1083}],1057:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Retrieve the value at a given path.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig [Idx] -> {a} -> a | Undefined
   * @param {Array} path The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path`.
   * @see R.prop
   * @example
   *
   *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
   */


  var path = /*#__PURE__*/_curry2(function path(paths, obj) {
    var val = obj;
    var idx = 0;
    while (idx < paths.length) {
      if (val == null) {
        return;
      }
      val = val[paths[idx]];
      idx += 1;
    }
    return val;
  });
  module.exports = path;
  },{"./internal/_curry2":934}],1058:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var equals = /*#__PURE__*/require('./equals');

  var path = /*#__PURE__*/require('./path');

  /**
   * Determines whether a nested path on an object has a specific value, in
   * [`R.equals`](#equals) terms. Most likely used to filter a list.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Relation
   * @typedefn Idx = String | Int
   * @sig [Idx] -> a -> {a} -> Boolean
   * @param {Array} path The path of the nested property to use
   * @param {*} val The value to compare the nested property with
   * @param {Object} obj The object to check the nested property in
   * @return {Boolean} `true` if the value equals the nested object property,
   *         `false` otherwise.
   * @example
   *
   *      var user1 = { address: { zipCode: 90210 } };
   *      var user2 = { address: { zipCode: 55555 } };
   *      var user3 = { name: 'Bob' };
   *      var users = [ user1, user2, user3 ];
   *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
   *      R.filter(isFamous, users); //=> [ user1 ]
   */


  var pathEq = /*#__PURE__*/_curry3(function pathEq(_path, val, obj) {
    return equals(path(_path, obj), val);
  });
  module.exports = pathEq;
  },{"./equals":890,"./internal/_curry3":935,"./path":1057}],1059:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var defaultTo = /*#__PURE__*/require('./defaultTo');

  var path = /*#__PURE__*/require('./path');

  /**
   * If the given, non-null object has a value at the given path, returns the
   * value at that path. Otherwise returns the provided default value.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig a -> [Idx] -> {a} -> a
   * @param {*} d The default value.
   * @param {Array} p The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path` of the supplied object or the default value.
   * @example
   *
   *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
   */


  var pathOr = /*#__PURE__*/_curry3(function pathOr(d, p, obj) {
    return defaultTo(d, path(p, obj));
  });
  module.exports = pathOr;
  },{"./defaultTo":872,"./internal/_curry3":935,"./path":1057}],1060:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var path = /*#__PURE__*/require('./path');

  /**
   * Returns `true` if the specified object property at given path satisfies the
   * given predicate; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Logic
   * @typedefn Idx = String | Int
   * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
   * @param {Function} pred
   * @param {Array} propPath
   * @param {*} obj
   * @return {Boolean}
   * @see R.propSatisfies, R.path
   * @example
   *
   *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
   */


  var pathSatisfies = /*#__PURE__*/_curry3(function pathSatisfies(pred, propPath, obj) {
    return propPath.length > 0 && pred(path(propPath, obj));
  });
  module.exports = pathSatisfies;
  },{"./internal/_curry3":935,"./path":1057}],1061:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a partial copy of an object containing only the keys specified. If
   * the key does not exist, the property is ignored.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.omit, R.props
   * @example
   *
   *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
   */


  var pick = /*#__PURE__*/_curry2(function pick(names, obj) {
    var result = {};
    var idx = 0;
    while (idx < names.length) {
      if (names[idx] in obj) {
        result[names[idx]] = obj[names[idx]];
      }
      idx += 1;
    }
    return result;
  });
  module.exports = pick;
  },{"./internal/_curry2":934}],1062:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Similar to `pick` except that this one includes a `key: undefined` pair for
   * properties that don't exist.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.pick
   * @example
   *
   *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
   */


  var pickAll = /*#__PURE__*/_curry2(function pickAll(names, obj) {
    var result = {};
    var idx = 0;
    var len = names.length;
    while (idx < len) {
      var name = names[idx];
      result[name] = obj[name];
      idx += 1;
    }
    return result;
  });
  module.exports = pickAll;
  },{"./internal/_curry2":934}],1063:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a partial copy of an object containing only the keys that satisfy
   * the supplied predicate.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
   * @param {Function} pred A predicate to determine whether or not a key
   *        should be included on the output object.
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties that satisfy `pred`
   *         on it.
   * @see R.pick, R.filter
   * @example
   *
   *      var isUpperCase = (val, key) => key.toUpperCase() === key;
   *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
   */


  var pickBy = /*#__PURE__*/_curry2(function pickBy(test, obj) {
    var result = {};
    for (var prop in obj) {
      if (test(obj[prop], prop, obj)) {
        result[prop] = obj[prop];
      }
    }
    return result;
  });
  module.exports = pickBy;
  },{"./internal/_curry2":934}],1064:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _pipe = /*#__PURE__*/require('./internal/_pipe');

  var reduce = /*#__PURE__*/require('./reduce');

  var tail = /*#__PURE__*/require('./tail');

  /**
   * Performs left-to-right function composition. The leftmost function may have
   * any arity; the remaining functions must be unary.
   *
   * In some libraries this function is named `sequence`.
   *
   * **Note:** The result of pipe is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.compose
   * @example
   *
   *      var f = R.pipe(Math.pow, R.negate, R.inc);
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
   */


  function pipe() {
    if (arguments.length === 0) {
      throw new Error('pipe requires at least one argument');
    }
    return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
  }
  module.exports = pipe;
  },{"./internal/_arity":922,"./internal/_pipe":963,"./reduce":1078,"./tail":1104}],1065:[function(require,module,exports){
  var composeK = /*#__PURE__*/require('./composeK');

  var reverse = /*#__PURE__*/require('./reverse');

  /**
   * Returns the left-to-right Kleisli composition of the provided functions,
   * each of which must return a value of a type supported by [`chain`](#chain).
   *
   * `R.pipeK(f, g, h)` is equivalent to `R.pipe(f, R.chain(g), R.chain(h))`.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Function
   * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
   * @param {...Function}
   * @return {Function}
   * @see R.composeK
   * @example
   *
   *      //  parseJson :: String -> Maybe *
   *      //  get :: String -> Object -> Maybe *
   *
   *      //  getStateCode :: Maybe String -> Maybe String
   *      var getStateCode = R.pipeK(
   *        parseJson,
   *        get('user'),
   *        get('address'),
   *        get('state'),
   *        R.compose(Maybe.of, R.toUpper)
   *      );
   *
   *      getStateCode('{"user":{"address":{"state":"ny"}}}');
   *      //=> Just('NY')
   *      getStateCode('[Invalid JSON]');
   *      //=> Nothing()
   * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
   */


  function pipeK() {
    if (arguments.length === 0) {
      throw new Error('pipeK requires at least one argument');
    }
    return composeK.apply(this, reverse(arguments));
  }
  module.exports = pipeK;
  },{"./composeK":860,"./reverse":1087}],1066:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _pipeP = /*#__PURE__*/require('./internal/_pipeP');

  var reduce = /*#__PURE__*/require('./reduce');

  var tail = /*#__PURE__*/require('./tail');

  /**
   * Performs left-to-right composition of one or more Promise-returning
   * functions. The leftmost function may have any arity; the remaining functions
   * must be unary.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.composeP
   * @example
   *
   *      //  followersForUser :: String -> Promise [User]
   *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
   */


  function pipeP() {
    if (arguments.length === 0) {
      throw new Error('pipeP requires at least one argument');
    }
    return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
  }
  module.exports = pipeP;
  },{"./internal/_arity":922,"./internal/_pipeP":964,"./reduce":1078,"./tail":1104}],1067:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var map = /*#__PURE__*/require('./map');

  var prop = /*#__PURE__*/require('./prop');

  /**
   * Returns a new list by plucking the same named property off all objects in
   * the list supplied.
   *
   * `pluck` will work on
   * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
   * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => k -> f {k: v} -> f v
   * @param {Number|String} key The key name to pluck off of each object.
   * @param {Array} f The array or functor to consider.
   * @return {Array} The list of values for the given key.
   * @see R.props
   * @example
   *
   *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
   *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
   *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
   * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
   * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
   */


  var pluck = /*#__PURE__*/_curry2(function pluck(p, list) {
    return map(prop(p), list);
  });
  module.exports = pluck;
  },{"./internal/_curry2":934,"./map":1016,"./prop":1071}],1068:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a new list with the given element at the front, followed by the
   * contents of the list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The item to add to the head of the output list.
   * @param {Array} list The array to add to the tail of the output list.
   * @return {Array} A new array.
   * @see R.append
   * @example
   *
   *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
   */


  var prepend = /*#__PURE__*/_curry2(function prepend(el, list) {
    return _concat([el], list);
  });
  module.exports = prepend;
  },{"./internal/_concat":929,"./internal/_curry2":934}],1069:[function(require,module,exports){
  var multiply = /*#__PURE__*/require('./multiply');

  var reduce = /*#__PURE__*/require('./reduce');

  /**
   * Multiplies together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The product of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.product([2,4,6,8,100,1]); //=> 38400
   */


  var product = /*#__PURE__*/reduce(multiply, 1);
  module.exports = product;
  },{"./multiply":1039,"./reduce":1078}],1070:[function(require,module,exports){
  var _map = /*#__PURE__*/require('./internal/_map');

  var identity = /*#__PURE__*/require('./identity');

  var pickAll = /*#__PURE__*/require('./pickAll');

  var useWith = /*#__PURE__*/require('./useWith');

  /**
   * Reasonable analog to SQL `select` statement.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @category Relation
   * @sig [k] -> [{k: v}] -> [{k: v}]
   * @param {Array} props The property names to project
   * @param {Array} objs The objects to query
   * @return {Array} An array of objects with just the `props` properties.
   * @example
   *
   *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
   *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
   *      var kids = [abby, fred];
   *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
   */


  var project = /*#__PURE__*/useWith(_map, [pickAll, identity]); // passing `identity` gives correct arity
  module.exports = project;
  },{"./identity":910,"./internal/_map":960,"./pickAll":1062,"./useWith":1136}],1071:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var path = /*#__PURE__*/require('./path');

  /**
   * Returns a function that when supplied an object returns the indicated
   * property of that object, if it exists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig s -> {s: a} -> a | Undefined
   * @param {String} p The property name
   * @param {Object} obj The object to query
   * @return {*} The value at `obj.p`.
   * @see R.path
   * @example
   *
   *      R.prop('x', {x: 100}); //=> 100
   *      R.prop('x', {}); //=> undefined
   */

  var prop = /*#__PURE__*/_curry2(function prop(p, obj) {
    return path([p], obj);
  });
  module.exports = prop;
  },{"./internal/_curry2":934,"./path":1057}],1072:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var equals = /*#__PURE__*/require('./equals');

  /**
   * Returns `true` if the specified object property is equal, in
   * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
   * You can test multiple properties with [`R.where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig String -> a -> Object -> Boolean
   * @param {String} name
   * @param {*} val
   * @param {*} obj
   * @return {Boolean}
   * @see R.whereEq, R.propSatisfies, R.equals
   * @example
   *
   *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
   *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
   *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
   *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
   *      var kids = [abby, fred, rusty, alois];
   *      var hasBrownHair = R.propEq('hair', 'brown');
   *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
   */


  var propEq = /*#__PURE__*/_curry3(function propEq(name, val, obj) {
    return equals(val, obj[name]);
  });
  module.exports = propEq;
  },{"./equals":890,"./internal/_curry3":935}],1073:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var is = /*#__PURE__*/require('./is');

  /**
   * Returns `true` if the specified object property is of the given type;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Type
   * @sig Type -> String -> Object -> Boolean
   * @param {Function} type
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.is, R.propSatisfies
   * @example
   *
   *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
   *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
   *      R.propIs(Number, 'x', {});            //=> false
   */


  var propIs = /*#__PURE__*/_curry3(function propIs(type, name, obj) {
    return is(type, obj[name]);
  });
  module.exports = propIs;
  },{"./internal/_curry3":935,"./is":998}],1074:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var _has = /*#__PURE__*/require('./internal/_has');

  /**
   * If the given, non-null object has an own property with the specified name,
   * returns the value of that property. Otherwise returns the provided default
   * value.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Object
   * @sig a -> String -> Object -> a
   * @param {*} val The default value.
   * @param {String} p The name of the property to return.
   * @param {Object} obj The object to query.
   * @return {*} The value of given property of the supplied object or the default value.
   * @example
   *
   *      var alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      var favorite = R.prop('favoriteLibrary');
   *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
   *
   *      favorite(alice);  //=> undefined
   *      favoriteWithDefault(alice);  //=> 'Ramda'
   */


  var propOr = /*#__PURE__*/_curry3(function propOr(val, p, obj) {
    return obj != null && _has(p, obj) ? obj[p] : val;
  });
  module.exports = propOr;
  },{"./internal/_curry3":935,"./internal/_has":945}],1075:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Returns `true` if the specified object property satisfies the given
   * predicate; `false` otherwise. You can test multiple properties with
   * [`R.where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Logic
   * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
   * @param {Function} pred
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.where, R.propEq, R.propIs
   * @example
   *
   *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
   */


  var propSatisfies = /*#__PURE__*/_curry3(function propSatisfies(pred, name, obj) {
    return pred(obj[name]);
  });
  module.exports = propSatisfies;
  },{"./internal/_curry3":935}],1076:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Acts as multiple `prop`: array of keys in, array of values out. Preserves
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> [v]
   * @param {Array} ps The property names to fetch
   * @param {Object} obj The object to query
   * @return {Array} The corresponding values or partially applied function.
   * @example
   *
   *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
   *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
   *
   *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
   *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
   */


  var props = /*#__PURE__*/_curry2(function props(ps, obj) {
    var len = ps.length;
    var out = [];
    var idx = 0;

    while (idx < len) {
      out[idx] = obj[ps[idx]];
      idx += 1;
    }

    return out;
  });
  module.exports = props;
  },{"./internal/_curry2":934}],1077:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isNumber = /*#__PURE__*/require('./internal/_isNumber');

  /**
   * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> Number -> [Number]
   * @param {Number} from The first number in the list.
   * @param {Number} to One more than the last number in the list.
   * @return {Array} The list of numbers in tthe set `[a, b)`.
   * @example
   *
   *      R.range(1, 5);    //=> [1, 2, 3, 4]
   *      R.range(50, 53);  //=> [50, 51, 52]
   */


  var range = /*#__PURE__*/_curry2(function range(from, to) {
    if (!(_isNumber(from) && _isNumber(to))) {
      throw new TypeError('Both arguments to range must be numbers');
    }
    var result = [];
    var n = from;
    while (n < to) {
      result.push(n);
      n += 1;
    }
    return result;
  });
  module.exports = range;
  },{"./internal/_curry2":934,"./internal/_isNumber":953}],1078:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to shortcut the iteration.
   *
   * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
   * is *(value, acc)*.
   *
   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
   *
   * Dispatches to the `reduce` method of the third argument, if present. When
   * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
   * shortcuting, as this is not implemented by `reduce`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduced, R.addIndex, R.reduceRight
   * @example
   *
   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
   *      //          -               -10
   *      //         / \              / \
   *      //        -   4           -6   4
   *      //       / \              / \
   *      //      -   3   ==>     -3   3
   *      //     / \              / \
   *      //    -   2           -1   2
   *      //   / \              / \
   *      //  0   1            0   1
   *
   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
   */


  var reduce = /*#__PURE__*/_curry3(_reduce);
  module.exports = reduce;
  },{"./internal/_curry3":935,"./internal/_reduce":966}],1079:[function(require,module,exports){
  var _curryN = /*#__PURE__*/require('./internal/_curryN');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _has = /*#__PURE__*/require('./internal/_has');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var _xreduceBy = /*#__PURE__*/require('./internal/_xreduceBy');

  /**
   * Groups the elements of the list according to the result of calling
   * the String-returning function `keyFn` on each element and reduces the elements
   * of each group to a single value via the reducer function `valueFn`.
   *
   * This function is basically a more general [`groupBy`](#groupBy) function.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category List
   * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
   * @param {Function} valueFn The function that reduces the elements of each group to a single
   *        value. Receives two values, accumulator for a particular group and the current element.
   * @param {*} acc The (initial) accumulator value for each group.
   * @param {Function} keyFn The function that maps the list's element into a key.
   * @param {Array} list The array to group.
   * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
   *         `valueFn` for elements which produced that key when passed to `keyFn`.
   * @see R.groupBy, R.reduce
   * @example
   *
   *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
   *      var namesByGrade = reduceToNamesBy(function(student) {
   *        var score = student.score;
   *        return score < 65 ? 'F' :
   *               score < 70 ? 'D' :
   *               score < 80 ? 'C' :
   *               score < 90 ? 'B' : 'A';
   *      });
   *      var students = [{name: 'Lucy', score: 92},
   *                      {name: 'Drew', score: 85},
   *                      // ...
   *                      {name: 'Bart', score: 62}];
   *      namesByGrade(students);
   *      // {
   *      //   'A': ['Lucy'],
   *      //   'B': ['Drew']
   *      //   // ...,
   *      //   'F': ['Bart']
   *      // }
   */


  var reduceBy = /*#__PURE__*/_curryN(4, [], /*#__PURE__*/_dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
    return _reduce(function (acc, elt) {
      var key = keyFn(elt);
      acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
      return acc;
    }, {}, list);
  }));
  module.exports = reduceBy;
  },{"./internal/_curryN":936,"./internal/_dispatchable":937,"./internal/_has":945,"./internal/_reduce":966,"./internal/_xreduceBy":987}],1080:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * Similar to [`reduce`](#reduce), except moves through the input list from the
   * right to the left.
   *
   * The iterator function receives two values: *(value, acc)*, while the arguments'
   * order of `reduce`'s iterator function is *(acc, value)*.
   *
   * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> b) -> b -> [a] -> b
   * @param {Function} fn The iterator function. Receives two values, the current element from the array
   *        and the accumulator.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.addIndex
   * @example
   *
   *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
   *      //    -               -2
   *      //   / \              / \
   *      //  1   -            1   3
   *      //     / \              / \
   *      //    2   -     ==>    2  -1
   *      //       / \              / \
   *      //      3   -            3   4
   *      //         / \              / \
   *      //        4   0            4   0
   *
   * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
   */


  var reduceRight = /*#__PURE__*/_curry3(function reduceRight(fn, acc, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      acc = fn(list[idx], acc);
      idx -= 1;
    }
    return acc;
  });
  module.exports = reduceRight;
  },{"./internal/_curry3":935}],1081:[function(require,module,exports){
  var _curryN = /*#__PURE__*/require('./internal/_curryN');

  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var _reduced = /*#__PURE__*/require('./internal/_reduced');

  /**
   * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
   * through the list, successively calling the iterator function. `reduceWhile`
   * also takes a predicate that is evaluated before each step. If the predicate
   * returns `false`, it "short-circuits" the iteration and returns the current
   * value of the accumulator.
   *
   * @func
   * @memberOf R
   * @since v0.22.0
   * @category List
   * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} pred The predicate. It is passed the accumulator and the
   *        current element.
   * @param {Function} fn The iterator function. Receives two values, the
   *        accumulator and the current element.
   * @param {*} a The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced
   * @example
   *
   *      var isOdd = (acc, x) => x % 2 === 1;
   *      var xs = [1, 3, 5, 60, 777, 800];
   *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
   *
   *      var ys = [2, 4, 6]
   *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
   */


  var reduceWhile = /*#__PURE__*/_curryN(4, [], function _reduceWhile(pred, fn, a, list) {
    return _reduce(function (acc, x) {
      return pred(acc, x) ? fn(acc, x) : _reduced(acc);
    }, a, list);
  });
  module.exports = reduceWhile;
  },{"./internal/_curryN":936,"./internal/_reduce":966,"./internal/_reduced":967}],1082:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _reduced = /*#__PURE__*/require('./internal/_reduced');

  /**
   * Returns a value wrapped to indicate that it is the final value of the reduce
   * and transduce functions. The returned value should be considered a black
   * box: the internal structure is not guaranteed to be stable.
   *
   * Note: this optimization is unavailable to functions not explicitly listed
   * above. For instance, it is not currently supported by
   * [`reduceRight`](#reduceRight).
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category List
   * @sig a -> *
   * @param {*} x The final value of the reduce.
   * @return {*} The wrapped value.
   * @see R.reduce, R.transduce
   * @example
   *
   *     R.reduce(
   *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
   *       [],
   *       [1, 2, 3, 4, 5]) // [1, 2, 3]
   */


  var reduced = /*#__PURE__*/_curry1(_reduced);
  module.exports = reduced;
  },{"./internal/_curry1":933,"./internal/_reduced":967}],1083:[function(require,module,exports){
  var _complement = /*#__PURE__*/require('./internal/_complement');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var filter = /*#__PURE__*/require('./filter');

  /**
   * The complement of [`filter`](#filter).
   *
   * Acts as a transducer if a transformer is given in list position. Filterable
   * objects include plain objects or any object that has a filter method such
   * as `Array`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array}
   * @see R.filter, R.transduce, R.addIndex
   * @example
   *
   *      var isOdd = (n) => n % 2 === 1;
   *
   *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */


  var reject = /*#__PURE__*/_curry2(function reject(pred, filterable) {
    return filter(_complement(pred), filterable);
  });
  module.exports = reject;
  },{"./filter":892,"./internal/_complement":928,"./internal/_curry2":934}],1084:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Removes the sub-list of `list` starting at index `start` and containing
   * `count` elements. _Note that this is not destructive_: it returns a copy of
   * the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number} start The position to start removing elements
   * @param {Number} count The number of elements to remove
   * @param {Array} list The list to remove from
   * @return {Array} A new Array with `count` elements from `start` removed.
   * @example
   *
   *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
   */


  var remove = /*#__PURE__*/_curry3(function remove(start, count, list) {
    var result = Array.prototype.slice.call(list, 0);
    result.splice(start, count);
    return result;
  });
  module.exports = remove;
  },{"./internal/_curry3":935}],1085:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var always = /*#__PURE__*/require('./always');

  var times = /*#__PURE__*/require('./times');

  /**
   * Returns a fixed list of size `n` containing a specified identical value.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig a -> n -> [a]
   * @param {*} value The value to repeat.
   * @param {Number} n The desired size of the output list.
   * @return {Array} A new array containing `n` `value`s.
   * @see R.times
   * @example
   *
   *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
   *
   *      var obj = {};
   *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
   *      repeatedObjs[0] === repeatedObjs[1]; //=> true
   * @symb R.repeat(a, 0) = []
   * @symb R.repeat(a, 1) = [a]
   * @symb R.repeat(a, 2) = [a, a]
   */


  var repeat = /*#__PURE__*/_curry2(function repeat(value, n) {
    return times(always(value), n);
  });
  module.exports = repeat;
  },{"./always":837,"./internal/_curry2":934,"./times":1111}],1086:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Replace a substring or regex match in a string with a replacement.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category String
   * @sig RegExp|String -> String -> String -> String
   * @param {RegExp|String} pattern A regular expression or a substring to match.
   * @param {String} replacement The string to replace the matches with.
   * @param {String} str The String to do the search and replacement in.
   * @return {String} The result.
   * @example
   *
   *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *
   *      // Use the "g" (global) flag to replace all occurrences:
   *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
   */


  var replace = /*#__PURE__*/_curry3(function replace(regex, replacement, str) {
    return str.replace(regex, replacement);
  });
  module.exports = replace;
  },{"./internal/_curry3":935}],1087:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _isString = /*#__PURE__*/require('./internal/_isString');

  /**
   * Returns a new list or string with the elements or characters in reverse
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {Array|String} list
   * @return {Array|String}
   * @example
   *
   *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
   *      R.reverse([1, 2]);     //=> [2, 1]
   *      R.reverse([1]);        //=> [1]
   *      R.reverse([]);         //=> []
   *
   *      R.reverse('abc');      //=> 'cba'
   *      R.reverse('ab');       //=> 'ba'
   *      R.reverse('a');        //=> 'a'
   *      R.reverse('');         //=> ''
   */


  var reverse = /*#__PURE__*/_curry1(function reverse(list) {
    return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
  });
  module.exports = reverse;
  },{"./internal/_curry1":933,"./internal/_isString":957}],1088:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Scan is similar to [`reduce`](#reduce), but returns a list of successively
   * reduced values from the left
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> [a]
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {Array} A list of all intermediately reduced values.
   * @see R.reduce
   * @example
   *
   *      var numbers = [1, 2, 3, 4];
   *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
   * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
   */


  var scan = /*#__PURE__*/_curry3(function scan(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [acc];
    while (idx < len) {
      acc = fn(acc, list[idx]);
      result[idx + 1] = acc;
      idx += 1;
    }
    return result;
  });
  module.exports = scan;
  },{"./internal/_curry3":935}],1089:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var ap = /*#__PURE__*/require('./ap');

  var map = /*#__PURE__*/require('./map');

  var prepend = /*#__PURE__*/require('./prepend');

  var reduceRight = /*#__PURE__*/require('./reduceRight');

  /**
   * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
   * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
   * Applicative of Traversable.
   *
   * Dispatches to the `sequence` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
   * @param {Function} of
   * @param {*} traversable
   * @return {*}
   * @see R.traverse
   * @example
   *
   *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
   *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
   *
   *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
   *      R.sequence(R.of, Nothing());       //=> [Nothing()]
   */


  var sequence = /*#__PURE__*/_curry2(function sequence(of, traversable) {
    return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (x, acc) {
      return ap(map(prepend, x), acc);
    }, of([]), traversable);
  });
  module.exports = sequence;
  },{"./ap":841,"./internal/_curry2":934,"./map":1016,"./prepend":1068,"./reduceRight":1080}],1090:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var always = /*#__PURE__*/require('./always');

  var over = /*#__PURE__*/require('./over');

  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the given value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> a -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.prop, R.lensIndex, R.lensProp
   * @example
   *
   *      var xLens = R.lensProp('x');
   *
   *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
   *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
   */


  var set = /*#__PURE__*/_curry3(function set(lens, v, x) {
    return over(lens, always(v), x);
  });
  module.exports = set;
  },{"./always":837,"./internal/_curry3":935,"./over":1052}],1091:[function(require,module,exports){
  var _checkForMethod = /*#__PURE__*/require('./internal/_checkForMethod');

  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Returns the elements of the given list or string (or object with a `slice`
   * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
   *
   * Dispatches to the `slice` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @sig Number -> Number -> String -> String
   * @param {Number} fromIndex The start index (inclusive).
   * @param {Number} toIndex The end index (exclusive).
   * @param {*} list
   * @return {*}
   * @example
   *
   *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
   *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
   *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
   *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
   *      R.slice(0, 3, 'ramda');                     //=> 'ram'
   */


  var slice = /*#__PURE__*/_curry3( /*#__PURE__*/_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  }));
  module.exports = slice;
  },{"./internal/_checkForMethod":925,"./internal/_curry3":935}],1092:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a copy of the list, sorted according to the comparator function,
   * which should accept two values at a time and return a negative number if the
   * first value is smaller, a positive number if it's larger, and zero if they
   * are equal. Please note that this is a **copy** of the list. It does not
   * modify the original.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, a) -> Number) -> [a] -> [a]
   * @param {Function} comparator A sorting function :: a -> b -> Int
   * @param {Array} list The list to sort
   * @return {Array} a new array with its elements sorted by the comparator function.
   * @example
   *
   *      var diff = function(a, b) { return a - b; };
   *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
   */


  var sort = /*#__PURE__*/_curry2(function sort(comparator, list) {
    return Array.prototype.slice.call(list, 0).sort(comparator);
  });
  module.exports = sort;
  },{"./internal/_curry2":934}],1093:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Sorts the list according to the supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord b => (a -> b) -> [a] -> [a]
   * @param {Function} fn
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted by the keys generated by `fn`.
   * @example
   *
   *      var sortByFirstItem = R.sortBy(R.prop(0));
   *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
   *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
   *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
   *      var alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      var bob = {
   *        name: 'Bob',
   *        age: -10
   *      };
   *      var clara = {
   *        name: 'clara',
   *        age: 314.159
   *      };
   *      var people = [clara, bob, alice];
   *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
   */


  var sortBy = /*#__PURE__*/_curry2(function sortBy(fn, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
  });
  module.exports = sortBy;
  },{"./internal/_curry2":934}],1094:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Sorts a list according to a list of comparators.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Relation
   * @sig [(a, a) -> Number] -> [a] -> [a]
   * @param {Array} functions A list of comparator functions.
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted according to the comarator functions.
   * @example
   *
   *      var alice = {
   *        name: 'alice',
   *        age: 40
   *      };
   *      var bob = {
   *        name: 'bob',
   *        age: 30
   *      };
   *      var clara = {
   *        name: 'clara',
   *        age: 40
   *      };
   *      var people = [clara, bob, alice];
   *      var ageNameSort = R.sortWith([
   *        R.descend(R.prop('age')),
   *        R.ascend(R.prop('name'))
   *      ]);
   *      ageNameSort(people); //=> [alice, clara, bob]
   */


  var sortWith = /*#__PURE__*/_curry2(function sortWith(fns, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var result = 0;
      var i = 0;
      while (result === 0 && i < fns.length) {
        result = fns[i](a, b);
        i += 1;
      }
      return result;
    });
  });
  module.exports = sortWith;
  },{"./internal/_curry2":934}],1095:[function(require,module,exports){
  var invoker = /*#__PURE__*/require('./invoker');

  /**
   * Splits a string into an array of strings based on the given
   * separator.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig (String | RegExp) -> String -> [String]
   * @param {String|RegExp} sep The pattern.
   * @param {String} str The string to separate into an array.
   * @return {Array} The array of strings from `str` separated by `str`.
   * @see R.join
   * @example
   *
   *      var pathComponents = R.split('/');
   *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
   *
   *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
   */


  var split = /*#__PURE__*/invoker(1, 'split');
  module.exports = split;
  },{"./invoker":997}],1096:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var length = /*#__PURE__*/require('./length');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Splits a given list or string at a given index.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig Number -> [a] -> [[a], [a]]
   * @sig Number -> String -> [String, String]
   * @param {Number} index The index where the array/string is split.
   * @param {Array|String} array The array/string to be split.
   * @return {Array}
   * @example
   *
   *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
   *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
   *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
   */


  var splitAt = /*#__PURE__*/_curry2(function splitAt(index, array) {
    return [slice(0, index, array), slice(index, length(array), array)];
  });
  module.exports = splitAt;
  },{"./internal/_curry2":934,"./length":1007,"./slice":1091}],1097:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Splits a collection into slices of the specified length.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @sig Number -> String -> [String]
   * @param {Number} n
   * @param {Array} list
   * @return {Array}
   * @example
   *
   *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
   *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
   */


  var splitEvery = /*#__PURE__*/_curry2(function splitEvery(n, list) {
    if (n <= 0) {
      throw new Error('First argument to splitEvery must be a positive integer');
    }
    var result = [];
    var idx = 0;
    while (idx < list.length) {
      result.push(slice(idx, idx += n, list));
    }
    return result;
  });
  module.exports = splitEvery;
  },{"./internal/_curry2":934,"./slice":1091}],1098:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Takes a list and a predicate and returns a pair of lists with the following properties:
   *
   *  - the result of concatenating the two output lists is equivalent to the input list;
   *  - none of the elements of the first output list satisfies the predicate; and
   *  - if the second output list is non-empty, its first element satisfies the predicate.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [[a], [a]]
   * @param {Function} pred The predicate that determines where the array is split.
   * @param {Array} list The array to be split.
   * @return {Array}
   * @example
   *
   *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
   */


  var splitWhen = /*#__PURE__*/_curry2(function splitWhen(pred, list) {
    var idx = 0;
    var len = list.length;
    var prefix = [];

    while (idx < len && !pred(list[idx])) {
      prefix.push(list[idx]);
      idx += 1;
    }

    return [prefix, Array.prototype.slice.call(list, idx)];
  });
  module.exports = splitWhen;
  },{"./internal/_curry2":934}],1099:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var equals = /*#__PURE__*/require('./equals');

  var take = /*#__PURE__*/require('./take');

  /**
   * Checks if a list starts with the provided values
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category List
   * @sig [a] -> Boolean
   * @sig String -> Boolean
   * @param {*} prefix
   * @param {*} list
   * @return {Boolean}
   * @example
   *
   *      R.startsWith('a', 'abc')                //=> true
   *      R.startsWith('b', 'abc')                //=> false
   *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
   *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
   */


  var startsWith = /*#__PURE__*/_curry2(function (prefix, list) {
    return equals(take(prefix.length, list), prefix);
  });
  module.exports = startsWith;
  },{"./equals":890,"./internal/_curry2":934,"./take":1105}],1100:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Subtracts its second argument from its first argument.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a - b`.
   * @see R.add
   * @example
   *
   *      R.subtract(10, 8); //=> 2
   *
   *      var minus5 = R.subtract(R.__, 5);
   *      minus5(17); //=> 12
   *
   *      var complementaryAngle = R.subtract(90);
   *      complementaryAngle(30); //=> 60
   *      complementaryAngle(72); //=> 18
   */


  var subtract = /*#__PURE__*/_curry2(function subtract(a, b) {
    return Number(a) - Number(b);
  });
  module.exports = subtract;
  },{"./internal/_curry2":934}],1101:[function(require,module,exports){
  var add = /*#__PURE__*/require('./add');

  var reduce = /*#__PURE__*/require('./reduce');

  /**
   * Adds together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The sum of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.sum([2,4,6,8,100,1]); //=> 121
   */


  var sum = /*#__PURE__*/reduce(add, 0);
  module.exports = sum;
  },{"./add":832,"./reduce":1078}],1102:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var concat = /*#__PURE__*/require('./concat');

  var difference = /*#__PURE__*/require('./difference');

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
   * @example
   *
   *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
   *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
   */


  var symmetricDifference = /*#__PURE__*/_curry2(function symmetricDifference(list1, list2) {
    return concat(difference(list1, list2), difference(list2, list1));
  });
  module.exports = symmetricDifference;
  },{"./concat":862,"./difference":874,"./internal/_curry2":934}],1103:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var concat = /*#__PURE__*/require('./concat');

  var differenceWith = /*#__PURE__*/require('./differenceWith');

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both. Duplication is determined according to the value
   * returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifference, R.difference, R.differenceWith
   * @example
   *
   *      var eqA = R.eqBy(R.prop('a'));
   *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
   *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
   *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
   */


  var symmetricDifferenceWith = /*#__PURE__*/_curry3(function symmetricDifferenceWith(pred, list1, list2) {
    return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
  });
  module.exports = symmetricDifferenceWith;
  },{"./concat":862,"./differenceWith":875,"./internal/_curry3":935}],1104:[function(require,module,exports){
  var _checkForMethod = /*#__PURE__*/require('./internal/_checkForMethod');

  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Returns all but the first element of the given list or string (or object
   * with a `tail` method).
   *
   * Dispatches to the `slice` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.head, R.init, R.last
   * @example
   *
   *      R.tail([1, 2, 3]);  //=> [2, 3]
   *      R.tail([1, 2]);     //=> [2]
   *      R.tail([1]);        //=> []
   *      R.tail([]);         //=> []
   *
   *      R.tail('abc');  //=> 'bc'
   *      R.tail('ab');   //=> 'b'
   *      R.tail('a');    //=> ''
   *      R.tail('');     //=> ''
   */


  var tail = /*#__PURE__*/_curry1( /*#__PURE__*/_checkForMethod('tail', /*#__PURE__*/slice(1, Infinity)));
  module.exports = tail;
  },{"./internal/_checkForMethod":925,"./internal/_curry1":933,"./slice":1091}],1105:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xtake = /*#__PURE__*/require('./internal/_xtake');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Returns the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `take` method).
   *
   * Dispatches to the `take` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*}
   * @see R.drop
   * @example
   *
   *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(3, 'ramda');               //=> 'ram'
   *
   *      var personnel = [
   *        'Dave Brubeck',
   *        'Paul Desmond',
   *        'Eugene Wright',
   *        'Joe Morello',
   *        'Gerry Mulligan',
   *        'Bob Bates',
   *        'Joe Dodge',
   *        'Ron Crotty'
   *      ];
   *
   *      var takeFive = R.take(5);
   *      takeFive(personnel);
   *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
   * @symb R.take(-1, [a, b]) = [a, b]
   * @symb R.take(0, [a, b]) = []
   * @symb R.take(1, [a, b]) = [a]
   * @symb R.take(2, [a, b]) = [a, b]
   */


  var take = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['take'], _xtake, function take(n, xs) {
    return slice(0, n < 0 ? Infinity : n, xs);
  }));
  module.exports = take;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xtake":988,"./slice":1091}],1106:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var drop = /*#__PURE__*/require('./drop');

  /**
   * Returns a new list containing the last `n` elements of the given list.
   * If `n > list.length`, returns a list of `list.length` elements.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements to return.
   * @param {Array} xs The collection to consider.
   * @return {Array}
   * @see R.dropLast
   * @example
   *
   *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(3, 'ramda');               //=> 'mda'
   */


  var takeLast = /*#__PURE__*/_curry2(function takeLast(n, xs) {
    return drop(n >= 0 ? xs.length - n : 0, xs);
  });
  module.exports = takeLast;
  },{"./drop":879,"./internal/_curry2":934}],1107:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Returns a new list containing the last `n` elements of a given list, passing
   * each value to the supplied predicate function, and terminating when the
   * predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropLastWhile, R.addIndex
   * @example
   *
   *      var isNotOne = x => x !== 1;
   *
   *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
   *
   *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
   */


  var takeLastWhile = /*#__PURE__*/_curry2(function takeLastWhile(fn, xs) {
    var idx = xs.length - 1;
    while (idx >= 0 && fn(xs[idx])) {
      idx -= 1;
    }
    return slice(idx + 1, Infinity, xs);
  });
  module.exports = takeLastWhile;
  },{"./internal/_curry2":934,"./slice":1091}],1108:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xtakeWhile = /*#__PURE__*/require('./internal/_xtakeWhile');

  var slice = /*#__PURE__*/require('./slice');

  /**
   * Returns a new list containing the first `n` elements of a given list,
   * passing each value to the supplied predicate function, and terminating when
   * the predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * Dispatches to the `takeWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropWhile, R.transduce, R.addIndex
   * @example
   *
   *      var isNotFour = x => x !== 4;
   *
   *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
   *
   *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
   */


  var takeWhile = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, xs) {
    var idx = 0;
    var len = xs.length;
    while (idx < len && fn(xs[idx])) {
      idx += 1;
    }
    return slice(0, idx, xs);
  }));
  module.exports = takeWhile;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xtakeWhile":989,"./slice":1091}],1109:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _dispatchable = /*#__PURE__*/require('./internal/_dispatchable');

  var _xtap = /*#__PURE__*/require('./internal/_xtap');

  /**
   * Runs the given function with the supplied object, then returns the object.
   *
   * Acts as a transducer if a transformer is given as second parameter.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a -> *) -> a -> a
   * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
   * @param {*} x
   * @return {*} `x`.
   * @example
   *
   *      var sayX = x => console.log('x is ' + x);
   *      R.tap(sayX, 100); //=> 100
   *      // logs 'x is 100'
   * @symb R.tap(f, a) = a
   */


  var tap = /*#__PURE__*/_curry2( /*#__PURE__*/_dispatchable([], _xtap, function tap(fn, x) {
    fn(x);
    return x;
  }));
  module.exports = tap;
  },{"./internal/_curry2":934,"./internal/_dispatchable":937,"./internal/_xtap":990}],1110:[function(require,module,exports){
  var _cloneRegExp = /*#__PURE__*/require('./internal/_cloneRegExp');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _isRegExp = /*#__PURE__*/require('./internal/_isRegExp');

  var toString = /*#__PURE__*/require('./toString');

  /**
   * Determines whether a given string matches a given regular expression.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category String
   * @sig RegExp -> String -> Boolean
   * @param {RegExp} pattern
   * @param {String} str
   * @return {Boolean}
   * @see R.match
   * @example
   *
   *      R.test(/^x/, 'xyz'); //=> true
   *      R.test(/^y/, 'xyz'); //=> false
   */


  var test = /*#__PURE__*/_curry2(function test(pattern, str) {
    if (!_isRegExp(pattern)) {
      throw new TypeError('‘test’ requires a value of type RegExp as its first argument; received ' + toString(pattern));
    }
    return _cloneRegExp(pattern).test(str);
  });
  module.exports = test;
  },{"./internal/_cloneRegExp":927,"./internal/_curry2":934,"./internal/_isRegExp":956,"./toString":1115}],1111:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Calls an input function `n` times, returning an array containing the results
   * of those function calls.
   *
   * `fn` is passed one argument: The current value of `n`, which begins at `0`
   * and is gradually incremented to `n - 1`.
   *
   * @func
   * @memberOf R
   * @since v0.2.3
   * @category List
   * @sig (Number -> a) -> Number -> [a]
   * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
   * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
   * @return {Array} An array containing the return values of all calls to `fn`.
   * @see R.repeat
   * @example
   *
   *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
   * @symb R.times(f, 0) = []
   * @symb R.times(f, 1) = [f(0)]
   * @symb R.times(f, 2) = [f(0), f(1)]
   */


  var times = /*#__PURE__*/_curry2(function times(fn, n) {
    var len = Number(n);
    var idx = 0;
    var list;

    if (len < 0 || isNaN(len)) {
      throw new RangeError('n must be a non-negative number');
    }
    list = new Array(len);
    while (idx < len) {
      list[idx] = fn(idx);
      idx += 1;
    }
    return list;
  });
  module.exports = times;
  },{"./internal/_curry2":934}],1112:[function(require,module,exports){
  var invoker = /*#__PURE__*/require('./invoker');

  /**
   * The lower case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to lower case.
   * @return {String} The lower case version of `str`.
   * @see R.toUpper
   * @example
   *
   *      R.toLower('XYZ'); //=> 'xyz'
   */


  var toLower = /*#__PURE__*/invoker(0, 'toLowerCase');
  module.exports = toLower;
  },{"./invoker":997}],1113:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _has = /*#__PURE__*/require('./internal/_has');

  /**
   * Converts an object into an array of key, value arrays. Only the object's
   * own properties are used.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own properties.
   * @see R.fromPairs
   * @example
   *
   *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
   */


  var toPairs = /*#__PURE__*/_curry1(function toPairs(obj) {
    var pairs = [];
    for (var prop in obj) {
      if (_has(prop, obj)) {
        pairs[pairs.length] = [prop, obj[prop]];
      }
    }
    return pairs;
  });
  module.exports = toPairs;
  },{"./internal/_curry1":933,"./internal/_has":945}],1114:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Converts an object into an array of key, value arrays. The object's own
   * properties and prototype properties are used. Note that the order of the
   * output array is not guaranteed to be consistent across different JS
   * platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own
   *         and prototype properties.
   * @example
   *
   *      var F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      var f = new F();
   *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
   */


  var toPairsIn = /*#__PURE__*/_curry1(function toPairsIn(obj) {
    var pairs = [];
    for (var prop in obj) {
      pairs[pairs.length] = [prop, obj[prop]];
    }
    return pairs;
  });
  module.exports = toPairsIn;
  },{"./internal/_curry1":933}],1115:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var _toString = /*#__PURE__*/require('./internal/_toString');

  /**
   * Returns the string representation of the given value. `eval`'ing the output
   * should result in a value equivalent to the input value. Many of the built-in
   * `toString` methods do not satisfy this requirement.
   *
   * If the given value is an `[object Object]` with a `toString` method other
   * than `Object.prototype.toString`, this method is invoked with no arguments
   * to produce the return value. This means user-defined constructor functions
   * can provide a suitable `toString` method. For example:
   *
   *     function Point(x, y) {
   *       this.x = x;
   *       this.y = y;
   *     }
   *
   *     Point.prototype.toString = function() {
   *       return 'new Point(' + this.x + ', ' + this.y + ')';
   *     };
   *
   *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category String
   * @sig * -> String
   * @param {*} val
   * @return {String}
   * @example
   *
   *      R.toString(42); //=> '42'
   *      R.toString('abc'); //=> '"abc"'
   *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
   *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
   *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
   */


  var toString = /*#__PURE__*/_curry1(function toString(val) {
    return _toString(val, []);
  });
  module.exports = toString;
  },{"./internal/_curry1":933,"./internal/_toString":970}],1116:[function(require,module,exports){
  var invoker = /*#__PURE__*/require('./invoker');

  /**
   * The upper case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to upper case.
   * @return {String} The upper case version of `str`.
   * @see R.toLower
   * @example
   *
   *      R.toUpper('abc'); //=> 'ABC'
   */


  var toUpper = /*#__PURE__*/invoker(0, 'toUpperCase');
  module.exports = toUpper;
  },{"./invoker":997}],1117:[function(require,module,exports){
  var _reduce = /*#__PURE__*/require('./internal/_reduce');

  var _xwrap = /*#__PURE__*/require('./internal/_xwrap');

  var curryN = /*#__PURE__*/require('./curryN');

  /**
   * Initializes a transducer using supplied iterator function. Returns a single
   * item by iterating through the list, successively calling the transformed
   * iterator function and passing it an accumulator value and the current value
   * from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It will be
   * wrapped as a transformer to initialize the transducer. A transformer can be
   * passed directly in place of an iterator function. In both cases, iteration
   * may be stopped early with the [`R.reduced`](#reduced) function.
   *
   * A transducer is a function that accepts a transformer and returns a
   * transformer and can be composed directly.
   *
   * A transformer is an an object that provides a 2-arity reducing iterator
   * function, step, 0-arity initial value function, init, and 1-arity result
   * extraction function, result. The step function is used as the iterator
   * function in reduce. The result function is used to convert the final
   * accumulator into the return type and in most cases is
   * [`R.identity`](#identity). The init function can be used to provide an
   * initial accumulator, but is ignored by transduce.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array. Wrapped as transformer, if necessary, and used to
   *        initialize the transducer
   * @param {*} acc The initial accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced, R.into
   * @example
   *
   *      var numbers = [1, 2, 3, 4];
   *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
   *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
   *
   *      var isOdd = (x) => x % 2 === 1;
   *      var firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
   *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
   */


  var transduce = /*#__PURE__*/curryN(4, function transduce(xf, fn, acc, list) {
    return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
  });
  module.exports = transduce;
  },{"./curryN":870,"./internal/_reduce":966,"./internal/_xwrap":991}],1118:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Transposes the rows and columns of a 2D list.
   * When passed a list of `n` lists of length `x`,
   * returns a list of `x` lists of length `n`.
   *
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [[a]] -> [[a]]
   * @param {Array} list A 2D list
   * @return {Array} A 2D list
   * @example
   *
   *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
   *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   *
   *      // If some of the rows are shorter than the following rows, their elements are skipped:
   *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
   * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
   * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
   * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
   */


  var transpose = /*#__PURE__*/_curry1(function transpose(outerlist) {
    var i = 0;
    var result = [];
    while (i < outerlist.length) {
      var innerlist = outerlist[i];
      var j = 0;
      while (j < innerlist.length) {
        if (typeof result[j] === 'undefined') {
          result[j] = [];
        }
        result[j].push(innerlist[j]);
        j += 1;
      }
      i += 1;
    }
    return result;
  });
  module.exports = transpose;
  },{"./internal/_curry1":933}],1119:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var map = /*#__PURE__*/require('./map');

  var sequence = /*#__PURE__*/require('./sequence');

  /**
   * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
   * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
   * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
   * into an Applicative of Traversable.
   *
   * Dispatches to the `traverse` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
   * @param {Function} of
   * @param {Function} f
   * @param {*} traversable
   * @return {*}
   * @see R.sequence
   * @example
   *
   *      // Returns `Nothing` if the given divisor is `0`
   *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
   *
   *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
   *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
   */


  var traverse = /*#__PURE__*/_curry3(function traverse(of, f, traversable) {
    return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : sequence(of, map(f, traversable));
  });
  module.exports = traverse;
  },{"./internal/_curry3":935,"./map":1016,"./sequence":1089}],1120:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
  var zeroWidth = '\u200b';
  var hasProtoTrim = typeof String.prototype.trim === 'function';
  /**
   * Removes (strips) whitespace from both ends of the string.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to trim.
   * @return {String} Trimmed version of `str`.
   * @example
   *
   *      R.trim('   xyz  '); //=> 'xyz'
   *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
   */
  var _trim = !hasProtoTrim || /*#__PURE__*/ws.trim() || ! /*#__PURE__*/zeroWidth.trim() ? function trim(str) {
    var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
    var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
    return str.replace(beginRx, '').replace(endRx, '');
  } : function trim(str) {
    return str.trim();
  };
  var trim = /*#__PURE__*/_curry1(_trim);
  module.exports = trim;
  },{"./internal/_curry1":933}],1121:[function(require,module,exports){
  var _arity = /*#__PURE__*/require('./internal/_arity');

  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
   * function evaluates the `tryer`; if it does not throw, it simply returns the
   * result. If the `tryer` *does* throw, the returned function evaluates the
   * `catcher` function and returns its result. Note that for effective
   * composition with this function, both the `tryer` and `catcher` functions
   * must return the same type of results.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
   * @param {Function} tryer The function that may throw.
   * @param {Function} catcher The function that will be evaluated if `tryer` throws.
   * @return {Function} A new function that will catch exceptions and send then to the catcher.
   * @example
   *
   *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
   *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
   */


  var tryCatch = /*#__PURE__*/_curry2(function _tryCatch(tryer, catcher) {
    return _arity(tryer.length, function () {
      try {
        return tryer.apply(this, arguments);
      } catch (e) {
        return catcher.apply(this, _concat([e], arguments));
      }
    });
  });
  module.exports = tryCatch;
  },{"./internal/_arity":922,"./internal/_concat":929,"./internal/_curry2":934}],1122:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Gives a single-word string description of the (native) type of a value,
   * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
   * attempt to distinguish user Object types any further, reporting them all as
   * 'Object'.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Type
   * @sig (* -> {*}) -> String
   * @param {*} val The value to test
   * @return {String}
   * @example
   *
   *      R.type({}); //=> "Object"
   *      R.type(1); //=> "Number"
   *      R.type(false); //=> "Boolean"
   *      R.type('s'); //=> "String"
   *      R.type(null); //=> "Null"
   *      R.type([]); //=> "Array"
   *      R.type(/[A-z]/); //=> "RegExp"
   *      R.type(() => {}); //=> "Function"
   *      R.type(undefined); //=> "Undefined"
   */


  var type = /*#__PURE__*/_curry1(function type(val) {
    return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
  });
  module.exports = type;
  },{"./internal/_curry1":933}],1123:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Takes a function `fn`, which takes a single array argument, and returns a
   * function which:
   *
   *   - takes any number of positional arguments;
   *   - passes these arguments to `fn` as an array; and
   *   - returns the result.
   *
   * In other words, `R.unapply` derives a variadic function from a function which
   * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Function
   * @sig ([*...] -> a) -> (*... -> a)
   * @param {Function} fn
   * @return {Function}
   * @see R.apply
   * @example
   *
   *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
   * @symb R.unapply(f)(a, b) = f([a, b])
   */


  var unapply = /*#__PURE__*/_curry1(function unapply(fn) {
    return function () {
      return fn(Array.prototype.slice.call(arguments, 0));
    };
  });
  module.exports = unapply;
  },{"./internal/_curry1":933}],1124:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var nAry = /*#__PURE__*/require('./nAry');

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 1 parameter. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (* -> b) -> (a -> b)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 1.
   * @see R.binary, R.nAry
   * @example
   *
   *      var takesTwoArgs = function(a, b) {
   *        return [a, b];
   *      };
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      var takesOneArg = R.unary(takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only 1 argument is passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.unary(f)(a, b, c) = f(a)
   */


  var unary = /*#__PURE__*/_curry1(function unary(fn) {
    return nAry(1, fn);
  });
  module.exports = unary;
  },{"./internal/_curry1":933,"./nAry":1040}],1125:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var curryN = /*#__PURE__*/require('./curryN');

  /**
   * Returns a function of arity `n` from a (manually) curried function.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Function
   * @sig Number -> (a -> b) -> (a -> c)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to uncurry.
   * @return {Function} A new function.
   * @see R.curry
   * @example
   *
   *      var addFour = a => b => c => d => a + b + c + d;
   *
   *      var uncurriedAddFour = R.uncurryN(4, addFour);
   *      uncurriedAddFour(1, 2, 3, 4); //=> 10
   */


  var uncurryN = /*#__PURE__*/_curry2(function uncurryN(depth, fn) {
    return curryN(depth, function () {
      var currentDepth = 1;
      var value = fn;
      var idx = 0;
      var endIdx;
      while (currentDepth <= depth && typeof value === 'function') {
        endIdx = currentDepth === depth ? arguments.length : idx + value.length;
        value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
        currentDepth += 1;
        idx = endIdx;
      }
      return value;
    });
  });
  module.exports = uncurryN;
  },{"./curryN":870,"./internal/_curry2":934}],1126:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Builds a list from a seed value. Accepts an iterator function, which returns
   * either false to stop iteration or an array of length 2 containing the value
   * to add to the resulting list and the seed to be used in the next call to the
   * iterator function.
   *
   * The iterator function receives one argument: *(seed)*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig (a -> [b]) -> * -> [b]
   * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
   *        either false to quit iteration or an array of length two to proceed. The element
   *        at index 0 of this array will be added to the resulting array, and the element
   *        at index 1 will be passed to the next call to `fn`.
   * @param {*} seed The seed value.
   * @return {Array} The final list.
   * @example
   *
   *      var f = n => n > 50 ? false : [-n, n + 10];
   *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
   * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
   */


  var unfold = /*#__PURE__*/_curry2(function unfold(fn, seed) {
    var pair = fn(seed);
    var result = [];
    while (pair && pair.length) {
      result[result.length] = pair[0];
      pair = fn(pair[1]);
    }
    return result;
  });
  module.exports = unfold;
  },{"./internal/_curry2":934}],1127:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var compose = /*#__PURE__*/require('./compose');

  var uniq = /*#__PURE__*/require('./uniq');

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @example
   *
   *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
   */


  var union = /*#__PURE__*/_curry2( /*#__PURE__*/compose(uniq, _concat));
  module.exports = union;
  },{"./compose":859,"./internal/_concat":929,"./internal/_curry2":934,"./uniq":1129}],1128:[function(require,module,exports){
  var _concat = /*#__PURE__*/require('./internal/_concat');

  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var uniqWith = /*#__PURE__*/require('./uniqWith');

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list. Duplication is determined according to the value returned by
   * applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @see R.union
   * @example
   *
   *      var l1 = [{a: 1}, {a: 2}];
   *      var l2 = [{a: 1}, {a: 4}];
   *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
   */


  var unionWith = /*#__PURE__*/_curry3(function unionWith(pred, list1, list2) {
    return uniqWith(pred, _concat(list1, list2));
  });
  module.exports = unionWith;
  },{"./internal/_concat":929,"./internal/_curry3":935,"./uniqWith":1131}],1129:[function(require,module,exports){
  var identity = /*#__PURE__*/require('./identity');

  var uniqBy = /*#__PURE__*/require('./uniqBy');

  /**
   * Returns a new list containing only one copy of each element in the original
   * list. [`R.equals`](#equals) is used to determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
   *      R.uniq([1, '1']);     //=> [1, '1']
   *      R.uniq([[42], [42]]); //=> [[42]]
   */


  var uniq = /*#__PURE__*/uniqBy(identity);
  module.exports = uniq;
  },{"./identity":910,"./uniqBy":1130}],1130:[function(require,module,exports){
  var _Set = /*#__PURE__*/require('./internal/_Set');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied function to
   * each list element. Prefers the first item if the supplied function produces
   * the same value on two items. [`R.equals`](#equals) is used for comparison.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> b) -> [a] -> [a]
   * @param {Function} fn A function used to produce a value to use during comparisons.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
   */


  var uniqBy = /*#__PURE__*/_curry2(function uniqBy(fn, list) {
    var set = new _Set();
    var result = [];
    var idx = 0;
    var appliedItem, item;

    while (idx < list.length) {
      item = list[idx];
      appliedItem = fn(item);
      if (set.add(appliedItem)) {
        result.push(item);
      }
      idx += 1;
    }
    return result;
  });
  module.exports = uniqBy;
  },{"./internal/_Set":920,"./internal/_curry2":934}],1131:[function(require,module,exports){
  var _containsWith = /*#__PURE__*/require('./internal/_containsWith');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied predicate to
   * two list elements. Prefers the first item if two items compare equal based
   * on the predicate.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category List
   * @sig ((a, a) -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      var strEq = R.eqBy(String);
   *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
   *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
   *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
   *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
   */


  var uniqWith = /*#__PURE__*/_curry2(function uniqWith(pred, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var item;
    while (idx < len) {
      item = list[idx];
      if (!_containsWith(pred, item, result)) {
        result[result.length] = item;
      }
      idx += 1;
    }
    return result;
  });
  module.exports = uniqWith;
  },{"./internal/_containsWith":931,"./internal/_curry2":934}],1132:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is not satisfied, the function will return the result of
   * calling the `whenFalseFn` function with the same argument. If the predicate
   * is satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred        A predicate function
   * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
   *                               to a falsy value.
   * @param {*}        x           An object to test with the `pred` function and
   *                               pass to `whenFalseFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
   * @see R.ifElse, R.when
   * @example
   *
   *      let safeInc = R.unless(R.isNil, R.inc);
   *      safeInc(null); //=> null
   *      safeInc(1); //=> 2
   */


  var unless = /*#__PURE__*/_curry3(function unless(pred, whenFalseFn, x) {
    return pred(x) ? x : whenFalseFn(x);
  });
  module.exports = unless;
  },{"./internal/_curry3":935}],1133:[function(require,module,exports){
  var _identity = /*#__PURE__*/require('./internal/_identity');

  var chain = /*#__PURE__*/require('./chain');

  /**
   * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
   * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain c => c (c a) -> c a
   * @param {*} list
   * @return {*}
   * @see R.flatten, R.chain
   * @example
   *
   *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
   *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
   */


  var unnest = /*#__PURE__*/chain(_identity);
  module.exports = unnest;
  },{"./chain":854,"./internal/_identity":946}],1134:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Takes a predicate, a transformation function, and an initial value,
   * and returns a value of the same type as the initial value.
   * It does so by applying the transformation until the predicate is satisfied,
   * at which point it returns the satisfactory value.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred A predicate function
   * @param {Function} fn The iterator function
   * @param {*} init Initial value
   * @return {*} Final value that satisfies predicate
   * @example
   *
   *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
   */


  var until = /*#__PURE__*/_curry3(function until(pred, fn, init) {
    var val = init;
    while (!pred(val)) {
      val = fn(val);
    }
    return val;
  });
  module.exports = until;
  },{"./internal/_curry3":935}],1135:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  var adjust = /*#__PURE__*/require('./adjust');

  var always = /*#__PURE__*/require('./always');

  /**
   * Returns a new copy of the array with the element at the provided index
   * replaced with the given value.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} idx The index to update.
   * @param {*} x The value to exist at the given index of the returned array.
   * @param {Array|Arguments} list The source array-like object to be updated.
   * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
   * @see R.adjust
   * @example
   *
   *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
   *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
   * @symb R.update(-1, a, [b, c]) = [b, a]
   * @symb R.update(0, a, [b, c]) = [a, c]
   * @symb R.update(1, a, [b, c]) = [b, a]
   */


  var update = /*#__PURE__*/_curry3(function update(idx, x, list) {
    return adjust(always(x), idx, list);
  });
  module.exports = update;
  },{"./adjust":834,"./always":837,"./internal/_curry3":935}],1136:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var curryN = /*#__PURE__*/require('./curryN');

  /**
   * Accepts a function `fn` and a list of transformer functions and returns a
   * new curried function. When the new function is invoked, it calls the
   * function `fn` with parameters consisting of the result of calling each
   * supplied handler on successive arguments to the new function.
   *
   * If more arguments are passed to the returned function than transformer
   * functions, those arguments are passed directly to `fn` as additional
   * parameters. If you expect additional arguments that don't need to be
   * transformed, although you can ignore them, it's best to pass an identity
   * function so that the new function reports the correct arity.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} fn The function to wrap.
   * @param {Array} transformers A list of transformer functions
   * @return {Function} The wrapped function.
   * @see R.converge
   * @example
   *
   *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
   *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
   *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
   *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
   * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
   */


  var useWith = /*#__PURE__*/_curry2(function useWith(fn, transformers) {
    return curryN(transformers.length, function () {
      var args = [];
      var idx = 0;
      while (idx < transformers.length) {
        args.push(transformers[idx].call(this, arguments[idx]));
        idx += 1;
      }
      return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
    });
  });
  module.exports = useWith;
  },{"./curryN":870,"./internal/_curry2":934}],1137:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  var keys = /*#__PURE__*/require('./keys');

  /**
   * Returns a list of all the enumerable own properties of the supplied object.
   * Note that the order of the output array is not guaranteed across different
   * JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own properties.
   * @see R.valuesIn, R.keys
   * @example
   *
   *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
   */


  var values = /*#__PURE__*/_curry1(function values(obj) {
    var props = keys(obj);
    var len = props.length;
    var vals = [];
    var idx = 0;
    while (idx < len) {
      vals[idx] = obj[props[idx]];
      idx += 1;
    }
    return vals;
  });
  module.exports = values;
  },{"./internal/_curry1":933,"./keys":1003}],1138:[function(require,module,exports){
  var _curry1 = /*#__PURE__*/require('./internal/_curry1');

  /**
   * Returns a list of all the properties, including prototype properties, of the
   * supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own and prototype properties.
   * @see R.values, R.keysIn
   * @example
   *
   *      var F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      var f = new F();
   *      R.valuesIn(f); //=> ['X', 'Y']
   */


  var valuesIn = /*#__PURE__*/_curry1(function valuesIn(obj) {
    var prop;
    var vs = [];
    for (prop in obj) {
      vs[vs.length] = obj[prop];
    }
    return vs;
  });
  module.exports = valuesIn;
  },{"./internal/_curry1":933}],1139:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  // `Const` is a functor that effectively ignores the function given to `map`.


  var Const = function (x) {
    return { value: x, 'fantasy-land/map': function () {
        return this;
      } };
  };

  /**
   * Returns a "view" of the given data structure, determined by the given lens.
   * The lens's focus determines which portion of the data structure is visible.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> s -> a
   * @param {Lens} lens
   * @param {*} x
   * @return {*}
   * @see R.prop, R.lensIndex, R.lensProp
   * @example
   *
   *      var xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});  //=> 1
   *      R.view(xLens, {x: 4, y: 2});  //=> 4
   */
  var view = /*#__PURE__*/_curry2(function view(lens, x) {
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    return lens(Const)(x).value;
  });
  module.exports = view;
  },{"./internal/_curry2":934}],1140:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is satisfied, the function will return the result of calling
   * the `whenTrueFn` function with the same argument. If the predicate is not
   * satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred       A predicate function
   * @param {Function} whenTrueFn A function to invoke when the `condition`
   *                              evaluates to a truthy value.
   * @param {*}        x          An object to test with the `pred` function and
   *                              pass to `whenTrueFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
   * @see R.ifElse, R.unless
   * @example
   *
   *      // truncate :: String -> String
   *      var truncate = R.when(
   *        R.propSatisfies(R.gt(R.__, 10), 'length'),
   *        R.pipe(R.take(10), R.append('…'), R.join(''))
   *      );
   *      truncate('12345');         //=> '12345'
   *      truncate('0123456789ABC'); //=> '0123456789…'
   */


  var when = /*#__PURE__*/_curry3(function when(pred, whenTrueFn, x) {
    return pred(x) ? whenTrueFn(x) : x;
  });
  module.exports = when;
  },{"./internal/_curry3":935}],1141:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var _has = /*#__PURE__*/require('./internal/_has');

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec. Each of the spec's own properties must be a predicate function.
   * Each predicate is applied to the value of the corresponding property of the
   * test object. `where` returns true if all the predicates return true, false
   * otherwise.
   *
   * `where` is well suited to declaratively expressing constraints for other
   * functions such as [`filter`](#filter) and [`find`](#find).
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Object
   * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propSatisfies, R.whereEq
   * @example
   *
   *      // pred :: Object -> Boolean
   *      var pred = R.where({
   *        a: R.equals('foo'),
   *        b: R.complement(R.equals('bar')),
   *        x: R.gt(R.__, 10),
   *        y: R.lt(R.__, 20)
   *      });
   *
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
   *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
   */


  var where = /*#__PURE__*/_curry2(function where(spec, testObj) {
    for (var prop in spec) {
      if (_has(prop, spec) && !spec[prop](testObj[prop])) {
        return false;
      }
    }
    return true;
  });
  module.exports = where;
  },{"./internal/_curry2":934,"./internal/_has":945}],1142:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var equals = /*#__PURE__*/require('./equals');

  var map = /*#__PURE__*/require('./map');

  var where = /*#__PURE__*/require('./where');

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec, false otherwise. An object satisfies the spec if, for each of the
   * spec's own properties, accessing that property of the object gives the same
   * value (in [`R.equals`](#equals) terms) as accessing that property of the
   * spec.
   *
   * `whereEq` is a specialization of [`where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @sig {String: *} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propEq, R.where
   * @example
   *
   *      // pred :: Object -> Boolean
   *      var pred = R.whereEq({a: 1, b: 2});
   *
   *      pred({a: 1});              //=> false
   *      pred({a: 1, b: 2});        //=> true
   *      pred({a: 1, b: 2, c: 3});  //=> true
   *      pred({a: 1, b: 1});        //=> false
   */


  var whereEq = /*#__PURE__*/_curry2(function whereEq(spec, testObj) {
    return where(map(equals, spec), testObj);
  });
  module.exports = whereEq;
  },{"./equals":890,"./internal/_curry2":934,"./map":1016,"./where":1141}],1143:[function(require,module,exports){
  var _contains = /*#__PURE__*/require('./internal/_contains');

  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  var flip = /*#__PURE__*/require('./flip');

  var reject = /*#__PURE__*/require('./reject');

  /**
   * Returns a new list without values in the first argument.
   * [`R.equals`](#equals) is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @param {Array} list1 The values to be removed from `list2`.
   * @param {Array} list2 The array to remove values from.
   * @return {Array} The new array without values in `list1`.
   * @see R.transduce, R.difference
   * @example
   *
   *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
   */


  var without = /*#__PURE__*/_curry2(function (xs, list) {
    return reject(flip(_contains)(xs), list);
  });
  module.exports = without;
  },{"./flip":898,"./internal/_contains":930,"./internal/_curry2":934,"./reject":1083}],1144:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Creates a new list out of the two supplied by creating each possible pair
   * from the lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The list made by combining each possible pair from
   *         `as` and `bs` into pairs (`[a, b]`).
   * @example
   *
   *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
   * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
   */


  var xprod = /*#__PURE__*/_curry2(function xprod(a, b) {
    // = xprodWith(prepend); (takes about 3 times as long...)
    var idx = 0;
    var ilen = a.length;
    var j;
    var jlen = b.length;
    var result = [];
    while (idx < ilen) {
      j = 0;
      while (j < jlen) {
        result[result.length] = [a[idx], b[j]];
        j += 1;
      }
      idx += 1;
    }
    return result;
  });
  module.exports = xprod;
  },{"./internal/_curry2":934}],1145:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Creates a new list out of the two supplied by pairing up equally-positioned
   * items from both lists. The returned list is truncated to the length of the
   * shorter of the two input lists.
   * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
   * @example
   *
   *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
   */


  var zip = /*#__PURE__*/_curry2(function zip(a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);
    while (idx < len) {
      rv[idx] = [a[idx], b[idx]];
      idx += 1;
    }
    return rv;
  });
  module.exports = zip;
  },{"./internal/_curry2":934}],1146:[function(require,module,exports){
  var _curry2 = /*#__PURE__*/require('./internal/_curry2');

  /**
   * Creates a new object out of a list of keys and a list of values.
   * Key/value pairing is truncated to the length of the shorter of the two lists.
   * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [String] -> [*] -> {String: *}
   * @param {Array} keys The array that will be properties on the output object.
   * @param {Array} values The list of values on the output object.
   * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
   * @example
   *
   *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
   */


  var zipObj = /*#__PURE__*/_curry2(function zipObj(keys, values) {
    var idx = 0;
    var len = Math.min(keys.length, values.length);
    var out = {};
    while (idx < len) {
      out[keys[idx]] = values[idx];
      idx += 1;
    }
    return out;
  });
  module.exports = zipObj;
  },{"./internal/_curry2":934}],1147:[function(require,module,exports){
  var _curry3 = /*#__PURE__*/require('./internal/_curry3');

  /**
   * Creates a new list out of the two supplied by applying the function to each
   * equally-positioned pair in the lists. The returned list is truncated to the
   * length of the shorter of the two input lists.
   *
   * @function
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
   * @param {Function} fn The function used to combine the two elements into one value.
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
   *         using `fn`.
   * @example
   *
   *      var f = (x, y) => {
   *        // ...
   *      };
   *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
   *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
   * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
   */


  var zipWith = /*#__PURE__*/_curry3(function zipWith(fn, a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);
    while (idx < len) {
      rv[idx] = fn(a[idx], b[idx]);
      idx += 1;
    }
    return rv;
  });
  module.exports = zipWith;
  },{"./internal/_curry3":935}],1148:[function(require,module,exports){
  function RavenConfigError(message) {
    this.name = 'RavenConfigError';
    this.message = message;
  }
  RavenConfigError.prototype = new Error();
  RavenConfigError.prototype.constructor = RavenConfigError;

  module.exports = RavenConfigError;

  },{}],1149:[function(require,module,exports){
  var utils = require('./utils');

  var wrapMethod = function(console, level, callback) {
    var originalConsoleLevel = console[level];
    var originalConsole = console;

    if (!(level in console)) {
      return;
    }

    var sentryLevel = level === 'warn' ? 'warning' : level;

    console[level] = function() {
      var args = [].slice.call(arguments);

      var msg = utils.safeJoin(args, ' ');
      var data = {level: sentryLevel, logger: 'console', extra: {arguments: args}};

      if (level === 'assert') {
        if (args[0] === false) {
          // Default browsers message
          msg =
            'Assertion failed: ' + (utils.safeJoin(args.slice(1), ' ') || 'console.assert');
          data.extra.arguments = args.slice(1);
          callback && callback(msg, data);
        }
      } else {
        callback && callback(msg, data);
      }

      // this fails for some browsers. :(
      if (originalConsoleLevel) {
        // IE9 doesn't allow calling apply on console functions directly
        // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
        Function.prototype.apply.call(originalConsoleLevel, originalConsole, args);
      }
    };
  };

  module.exports = {
    wrapMethod: wrapMethod
  };

  },{"./utils":1152}],1152:[function(require,module,exports){
  (function (global){
  var _window =
    typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function isObject(what) {
    return typeof what === 'object' && what !== null;
  }

  // Yanked from https://git.io/vS8DV re-used under CC0
  // with some tiny modifications
  function isError(value) {
    switch ({}.toString.call(value)) {
      case '[object Error]':
        return true;
      case '[object Exception]':
        return true;
      case '[object DOMException]':
        return true;
      default:
        return value instanceof Error;
    }
  }

  function isErrorEvent(value) {
    return supportsErrorEvent() && {}.toString.call(value) === '[object ErrorEvent]';
  }

  function isUndefined(what) {
    return what === void 0;
  }

  function isFunction(what) {
    return typeof what === 'function';
  }

  function isPlainObject(what) {
    return Object.prototype.toString.call(what) === '[object Object]';
  }

  function isString(what) {
    return Object.prototype.toString.call(what) === '[object String]';
  }

  function isArray(what) {
    return Object.prototype.toString.call(what) === '[object Array]';
  }

  function isEmptyObject(what) {
    if (!isPlainObject(what)) return false;

    for (var _ in what) {
      if (what.hasOwnProperty(_)) {
        return false;
      }
    }
    return true;
  }

  function supportsErrorEvent() {
    try {
      new ErrorEvent(''); // eslint-disable-line no-new
      return true;
    } catch (e) {
      return false;
    }
  }

  function supportsFetch() {
    if (!('fetch' in _window)) return false;

    try {
      new Headers(); // eslint-disable-line no-new
      new Request(''); // eslint-disable-line no-new
      new Response(); // eslint-disable-line no-new
      return true;
    } catch (e) {
      return false;
    }
  }

  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
  // https://caniuse.com/#feat=referrer-policy
  // It doesn't. And it throw exception instead of ignoring this parameter...
  // REF: https://github.com/getsentry/raven-js/issues/1233
  function supportsReferrerPolicy() {
    if (!supportsFetch()) return false;

    try {
      // eslint-disable-next-line no-new
      new Request('pickleRick', {
        referrerPolicy: 'origin'
      });
      return true;
    } catch (e) {
      return false;
    }
  }

  function wrappedCallback(callback) {
    function dataCallback(data, original) {
      var normalizedData = callback(data) || data;
      if (original) {
        return original(normalizedData) || normalizedData;
      }
      return normalizedData;
    }

    return dataCallback;
  }

  function each(obj, callback) {
    var i, j;

    if (isUndefined(obj.length)) {
      for (i in obj) {
        if (hasKey(obj, i)) {
          callback.call(null, i, obj[i]);
        }
      }
    } else {
      j = obj.length;
      if (j) {
        for (i = 0; i < j; i++) {
          callback.call(null, i, obj[i]);
        }
      }
    }
  }

  function objectMerge(obj1, obj2) {
    if (!obj2) {
      return obj1;
    }
    each(obj2, function(key, value) {
      obj1[key] = value;
    });
    return obj1;
  }

  /**
   * This function is only used for react-native.
   * react-native freezes object that have already been sent over the
   * js bridge. We need this function in order to check if the object is frozen.
   * So it's ok that objectFrozen returns false if Object.isFrozen is not
   * supported because it's not relevant for other "platforms". See related issue:
   * https://github.com/getsentry/react-native-sentry/issues/57
   */
  function objectFrozen(obj) {
    if (!Object.isFrozen) {
      return false;
    }
    return Object.isFrozen(obj);
  }

  function truncate(str, max) {
    return !max || str.length <= max ? str : str.substr(0, max) + '\u2026';
  }

  /**
   * hasKey, a better form of hasOwnProperty
   * Example: hasKey(MainHostObject, property) === true/false
   *
   * @param {Object} host object to check property
   * @param {string} key to check
   */
  function hasKey(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
  }

  function joinRegExp(patterns) {
    // Combine an array of regular expressions and strings into one large regexp
    // Be mad.
    var sources = [],
      i = 0,
      len = patterns.length,
      pattern;

    for (; i < len; i++) {
      pattern = patterns[i];
      if (isString(pattern)) {
        // If it's a string, we need to escape it
        // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
        sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
      } else if (pattern && pattern.source) {
        // If it's a regexp already, we want to extract the source
        sources.push(pattern.source);
      }
      // Intentionally skip other cases
    }
    return new RegExp(sources.join('|'), 'i');
  }

  function urlencode(o) {
    var pairs = [];
    each(o, function(key, value) {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
    });
    return pairs.join('&');
  }

  // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
  // intentionally using regex and not <a/> href parsing trick because React Native and other
  // environments where DOM might not be available
  function parseUrl(url) {
    if (typeof url !== 'string') return {};
    var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

    // coerce to undefined values to empty string so we don't get 'undefined'
    var query = match[6] || '';
    var fragment = match[8] || '';
    return {
      protocol: match[2],
      host: match[4],
      path: match[5],
      relative: match[5] + query + fragment // everything minus origin
    };
  }
  function uuid4() {
    var crypto = _window.crypto || _window.msCrypto;

    if (!isUndefined(crypto) && crypto.getRandomValues) {
      // Use window.crypto API if available
      // eslint-disable-next-line no-undef
      var arr = new Uint16Array(8);
      crypto.getRandomValues(arr);

      // set 4 in byte 7
      arr[3] = (arr[3] & 0xfff) | 0x4000;
      // set 2 most significant bits of byte 9 to '10'
      arr[4] = (arr[4] & 0x3fff) | 0x8000;

      var pad = function(num) {
        var v = num.toString(16);
        while (v.length < 4) {
          v = '0' + v;
        }
        return v;
      };

      return (
        pad(arr[0]) +
        pad(arr[1]) +
        pad(arr[2]) +
        pad(arr[3]) +
        pad(arr[4]) +
        pad(arr[5]) +
        pad(arr[6]) +
        pad(arr[7])
      );
    } else {
      // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
      return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (Math.random() * 16) | 0,
          v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
    }
  }

  /**
   * Given a child DOM element, returns a query-selector statement describing that
   * and its ancestors
   * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
   * @param elem
   * @returns {string}
   */
  function htmlTreeAsString(elem) {
    /* eslint no-extra-parens:0*/
    var MAX_TRAVERSE_HEIGHT = 5,
      MAX_OUTPUT_LEN = 80,
      out = [],
      height = 0,
      len = 0,
      separator = ' > ',
      sepLength = separator.length,
      nextStr;

    while (elem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = htmlElementAsString(elem);
      // bail out if
      // - nextStr is the 'html' element
      // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
      //   (ignore this limit if we are on the first iteration)
      if (
        nextStr === 'html' ||
        (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)
      ) {
        break;
      }

      out.push(nextStr);

      len += nextStr.length;
      elem = elem.parentNode;
    }

    return out.reverse().join(separator);
  }

  /**
   * Returns a simple, query-selector representation of a DOM element
   * e.g. [HTMLElement] => input#foo.btn[name=baz]
   * @param HTMLElement
   * @returns {string}
   */
  function htmlElementAsString(elem) {
    var out = [],
      className,
      classes,
      key,
      attr,
      i;

    if (!elem || !elem.tagName) {
      return '';
    }

    out.push(elem.tagName.toLowerCase());
    if (elem.id) {
      out.push('#' + elem.id);
    }

    className = elem.className;
    if (className && isString(className)) {
      classes = className.split(/\s+/);
      for (i = 0; i < classes.length; i++) {
        out.push('.' + classes[i]);
      }
    }
    var attrWhitelist = ['type', 'name', 'title', 'alt'];
    for (i = 0; i < attrWhitelist.length; i++) {
      key = attrWhitelist[i];
      attr = elem.getAttribute(key);
      if (attr) {
        out.push('[' + key + '="' + attr + '"]');
      }
    }
    return out.join('');
  }

  /**
   * Returns true if either a OR b is truthy, but not both
   */
  function isOnlyOneTruthy(a, b) {
    return !!(!!a ^ !!b);
  }

  /**
   * Returns true if both parameters are undefined
   */
  function isBothUndefined(a, b) {
    return isUndefined(a) && isUndefined(b);
  }

  /**
   * Returns true if the two input exception interfaces have the same content
   */
  function isSameException(ex1, ex2) {
    if (isOnlyOneTruthy(ex1, ex2)) return false;

    ex1 = ex1.values[0];
    ex2 = ex2.values[0];

    if (ex1.type !== ex2.type || ex1.value !== ex2.value) return false;

    // in case both stacktraces are undefined, we can't decide so default to false
    if (isBothUndefined(ex1.stacktrace, ex2.stacktrace)) return false;

    return isSameStacktrace(ex1.stacktrace, ex2.stacktrace);
  }

  /**
   * Returns true if the two input stack trace interfaces have the same content
   */
  function isSameStacktrace(stack1, stack2) {
    if (isOnlyOneTruthy(stack1, stack2)) return false;

    var frames1 = stack1.frames;
    var frames2 = stack2.frames;

    // Exit early if frame count differs
    if (frames1.length !== frames2.length) return false;

    // Iterate through every frame; bail out if anything differs
    var a, b;
    for (var i = 0; i < frames1.length; i++) {
      a = frames1[i];
      b = frames2[i];
      if (
        a.filename !== b.filename ||
        a.lineno !== b.lineno ||
        a.colno !== b.colno ||
        a['function'] !== b['function']
      )
        return false;
    }
    return true;
  }

  /**
   * Polyfill a method
   * @param obj object e.g. `document`
   * @param name method name present on object e.g. `addEventListener`
   * @param replacement replacement function
   * @param track {optional} record instrumentation to an array
   */
  function fill(obj, name, replacement, track) {
    var orig = obj[name];
    obj[name] = replacement(orig);
    obj[name].__raven__ = true;
    obj[name].__orig__ = orig;
    if (track) {
      track.push([obj, name, orig]);
    }
  }

  /**
   * Join values in array
   * @param input array of values to be joined together
   * @param delimiter string to be placed in-between values
   * @returns {string}
   */
  function safeJoin(input, delimiter) {
    if (!isArray(input)) return '';

    var output = [];

    for (var i = 0; i < input.length; i++) {
      try {
        output.push(String(input[i]));
      } catch (e) {
        output.push('[value cannot be serialized]');
      }
    }

    return output.join(delimiter);
  }

  module.exports = {
    isObject: isObject,
    isError: isError,
    isErrorEvent: isErrorEvent,
    isUndefined: isUndefined,
    isFunction: isFunction,
    isPlainObject: isPlainObject,
    isString: isString,
    isArray: isArray,
    isEmptyObject: isEmptyObject,
    supportsErrorEvent: supportsErrorEvent,
    supportsFetch: supportsFetch,
    supportsReferrerPolicy: supportsReferrerPolicy,
    wrappedCallback: wrappedCallback,
    each: each,
    objectMerge: objectMerge,
    truncate: truncate,
    objectFrozen: objectFrozen,
    hasKey: hasKey,
    joinRegExp: joinRegExp,
    urlencode: urlencode,
    uuid4: uuid4,
    htmlTreeAsString: htmlTreeAsString,
    htmlElementAsString: htmlElementAsString,
    isSameException: isSameException,
    isSameStacktrace: isSameStacktrace,
    parseUrl: parseUrl,
    fill: fill,
    safeJoin: safeJoin
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],1153:[function(require,module,exports){
  (function (global){
  var utils = require('../../src/utils');

  /*
   TraceKit - Cross brower stack traces

   This was originally forked from github.com/occ/TraceKit, but has since been
   largely re-written and is now maintained as part of raven-js.  Tests for
   this are in test/vendor.

   MIT license
  */

  var TraceKit = {
    collectWindowErrors: true,
    debug: false
  };

  // This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
  var _window =
    typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  // global reference to slice
  var _slice = [].slice;
  var UNKNOWN_FUNCTION = '?';

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
  var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

  function getLocationHref() {
    if (typeof document === 'undefined' || document.location == null) return '';

    return document.location.href;
  }

  /**
   * TraceKit.report: cross-browser processing of unhandled exceptions
   *
   * Syntax:
   *   TraceKit.report.subscribe(function(stackInfo) { ... })
   *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
   *   TraceKit.report(exception)
   *   try { ...code... } catch(ex) { TraceKit.report(ex); }
   *
   * Supports:
   *   - Firefox: full stack trace with line numbers, plus column number
   *              on top frame; column number is not guaranteed
   *   - Opera:   full stack trace with line and column numbers
   *   - Chrome:  full stack trace with line and column numbers
   *   - Safari:  line and column number for the top frame only; some frames
   *              may be missing, and column number is not guaranteed
   *   - IE:      line and column number for the top frame only; some frames
   *              may be missing, and column number is not guaranteed
   *
   * In theory, TraceKit should work on all of the following versions:
   *   - IE5.5+ (only 8.0 tested)
   *   - Firefox 0.9+ (only 3.5+ tested)
   *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
   *     Exceptions Have Stacktrace to be enabled in opera:config)
   *   - Safari 3+ (only 4+ tested)
   *   - Chrome 1+ (only 5+ tested)
   *   - Konqueror 3.5+ (untested)
   *
   * Requires TraceKit.computeStackTrace.
   *
   * Tries to catch all unhandled exceptions and report them to the
   * subscribed handlers. Please note that TraceKit.report will rethrow the
   * exception. This is REQUIRED in order to get a useful stack trace in IE.
   * If the exception does not reach the top of the browser, you will only
   * get a stack trace from the point where TraceKit.report was called.
   *
   * Handlers receive a stackInfo object as described in the
   * TraceKit.computeStackTrace docs.
   */
  TraceKit.report = (function reportModuleWrapper() {
    var handlers = [],
      lastArgs = null,
      lastException = null,
      lastExceptionStack = null;

    /**
     * Add a crash handler.
     * @param {Function} handler
     */
    function subscribe(handler) {
      installGlobalHandler();
      handlers.push(handler);
    }

    /**
     * Remove a crash handler.
     * @param {Function} handler
     */
    function unsubscribe(handler) {
      for (var i = handlers.length - 1; i >= 0; --i) {
        if (handlers[i] === handler) {
          handlers.splice(i, 1);
        }
      }
    }

    /**
     * Remove all crash handlers.
     */
    function unsubscribeAll() {
      uninstallGlobalHandler();
      handlers = [];
    }

    /**
     * Dispatch stack information to all handlers.
     * @param {Object.<string, *>} stack
     */
    function notifyHandlers(stack, isWindowError) {
      var exception = null;
      if (isWindowError && !TraceKit.collectWindowErrors) {
        return;
      }
      for (var i in handlers) {
        if (handlers.hasOwnProperty(i)) {
          try {
            handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
          } catch (inner) {
            exception = inner;
          }
        }
      }

      if (exception) {
        throw exception;
      }
    }

    var _oldOnerrorHandler, _onErrorHandlerInstalled;

    /**
     * Ensures all global unhandled exceptions are recorded.
     * Supported by Gecko and IE.
     * @param {string} msg Error message.
     * @param {string} url URL of script that generated the exception.
     * @param {(number|string)} lineNo The line number at which the error
     * occurred.
     * @param {?(number|string)} colNo The column number at which the error
     * occurred.
     * @param {?Error} ex The actual Error object.
     */
    function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {
      var stack = null;
      // If 'ex' is ErrorEvent, get real Error from inside
      var exception = utils.isErrorEvent(ex) ? ex.error : ex;
      // If 'msg' is ErrorEvent, get real message from inside
      var message = utils.isErrorEvent(msg) ? msg.message : msg;

      if (lastExceptionStack) {
        TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(
          lastExceptionStack,
          url,
          lineNo,
          message
        );
        processLastException();
      } else if (exception && utils.isError(exception)) {
        // non-string `exception` arg; attempt to extract stack trace

        // New chrome and blink send along a real error object
        // Let's just report that like a normal error.
        // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
        stack = TraceKit.computeStackTrace(exception);
        notifyHandlers(stack, true);
      } else {
        var location = {
          url: url,
          line: lineNo,
          column: colNo
        };

        var name = undefined;
        var groups;

        if ({}.toString.call(message) === '[object String]') {
          var groups = message.match(ERROR_TYPES_RE);
          if (groups) {
            name = groups[1];
            message = groups[2];
          }
        }

        location.func = UNKNOWN_FUNCTION;

        stack = {
          name: name,
          message: message,
          url: getLocationHref(),
          stack: [location]
        };
        notifyHandlers(stack, true);
      }

      if (_oldOnerrorHandler) {
        return _oldOnerrorHandler.apply(this, arguments);
      }

      return false;
    }

    function installGlobalHandler() {
      if (_onErrorHandlerInstalled) {
        return;
      }
      _oldOnerrorHandler = _window.onerror;
      _window.onerror = traceKitWindowOnError;
      _onErrorHandlerInstalled = true;
    }

    function uninstallGlobalHandler() {
      if (!_onErrorHandlerInstalled) {
        return;
      }
      _window.onerror = _oldOnerrorHandler;
      _onErrorHandlerInstalled = false;
      _oldOnerrorHandler = undefined;
    }

    function processLastException() {
      var _lastExceptionStack = lastExceptionStack,
        _lastArgs = lastArgs;
      lastArgs = null;
      lastExceptionStack = null;
      lastException = null;
      notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
    }

    /**
     * Reports an unhandled Error to TraceKit.
     * @param {Error} ex
     * @param {?boolean} rethrow If false, do not re-throw the exception.
     * Only used for window.onerror to not cause an infinite loop of
     * rethrowing.
     */
    function report(ex, rethrow) {
      var args = _slice.call(arguments, 1);
      if (lastExceptionStack) {
        if (lastException === ex) {
          return; // already caught by an inner catch block, ignore
        } else {
          processLastException();
        }
      }

      var stack = TraceKit.computeStackTrace(ex);
      lastExceptionStack = stack;
      lastException = ex;
      lastArgs = args;

      // If the stack trace is incomplete, wait for 2 seconds for
      // slow slow IE to see if onerror occurs or not before reporting
      // this exception; otherwise, we will end up with an incomplete
      // stack trace
      setTimeout(function() {
        if (lastException === ex) {
          processLastException();
        }
      }, stack.incomplete ? 2000 : 0);

      if (rethrow !== false) {
        throw ex; // re-throw to propagate to the top level (and cause window.onerror)
      }
    }

    report.subscribe = subscribe;
    report.unsubscribe = unsubscribe;
    report.uninstall = unsubscribeAll;
    return report;
  })();

  /**
   * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
   *
   * Syntax:
   *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
   * Returns:
   *   s.name              - exception name
   *   s.message           - exception message
   *   s.stack[i].url      - JavaScript or HTML file URL
   *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
   *   s.stack[i].args     - arguments passed to the function, if known
   *   s.stack[i].line     - line number, if known
   *   s.stack[i].column   - column number, if known
   *
   * Supports:
   *   - Firefox:  full stack trace with line numbers and unreliable column
   *               number on top frame
   *   - Opera 10: full stack trace with line and column numbers
   *   - Opera 9-: full stack trace with line numbers
   *   - Chrome:   full stack trace with line and column numbers
   *   - Safari:   line and column number for the topmost stacktrace element
   *               only
   *   - IE:       no line numbers whatsoever
   *
   * Tries to guess names of anonymous functions by looking for assignments
   * in the source code. In IE and Safari, we have to guess source file names
   * by searching for function bodies inside all page scripts. This will not
   * work for scripts that are loaded cross-domain.
   * Here be dragons: some function names may be guessed incorrectly, and
   * duplicate functions may be mismatched.
   *
   * TraceKit.computeStackTrace should only be used for tracing purposes.
   * Logging of unhandled exceptions should be done with TraceKit.report,
   * which builds on top of TraceKit.computeStackTrace and provides better
   * IE support by utilizing the window.onerror event to retrieve information
   * about the top of the stack.
   *
   * Note: In IE and Safari, no stack trace is recorded on the Error object,
   * so computeStackTrace instead walks its *own* chain of callers.
   * This means that:
   *  * in Safari, some methods may be missing from the stack trace;
   *  * in IE, the topmost function in the stack trace will always be the
   *    caller of computeStackTrace.
   *
   * This is okay for tracing (because you are likely to be calling
   * computeStackTrace from the function you want to be the topmost element
   * of the stack trace anyway), but not okay for logging unhandled
   * exceptions (because your catch block will likely be far away from the
   * inner function that actually caused the exception).
   *
   */
  TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
    // Contents of Exception in various browsers.
    //
    // SAFARI:
    // ex.message = Can't find variable: qq
    // ex.line = 59
    // ex.sourceId = 580238192
    // ex.sourceURL = http://...
    // ex.expressionBeginOffset = 96
    // ex.expressionCaretOffset = 98
    // ex.expressionEndOffset = 98
    // ex.name = ReferenceError
    //
    // FIREFOX:
    // ex.message = qq is not defined
    // ex.fileName = http://...
    // ex.lineNumber = 59
    // ex.columnNumber = 69
    // ex.stack = ...stack trace... (see the example below)
    // ex.name = ReferenceError
    //
    // CHROME:
    // ex.message = qq is not defined
    // ex.name = ReferenceError
    // ex.type = not_defined
    // ex.arguments = ['aa']
    // ex.stack = ...stack trace...
    //
    // INTERNET EXPLORER:
    // ex.message = ...
    // ex.name = ReferenceError
    //
    // OPERA:
    // ex.message = ...message... (see the example below)
    // ex.name = ReferenceError
    // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
    // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

    /**
     * Computes stack trace information from the stack property.
     * Chrome and Gecko use this property.
     * @param {Error} ex
     * @return {?Object.<string, *>} Stack trace information.
     */
    function computeStackTraceFromStackProp(ex) {
      if (typeof ex.stack === 'undefined' || !ex.stack) return;

      var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
      var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
      // NOTE: blob urls are now supposed to always have an origin, therefore it's format
      // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\/` as well
      var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\/.*?|\[native code\]|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
      // Used to additionally parse URL/line/column from eval frames
      var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
      var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
      var lines = ex.stack.split('\n');
      var stack = [];
      var submatch;
      var parts;
      var element;
      var reference = /^(.*) is undefined$/.exec(ex.message);

      for (var i = 0, j = lines.length; i < j; ++i) {
        if ((parts = chrome.exec(lines[i]))) {
          var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
          var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
          if (isEval && (submatch = chromeEval.exec(parts[2]))) {
            // throw out eval line/column and use top-most line/column number
            parts[2] = submatch[1]; // url
            parts[3] = submatch[2]; // line
            parts[4] = submatch[3]; // column
          }
          element = {
            url: !isNative ? parts[2] : null,
            func: parts[1] || UNKNOWN_FUNCTION,
            args: isNative ? [parts[2]] : [],
            line: parts[3] ? +parts[3] : null,
            column: parts[4] ? +parts[4] : null
          };
        } else if ((parts = winjs.exec(lines[i]))) {
          element = {
            url: parts[2],
            func: parts[1] || UNKNOWN_FUNCTION,
            args: [],
            line: +parts[3],
            column: parts[4] ? +parts[4] : null
          };
        } else if ((parts = gecko.exec(lines[i]))) {
          var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
          if (isEval && (submatch = geckoEval.exec(parts[3]))) {
            // throw out eval line/column and use top-most line number
            parts[3] = submatch[1];
            parts[4] = submatch[2];
            parts[5] = null; // no column when eval
          } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {
            // FireFox uses this awesome columnNumber property for its top frame
            // Also note, Firefox's column number is 0-based and everything else expects 1-based,
            // so adding 1
            // NOTE: this hack doesn't work if top-most frame is eval
            stack[0].column = ex.columnNumber + 1;
          }
          element = {
            url: parts[3],
            func: parts[1] || UNKNOWN_FUNCTION,
            args: parts[2] ? parts[2].split(',') : [],
            line: parts[4] ? +parts[4] : null,
            column: parts[5] ? +parts[5] : null
          };
        } else {
          continue;
        }

        if (!element.func && element.line) {
          element.func = UNKNOWN_FUNCTION;
        }

        stack.push(element);
      }

      if (!stack.length) {
        return null;
      }

      return {
        name: ex.name,
        message: ex.message,
        url: getLocationHref(),
        stack: stack
      };
    }

    /**
     * Adds information about the first frame to incomplete stack traces.
     * Safari and IE require this to get complete data on the first frame.
     * @param {Object.<string, *>} stackInfo Stack trace information from
     * one of the compute* methods.
     * @param {string} url The URL of the script that caused an error.
     * @param {(number|string)} lineNo The line number of the script that
     * caused an error.
     * @param {string=} message The error generated by the browser, which
     * hopefully contains the name of the object that caused the error.
     * @return {boolean} Whether or not the stack information was
     * augmented.
     */
    function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
      var initial = {
        url: url,
        line: lineNo
      };

      if (initial.url && initial.line) {
        stackInfo.incomplete = false;

        if (!initial.func) {
          initial.func = UNKNOWN_FUNCTION;
        }

        if (stackInfo.stack.length > 0) {
          if (stackInfo.stack[0].url === initial.url) {
            if (stackInfo.stack[0].line === initial.line) {
              return false; // already in stack trace
            } else if (
              !stackInfo.stack[0].line &&
              stackInfo.stack[0].func === initial.func
            ) {
              stackInfo.stack[0].line = initial.line;
              return false;
            }
          }
        }

        stackInfo.stack.unshift(initial);
        stackInfo.partial = true;
        return true;
      } else {
        stackInfo.incomplete = true;
      }

      return false;
    }

    /**
     * Computes stack trace information by walking the arguments.caller
     * chain at the time the exception occurred. This will cause earlier
     * frames to be missed but is the only way to get any stack trace in
     * Safari and IE. The top frame is restored by
     * {@link augmentStackTraceWithInitialElement}.
     * @param {Error} ex
     * @return {?Object.<string, *>} Stack trace information.
     */
    function computeStackTraceByWalkingCallerChain(ex, depth) {
      var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
        stack = [],
        funcs = {},
        recursion = false,
        parts,
        item,
        source;

      for (
        var curr = computeStackTraceByWalkingCallerChain.caller;
        curr && !recursion;
        curr = curr.caller
      ) {
        if (curr === computeStackTrace || curr === TraceKit.report) {
          // console.log('skipping internal function');
          continue;
        }

        item = {
          url: null,
          func: UNKNOWN_FUNCTION,
          line: null,
          column: null
        };

        if (curr.name) {
          item.func = curr.name;
        } else if ((parts = functionName.exec(curr.toString()))) {
          item.func = parts[1];
        }

        if (typeof item.func === 'undefined') {
          try {
            item.func = parts.input.substring(0, parts.input.indexOf('{'));
          } catch (e) {}
        }

        if (funcs['' + curr]) {
          recursion = true;
        } else {
          funcs['' + curr] = true;
        }

        stack.push(item);
      }

      if (depth) {
        // console.log('depth is ' + depth);
        // console.log('stack is ' + stack.length);
        stack.splice(0, depth);
      }

      var result = {
        name: ex.name,
        message: ex.message,
        url: getLocationHref(),
        stack: stack
      };
      augmentStackTraceWithInitialElement(
        result,
        ex.sourceURL || ex.fileName,
        ex.line || ex.lineNumber,
        ex.message || ex.description
      );
      return result;
    }

    /**
     * Computes a stack trace for an exception.
     * @param {Error} ex
     * @param {(string|number)=} depth
     */
    function computeStackTrace(ex, depth) {
      var stack = null;
      depth = depth == null ? 0 : +depth;

      try {
        stack = computeStackTraceFromStackProp(ex);
        if (stack) {
          return stack;
        }
      } catch (e) {
        if (TraceKit.debug) {
          throw e;
        }
      }

      try {
        stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
        if (stack) {
          return stack;
        }
      } catch (e) {
        if (TraceKit.debug) {
          throw e;
        }
      }
      return {
        name: ex.name,
        message: ex.message,
        url: getLocationHref()
      };
    }

    computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
    computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

    return computeStackTrace;
  })();

  module.exports = TraceKit;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"../../src/utils":1152}],1154:[function(require,module,exports){
  /*
   json-stringify-safe
   Like JSON.stringify, but doesn't throw on circular references.

   Originally forked from https://github.com/isaacs/json-stringify-safe
   version 5.0.1 on 3/8/2017 and modified to handle Errors serialization
   and IE8 compatibility. Tests for this are in test/vendor.

   ISC license: https://github.com/isaacs/json-stringify-safe/blob/master/LICENSE
  */

  exports = module.exports = stringify;
  exports.getSerialize = serializer;

  function indexOf(haystack, needle) {
    for (var i = 0; i < haystack.length; ++i) {
      if (haystack[i] === needle) return i;
    }
    return -1;
  }

  function stringify(obj, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
  }

  // https://github.com/ftlabs/js-abbreviate/blob/fa709e5f139e7770a71827b1893f22418097fbda/index.js#L95-L106
  function stringifyError(value) {
    var err = {
      // These properties are implemented as magical getters and don't show up in for in
      stack: value.stack,
      message: value.message,
      name: value.name
    };

    for (var i in value) {
      if (Object.prototype.hasOwnProperty.call(value, i)) {
        err[i] = value[i];
      }
    }

    return err;
  }

  function serializer(replacer, cycleReplacer) {
    var stack = [];
    var keys = [];

    if (cycleReplacer == null) {
      cycleReplacer = function(key, value) {
        if (stack[0] === value) {
          return '[Circular ~]';
        }
        return '[Circular ~.' + keys.slice(0, indexOf(stack, value)).join('.') + ']';
      };
    }

    return function(key, value) {
      if (stack.length > 0) {
        var thisPos = indexOf(stack, this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);

        if (~indexOf(stack, value)) {
          value = cycleReplacer.call(this, key, value);
        }
      } else {
        stack.push(value);
      }

      return replacer == null
        ? value instanceof Error ? stringifyError(value) : value
        : replacer.call(this, key, value);
    };
  }

  },{}],1155:[function(require,module,exports){
  /** @license React v16.2.0
   * react-dom.development.js
   *
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';



  if ("production" !== "production") {
    (function() {
  'use strict';

  var React = require('react');
  var invariant = require('fbjs/lib/invariant');
  var warning = require('fbjs/lib/warning');
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  var _assign = require('object-assign');
  var emptyFunction = require('fbjs/lib/emptyFunction');
  var EventListener = require('fbjs/lib/EventListener');
  var getActiveElement = require('fbjs/lib/getActiveElement');
  var shallowEqual = require('fbjs/lib/shallowEqual');
  var containsNode = require('fbjs/lib/containsNode');
  var focusNode = require('fbjs/lib/focusNode');
  var emptyObject = require('fbjs/lib/emptyObject');
  var checkPropTypes = require('prop-types/checkPropTypes');
  var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
  var camelizeStyleName = require('fbjs/lib/camelizeStyleName');

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  !React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

  // These attributes should be all lowercase to allow for
  // case insensitive checks
  var RESERVED_PROPS = {
    children: true,
    dangerouslySetInnerHTML: true,
    defaultValue: true,
    defaultChecked: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    suppressHydrationWarning: true,
    style: true
  };

  function checkMask(value, bitmask) {
    return (value & bitmask) === bitmask;
  }

  var DOMPropertyInjection = {
    /**
     * Mapping from normalized, camelcased property names to a configuration that
     * specifies how the associated DOM property should be accessed or rendered.
     */
    MUST_USE_PROPERTY: 0x1,
    HAS_BOOLEAN_VALUE: 0x4,
    HAS_NUMERIC_VALUE: 0x8,
    HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
    HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
    HAS_STRING_BOOLEAN_VALUE: 0x40,

    /**
     * Inject some specialized knowledge about the DOM. This takes a config object
     * with the following properties:
     *
     * Properties: object mapping DOM property name to one of the
     * DOMPropertyInjection constants or null. If your attribute isn't in here,
     * it won't get written to the DOM.
     *
     * DOMAttributeNames: object mapping React attribute name to the DOM
     * attribute name. Attribute names not specified use the **lowercase**
     * normalized name.
     *
     * DOMAttributeNamespaces: object mapping React attribute name to the DOM
     * attribute namespace URL. (Attribute names not specified use no namespace.)
     *
     * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
     * Property names not specified use the normalized name.
     *
     * DOMMutationMethods: Properties that require special mutation methods. If
     * `value` is undefined, the mutation method should unset the property.
     *
     * @param {object} domPropertyConfig the config as described above.
     */
    injectDOMPropertyConfig: function (domPropertyConfig) {
      var Injection = DOMPropertyInjection;
      var Properties = domPropertyConfig.Properties || {};
      var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
      var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
      var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

      for (var propName in Properties) {
        !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

        var lowerCased = propName.toLowerCase();
        var propConfig = Properties[propName];

        var propertyInfo = {
          attributeName: lowerCased,
          attributeNamespace: null,
          propertyName: propName,
          mutationMethod: null,

          mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
          hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
          hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
          hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
          hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
          hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
        };
        !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

        if (DOMAttributeNames.hasOwnProperty(propName)) {
          var attributeName = DOMAttributeNames[propName];

          propertyInfo.attributeName = attributeName;
        }

        if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
          propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
        }

        if (DOMMutationMethods.hasOwnProperty(propName)) {
          propertyInfo.mutationMethod = DOMMutationMethods[propName];
        }

        // Downcase references to whitelist properties to check for membership
        // without case-sensitivity. This allows the whitelist to pick up
        // `allowfullscreen`, which should be written using the property configuration
        // for `allowFullscreen`
        properties[propName] = propertyInfo;
      }
    }
  };

  /* eslint-disable max-len */
  var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  /* eslint-enable max-len */
  var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


  var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  var properties = {};

  /**
   * Checks whether a property name is a writeable attribute.
   * @method
   */
  function shouldSetAttribute(name, value) {
    if (isReservedProp(name)) {
      return false;
    }
    if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
      return false;
    }
    if (value === null) {
      return true;
    }
    switch (typeof value) {
      case 'boolean':
        return shouldAttributeAcceptBooleanValue(name);
      case 'undefined':
      case 'number':
      case 'string':
      case 'object':
        return true;
      default:
        // function, symbol
        return false;
    }
  }

  function getPropertyInfo(name) {
    return properties.hasOwnProperty(name) ? properties[name] : null;
  }

  function shouldAttributeAcceptBooleanValue(name) {
    if (isReservedProp(name)) {
      return true;
    }
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
    }
    var prefix = name.toLowerCase().slice(0, 5);
    return prefix === 'data-' || prefix === 'aria-';
  }

  /**
   * Checks to see if a property name is within the list of properties
   * reserved for internal React operations. These properties should
   * not be set on an HTML element.
   *
   * @private
   * @param {string} name
   * @return {boolean} If the name is within reserved props
   */
  function isReservedProp(name) {
    return RESERVED_PROPS.hasOwnProperty(name);
  }

  var injection = DOMPropertyInjection;

  var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
  var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
  var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
  var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
  var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
  var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

  var HTMLDOMPropertyConfig = {
    // When adding attributes to this list, be sure to also add them to
    // the `possibleStandardNames` module to ensure casing and incorrect
    // name warnings.
    Properties: {
      allowFullScreen: HAS_BOOLEAN_VALUE,
      // specifies target context for links with `preload` type
      async: HAS_BOOLEAN_VALUE,
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      autoFocus: HAS_BOOLEAN_VALUE,
      autoPlay: HAS_BOOLEAN_VALUE,
      capture: HAS_OVERLOADED_BOOLEAN_VALUE,
      checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      cols: HAS_POSITIVE_NUMERIC_VALUE,
      contentEditable: HAS_STRING_BOOLEAN_VALUE,
      controls: HAS_BOOLEAN_VALUE,
      'default': HAS_BOOLEAN_VALUE,
      defer: HAS_BOOLEAN_VALUE,
      disabled: HAS_BOOLEAN_VALUE,
      download: HAS_OVERLOADED_BOOLEAN_VALUE,
      draggable: HAS_STRING_BOOLEAN_VALUE,
      formNoValidate: HAS_BOOLEAN_VALUE,
      hidden: HAS_BOOLEAN_VALUE,
      loop: HAS_BOOLEAN_VALUE,
      // Caution; `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`.
      multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      noValidate: HAS_BOOLEAN_VALUE,
      open: HAS_BOOLEAN_VALUE,
      playsInline: HAS_BOOLEAN_VALUE,
      readOnly: HAS_BOOLEAN_VALUE,
      required: HAS_BOOLEAN_VALUE,
      reversed: HAS_BOOLEAN_VALUE,
      rows: HAS_POSITIVE_NUMERIC_VALUE,
      rowSpan: HAS_NUMERIC_VALUE,
      scoped: HAS_BOOLEAN_VALUE,
      seamless: HAS_BOOLEAN_VALUE,
      selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
      size: HAS_POSITIVE_NUMERIC_VALUE,
      start: HAS_NUMERIC_VALUE,
      // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
      span: HAS_POSITIVE_NUMERIC_VALUE,
      spellCheck: HAS_STRING_BOOLEAN_VALUE,
      // Style must be explicitly set in the attribute list. React components
      // expect a style object
      style: 0,
      // Keep it in the whitelist because it is case-sensitive for SVG.
      tabIndex: 0,
      // itemScope is for for Microdata support.
      // See http://schema.org/docs/gs.html
      itemScope: HAS_BOOLEAN_VALUE,
      // These attributes must stay in the white-list because they have
      // different attribute names (see DOMAttributeNames below)
      acceptCharset: 0,
      className: 0,
      htmlFor: 0,
      httpEquiv: 0,
      // Attributes with mutation methods must be specified in the whitelist
      // Set the string boolean flag to allow the behavior
      value: HAS_STRING_BOOLEAN_VALUE
    },
    DOMAttributeNames: {
      acceptCharset: 'accept-charset',
      className: 'class',
      htmlFor: 'for',
      httpEquiv: 'http-equiv'
    },
    DOMMutationMethods: {
      value: function (node, value) {
        if (value == null) {
          return node.removeAttribute('value');
        }

        // Number inputs get special treatment due to some edge cases in
        // Chrome. Let everything else assign the value attribute as normal.
        // https://github.com/facebook/react/issues/7253#issuecomment-236074326
        if (node.type !== 'number' || node.hasAttribute('value') === false) {
          node.setAttribute('value', '' + value);
        } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
          // Don't assign an attribute if validation reports bad
          // input. Chrome will clear the value. Additionally, don't
          // operate on inputs that have focus, otherwise Chrome might
          // strip off trailing decimal places and cause the user's
          // cursor position to jump to the beginning of the input.
          //
          // In ReactDOMInput, we have an onBlur event that will trigger
          // this function again when focus is lost.
          node.setAttribute('value', '' + value);
        }
      }
    }
  };

  var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


  var NS = {
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };

  /**
   * This is a list of all SVG attributes that need special casing,
   * namespacing, or boolean value assignment.
   *
   * When adding attributes to this list, be sure to also add them to
   * the `possibleStandardNames` module to ensure casing and incorrect
   * name warnings.
   *
   * SVG Attributes List:
   * https://www.w3.org/TR/SVG/attindex.html
   * SMIL Spec:
   * https://www.w3.org/TR/smil
   */
  var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

  var SVGDOMPropertyConfig = {
    Properties: {
      autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
      externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
      preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
    },
    DOMAttributeNames: {
      autoReverse: 'autoReverse',
      externalResourcesRequired: 'externalResourcesRequired',
      preserveAlpha: 'preserveAlpha'
    },
    DOMAttributeNamespaces: {
      xlinkActuate: NS.xlink,
      xlinkArcrole: NS.xlink,
      xlinkHref: NS.xlink,
      xlinkRole: NS.xlink,
      xlinkShow: NS.xlink,
      xlinkTitle: NS.xlink,
      xlinkType: NS.xlink,
      xmlBase: NS.xml,
      xmlLang: NS.xml,
      xmlSpace: NS.xml
    }
  };

  var CAMELIZE = /[\-\:]([a-z])/g;
  var capitalize = function (token) {
    return token[1].toUpperCase();
  };

  ATTRS.forEach(function (original) {
    var reactName = original.replace(CAMELIZE, capitalize);

    SVGDOMPropertyConfig.Properties[reactName] = 0;
    SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
  });

  injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  var ReactErrorUtils = {
    // Used by Fiber to simulate a try-catch.
    _caughtError: null,
    _hasCaughtError: false,

    // Used by event system to capture/rethrow the first error.
    _rethrowError: null,
    _hasRethrowError: false,

    injection: {
      injectErrorUtils: function (injectedErrorUtils) {
        !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
        invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
      }
    },

    /**
     * Call a function while guarding against errors that happens within it.
     * Returns an error if it throws, otherwise null.
     *
     * In production, this is implemented using a try-catch. The reason we don't
     * use a try-catch directly is so that we can swap out a different
     * implementation in DEV mode.
     *
     * @param {String} name of the guard to use for logging or debugging
     * @param {Function} func The function to invoke
     * @param {*} context The context to use when calling the function
     * @param {...*} args Arguments for function
     */
    invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
      invokeGuardedCallback.apply(ReactErrorUtils, arguments);
    },

    /**
     * Same as invokeGuardedCallback, but instead of returning an error, it stores
     * it in a global so it can be rethrown by `rethrowCaughtError` later.
     * TODO: See if _caughtError and _rethrowError can be unified.
     *
     * @param {String} name of the guard to use for logging or debugging
     * @param {Function} func The function to invoke
     * @param {*} context The context to use when calling the function
     * @param {...*} args Arguments for function
     */
    invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
      ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
      if (ReactErrorUtils.hasCaughtError()) {
        var error = ReactErrorUtils.clearCaughtError();
        if (!ReactErrorUtils._hasRethrowError) {
          ReactErrorUtils._hasRethrowError = true;
          ReactErrorUtils._rethrowError = error;
        }
      }
    },

    /**
     * During execution of guarded functions we will capture the first error which
     * we will rethrow to be handled by the top level error handler.
     */
    rethrowCaughtError: function () {
      return rethrowCaughtError.apply(ReactErrorUtils, arguments);
    },

    hasCaughtError: function () {
      return ReactErrorUtils._hasCaughtError;
    },

    clearCaughtError: function () {
      if (ReactErrorUtils._hasCaughtError) {
        var error = ReactErrorUtils._caughtError;
        ReactErrorUtils._caughtError = null;
        ReactErrorUtils._hasCaughtError = false;
        return error;
      } else {
        invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
      }
    }
  };

  var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils._hasCaughtError = false;
    ReactErrorUtils._caughtError = null;
    var funcArgs = Array.prototype.slice.call(arguments, 3);
    try {
      func.apply(context, funcArgs);
    } catch (error) {
      ReactErrorUtils._caughtError = error;
      ReactErrorUtils._hasCaughtError = true;
    }
  };

  {
    // In DEV mode, we swap out invokeGuardedCallback for a special version
    // that plays more nicely with the browser's DevTools. The idea is to preserve
    // "Pause on exceptions" behavior. Because React wraps all user-provided
    // functions in invokeGuardedCallback, and the production version of
    // invokeGuardedCallback uses a try-catch, all user exceptions are treated
    // like caught exceptions, and the DevTools won't pause unless the developer
    // takes the extra step of enabling pause on caught exceptions. This is
    // untintuitive, though, because even though React has caught the error, from
    // the developer's perspective, the error is uncaught.
    //
    // To preserve the expected "Pause on exceptions" behavior, we don't use a
    // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
    // DOM node, and call the user-provided callback from inside an event handler
    // for that fake event. If the callback throws, the error is "captured" using
    // a global event handler. But because the error happens in a different
    // event loop context, it does not interrupt the normal program flow.
    // Effectively, this gives us try-catch behavior without actually using
    // try-catch. Neat!

    // Check that the browser supports the APIs we need to implement our special
    // DEV version of invokeGuardedCallback
    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
      var fakeNode = document.createElement('react');

      var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
        // Keeps track of whether the user-provided callback threw an error. We
        // set this to true at the beginning, then set it to false right after
        // calling the function. If the function errors, `didError` will never be
        // set to false. This strategy works even if the browser is flaky and
        // fails to call our global error handler, because it doesn't rely on
        // the error event at all.
        var didError = true;

        // Create an event handler for our fake event. We will synchronously
        // dispatch our fake event using `dispatchEvent`. Inside the handler, we
        // call the user-provided callback.
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        function callCallback() {
          // We immediately remove the callback from event listeners so that
          // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
          // nested call would trigger the fake event handlers of any call higher
          // in the stack.
          fakeNode.removeEventListener(evtType, callCallback, false);
          func.apply(context, funcArgs);
          didError = false;
        }

        // Create a global error event handler. We use this to capture the value
        // that was thrown. It's possible that this error handler will fire more
        // than once; for example, if non-React code also calls `dispatchEvent`
        // and a handler for that event throws. We should be resilient to most of
        // those cases. Even if our error event handler fires more than once, the
        // last error event is always used. If the callback actually does error,
        // we know that the last error event is the correct one, because it's not
        // possible for anything else to have happened in between our callback
        // erroring and the code that follows the `dispatchEvent` call below. If
        // the callback doesn't error, but the error event was fired, we know to
        // ignore it because `didError` will be false, as described above.
        var error = void 0;
        // Use this to track whether the error event is ever called.
        var didSetError = false;
        var isCrossOriginError = false;

        function onError(event) {
          error = event.error;
          didSetError = true;
          if (error === null && event.colno === 0 && event.lineno === 0) {
            isCrossOriginError = true;
          }
        }

        // Create a fake event type.
        var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

        // Attach our event handlers
        window.addEventListener('error', onError);
        fakeNode.addEventListener(evtType, callCallback, false);

        // Synchronously dispatch our fake event. If the user-provided function
        // errors, it will trigger our global error handler.
        var evt = document.createEvent('Event');
        evt.initEvent(evtType, false, false);
        fakeNode.dispatchEvent(evt);

        if (didError) {
          if (!didSetError) {
            // The callback errored, but the error event never fired.
            error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
          } else if (isCrossOriginError) {
            error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
          }
          ReactErrorUtils._hasCaughtError = true;
          ReactErrorUtils._caughtError = error;
        } else {
          ReactErrorUtils._hasCaughtError = false;
          ReactErrorUtils._caughtError = null;
        }

        // Remove our event listeners
        window.removeEventListener('error', onError);
      };

      invokeGuardedCallback = invokeGuardedCallbackDev;
    }
  }

  var rethrowCaughtError = function () {
    if (ReactErrorUtils._hasRethrowError) {
      var error = ReactErrorUtils._rethrowError;
      ReactErrorUtils._rethrowError = null;
      ReactErrorUtils._hasRethrowError = false;
      throw error;
    }
  };

  /**
   * Injectable ordering of event plugins.
   */
  var eventPluginOrder = null;

  /**
   * Injectable mapping from names to event plugin modules.
   */
  var namesToPlugins = {};

  /**
   * Recomputes the plugin list using the injected plugins and plugin ordering.
   *
   * @private
   */
  function recomputePluginOrdering() {
    if (!eventPluginOrder) {
      // Wait until an `eventPluginOrder` is injected.
      return;
    }
    for (var pluginName in namesToPlugins) {
      var pluginModule = namesToPlugins[pluginName];
      var pluginIndex = eventPluginOrder.indexOf(pluginName);
      !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
      if (plugins[pluginIndex]) {
        continue;
      }
      !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
      plugins[pluginIndex] = pluginModule;
      var publishedEvents = pluginModule.eventTypes;
      for (var eventName in publishedEvents) {
        !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
      }
    }
  }

  /**
   * Publishes an event so that it can be dispatched by the supplied plugin.
   *
   * @param {object} dispatchConfig Dispatch configuration for the event.
   * @param {object} PluginModule Plugin publishing the event.
   * @return {boolean} True if the event was successfully published.
   * @private
   */
  function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
    !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
    eventNameDispatchConfigs[eventName] = dispatchConfig;

    var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
    if (phasedRegistrationNames) {
      for (var phaseName in phasedRegistrationNames) {
        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
          var phasedRegistrationName = phasedRegistrationNames[phaseName];
          publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
        }
      }
      return true;
    } else if (dispatchConfig.registrationName) {
      publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
      return true;
    }
    return false;
  }

  /**
   * Publishes a registration name that is used to identify dispatched events.
   *
   * @param {string} registrationName Registration name to add.
   * @param {object} PluginModule Plugin publishing the event.
   * @private
   */
  function publishRegistrationName(registrationName, pluginModule, eventName) {
    !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
    registrationNameModules[registrationName] = pluginModule;
    registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

    {
      var lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;

      if (registrationName === 'onDoubleClick') {
        possibleRegistrationNames.ondblclick = registrationName;
      }
    }
  }

  /**
   * Registers plugins so that they can extract and dispatch events.
   *
   * @see {EventPluginHub}
   */

  /**
   * Ordered list of injected plugins.
   */
  var plugins = [];

  /**
   * Mapping from event name to dispatch config
   */
  var eventNameDispatchConfigs = {};

  /**
   * Mapping from registration name to plugin module
   */
  var registrationNameModules = {};

  /**
   * Mapping from registration name to event name
   */
  var registrationNameDependencies = {};

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in true.
   * @type {Object}
   */
  var possibleRegistrationNames = {};
  // Trust the developer to only use possibleRegistrationNames in true

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  function injectEventPluginOrder(injectedEventPluginOrder) {
    !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  }

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  function injectEventPluginsByName(injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  }

  var EventPluginRegistry = Object.freeze({
    plugins: plugins,
    eventNameDispatchConfigs: eventNameDispatchConfigs,
    registrationNameModules: registrationNameModules,
    registrationNameDependencies: registrationNameDependencies,
    possibleRegistrationNames: possibleRegistrationNames,
    injectEventPluginOrder: injectEventPluginOrder,
    injectEventPluginsByName: injectEventPluginsByName
  });

  var getFiberCurrentPropsFromNode = null;
  var getInstanceFromNode = null;
  var getNodeFromInstance = null;

  var injection$2 = {
    injectComponentTree: function (Injected) {
      getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
      getInstanceFromNode = Injected.getInstanceFromNode;
      getNodeFromInstance = Injected.getNodeFromInstance;

      {
        warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
      }
    }
  };






  var validateEventDispatches;
  {
    validateEventDispatches = function (event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;

      var listenersIsArr = Array.isArray(dispatchListeners);
      var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

      var instancesIsArr = Array.isArray(dispatchInstances);
      var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

      warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
    };
  }

  /**
   * Dispatch the event to the listener.
   * @param {SyntheticEvent} event SyntheticEvent to handle
   * @param {boolean} simulated If the event is simulated (changes exn behavior)
   * @param {function} listener Application-level callback
   * @param {*} inst Internal component instance
   */
  function executeDispatch(event, simulated, listener, inst) {
    var type = event.type || 'unknown-event';
    event.currentTarget = getNodeFromInstance(inst);
    ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
    event.currentTarget = null;
  }

  /**
   * Standard/simple iteration through an event's collected dispatches.
   */
  function executeDispatchesInOrder(event, simulated) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;
    {
      validateEventDispatches(event);
    }
    if (Array.isArray(dispatchListeners)) {
      for (var i = 0; i < dispatchListeners.length; i++) {
        if (event.isPropagationStopped()) {
          break;
        }
        // Listeners and Instances are two parallel arrays that are always in sync.
        executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
      }
    } else if (dispatchListeners) {
      executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
    }
    event._dispatchListeners = null;
    event._dispatchInstances = null;
  }

  /**
   * @see executeDispatchesInOrderStopAtTrueImpl
   */


  /**
   * Execution of a "direct" dispatch - there must be at most one dispatch
   * accumulated on the event or it is considered an error. It doesn't really make
   * sense for an event with multiple dispatches (bubbled) to keep track of the
   * return values at each dispatch execution, but it does tend to make sense when
   * dealing with "direct" dispatches.
   *
   * @return {*} The return value of executing the single dispatch.
   */


  /**
   * @param {SyntheticEvent} event
   * @return {boolean} True iff number of dispatches accumulated is greater than 0.
   */

  /**
   * Accumulates items that must not be null or undefined into the first one. This
   * is used to conserve memory by avoiding array allocations, and thus sacrifices
   * API cleanness. Since `current` can be null before being passed in and not
   * null after this function, make sure to assign it back to `current`:
   *
   * `a = accumulateInto(a, b);`
   *
   * This API should be sparingly used. Try `accumulate` for something cleaner.
   *
   * @return {*|array<*>} An accumulation of items.
   */

  function accumulateInto(current, next) {
    !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

    if (current == null) {
      return next;
    }

    // Both are not empty. Warning: Never call x.concat(y) when you are not
    // certain that x is an Array (x could be a string with concat method).
    if (Array.isArray(current)) {
      if (Array.isArray(next)) {
        current.push.apply(current, next);
        return current;
      }
      current.push(next);
      return current;
    }

    if (Array.isArray(next)) {
      // A bit too dangerous to mutate `next`.
      return [current].concat(next);
    }

    return [current, next];
  }

  /**
   * @param {array} arr an "accumulation" of items which is either an Array or
   * a single item. Useful when paired with the `accumulate` module. This is a
   * simple utility that allows us to reason about a collection of items, but
   * handling the case when there is exactly one item (and we do not need to
   * allocate an array).
   * @param {function} cb Callback invoked with each element or a collection.
   * @param {?} [scope] Scope used as `this` in a callback.
   */
  function forEachAccumulated(arr, cb, scope) {
    if (Array.isArray(arr)) {
      arr.forEach(cb, scope);
    } else if (arr) {
      cb.call(scope, arr);
    }
  }

  /**
   * Internal queue of events that have accumulated their dispatches and are
   * waiting to have their dispatches executed.
   */
  var eventQueue = null;

  /**
   * Dispatches an event and releases it back into the pool, unless persistent.
   *
   * @param {?object} event Synthetic event to be dispatched.
   * @param {boolean} simulated If the event is simulated (changes exn behavior)
   * @private
   */
  var executeDispatchesAndRelease = function (event, simulated) {
    if (event) {
      executeDispatchesInOrder(event, simulated);

      if (!event.isPersistent()) {
        event.constructor.release(event);
      }
    }
  };
  var executeDispatchesAndReleaseSimulated = function (e) {
    return executeDispatchesAndRelease(e, true);
  };
  var executeDispatchesAndReleaseTopLevel = function (e) {
    return executeDispatchesAndRelease(e, false);
  };

  function isInteractive(tag) {
    return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
  }

  function shouldPreventMouseEvent(name, type, props) {
    switch (name) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
        return !!(props.disabled && isInteractive(type));
      default:
        return false;
    }
  }

  /**
   * This is a unified interface for event plugins to be installed and configured.
   *
   * Event plugins can implement the following properties:
   *
   *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
   *     Required. When a top-level event is fired, this method is expected to
   *     extract synthetic events that will in turn be queued and dispatched.
   *
   *   `eventTypes` {object}
   *     Optional, plugins that fire events must publish a mapping of registration
   *     names that are used to register listeners. Values of this mapping must
   *     be objects that contain `registrationName` or `phasedRegistrationNames`.
   *
   *   `executeDispatch` {function(object, function, string)}
   *     Optional, allows plugins to override how an event gets dispatched. By
   *     default, the listener is simply invoked.
   *
   * Each plugin that is injected into `EventsPluginHub` is immediately operable.
   *
   * @public
   */

  /**
   * Methods for injecting dependencies.
   */
  var injection$1 = {
    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: injectEventPluginsByName
  };

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  function getListener(inst, registrationName) {
    var listener;

    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var stateNode = inst.stateNode;
    if (!stateNode) {
      // Work in progress (ex: onload events in incremental mode).
      return null;
    }
    var props = getFiberCurrentPropsFromNode(stateNode);
    if (!props) {
      // Work in progress.
      return null;
    }
    listener = props[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
      return null;
    }
    !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
    return listener;
  }

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  }

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  function enqueueEvents(events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  }

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  function processEventQueue(simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;

    if (!processingEventQueue) {
      return;
    }

    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  }

  var EventPluginHub = Object.freeze({
    injection: injection$1,
    getListener: getListener,
    extractEvents: extractEvents,
    enqueueEvents: enqueueEvents,
    processEventQueue: processEventQueue
  });

  var IndeterminateComponent = 0; // Before we know whether it is functional or class
  var FunctionalComponent = 1;
  var ClassComponent = 2;
  var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
  var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
  var HostComponent = 5;
  var HostText = 6;
  var CallComponent = 7;
  var CallHandlerPhase = 8;
  var ReturnComponent = 9;
  var Fragment = 10;

  var randomKey = Math.random().toString(36).slice(2);
  var internalInstanceKey = '__reactInternalInstance$' + randomKey;
  var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

  function precacheFiberNode$1(hostInst, node) {
    node[internalInstanceKey] = hostInst;
  }

  /**
   * Given a DOM node, return the closest ReactDOMComponent or
   * ReactDOMTextComponent instance ancestor.
   */
  function getClosestInstanceFromNode(node) {
    if (node[internalInstanceKey]) {
      return node[internalInstanceKey];
    }

    // Walk up the tree until we find an ancestor whose instance we have cached.
    var parents = [];
    while (!node[internalInstanceKey]) {
      parents.push(node);
      if (node.parentNode) {
        node = node.parentNode;
      } else {
        // Top of the tree. This node must not be part of a React tree (or is
        // unmounted, potentially).
        return null;
      }
    }

    var closest = void 0;
    var inst = node[internalInstanceKey];
    if (inst.tag === HostComponent || inst.tag === HostText) {
      // In Fiber, this will always be the deepest root.
      return inst;
    }
    for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
      closest = inst;
    }

    return closest;
  }

  /**
   * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
   * instance, or null if the node was not rendered by this React.
   */
  function getInstanceFromNode$1(node) {
    var inst = node[internalInstanceKey];
    if (inst) {
      if (inst.tag === HostComponent || inst.tag === HostText) {
        return inst;
      } else {
        return null;
      }
    }
    return null;
  }

  /**
   * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
   * DOM node.
   */
  function getNodeFromInstance$1(inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      // In Fiber this, is just the state node right now. We assume it will be
      // a host component or host text.
      return inst.stateNode;
    }

    // Without this first invariant, passing a non-DOM-component triggers the next
    // invariant for a missing parent, which is super confusing.
    invariant(false, 'getNodeFromInstance: Invalid argument.');
  }

  function getFiberCurrentPropsFromNode$1(node) {
    return node[internalEventHandlersKey] || null;
  }

  function updateFiberProps$1(node, props) {
    node[internalEventHandlersKey] = props;
  }

  var ReactDOMComponentTree = Object.freeze({
    precacheFiberNode: precacheFiberNode$1,
    getClosestInstanceFromNode: getClosestInstanceFromNode,
    getInstanceFromNode: getInstanceFromNode$1,
    getNodeFromInstance: getNodeFromInstance$1,
    getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
    updateFiberProps: updateFiberProps$1
  });

  function getParent(inst) {
    do {
      inst = inst['return'];
      // TODO: If this is a HostRoot we might want to bail out.
      // That is depending on if we want nested subtrees (layers) to bubble
      // events to their parent. We could also go through parentNode on the
      // host node but that wouldn't work for React Native and doesn't let us
      // do the portal feature.
    } while (inst && inst.tag !== HostComponent);
    if (inst) {
      return inst;
    }
    return null;
  }

  /**
   * Return the lowest common ancestor of A and B, or null if they are in
   * different trees.
   */
  function getLowestCommonAncestor(instA, instB) {
    var depthA = 0;
    for (var tempA = instA; tempA; tempA = getParent(tempA)) {
      depthA++;
    }
    var depthB = 0;
    for (var tempB = instB; tempB; tempB = getParent(tempB)) {
      depthB++;
    }

    // If A is deeper, crawl up.
    while (depthA - depthB > 0) {
      instA = getParent(instA);
      depthA--;
    }

    // If B is deeper, crawl up.
    while (depthB - depthA > 0) {
      instB = getParent(instB);
      depthB--;
    }

    // Walk in lockstep until we find a match.
    var depth = depthA;
    while (depth--) {
      if (instA === instB || instA === instB.alternate) {
        return instA;
      }
      instA = getParent(instA);
      instB = getParent(instB);
    }
    return null;
  }

  /**
   * Return if A is an ancestor of B.
   */


  /**
   * Return the parent instance of the passed-in instance.
   */
  function getParentInstance(inst) {
    return getParent(inst);
  }

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   */
  function traverseTwoPhase(inst, fn, arg) {
    var path = [];
    while (inst) {
      path.push(inst);
      inst = getParent(inst);
    }
    var i;
    for (i = path.length; i-- > 0;) {
      fn(path[i], 'captured', arg);
    }
    for (i = 0; i < path.length; i++) {
      fn(path[i], 'bubbled', arg);
    }
  }

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * Does not invoke the callback on the nearest common ancestor because nothing
   * "entered" or "left" that element.
   */
  function traverseEnterLeave(from, to, fn, argFrom, argTo) {
    var common = from && to ? getLowestCommonAncestor(from, to) : null;
    var pathFrom = [];
    while (true) {
      if (!from) {
        break;
      }
      if (from === common) {
        break;
      }
      var alternate = from.alternate;
      if (alternate !== null && alternate === common) {
        break;
      }
      pathFrom.push(from);
      from = getParent(from);
    }
    var pathTo = [];
    while (true) {
      if (!to) {
        break;
      }
      if (to === common) {
        break;
      }
      var _alternate = to.alternate;
      if (_alternate !== null && _alternate === common) {
        break;
      }
      pathTo.push(to);
      to = getParent(to);
    }
    for (var i = 0; i < pathFrom.length; i++) {
      fn(pathFrom[i], 'bubbled', argFrom);
    }
    for (var _i = pathTo.length; _i-- > 0;) {
      fn(pathTo[_i], 'captured', argTo);
    }
  }

  /**
   * Some event types have a notion of different registration names for different
   * "phases" of propagation. This finds listeners by a given phase.
   */
  function listenerAtPhase(inst, event, propagationPhase) {
    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
    return getListener(inst, registrationName);
  }

  /**
   * A small set of propagation patterns, each of which will accept a small amount
   * of information, and generate a set of "dispatch ready event objects" - which
   * are sets of events that have already been annotated with a set of dispatched
   * listener functions/ids. The API is designed this way to discourage these
   * propagation strategies from actually executing the dispatches, since we
   * always want to collect the entire set of dispatches before executing even a
   * single one.
   */

  /**
   * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
   * here, allows us to not have to bind or create functions for each event.
   * Mutating the event's members allows us to not have to create a wrapping
   * "dispatch" object that pairs the event with the listener.
   */
  function accumulateDirectionalDispatches(inst, phase, event) {
    {
      warning(inst, 'Dispatching inst must not be null');
    }
    var listener = listenerAtPhase(inst, event, phase);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }

  /**
   * Collect dispatches (must be entirely collected before dispatching - see unit
   * tests). Lazily allocate the array to conserve memory.  We must loop through
   * each event and perform the traversal for each one. We cannot perform a
   * single traversal for the entire collection of events because each event may
   * have a different target.
   */
  function accumulateTwoPhaseDispatchesSingle(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
    }
  }

  /**
   * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
   */
  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      var parentInst = targetInst ? getParentInstance(targetInst) : null;
      traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
    }
  }

  /**
   * Accumulates without regard to direction, does not look for phased
   * registration names. Same as `accumulateDirectDispatchesSingle` but without
   * requiring that the `dispatchMarker` be the same as the dispatched ID.
   */
  function accumulateDispatches(inst, ignoredDirection, event) {
    if (inst && event && event.dispatchConfig.registrationName) {
      var registrationName = event.dispatchConfig.registrationName;
      var listener = getListener(inst, registrationName);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }
  }

  /**
   * Accumulates dispatches on an `SyntheticEvent`, but only for the
   * `dispatchMarker`.
   * @param {SyntheticEvent} event
   */
  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      accumulateDispatches(event._targetInst, null, event);
    }
  }

  function accumulateTwoPhaseDispatches(events) {
    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
  }

  function accumulateTwoPhaseDispatchesSkipTarget(events) {
    forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
  }

  function accumulateEnterLeaveDispatches(leave, enter, from, to) {
    traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
  }

  function accumulateDirectDispatches(events) {
    forEachAccumulated(events, accumulateDirectDispatchesSingle);
  }

  var EventPropagators = Object.freeze({
    accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
    accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
    accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
    accumulateDirectDispatches: accumulateDirectDispatches
  });

  var contentKey = null;

  /**
   * Gets the key used to access text content on a DOM node.
   *
   * @return {?string} Key used to access text content.
   * @internal
   */
  function getTextContentAccessor() {
    if (!contentKey && ExecutionEnvironment.canUseDOM) {
      // Prefer textContent to innerText because many browsers support both but
      // SVG <text> elements don't support innerText even when <div> does.
      contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
    }
    return contentKey;
  }

  /**
   * This helper object stores information about text content of a target node,
   * allowing comparison of content before and after a given event.
   *
   * Identify the node where selection currently begins, then observe
   * both its text content and its current position in the DOM. Since the
   * browser may natively replace the target node during composition, we can
   * use its position to find its replacement.
   *
   *
   */
  var compositionState = {
    _root: null,
    _startText: null,
    _fallbackText: null
  };

  function initialize(nativeEventTarget) {
    compositionState._root = nativeEventTarget;
    compositionState._startText = getText();
    return true;
  }

  function reset() {
    compositionState._root = null;
    compositionState._startText = null;
    compositionState._fallbackText = null;
  }

  function getData() {
    if (compositionState._fallbackText) {
      return compositionState._fallbackText;
    }

    var start;
    var startValue = compositionState._startText;
    var startLength = startValue.length;
    var end;
    var endValue = getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    compositionState._fallbackText = endValue.slice(start, sliceTail);
    return compositionState._fallbackText;
  }

  function getText() {
    if ('value' in compositionState._root) {
      return compositionState._root.value;
    }
    return compositionState._root[getTextContentAccessor()];
  }

  /* eslint valid-typeof: 0 */

  var didWarnForAddedNewProperty = false;
  var isProxySupported = typeof Proxy === 'function';
  var EVENT_POOL_SIZE = 10;

  var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

  /**
   * @interface Event
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var EventInterface = {
    type: null,
    target: null,
    // currentTarget is set when dispatching; no use in copying it here
    currentTarget: emptyFunction.thatReturnsNull,
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };

  /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   *
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {*} targetInst Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @param {DOMEventTarget} nativeEventTarget Target node.
   */
  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    {
      // these have a getter/setter for warnings
      delete this.nativeEvent;
      delete this.preventDefault;
      delete this.stopPropagation;
    }

    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;

    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (!Interface.hasOwnProperty(propName)) {
        continue;
      }
      {
        delete this[propName]; // this has a getter/setter for warnings
      }
      var normalize = Interface[propName];
      if (normalize) {
        this[propName] = normalize(nativeEvent);
      } else {
        if (propName === 'target') {
          this.target = nativeEventTarget;
        } else {
          this[propName] = nativeEvent[propName];
        }
      }
    }

    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
    if (defaultPrevented) {
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    } else {
      this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsFalse;
    return this;
  }

  _assign(SyntheticEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      if (!event) {
        return;
      }

      if (event.preventDefault) {
        event.preventDefault();
      } else if (typeof event.returnValue !== 'unknown') {
        event.returnValue = false;
      }
      this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
    },

    stopPropagation: function () {
      var event = this.nativeEvent;
      if (!event) {
        return;
      }

      if (event.stopPropagation) {
        event.stopPropagation();
      } else if (typeof event.cancelBubble !== 'unknown') {
        // The ChangeEventPlugin registers a "propertychange" event for
        // IE. This event does not support bubbling or cancelling, and
        // any references to cancelBubble throw "Member not found".  A
        // typeof check of "unknown" circumvents this issue (and is also
        // IE specific).
        event.cancelBubble = true;
      }

      this.isPropagationStopped = emptyFunction.thatReturnsTrue;
    },

    /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */
    persist: function () {
      this.isPersistent = emptyFunction.thatReturnsTrue;
    },

    /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */
    isPersistent: emptyFunction.thatReturnsFalse,

    /**
     * `PooledClass` looks for `destructor` on each instance it releases.
     */
    destructor: function () {
      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        {
          Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
        }
      }
      for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
        this[shouldBeReleasedProperties[i]] = null;
      }
      {
        Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
        Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
        Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
      }
    }
  });

  SyntheticEvent.Interface = EventInterface;

  /**
   * Helper to reduce boilerplate when creating subclasses.
   *
   * @param {function} Class
   * @param {?object} Interface
   */
  SyntheticEvent.augmentClass = function (Class, Interface) {
    var Super = this;

    var E = function () {};
    E.prototype = Super.prototype;
    var prototype = new E();

    _assign(prototype, Class.prototype);
    Class.prototype = prototype;
    Class.prototype.constructor = Class;

    Class.Interface = _assign({}, Super.Interface, Interface);
    Class.augmentClass = Super.augmentClass;
    addEventPoolingTo(Class);
  };

  /** Proxying after everything set on SyntheticEvent
   * to resolve Proxy issue on some WebKit browsers
   * in which some Event properties are set to undefined (GH#10010)
   */
  {
    if (isProxySupported) {
      /*eslint-disable no-func-assign */
      SyntheticEvent = new Proxy(SyntheticEvent, {
        construct: function (target, args) {
          return this.apply(target, Object.create(target.prototype), args);
        },
        apply: function (constructor, that, args) {
          return new Proxy(constructor.apply(that, args), {
            set: function (target, prop, value) {
              if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
                warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
                didWarnForAddedNewProperty = true;
              }
              target[prop] = value;
              return true;
            }
          });
        }
      });
      /*eslint-enable no-func-assign */
    }
  }

  addEventPoolingTo(SyntheticEvent);

  /**
   * Helper to nullify syntheticEvent instance properties when destructing
   *
   * @param {String} propName
   * @param {?object} getVal
   * @return {object} defineProperty object
   */
  function getPooledWarningPropertyDefinition(propName, getVal) {
    var isFunction = typeof getVal === 'function';
    return {
      configurable: true,
      set: set,
      get: get
    };

    function set(val) {
      var action = isFunction ? 'setting the method' : 'setting the property';
      warn(action, 'This is effectively a no-op');
      return val;
    }

    function get() {
      var action = isFunction ? 'accessing the method' : 'accessing the property';
      var result = isFunction ? 'This is a no-op function' : 'This is set to null';
      warn(action, result);
      return getVal;
    }

    function warn(action, result) {
      var warningCondition = false;
      warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
    }
  }

  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    var EventConstructor = this;
    if (EventConstructor.eventPool.length) {
      var instance = EventConstructor.eventPool.pop();
      EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }
    return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }

  function releasePooledEvent(event) {
    var EventConstructor = this;
    !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
    event.destructor();
    if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
      EventConstructor.eventPool.push(event);
    }
  }

  function addEventPoolingTo(EventConstructor) {
    EventConstructor.eventPool = [];
    EventConstructor.getPooled = getPooledEvent;
    EventConstructor.release = releasePooledEvent;
  }

  var SyntheticEvent$1 = SyntheticEvent;

  /**
   * @interface Event
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
   */
  var CompositionEventInterface = {
    data: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

  /**
   * @interface Event
   * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
   *      /#events-inputevents
   */
  var InputEventInterface = {
    data: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

  var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
  var START_KEYCODE = 229;

  var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

  var documentMode = null;
  if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
    documentMode = document.documentMode;
  }

  // Webkit offers a very useful `textInput` event that can be used to
  // directly represent `beforeInput`. The IE `textinput` event is not as
  // useful, so we don't use it.
  var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

  // In IE9+, we have access to composition events, but the data supplied
  // by the native compositionend event may be incorrect. Japanese ideographic
  // spaces, for instance (\u3000) are not recorded correctly.
  var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

  /**
   * Opera <= 12 includes TextEvent in window, but does not fire
   * text input events. Rely on keypress instead.
   */
  function isPresto() {
    var opera = window.opera;
    return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
  }

  var SPACEBAR_CODE = 32;
  var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

  // Events and their corresponding property names.
  var eventTypes = {
    beforeInput: {
      phasedRegistrationNames: {
        bubbled: 'onBeforeInput',
        captured: 'onBeforeInputCapture'
      },
      dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
    },
    compositionEnd: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionEnd',
        captured: 'onCompositionEndCapture'
      },
      dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionStart: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionStart',
        captured: 'onCompositionStartCapture'
      },
      dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    },
    compositionUpdate: {
      phasedRegistrationNames: {
        bubbled: 'onCompositionUpdate',
        captured: 'onCompositionUpdateCapture'
      },
      dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
    }
  };

  // Track whether we've ever handled a keypress on the space key.
  var hasSpaceKeypress = false;

  /**
   * Return whether a native keypress event is assumed to be a command.
   * This is required because Firefox fires `keypress` events for key commands
   * (cut, copy, select-all, etc.) even though no character is inserted.
   */
  function isKeypressCommand(nativeEvent) {
    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
    // ctrlKey && altKey is equivalent to AltGr, and is not a command.
    !(nativeEvent.ctrlKey && nativeEvent.altKey);
  }

  /**
   * Translate native top level events into event types.
   *
   * @param {string} topLevelType
   * @return {object}
   */
  function getCompositionEventType(topLevelType) {
    switch (topLevelType) {
      case 'topCompositionStart':
        return eventTypes.compositionStart;
      case 'topCompositionEnd':
        return eventTypes.compositionEnd;
      case 'topCompositionUpdate':
        return eventTypes.compositionUpdate;
    }
  }

  /**
   * Does our fallback best-guess model think this event signifies that
   * composition has begun?
   *
   * @param {string} topLevelType
   * @param {object} nativeEvent
   * @return {boolean}
   */
  function isFallbackCompositionStart(topLevelType, nativeEvent) {
    return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
  }

  /**
   * Does our fallback mode think that this event is the end of composition?
   *
   * @param {string} topLevelType
   * @param {object} nativeEvent
   * @return {boolean}
   */
  function isFallbackCompositionEnd(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topKeyUp':
        // Command keys insert or clear IME input.
        return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
      case 'topKeyDown':
        // Expect IME keyCode on each keydown. If we get any other
        // code we must have exited earlier.
        return nativeEvent.keyCode !== START_KEYCODE;
      case 'topKeyPress':
      case 'topMouseDown':
      case 'topBlur':
        // Events are not possible without cancelling IME.
        return true;
      default:
        return false;
    }
  }

  /**
   * Google Input Tools provides composition data via a CustomEvent,
   * with the `data` property populated in the `detail` object. If this
   * is available on the event object, use it. If not, this is a plain
   * composition event and we have nothing special to extract.
   *
   * @param {object} nativeEvent
   * @return {?string}
   */
  function getDataFromCustomEvent(nativeEvent) {
    var detail = nativeEvent.detail;
    if (typeof detail === 'object' && 'data' in detail) {
      return detail.data;
    }
    return null;
  }

  // Track the current IME composition status, if any.
  var isComposing = false;

  /**
   * @return {?object} A SyntheticCompositionEvent.
   */
  function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var eventType;
    var fallbackData;

    if (canUseCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!isComposing) {
      if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }

    if (!eventType) {
      return null;
    }

    if (useFallbackCompositionData) {
      // The current composition is stored statically and must not be
      // overwritten while composition continues.
      if (!isComposing && eventType === eventTypes.compositionStart) {
        isComposing = initialize(nativeEventTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (isComposing) {
          fallbackData = getData();
        }
      }
    }

    var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

    if (fallbackData) {
      // Inject data generated from fallback path into the synthetic event.
      // This matches the property of native CompositionEventInterface.
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);
      if (customData !== null) {
        event.data = customData;
      }
    }

    accumulateTwoPhaseDispatches(event);
    return event;
  }

  /**
   * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
   * @param {object} nativeEvent Native browser event.
   * @return {?string} The string corresponding to this `beforeInput` event.
   */
  function getNativeBeforeInputChars(topLevelType, nativeEvent) {
    switch (topLevelType) {
      case 'topCompositionEnd':
        return getDataFromCustomEvent(nativeEvent);
      case 'topKeyPress':
        /**
         * If native `textInput` events are available, our goal is to make
         * use of them. However, there is a special case: the spacebar key.
         * In Webkit, preventing default on a spacebar `textInput` event
         * cancels character insertion, but it *also* causes the browser
         * to fall back to its default spacebar behavior of scrolling the
         * page.
         *
         * Tracking at:
         * https://code.google.com/p/chromium/issues/detail?id=355103
         *
         * To avoid this issue, use the keypress event as if no `textInput`
         * event is available.
         */
        var which = nativeEvent.which;
        if (which !== SPACEBAR_CODE) {
          return null;
        }

        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;

      case 'topTextInput':
        // Record the characters to be added to the DOM.
        var chars = nativeEvent.data;

        // If it's a spacebar character, assume that we have already handled
        // it at the keypress level and bail immediately. Android Chrome
        // doesn't give us keycodes, so we need to blacklist it.
        if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
          return null;
        }

        return chars;

      default:
        // For other native event types, do nothing.
        return null;
    }
  }

  /**
   * For browsers that do not provide the `textInput` event, extract the
   * appropriate string to use for SyntheticInputEvent.
   *
   * @param {string} topLevelType Record from `BrowserEventConstants`.
   * @param {object} nativeEvent Native browser event.
   * @return {?string} The fallback string for this `beforeInput` event.
   */
  function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
    // If we are currently composing (IME) and using a fallback to do so,
    // try to extract the composed characters from the fallback object.
    // If composition event is available, we extract a string only at
    // compositionevent, otherwise extract it at fallback events.
    if (isComposing) {
      if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
        var chars = getData();
        reset();
        isComposing = false;
        return chars;
      }
      return null;
    }

    switch (topLevelType) {
      case 'topPaste':
        // If a paste event occurs after a keypress, throw out the input
        // chars. Paste events should not lead to BeforeInput events.
        return null;
      case 'topKeyPress':
        /**
         * As of v27, Firefox may fire keypress events even when no character
         * will be inserted. A few possibilities:
         *
         * - `which` is `0`. Arrow keys, Esc key, etc.
         *
         * - `which` is the pressed key code, but no char is available.
         *   Ex: 'AltGr + d` in Polish. There is no modified character for
         *   this key combination and no character is inserted into the
         *   document, but FF fires the keypress for char code `100` anyway.
         *   No `input` event will occur.
         *
         * - `which` is the pressed key code, but a command combination is
         *   being used. Ex: `Cmd+C`. No character is inserted, and no
         *   `input` event will occur.
         */
        if (!isKeypressCommand(nativeEvent)) {
          // IE fires the `keypress` event when a user types an emoji via
          // Touch keyboard of Windows.  In such a case, the `char` property
          // holds an emoji character like `\uD83D\uDE0A`.  Because its length
          // is 2, the property `which` does not represent an emoji correctly.
          // In such a case, we directly return the `char` property instead of
          // using `which`.
          if (nativeEvent.char && nativeEvent.char.length > 1) {
            return nativeEvent.char;
          } else if (nativeEvent.which) {
            return String.fromCharCode(nativeEvent.which);
          }
        }
        return null;
      case 'topCompositionEnd':
        return useFallbackCompositionData ? null : nativeEvent.data;
      default:
        return null;
    }
  }

  /**
   * Extract a SyntheticInputEvent for `beforeInput`, based on either native
   * `textInput` or fallback behavior.
   *
   * @return {?object} A SyntheticInputEvent.
   */
  function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var chars;

    if (canUseTextInputEvent) {
      chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
    } else {
      chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
    }

    // If no characters are being inserted, no BeforeInput event should
    // be fired.
    if (!chars) {
      return null;
    }

    var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

    event.data = chars;
    accumulateTwoPhaseDispatches(event);
    return event;
  }

  /**
   * Create an `onBeforeInput` event to match
   * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
   *
   * This event plugin is based on the native `textInput` event
   * available in Chrome, Safari, Opera, and IE. This event fires after
   * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
   *
   * `beforeInput` is spec'd but not implemented in any browsers, and
   * the `input` event does not provide any useful information about what has
   * actually been added, contrary to the spec. Thus, `textInput` is the best
   * available event to identify the characters that have actually been inserted
   * into the target node.
   *
   * This plugin is also responsible for emitting `composition` events, thus
   * allowing us to share composition fallback code for both `beforeInput` and
   * `composition` event types.
   */
  var BeforeInputEventPlugin = {
    eventTypes: eventTypes,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
    }
  };

  // Use to restore controlled state after a change event has fired.

  var fiberHostComponent = null;

  var ReactControlledComponentInjection = {
    injectFiberControlledHostComponent: function (hostComponentImpl) {
      // The fiber implementation doesn't use dynamic dispatch so we need to
      // inject the implementation.
      fiberHostComponent = hostComponentImpl;
    }
  };

  var restoreTarget = null;
  var restoreQueue = null;

  function restoreStateOfTarget(target) {
    // We perform this translation at the end of the event loop so that we
    // always receive the correct fiber here
    var internalInstance = getInstanceFromNode(target);
    if (!internalInstance) {
      // Unmounted
      return;
    }
    !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
    fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
  }

  var injection$3 = ReactControlledComponentInjection;

  function enqueueStateRestore(target) {
    if (restoreTarget) {
      if (restoreQueue) {
        restoreQueue.push(target);
      } else {
        restoreQueue = [target];
      }
    } else {
      restoreTarget = target;
    }
  }

  function restoreStateIfNeeded() {
    if (!restoreTarget) {
      return;
    }
    var target = restoreTarget;
    var queuedTargets = restoreQueue;
    restoreTarget = null;
    restoreQueue = null;

    restoreStateOfTarget(target);
    if (queuedTargets) {
      for (var i = 0; i < queuedTargets.length; i++) {
        restoreStateOfTarget(queuedTargets[i]);
      }
    }
  }

  var ReactControlledComponent = Object.freeze({
    injection: injection$3,
    enqueueStateRestore: enqueueStateRestore,
    restoreStateIfNeeded: restoreStateIfNeeded
  });

  // Used as a way to call batchedUpdates when we don't have a reference to
  // the renderer. Such as when we're dispatching events or if third party
  // libraries need to call batchedUpdates. Eventually, this API will go away when
  // everything is batched by default. We'll then have a similar API to opt-out of
  // scheduled work and instead do synchronous work.

  // Defaults
  var fiberBatchedUpdates = function (fn, bookkeeping) {
    return fn(bookkeeping);
  };

  var isNestingBatched = false;
  function batchedUpdates(fn, bookkeeping) {
    if (isNestingBatched) {
      // If we are currently inside another batch, we need to wait until it
      // fully completes before restoring state. Therefore, we add the target to
      // a queue of work.
      return fiberBatchedUpdates(fn, bookkeeping);
    }
    isNestingBatched = true;
    try {
      return fiberBatchedUpdates(fn, bookkeeping);
    } finally {
      // Here we wait until all updates have propagated, which is important
      // when using controlled components within layers:
      // https://github.com/facebook/react/issues/1698
      // Then we restore state of any controlled component.
      isNestingBatched = false;
      restoreStateIfNeeded();
    }
  }

  var ReactGenericBatchingInjection = {
    injectFiberBatchedUpdates: function (_batchedUpdates) {
      fiberBatchedUpdates = _batchedUpdates;
    }
  };

  var injection$4 = ReactGenericBatchingInjection;

  /**
   * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
   */
  var supportedInputTypes = {
    color: true,
    date: true,
    datetime: true,
    'datetime-local': true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };

  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

    if (nodeName === 'input') {
      return !!supportedInputTypes[elem.type];
    }

    if (nodeName === 'textarea') {
      return true;
    }

    return false;
  }

  /**
   * HTML nodeType values that represent the type of the node
   */

  var ELEMENT_NODE = 1;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  var DOCUMENT_NODE = 9;
  var DOCUMENT_FRAGMENT_NODE = 11;

  /**
   * Gets the target node from a native browser event by accounting for
   * inconsistencies in browser DOM APIs.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {DOMEventTarget} Target node.
   */
  function getEventTarget(nativeEvent) {
    var target = nativeEvent.target || nativeEvent.srcElement || window;

    // Normalize SVG <use> element events #4963
    if (target.correspondingUseElement) {
      target = target.correspondingUseElement;
    }

    // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
    // @see http://www.quirksmode.org/js/events_properties.html
    return target.nodeType === TEXT_NODE ? target.parentNode : target;
  }

  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature = document.implementation && document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
  }

  /**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
      return false;
    }

    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;

    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }

  function isCheckable(elem) {
    var type = elem.type;
    var nodeName = elem.nodeName;
    return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
  }

  function getTracker(node) {
    return node._valueTracker;
  }

  function detachTracker(node) {
    node._valueTracker = null;
  }

  function getValueFromNode(node) {
    var value = '';
    if (!node) {
      return value;
    }

    if (isCheckable(node)) {
      value = node.checked ? 'true' : 'false';
    } else {
      value = node.value;
    }

    return value;
  }

  function trackValueOnNode(node) {
    var valueField = isCheckable(node) ? 'checked' : 'value';
    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

    var currentValue = '' + node[valueField];

    // if someone has already defined a value or Safari, then bail
    // and don't track value will cause over reporting of changes,
    // but it's better then a hard failure
    // (needed for certain tests that spyOn input values and Safari)
    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
      return;
    }

    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable,
      configurable: true,
      get: function () {
        return descriptor.get.call(this);
      },
      set: function (value) {
        currentValue = '' + value;
        descriptor.set.call(this, value);
      }
    });

    var tracker = {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = '' + value;
      },
      stopTracking: function () {
        detachTracker(node);
        delete node[valueField];
      }
    };
    return tracker;
  }

  function track(node) {
    if (getTracker(node)) {
      return;
    }

    // TODO: Once it's just Fiber we can move this to node._wrapperState
    node._valueTracker = trackValueOnNode(node);
  }

  function updateValueIfChanged(node) {
    if (!node) {
      return false;
    }

    var tracker = getTracker(node);
    // if there is no tracker at this point it's unlikely
    // that trying again will succeed
    if (!tracker) {
      return true;
    }

    var lastValue = tracker.getValue();
    var nextValue = getValueFromNode(node);
    if (nextValue !== lastValue) {
      tracker.setValue(nextValue);
      return true;
    }
    return false;
  }

  var eventTypes$1 = {
    change: {
      phasedRegistrationNames: {
        bubbled: 'onChange',
        captured: 'onChangeCapture'
      },
      dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
    }
  };

  function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
    var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
    event.type = 'change';
    // Flag this event loop as needing state restore.
    enqueueStateRestore(target);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
  /**
   * For IE shims
   */
  var activeElement = null;
  var activeElementInst = null;

  /**
   * SECTION: handle `change` event
   */
  function shouldUseChangeEvent(elem) {
    var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
  }

  function manualDispatchChangeEvent(nativeEvent) {
    var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

    // If change and propertychange bubbled, we'd just bind to it like all the
    // other events and have it go through ReactBrowserEventEmitter. Since it
    // doesn't, we manually listen for the events and so we have to enqueue and
    // process the abstract event manually.
    //
    // Batching is necessary here in order to ensure that all event handlers run
    // before the next rerender (including event handlers attached to ancestor
    // elements instead of directly on the input). Without this, controlled
    // components don't work properly in conjunction with event bubbling because
    // the component is rerendered and the value reverted before all the event
    // handlers can run. See https://github.com/facebook/react/issues/708.
    batchedUpdates(runEventInBatch, event);
  }

  function runEventInBatch(event) {
    enqueueEvents(event);
    processEventQueue(false);
  }

  function getInstIfValueChanged(targetInst) {
    var targetNode = getNodeFromInstance$1(targetInst);
    if (updateValueIfChanged(targetNode)) {
      return targetInst;
    }
  }

  function getTargetInstForChangeEvent(topLevelType, targetInst) {
    if (topLevelType === 'topChange') {
      return targetInst;
    }
  }

  /**
   * SECTION: handle `input` event
   */
  var isInputEventSupported = false;
  if (ExecutionEnvironment.canUseDOM) {
    // IE9 claims to support the input event but fails to trigger it when
    // deleting text, so we ignore its input events.
    isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
  }

  /**
   * (For IE <=9) Starts tracking propertychange events on the passed-in element
   * and override the value property so that we can distinguish user events from
   * value changes in JS.
   */
  function startWatchingForValueChange(target, targetInst) {
    activeElement = target;
    activeElementInst = targetInst;
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  }

  /**
   * (For IE <=9) Removes the event listeners from the currently-tracked element,
   * if any exists.
   */
  function stopWatchingForValueChange() {
    if (!activeElement) {
      return;
    }
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
    activeElement = null;
    activeElementInst = null;
  }

  /**
   * (For IE <=9) Handles a propertychange event, sending a `change` event if
   * the value of the active element has changed.
   */
  function handlePropertyChange(nativeEvent) {
    if (nativeEvent.propertyName !== 'value') {
      return;
    }
    if (getInstIfValueChanged(activeElementInst)) {
      manualDispatchChangeEvent(nativeEvent);
    }
  }

  function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
    if (topLevelType === 'topFocus') {
      // In IE9, propertychange fires for most input events but is buggy and
      // doesn't fire when text is deleted, but conveniently, selectionchange
      // appears to fire in all of the remaining cases so we catch those and
      // forward the event if the value has changed
      // In either case, we don't want to call the event handler if the value
      // is changed from JS so we redefine a setter for `.value` that updates
      // our activeElementValue variable, allowing us to ignore those changes
      //
      // stopWatching() should be a noop here but we call it just in case we
      // missed a blur event somehow.
      stopWatchingForValueChange();
      startWatchingForValueChange(target, targetInst);
    } else if (topLevelType === 'topBlur') {
      stopWatchingForValueChange();
    }
  }

  // For IE8 and IE9.
  function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
    if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
      // On the selectionchange event, the target is just document which isn't
      // helpful for us so just check activeElement instead.
      //
      // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
      // propertychange on the first input event after setting `value` from a
      // script and fires only keydown, keypress, keyup. Catching keyup usually
      // gets it and catching keydown lets us fire an event for the first
      // keystroke if user does a key repeat (it'll be a little delayed: right
      // before the second keystroke). Other input methods (e.g., paste) seem to
      // fire selectionchange normally.
      return getInstIfValueChanged(activeElementInst);
    }
  }

  /**
   * SECTION: handle `click` event
   */
  function shouldUseClickEvent(elem) {
    // Use the `click` event to detect changes to checkbox and radio inputs.
    // This approach works across all browsers, whereas `change` does not fire
    // until `blur` in IE8.
    var nodeName = elem.nodeName;
    return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
  }

  function getTargetInstForClickEvent(topLevelType, targetInst) {
    if (topLevelType === 'topClick') {
      return getInstIfValueChanged(targetInst);
    }
  }

  function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
    if (topLevelType === 'topInput' || topLevelType === 'topChange') {
      return getInstIfValueChanged(targetInst);
    }
  }

  function handleControlledInputBlur(inst, node) {
    // TODO: In IE, inst is occasionally null. Why?
    if (inst == null) {
      return;
    }

    // Fiber and ReactDOM keep wrapper state in separate places
    var state = inst._wrapperState || node._wrapperState;

    if (!state || !state.controlled || node.type !== 'number') {
      return;
    }

    // If controlled, assign the value attribute to the current value on blur
    var value = '' + node.value;
    if (node.getAttribute('value') !== value) {
      node.setAttribute('value', value);
    }
  }

  /**
   * This plugin creates an `onChange` event that normalizes change events
   * across form elements. This event fires at a time when it's possible to
   * change the element's value without seeing a flicker.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - select
   */
  var ChangeEventPlugin = {
    eventTypes: eventTypes$1,

    _isInputEventSupported: isInputEventSupported,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

      var getTargetInstFunc, handleEventFunc;
      if (shouldUseChangeEvent(targetNode)) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else if (isTextInputElement(targetNode)) {
        if (isInputEventSupported) {
          getTargetInstFunc = getTargetInstForInputOrChangeEvent;
        } else {
          getTargetInstFunc = getTargetInstForInputEventPolyfill;
          handleEventFunc = handleEventsForInputEventPolyfill;
        }
      } else if (shouldUseClickEvent(targetNode)) {
        getTargetInstFunc = getTargetInstForClickEvent;
      }

      if (getTargetInstFunc) {
        var inst = getTargetInstFunc(topLevelType, targetInst);
        if (inst) {
          var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
          return event;
        }
      }

      if (handleEventFunc) {
        handleEventFunc(topLevelType, targetNode, targetInst);
      }

      // When blurring, set the value attribute for number inputs
      if (topLevelType === 'topBlur') {
        handleControlledInputBlur(targetInst, targetNode);
      }
    }
  };

  /**
   * Module that is injectable into `EventPluginHub`, that specifies a
   * deterministic ordering of `EventPlugin`s. A convenient way to reason about
   * plugins, without having to package every one of them. This is better than
   * having plugins be ordered in the same order that they are injected because
   * that ordering would be influenced by the packaging order.
   * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
   * preventing default on events is convenient in `SimpleEventPlugin` handlers.
   */
  var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

  /**
   * @interface UIEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var UIEventInterface = {
    view: null,
    detail: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

  /**
   * Translation from modifier key to the associated property in the event.
   * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
   */

  var modifierKeyToProp = {
    Alt: 'altKey',
    Control: 'ctrlKey',
    Meta: 'metaKey',
    Shift: 'shiftKey'
  };

  // IE8 does not implement getModifierState so we simply map it to the only
  // modifier keys exposed by the event itself, does not support Lock-keys.
  // Currently, all major browsers except Chrome seems to support Lock-keys.
  function modifierStateGetter(keyArg) {
    var syntheticEvent = this;
    var nativeEvent = syntheticEvent.nativeEvent;
    if (nativeEvent.getModifierState) {
      return nativeEvent.getModifierState(keyArg);
    }
    var keyProp = modifierKeyToProp[keyArg];
    return keyProp ? !!nativeEvent[keyProp] : false;
  }

  function getEventModifierState(nativeEvent) {
    return modifierStateGetter;
  }

  /**
   * @interface MouseEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var MouseEventInterface = {
    screenX: null,
    screenY: null,
    clientX: null,
    clientY: null,
    pageX: null,
    pageY: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    getModifierState: getEventModifierState,
    button: null,
    buttons: null,
    relatedTarget: function (event) {
      return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
    }
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

  var eventTypes$2 = {
    mouseEnter: {
      registrationName: 'onMouseEnter',
      dependencies: ['topMouseOut', 'topMouseOver']
    },
    mouseLeave: {
      registrationName: 'onMouseLeave',
      dependencies: ['topMouseOut', 'topMouseOver']
    }
  };

  var EnterLeaveEventPlugin = {
    eventTypes: eventTypes$2,

    /**
     * For almost every interaction we care about, there will be both a top-level
     * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
     * we do not extract duplicate events. However, moving the mouse into the
     * browser from outside will not fire a `mouseout` event. In this case, we use
     * the `mouseover` top-level event.
     */
    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
        return null;
      }
      if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
        // Must not be a mouse in or mouse out - ignoring.
        return null;
      }

      var win;
      if (nativeEventTarget.window === nativeEventTarget) {
        // `nativeEventTarget` is probably a window object.
        win = nativeEventTarget;
      } else {
        // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
        var doc = nativeEventTarget.ownerDocument;
        if (doc) {
          win = doc.defaultView || doc.parentWindow;
        } else {
          win = window;
        }
      }

      var from;
      var to;
      if (topLevelType === 'topMouseOut') {
        from = targetInst;
        var related = nativeEvent.relatedTarget || nativeEvent.toElement;
        to = related ? getClosestInstanceFromNode(related) : null;
      } else {
        // Moving to a node from outside the window.
        from = null;
        to = targetInst;
      }

      if (from === to) {
        // Nothing pertains to our managed components.
        return null;
      }

      var fromNode = from == null ? win : getNodeFromInstance$1(from);
      var toNode = to == null ? win : getNodeFromInstance$1(to);

      var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
      leave.type = 'mouseleave';
      leave.target = fromNode;
      leave.relatedTarget = toNode;

      var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
      enter.type = 'mouseenter';
      enter.target = toNode;
      enter.relatedTarget = fromNode;

      accumulateEnterLeaveDispatches(leave, enter, from, to);

      return [leave, enter];
    }
  };

  /**
   * `ReactInstanceMap` maintains a mapping from a public facing stateful
   * instance (key) and the internal representation (value). This allows public
   * methods to accept the user facing instance as an argument and map them back
   * to internal methods.
   *
   * Note that this module is currently shared and assumed to be stateless.
   * If this becomes an actual Map, that will break.
   */

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */


  function get(key) {
    return key._reactInternalFiber;
  }

  function has(key) {
    return key._reactInternalFiber !== undefined;
  }

  function set(key, value) {
    key._reactInternalFiber = value;
  }

  var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
  var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

  function getComponentName(fiber) {
    var type = fiber.type;

    if (typeof type === 'string') {
      return type;
    }
    if (typeof type === 'function') {
      return type.displayName || type.name;
    }
    return null;
  }

  // Don't change these two values:
  var NoEffect = 0; //           0b00000000
  var PerformedWork = 1; //      0b00000001

  // You can change the rest (and add more).
  var Placement = 2; //          0b00000010
  var Update = 4; //             0b00000100
  var PlacementAndUpdate = 6; // 0b00000110
  var Deletion = 8; //           0b00001000
  var ContentReset = 16; //      0b00010000
  var Callback = 32; //          0b00100000
  var Err = 64; //               0b01000000
  var Ref = 128; //              0b10000000

  var MOUNTING = 1;
  var MOUNTED = 2;
  var UNMOUNTED = 3;

  function isFiberMountedImpl(fiber) {
    var node = fiber;
    if (!fiber.alternate) {
      // If there is no alternate, this might be a new tree that isn't inserted
      // yet. If it is, then it will have a pending insertion effect on it.
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
      while (node['return']) {
        node = node['return'];
        if ((node.effectTag & Placement) !== NoEffect) {
          return MOUNTING;
        }
      }
    } else {
      while (node['return']) {
        node = node['return'];
      }
    }
    if (node.tag === HostRoot) {
      // TODO: Check if this was a nested HostRoot when used with
      // renderContainerIntoSubtree.
      return MOUNTED;
    }
    // If we didn't hit the root, that means that we're in an disconnected tree
    // that has been unmounted.
    return UNMOUNTED;
  }

  function isFiberMounted(fiber) {
    return isFiberMountedImpl(fiber) === MOUNTED;
  }

  function isMounted(component) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null && owner.tag === ClassComponent) {
        var ownerFiber = owner;
        var instance = ownerFiber.stateNode;
        warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
        instance._warnedAboutRefsInRender = true;
      }
    }

    var fiber = get(component);
    if (!fiber) {
      return false;
    }
    return isFiberMountedImpl(fiber) === MOUNTED;
  }

  function assertIsMounted(fiber) {
    !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  }

  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      // If there is no alternate, then we only need to check if it is mounted.
      var state = isFiberMountedImpl(fiber);
      !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
      if (state === MOUNTING) {
        return null;
      }
      return fiber;
    }
    // If we have two possible branches, we'll walk backwards up to the root
    // to see what path the root points to. On the way we may hit one of the
    // special cases and we'll deal with them.
    var a = fiber;
    var b = alternate;
    while (true) {
      var parentA = a['return'];
      var parentB = parentA ? parentA.alternate : null;
      if (!parentA || !parentB) {
        // We're at the root.
        break;
      }

      // If both copies of the parent fiber point to the same child, we can
      // assume that the child is current. This happens when we bailout on low
      // priority: the bailed out fiber's child reuses the current child.
      if (parentA.child === parentB.child) {
        var child = parentA.child;
        while (child) {
          if (child === a) {
            // We've determined that A is the current branch.
            assertIsMounted(parentA);
            return fiber;
          }
          if (child === b) {
            // We've determined that B is the current branch.
            assertIsMounted(parentA);
            return alternate;
          }
          child = child.sibling;
        }
        // We should never have an alternate for any mounting node. So the only
        // way this could possibly happen is if this was unmounted, if at all.
        invariant(false, 'Unable to find node on an unmounted component.');
      }

      if (a['return'] !== b['return']) {
        // The return pointer of A and the return pointer of B point to different
        // fibers. We assume that return pointers never criss-cross, so A must
        // belong to the child set of A.return, and B must belong to the child
        // set of B.return.
        a = parentA;
        b = parentB;
      } else {
        // The return pointers point to the same fiber. We'll have to use the
        // default, slow path: scan the child sets of each parent alternate to see
        // which child belongs to which set.
        //
        // Search parent A's child set
        var didFindChild = false;
        var _child = parentA.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }
          _child = _child.sibling;
        }
        if (!didFindChild) {
          // Search parent B's child set
          _child = parentB.child;
          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }
            _child = _child.sibling;
          }
          !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
        }
      }

      !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    // If the root is not a host container, we're in a disconnected tree. I.e.
    // unmounted.
    !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (a.stateNode.current === a) {
      // We've determined that A is the current branch.
      return fiber;
    }
    // Otherwise B has to be current branch.
    return alternate;
  }

  function findCurrentHostFiber(parent) {
    var currentParent = findCurrentFiberUsingSlowPath(parent);
    if (!currentParent) {
      return null;
    }

    // Next we'll drill down this component to find the first HostComponent/Text.
    var node = currentParent;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        return node;
      } else if (node.child) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === currentParent) {
        return null;
      }
      while (!node.sibling) {
        if (!node['return'] || node['return'] === currentParent) {
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
    // Flow needs the return null here, but ESLint complains about it.
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function findCurrentHostFiberWithNoPortals(parent) {
    var currentParent = findCurrentFiberUsingSlowPath(parent);
    if (!currentParent) {
      return null;
    }

    // Next we'll drill down this component to find the first HostComponent/Text.
    var node = currentParent;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        return node;
      } else if (node.child && node.tag !== HostPortal) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === currentParent) {
        return null;
      }
      while (!node.sibling) {
        if (!node['return'] || node['return'] === currentParent) {
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
    // Flow needs the return null here, but ESLint complains about it.
    // eslint-disable-next-line no-unreachable
    return null;
  }

  var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
  var callbackBookkeepingPool = [];

  /**
   * Find the deepest React component completely containing the root of the
   * passed-in instance (for use when entire React trees are nested within each
   * other). If React trees are not nested, returns null.
   */
  function findRootContainerNode(inst) {
    // TODO: It may be a good idea to cache this to prevent unnecessary DOM
    // traversal, but caching is difficult to do correctly without using a
    // mutation observer to listen for all DOM changes.
    while (inst['return']) {
      inst = inst['return'];
    }
    if (inst.tag !== HostRoot) {
      // This can happen if we're in a detached tree.
      return null;
    }
    return inst.stateNode.containerInfo;
  }

  // Used to store ancestor hierarchy in top level callback
  function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
    if (callbackBookkeepingPool.length) {
      var instance = callbackBookkeepingPool.pop();
      instance.topLevelType = topLevelType;
      instance.nativeEvent = nativeEvent;
      instance.targetInst = targetInst;
      return instance;
    }
    return {
      topLevelType: topLevelType,
      nativeEvent: nativeEvent,
      targetInst: targetInst,
      ancestors: []
    };
  }

  function releaseTopLevelCallbackBookKeeping(instance) {
    instance.topLevelType = null;
    instance.nativeEvent = null;
    instance.targetInst = null;
    instance.ancestors.length = 0;
    if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
      callbackBookkeepingPool.push(instance);
    }
  }

  function handleTopLevelImpl(bookKeeping) {
    var targetInst = bookKeeping.targetInst;

    // Loop through the hierarchy, in case there's any nested components.
    // It's important that we build the array of ancestors before calling any
    // event handlers, because event handlers can modify the DOM, leading to
    // inconsistencies with ReactMount's node cache. See #1105.
    var ancestor = targetInst;
    do {
      if (!ancestor) {
        bookKeeping.ancestors.push(ancestor);
        break;
      }
      var root = findRootContainerNode(ancestor);
      if (!root) {
        break;
      }
      bookKeeping.ancestors.push(ancestor);
      ancestor = getClosestInstanceFromNode(root);
    } while (ancestor);

    for (var i = 0; i < bookKeeping.ancestors.length; i++) {
      targetInst = bookKeeping.ancestors[i];
      _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
    }
  }

  // TODO: can we stop exporting these?
  var _enabled = true;
  var _handleTopLevel = void 0;

  function setHandleTopLevel(handleTopLevel) {
    _handleTopLevel = handleTopLevel;
  }

  function setEnabled(enabled) {
    _enabled = !!enabled;
  }

  function isEnabled() {
    return _enabled;
  }

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `BrowserEventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  function trapBubbledEvent(topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
  }

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `BrowserEventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  function trapCapturedEvent(topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
  }

  function dispatchEvent(topLevelType, nativeEvent) {
    if (!_enabled) {
      return;
    }

    var nativeEventTarget = getEventTarget(nativeEvent);
    var targetInst = getClosestInstanceFromNode(nativeEventTarget);
    if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
      // If we get an event (ex: img onload) before committing that
      // component's mount, ignore it for now (that is, treat it as if it was an
      // event on a non-React tree). We might also consider queueing events and
      // dispatching them after the mount.
      targetInst = null;
    }

    var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      releaseTopLevelCallbackBookKeeping(bookKeeping);
    }
  }

  var ReactDOMEventListener = Object.freeze({
    get _enabled () { return _enabled; },
    get _handleTopLevel () { return _handleTopLevel; },
    setHandleTopLevel: setHandleTopLevel,
    setEnabled: setEnabled,
    isEnabled: isEnabled,
    trapBubbledEvent: trapBubbledEvent,
    trapCapturedEvent: trapCapturedEvent,
    dispatchEvent: dispatchEvent
  });

  /**
   * Generate a mapping of standard vendor prefixes using the defined style property and event name.
   *
   * @param {string} styleProp
   * @param {string} eventName
   * @returns {object}
   */
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};

    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes['Webkit' + styleProp] = 'webkit' + eventName;
    prefixes['Moz' + styleProp] = 'moz' + eventName;
    prefixes['ms' + styleProp] = 'MS' + eventName;
    prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

    return prefixes;
  }

  /**
   * A list of event names to a configurable list of vendor prefixes.
   */
  var vendorPrefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
    animationstart: makePrefixMap('Animation', 'AnimationStart'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };

  /**
   * Event names that have already been detected and prefixed (if applicable).
   */
  var prefixedEventNames = {};

  /**
   * Element to check for prefixes on.
   */
  var style = {};

  /**
   * Bootstrap if a DOM exists.
   */
  if (ExecutionEnvironment.canUseDOM) {
    style = document.createElement('div').style;

    // On some platforms, in particular some releases of Android 4.x,
    // the un-prefixed "animation" and "transition" properties are defined on the
    // style object but the events that fire will still be prefixed, so we need
    // to check if the un-prefixed events are usable, and if not remove them from the map.
    if (!('AnimationEvent' in window)) {
      delete vendorPrefixes.animationend.animation;
      delete vendorPrefixes.animationiteration.animation;
      delete vendorPrefixes.animationstart.animation;
    }

    // Same as above
    if (!('TransitionEvent' in window)) {
      delete vendorPrefixes.transitionend.transition;
    }
  }

  /**
   * Attempts to determine the correct vendor prefixed event name.
   *
   * @param {string} eventName
   * @returns {string}
   */
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    } else if (!vendorPrefixes[eventName]) {
      return eventName;
    }

    var prefixMap = vendorPrefixes[eventName];

    for (var styleProp in prefixMap) {
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
        return prefixedEventNames[eventName] = prefixMap[styleProp];
      }
    }

    return '';
  }

  /**
   * Types of raw signals from the browser caught at the top level.
   *
   * For events like 'submit' which don't consistently bubble (which we
   * trap at a lower node than `document`), binding at `document` would
   * cause duplicate events so we don't include them here.
   */
  var topLevelTypes$1 = {
    topAbort: 'abort',
    topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
    topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
    topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
    topBlur: 'blur',
    topCancel: 'cancel',
    topCanPlay: 'canplay',
    topCanPlayThrough: 'canplaythrough',
    topChange: 'change',
    topClick: 'click',
    topClose: 'close',
    topCompositionEnd: 'compositionend',
    topCompositionStart: 'compositionstart',
    topCompositionUpdate: 'compositionupdate',
    topContextMenu: 'contextmenu',
    topCopy: 'copy',
    topCut: 'cut',
    topDoubleClick: 'dblclick',
    topDrag: 'drag',
    topDragEnd: 'dragend',
    topDragEnter: 'dragenter',
    topDragExit: 'dragexit',
    topDragLeave: 'dragleave',
    topDragOver: 'dragover',
    topDragStart: 'dragstart',
    topDrop: 'drop',
    topDurationChange: 'durationchange',
    topEmptied: 'emptied',
    topEncrypted: 'encrypted',
    topEnded: 'ended',
    topError: 'error',
    topFocus: 'focus',
    topInput: 'input',
    topKeyDown: 'keydown',
    topKeyPress: 'keypress',
    topKeyUp: 'keyup',
    topLoadedData: 'loadeddata',
    topLoad: 'load',
    topLoadedMetadata: 'loadedmetadata',
    topLoadStart: 'loadstart',
    topMouseDown: 'mousedown',
    topMouseMove: 'mousemove',
    topMouseOut: 'mouseout',
    topMouseOver: 'mouseover',
    topMouseUp: 'mouseup',
    topPaste: 'paste',
    topPause: 'pause',
    topPlay: 'play',
    topPlaying: 'playing',
    topProgress: 'progress',
    topRateChange: 'ratechange',
    topScroll: 'scroll',
    topSeeked: 'seeked',
    topSeeking: 'seeking',
    topSelectionChange: 'selectionchange',
    topStalled: 'stalled',
    topSuspend: 'suspend',
    topTextInput: 'textInput',
    topTimeUpdate: 'timeupdate',
    topToggle: 'toggle',
    topTouchCancel: 'touchcancel',
    topTouchEnd: 'touchend',
    topTouchMove: 'touchmove',
    topTouchStart: 'touchstart',
    topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
    topVolumeChange: 'volumechange',
    topWaiting: 'waiting',
    topWheel: 'wheel'
  };

  var BrowserEventConstants = {
    topLevelTypes: topLevelTypes$1
  };

  function runEventQueueInBatch(events) {
    enqueueEvents(events);
    processEventQueue(false);
  }

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }

  var topLevelTypes = BrowserEventConstants.topLevelTypes;

  /**
   * Summary of `ReactBrowserEventEmitter` event handling:
   *
   *  - Top-level delegation is used to trap most native browser events. This
   *    may only occur in the main thread and is the responsibility of
   *    ReactDOMEventListener, which is injected and can therefore support
   *    pluggable event sources. This is the only work that occurs in the main
   *    thread.
   *
   *  - We normalize and de-duplicate events to account for browser quirks. This
   *    may be done in the worker thread.
   *
   *  - Forward these native events (with the associated top-level type used to
   *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
   *    to extract any synthetic events.
   *
   *  - The `EventPluginHub` will then process each event by annotating them with
   *    "dispatches", a sequence of listeners and IDs that care about that event.
   *
   *  - The `EventPluginHub` then dispatches the events.
   *
   * Overview of React and the event system:
   *
   * +------------+    .
   * |    DOM     |    .
   * +------------+    .
   *       |           .
   *       v           .
   * +------------+    .
   * | ReactEvent |    .
   * |  Listener  |    .
   * +------------+    .                         +-----------+
   *       |           .               +--------+|SimpleEvent|
   *       |           .               |         |Plugin     |
   * +-----|------+    .               v         +-----------+
   * |     |      |    .    +--------------+                    +------------+
   * |     +-----------.--->|EventPluginHub|                    |    Event   |
   * |            |    .    |              |     +-----------+  | Propagators|
   * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
   * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
   * |            |    .    |              |     +-----------+  |  utilities |
   * |     +-----------.--->|              |                    +------------+
   * |     |      |    .    +--------------+
   * +-----|------+    .                ^        +-----------+
   *       |           .                |        |Enter/Leave|
   *       +           .                +-------+|Plugin     |
   * +-------------+   .                         +-----------+
   * | application |   .
   * |-------------|   .
   * |             |   .
   * |             |   .
   * +-------------+   .
   *                   .
   *    React Core     .  General Purpose Event Plugin System
   */

  var alreadyListeningTo = {};
  var reactTopListenersCounter = 0;

  /**
   * To ensure no conflicts with other potential React instances on the page
   */
  var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

  function getListeningForDocument(mountAt) {
    // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
    // directly.
    if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
      mountAt[topListenersIDKey] = reactTopListenersCounter++;
      alreadyListeningTo[mountAt[topListenersIDKey]] = {};
    }
    return alreadyListeningTo[mountAt[topListenersIDKey]];
  }

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  function listenTo(registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topScroll') {
          trapCapturedEvent('topScroll', 'scroll', mountAt);
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
          trapCapturedEvent('topFocus', 'focus', mountAt);
          trapCapturedEvent('topBlur', 'blur', mountAt);

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (dependency === 'topCancel') {
          if (isEventSupported('cancel', true)) {
            trapCapturedEvent('topCancel', 'cancel', mountAt);
          }
          isListening.topCancel = true;
        } else if (dependency === 'topClose') {
          if (isEventSupported('close', true)) {
            trapCapturedEvent('topClose', 'close', mountAt);
          }
          isListening.topClose = true;
        } else if (topLevelTypes.hasOwnProperty(dependency)) {
          trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  }

  function isListeningToAllDependencies(registrationName, mountAt) {
    var isListening = getListeningForDocument(mountAt);
    var dependencies = registrationNameDependencies[registrationName];
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        return false;
      }
    }
    return true;
  }

  /**
   * Given any node return the first leaf node without children.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {DOMElement|DOMTextNode}
   */
  function getLeafNode(node) {
    while (node && node.firstChild) {
      node = node.firstChild;
    }
    return node;
  }

  /**
   * Get the next sibling within a container. This will walk up the
   * DOM if a node's siblings have been exhausted.
   *
   * @param {DOMElement|DOMTextNode} node
   * @return {?DOMElement|DOMTextNode}
   */
  function getSiblingNode(node) {
    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }
      node = node.parentNode;
    }
  }

  /**
   * Get object describing the nodes which contain characters at offset.
   *
   * @param {DOMElement|DOMTextNode} root
   * @param {number} offset
   * @return {?object}
   */
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    var nodeStart = 0;
    var nodeEnd = 0;

    while (node) {
      if (node.nodeType === TEXT_NODE) {
        nodeEnd = nodeStart + node.textContent.length;

        if (nodeStart <= offset && nodeEnd >= offset) {
          return {
            node: node,
            offset: offset - nodeStart
          };
        }

        nodeStart = nodeEnd;
      }

      node = getLeafNode(getSiblingNode(node));
    }
  }

  /**
   * @param {DOMElement} outerNode
   * @return {?object}
   */
  function getOffsets(outerNode) {
    var selection = window.getSelection && window.getSelection();

    if (!selection || selection.rangeCount === 0) {
      return null;
    }

    var anchorNode = selection.anchorNode,
        anchorOffset = selection.anchorOffset,
        focusNode$$1 = selection.focusNode,
        focusOffset = selection.focusOffset;

    // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
    // up/down buttons on an <input type="number">. Anonymous divs do not seem to
    // expose properties, triggering a "Permission denied error" if any of its
    // properties are accessed. The only seemingly possible way to avoid erroring
    // is to access a property that typically works for non-anonymous divs and
    // catch any error that may otherwise arise. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

    try {
      /* eslint-disable no-unused-expressions */
      anchorNode.nodeType;
      focusNode$$1.nodeType;
      /* eslint-enable no-unused-expressions */
    } catch (e) {
      return null;
    }

    return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
  }

  /**
   * Returns {start, end} where `start` is the character/codepoint index of
   * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
   * `end` is the index of (focusNode, focusOffset).
   *
   * Returns null if you pass in garbage input but we should probably just crash.
   *
   * Exported only for testing.
   */
  function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
    var length = 0;
    var start = -1;
    var end = -1;
    var indexWithinAnchor = 0;
    var indexWithinFocus = 0;
    var node = outerNode;
    var parentNode = null;

    outer: while (true) {
      var next = null;

      while (true) {
        if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
          start = length + anchorOffset;
        }
        if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
          end = length + focusOffset;
        }

        if (node.nodeType === TEXT_NODE) {
          length += node.nodeValue.length;
        }

        if ((next = node.firstChild) === null) {
          break;
        }
        // Moving from `node` to its first child `next`.
        parentNode = node;
        node = next;
      }

      while (true) {
        if (node === outerNode) {
          // If `outerNode` has children, this is always the second time visiting
          // it. If it has no children, this is still the first loop, and the only
          // valid selection is anchorNode and focusNode both equal to this node
          // and both offsets 0, in which case we will have handled above.
          break outer;
        }
        if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
          start = length;
        }
        if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
          end = length;
        }
        if ((next = node.nextSibling) !== null) {
          break;
        }
        node = parentNode;
        parentNode = node.parentNode;
      }

      // Moving from `node` to its next sibling `next`.
      node = next;
    }

    if (start === -1 || end === -1) {
      // This should never happen. (Would happen if the anchor/focus nodes aren't
      // actually inside the passed-in node.)
      return null;
    }

    return {
      start: start,
      end: end
    };
  }

  /**
   * In modern non-IE browsers, we can support both forward and backward
   * selections.
   *
   * Note: IE10+ supports the Selection object, but it does not support
   * the `extend` method, which means that even in modern IE, it's not possible
   * to programmatically create a backward selection. Thus, for all IE
   * versions, we use the old IE API to create our selections.
   *
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  function setOffsets(node, offsets) {
    if (!window.getSelection) {
      return;
    }

    var selection = window.getSelection();
    var length = node[getTextContentAccessor()].length;
    var start = Math.min(offsets.start, length);
    var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

    // IE 11 uses modern selection, but doesn't support the extend method.
    // Flip backward selections, so we can set with a single range.
    if (!selection.extend && start > end) {
      var temp = end;
      end = start;
      start = temp;
    }

    var startMarker = getNodeForCharacterOffset(node, start);
    var endMarker = getNodeForCharacterOffset(node, end);

    if (startMarker && endMarker) {
      if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
        return;
      }
      var range = document.createRange();
      range.setStart(startMarker.node, startMarker.offset);
      selection.removeAllRanges();

      if (start > end) {
        selection.addRange(range);
        selection.extend(endMarker.node, endMarker.offset);
      } else {
        range.setEnd(endMarker.node, endMarker.offset);
        selection.addRange(range);
      }
    }
  }

  function isInDocument(node) {
    return containsNode(document.documentElement, node);
  }

  /**
   * @ReactInputSelection: React input selection module. Based on Selection.js,
   * but modified to be suitable for react and has a couple of bug fixes (doesn't
   * assume buttons have range selections allowed).
   * Input selection module for React.
   */

  function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  }

  function getSelectionInformation() {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
    };
  }

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  function restoreSelection(priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (hasSelectionCapabilities(priorFocusedElem)) {
        setSelection(priorFocusedElem, priorSelectionRange);
      }

      // Focusing a node can change the scroll position, which is undesirable
      var ancestors = [];
      var ancestor = priorFocusedElem;
      while (ancestor = ancestor.parentNode) {
        if (ancestor.nodeType === ELEMENT_NODE) {
          ancestors.push({
            element: ancestor,
            left: ancestor.scrollLeft,
            top: ancestor.scrollTop
          });
        }
      }

      focusNode(priorFocusedElem);

      for (var i = 0; i < ancestors.length; i++) {
        var info = ancestors[i];
        info.element.scrollLeft = info.left;
        info.element.scrollTop = info.top;
      }
    }
  }

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  function getSelection$1(input) {
    var selection = void 0;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else {
      // Content editable or old IE textarea.
      selection = getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  }

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  function setSelection(input, offsets) {
    var start = offsets.start,
        end = offsets.end;

    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else {
      setOffsets(input, offsets);
    }
  }

  var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

  var eventTypes$3 = {
    select: {
      phasedRegistrationNames: {
        bubbled: 'onSelect',
        captured: 'onSelectCapture'
      },
      dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
    }
  };

  var activeElement$1 = null;
  var activeElementInst$1 = null;
  var lastSelection = null;
  var mouseDown = false;

  /**
   * Get an object which is a unique representation of the current selection.
   *
   * The return value will not be consistent across nodes or browsers, but
   * two identical selections on the same node will return identical objects.
   *
   * @param {DOMElement} node
   * @return {object}
   */
  function getSelection(node) {
    if ('selectionStart' in node && hasSelectionCapabilities(node)) {
      return {
        start: node.selectionStart,
        end: node.selectionEnd
      };
    } else if (window.getSelection) {
      var selection = window.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    }
  }

  /**
   * Poll selection to see whether it's changed.
   *
   * @param {object} nativeEvent
   * @return {?SyntheticEvent}
   */
  function constructSelectEvent(nativeEvent, nativeEventTarget) {
    // Ensure we have the right element, and that the user is not dragging a
    // selection (this matches native `select` event behavior). In HTML5, select
    // fires only on input and textarea thus if there's no focused element we
    // won't dispatch.
    if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
      return null;
    }

    // Only fire when selection has actually changed.
    var currentSelection = getSelection(activeElement$1);
    if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
      lastSelection = currentSelection;

      var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

      syntheticEvent.type = 'select';
      syntheticEvent.target = activeElement$1;

      accumulateTwoPhaseDispatches(syntheticEvent);

      return syntheticEvent;
    }

    return null;
  }

  /**
   * This plugin creates an `onSelect` event that normalizes select events
   * across form elements.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - contentEditable
   *
   * This differs from native browser implementations in the following ways:
   * - Fires on contentEditable fields as well as inputs.
   * - Fires for collapsed selection.
   * - Fires after user input.
   */
  var SelectEventPlugin = {
    eventTypes: eventTypes$3,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
      // Track whether all listeners exists for this plugin. If none exist, we do
      // not extract events. See #3639.
      if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
        return null;
      }

      var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

      switch (topLevelType) {
        // Track the input node that has focus.
        case 'topFocus':
          if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
            activeElement$1 = targetNode;
            activeElementInst$1 = targetInst;
            lastSelection = null;
          }
          break;
        case 'topBlur':
          activeElement$1 = null;
          activeElementInst$1 = null;
          lastSelection = null;
          break;
        // Don't fire the event while the user is dragging. This matches the
        // semantics of the native select event.
        case 'topMouseDown':
          mouseDown = true;
          break;
        case 'topContextMenu':
        case 'topMouseUp':
          mouseDown = false;
          return constructSelectEvent(nativeEvent, nativeEventTarget);
        // Chrome and IE fire non-standard event when selection is changed (and
        // sometimes when it hasn't). IE's event fires out of order with respect
        // to key and input events on deletion, so we discard it.
        //
        // Firefox doesn't support selectionchange, so check selection status
        // after each key entry. The selection changes after keydown and before
        // keyup, but we check on keydown as well in the case of holding down a
        // key, when multiple keydown events are fired but only one keyup is.
        // This is also our approach for IE handling, for the reason above.
        case 'topSelectionChange':
          if (skipSelectionChangeEvent) {
            break;
          }
        // falls through
        case 'topKeyDown':
        case 'topKeyUp':
          return constructSelectEvent(nativeEvent, nativeEventTarget);
      }

      return null;
    }
  };

  /**
   * @interface Event
   * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
   */
  var AnimationEventInterface = {
    animationName: null,
    elapsedTime: null,
    pseudoElement: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

  /**
   * @interface Event
   * @see http://www.w3.org/TR/clipboard-apis/
   */
  var ClipboardEventInterface = {
    clipboardData: function (event) {
      return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
    }
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

  /**
   * @interface FocusEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var FocusEventInterface = {
    relatedTarget: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

  /**
   * `charCode` represents the actual "character code" and is safe to use with
   * `String.fromCharCode`. As such, only keys that correspond to printable
   * characters produce a valid `charCode`, the only exception to this is Enter.
   * The Tab-key is considered non-printable and does not have a `charCode`,
   * presumably because it does not produce a tab-character in browsers.
   *
   * @param {object} nativeEvent Native browser event.
   * @return {number} Normalized `charCode` property.
   */
  function getEventCharCode(nativeEvent) {
    var charCode;
    var keyCode = nativeEvent.keyCode;

    if ('charCode' in nativeEvent) {
      charCode = nativeEvent.charCode;

      // FF does not set `charCode` for the Enter-key, check against `keyCode`.
      if (charCode === 0 && keyCode === 13) {
        charCode = 13;
      }
    } else {
      // IE8 does not implement `charCode`, but `keyCode` has the correct value.
      charCode = keyCode;
    }

    // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
    // Must not discard the (non-)printable Enter-key.
    if (charCode >= 32 || charCode === 13) {
      return charCode;
    }

    return 0;
  }

  /**
   * Normalization of deprecated HTML5 `key` values
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */
  var normalizeKey = {
    Esc: 'Escape',
    Spacebar: ' ',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Win: 'OS',
    Menu: 'ContextMenu',
    Apps: 'ContextMenu',
    Scroll: 'ScrollLock',
    MozPrintableKey: 'Unidentified'
  };

  /**
   * Translation from legacy `keyCode` to HTML5 `key`
   * Only special keys supported, all others depend on keyboard layout or browser
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */
  var translateToKey = {
    '8': 'Backspace',
    '9': 'Tab',
    '12': 'Clear',
    '13': 'Enter',
    '16': 'Shift',
    '17': 'Control',
    '18': 'Alt',
    '19': 'Pause',
    '20': 'CapsLock',
    '27': 'Escape',
    '32': ' ',
    '33': 'PageUp',
    '34': 'PageDown',
    '35': 'End',
    '36': 'Home',
    '37': 'ArrowLeft',
    '38': 'ArrowUp',
    '39': 'ArrowRight',
    '40': 'ArrowDown',
    '45': 'Insert',
    '46': 'Delete',
    '112': 'F1',
    '113': 'F2',
    '114': 'F3',
    '115': 'F4',
    '116': 'F5',
    '117': 'F6',
    '118': 'F7',
    '119': 'F8',
    '120': 'F9',
    '121': 'F10',
    '122': 'F11',
    '123': 'F12',
    '144': 'NumLock',
    '145': 'ScrollLock',
    '224': 'Meta'
  };

  /**
   * @param {object} nativeEvent Native browser event.
   * @return {string} Normalized `key` property.
   */
  function getEventKey(nativeEvent) {
    if (nativeEvent.key) {
      // Normalize inconsistent values reported by browsers due to
      // implementations of a working draft specification.

      // FireFox implements `key` but returns `MozPrintableKey` for all
      // printable characters (normalized to `Unidentified`), ignore it.
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if (key !== 'Unidentified') {
        return key;
      }
    }

    // Browser does not implement `key`, polyfill as much of it as we can.
    if (nativeEvent.type === 'keypress') {
      var charCode = getEventCharCode(nativeEvent);

      // The enter-key is technically both printable and non-printable and can
      // thus be captured by `keypress`, no other non-printable key should.
      return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
    }
    if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
      // While user keyboard layout determines the actual meaning of each
      // `keyCode` value, almost all function keys have a universal value.
      return translateToKey[nativeEvent.keyCode] || 'Unidentified';
    }
    return '';
  }

  /**
   * @interface KeyboardEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var KeyboardEventInterface = {
    key: getEventKey,
    location: null,
    ctrlKey: null,
    shiftKey: null,
    altKey: null,
    metaKey: null,
    repeat: null,
    locale: null,
    getModifierState: getEventModifierState,
    // Legacy Interface
    charCode: function (event) {
      // `charCode` is the result of a KeyPress event and represents the value of
      // the actual printable character.

      // KeyPress is deprecated, but its replacement is not yet final and not
      // implemented in any major browser. Only KeyPress has charCode.
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      return 0;
    },
    keyCode: function (event) {
      // `keyCode` is the result of a KeyDown/Up event and represents the value of
      // physical keyboard key.

      // The actual meaning of the value depends on the users' keyboard layout
      // which cannot be detected. Assuming that it is a US keyboard layout
      // provides a surprisingly accurate mapping for US and European users.
      // Due to this, it is left to the user to implement at this time.
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    },
    which: function (event) {
      // `which` is an alias for either `keyCode` or `charCode` depending on the
      // type of the event.
      if (event.type === 'keypress') {
        return getEventCharCode(event);
      }
      if (event.type === 'keydown' || event.type === 'keyup') {
        return event.keyCode;
      }
      return 0;
    }
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

  /**
   * @interface DragEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var DragEventInterface = {
    dataTransfer: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticMouseEvent}
   */
  function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

  /**
   * @interface TouchEvent
   * @see http://www.w3.org/TR/touch-events/
   */
  var TouchEventInterface = {
    touches: null,
    targetTouches: null,
    changedTouches: null,
    altKey: null,
    metaKey: null,
    ctrlKey: null,
    shiftKey: null,
    getModifierState: getEventModifierState
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticUIEvent}
   */
  function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

  /**
   * @interface Event
   * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
   * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
   */
  var TransitionEventInterface = {
    propertyName: null,
    elapsedTime: null,
    pseudoElement: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticEvent}
   */
  function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

  /**
   * @interface WheelEvent
   * @see http://www.w3.org/TR/DOM-Level-3-Events/
   */
  var WheelEventInterface = {
    deltaX: function (event) {
      return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
      'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function (event) {
      return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
      'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
      'wheelDelta' in event ? -event.wheelDelta : 0;
    },
    deltaZ: null,

    // Browsers without "deltaMode" is reporting in raw wheel delta where one
    // notch on the scroll is always +/- 120, roughly equivalent to pixels.
    // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
    // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
    deltaMode: null
  };

  /**
   * @param {object} dispatchConfig Configuration used to dispatch this event.
   * @param {string} dispatchMarker Marker identifying the event target.
   * @param {object} nativeEvent Native browser event.
   * @extends {SyntheticMouseEvent}
   */
  function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
    return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
  }

  SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

  /**
   * Turns
   * ['abort', ...]
   * into
   * eventTypes = {
   *   'abort': {
   *     phasedRegistrationNames: {
   *       bubbled: 'onAbort',
   *       captured: 'onAbortCapture',
   *     },
   *     dependencies: ['topAbort'],
   *   },
   *   ...
   * };
   * topLevelEventsToDispatchConfig = {
   *   'topAbort': { sameConfig }
   * };
   */
  var eventTypes$4 = {};
  var topLevelEventsToDispatchConfig = {};
  ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
    var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
    var onEvent = 'on' + capitalizedEvent;
    var topEvent = 'top' + capitalizedEvent;

    var type = {
      phasedRegistrationNames: {
        bubbled: onEvent,
        captured: onEvent + 'Capture'
      },
      dependencies: [topEvent]
    };
    eventTypes$4[event] = type;
    topLevelEventsToDispatchConfig[topEvent] = type;
  });

  // Only used in DEV for exhaustiveness validation.
  var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

  var SimpleEventPlugin = {
    eventTypes: eventTypes$4,

    extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
      if (!dispatchConfig) {
        return null;
      }
      var EventConstructor;
      switch (topLevelType) {
        case 'topKeyPress':
          // Firefox creates a keypress event for function keys too. This removes
          // the unwanted keypress events. Enter is however both printable and
          // non-printable. One would expect Tab to be as well (but it isn't).
          if (getEventCharCode(nativeEvent) === 0) {
            return null;
          }
        /* falls through */
        case 'topKeyDown':
        case 'topKeyUp':
          EventConstructor = SyntheticKeyboardEvent;
          break;
        case 'topBlur':
        case 'topFocus':
          EventConstructor = SyntheticFocusEvent;
          break;
        case 'topClick':
          // Firefox creates a click event on right mouse clicks. This removes the
          // unwanted click events.
          if (nativeEvent.button === 2) {
            return null;
          }
        /* falls through */
        case 'topDoubleClick':
        case 'topMouseDown':
        case 'topMouseMove':
        case 'topMouseUp':
        // TODO: Disabled elements should not respond to mouse events
        /* falls through */
        case 'topMouseOut':
        case 'topMouseOver':
        case 'topContextMenu':
          EventConstructor = SyntheticMouseEvent;
          break;
        case 'topDrag':
        case 'topDragEnd':
        case 'topDragEnter':
        case 'topDragExit':
        case 'topDragLeave':
        case 'topDragOver':
        case 'topDragStart':
        case 'topDrop':
          EventConstructor = SyntheticDragEvent;
          break;
        case 'topTouchCancel':
        case 'topTouchEnd':
        case 'topTouchMove':
        case 'topTouchStart':
          EventConstructor = SyntheticTouchEvent;
          break;
        case 'topAnimationEnd':
        case 'topAnimationIteration':
        case 'topAnimationStart':
          EventConstructor = SyntheticAnimationEvent;
          break;
        case 'topTransitionEnd':
          EventConstructor = SyntheticTransitionEvent;
          break;
        case 'topScroll':
          EventConstructor = SyntheticUIEvent;
          break;
        case 'topWheel':
          EventConstructor = SyntheticWheelEvent;
          break;
        case 'topCopy':
        case 'topCut':
        case 'topPaste':
          EventConstructor = SyntheticClipboardEvent;
          break;
        default:
          {
            if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
              warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
            }
          }
          // HTML Events
          // @see http://www.w3.org/TR/html5/index.html#events-0
          EventConstructor = SyntheticEvent$1;
          break;
      }
      var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
      accumulateTwoPhaseDispatches(event);
      return event;
    }
  };

  setHandleTopLevel(handleTopLevel);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  injection$1.injectEventPluginOrder(DOMEventPluginOrder);
  injection$2.injectComponentTree(ReactDOMComponentTree);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  injection$1.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  var enableAsyncSubtreeAPI = true;
  var enableAsyncSchedulingByDefaultInReactDOM = false;
  // Exports ReactDOM.createRoot
  var enableCreateRoot = false;
  var enableUserTimingAPI = true;

  // Mutating mode (React DOM, React ART, React Native):
  var enableMutatingReconciler = true;
  // Experimental noop mode (currently unused):
  var enableNoopReconciler = false;
  // Experimental persistent mode (CS):
  var enablePersistentReconciler = false;

  // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
  var debugRenderPhaseSideEffects = false;

  // Only used in www builds.

  var valueStack = [];

  {
    var fiberStack = [];
  }

  var index = -1;

  function createCursor(defaultValue) {
    return {
      current: defaultValue
    };
  }



  function pop(cursor, fiber) {
    if (index < 0) {
      {
        warning(false, 'Unexpected pop.');
      }
      return;
    }

    {
      if (fiber !== fiberStack[index]) {
        warning(false, 'Unexpected Fiber popped.');
      }
    }

    cursor.current = valueStack[index];

    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }

  function push(cursor, value, fiber) {
    index++;

    valueStack[index] = cursor.current;

    {
      fiberStack[index] = fiber;
    }

    cursor.current = value;
  }

  function reset$1() {
    while (index > -1) {
      valueStack[index] = null;

      {
        fiberStack[index] = null;
      }

      index--;
    }
  }

  var describeComponentFrame = function (name, source, ownerName) {
    return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
  };

  function describeFiber(fiber) {
    switch (fiber.tag) {
      case IndeterminateComponent:
      case FunctionalComponent:
      case ClassComponent:
      case HostComponent:
        var owner = fiber._debugOwner;
        var source = fiber._debugSource;
        var name = getComponentName(fiber);
        var ownerName = null;
        if (owner) {
          ownerName = getComponentName(owner);
        }
        return describeComponentFrame(name, source, ownerName);
      default:
        return '';
    }
  }

  // This function can only be called with a work-in-progress fiber and
  // only during begin or complete phase. Do not call it under any other
  // circumstances.
  function getStackAddendumByWorkInProgressFiber(workInProgress) {
    var info = '';
    var node = workInProgress;
    do {
      info += describeFiber(node);
      // Otherwise this return pointer might point to the wrong tree:
      node = node['return'];
    } while (node);
    return info;
  }

  function getCurrentFiberOwnerName() {
    {
      var fiber = ReactDebugCurrentFiber.current;
      if (fiber === null) {
        return null;
      }
      var owner = fiber._debugOwner;
      if (owner !== null && typeof owner !== 'undefined') {
        return getComponentName(owner);
      }
    }
    return null;
  }

  function getCurrentFiberStackAddendum() {
    {
      var fiber = ReactDebugCurrentFiber.current;
      if (fiber === null) {
        return null;
      }
      // Safe because if current fiber exists, we are reconciling,
      // and it is guaranteed to be the work-in-progress version.
      return getStackAddendumByWorkInProgressFiber(fiber);
    }
    return null;
  }

  function resetCurrentFiber() {
    ReactDebugCurrentFrame.getCurrentStack = null;
    ReactDebugCurrentFiber.current = null;
    ReactDebugCurrentFiber.phase = null;
  }

  function setCurrentFiber(fiber) {
    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
    ReactDebugCurrentFiber.current = fiber;
    ReactDebugCurrentFiber.phase = null;
  }

  function setCurrentPhase(phase) {
    ReactDebugCurrentFiber.phase = phase;
  }

  var ReactDebugCurrentFiber = {
    current: null,
    phase: null,
    resetCurrentFiber: resetCurrentFiber,
    setCurrentFiber: setCurrentFiber,
    setCurrentPhase: setCurrentPhase,
    getCurrentFiberOwnerName: getCurrentFiberOwnerName,
    getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
  };

  // Prefix measurements so that it's possible to filter them.
  // Longer prefixes are hard to read in DevTools.
  var reactEmoji = '\u269B';
  var warningEmoji = '\u26D4';
  var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

  // Keep track of current fiber so that we know the path to unwind on pause.
  // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
  var currentFiber = null;
  // If we're in the middle of user code, which fiber and method is it?
  // Reusing `currentFiber` would be confusing for this because user code fiber
  // can change during commit phase too, but we don't need to unwind it (since
  // lifecycles in the commit phase don't resemble a tree).
  var currentPhase = null;
  var currentPhaseFiber = null;
  // Did lifecycle hook schedule an update? This is often a performance problem,
  // so we will keep track of it, and include it in the report.
  // Track commits caused by cascading updates.
  var isCommitting = false;
  var hasScheduledUpdateInCurrentCommit = false;
  var hasScheduledUpdateInCurrentPhase = false;
  var commitCountInCurrentWorkLoop = 0;
  var effectCountInCurrentCommit = 0;
  var isWaitingForCallback = false;
  // During commits, we only show a measurement once per method name
  // to avoid stretch the commit phase with measurement overhead.
  var labelsInCurrentCommit = new Set();

  var formatMarkName = function (markName) {
    return reactEmoji + ' ' + markName;
  };

  var formatLabel = function (label, warning$$1) {
    var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
    var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
    return '' + prefix + label + suffix;
  };

  var beginMark = function (markName) {
    performance.mark(formatMarkName(markName));
  };

  var clearMark = function (markName) {
    performance.clearMarks(formatMarkName(markName));
  };

  var endMark = function (label, markName, warning$$1) {
    var formattedMarkName = formatMarkName(markName);
    var formattedLabel = formatLabel(label, warning$$1);
    try {
      performance.measure(formattedLabel, formattedMarkName);
    } catch (err) {}
    // If previous mark was missing for some reason, this will throw.
    // This could only happen if React crashed in an unexpected place earlier.
    // Don't pile on with more errors.

    // Clear marks immediately to avoid growing buffer.
    performance.clearMarks(formattedMarkName);
    performance.clearMeasures(formattedLabel);
  };

  var getFiberMarkName = function (label, debugID) {
    return label + ' (#' + debugID + ')';
  };

  var getFiberLabel = function (componentName, isMounted, phase) {
    if (phase === null) {
      // These are composite component total time measurements.
      return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
    } else {
      // Composite component methods.
      return componentName + '.' + phase;
    }
  };

  var beginFiberMark = function (fiber, phase) {
    var componentName = getComponentName(fiber) || 'Unknown';
    var debugID = fiber._debugID;
    var isMounted = fiber.alternate !== null;
    var label = getFiberLabel(componentName, isMounted, phase);

    if (isCommitting && labelsInCurrentCommit.has(label)) {
      // During the commit phase, we don't show duplicate labels because
      // there is a fixed overhead for every measurement, and we don't
      // want to stretch the commit phase beyond necessary.
      return false;
    }
    labelsInCurrentCommit.add(label);

    var markName = getFiberMarkName(label, debugID);
    beginMark(markName);
    return true;
  };

  var clearFiberMark = function (fiber, phase) {
    var componentName = getComponentName(fiber) || 'Unknown';
    var debugID = fiber._debugID;
    var isMounted = fiber.alternate !== null;
    var label = getFiberLabel(componentName, isMounted, phase);
    var markName = getFiberMarkName(label, debugID);
    clearMark(markName);
  };

  var endFiberMark = function (fiber, phase, warning$$1) {
    var componentName = getComponentName(fiber) || 'Unknown';
    var debugID = fiber._debugID;
    var isMounted = fiber.alternate !== null;
    var label = getFiberLabel(componentName, isMounted, phase);
    var markName = getFiberMarkName(label, debugID);
    endMark(label, markName, warning$$1);
  };

  var shouldIgnoreFiber = function (fiber) {
    // Host components should be skipped in the timeline.
    // We could check typeof fiber.type, but does this work with RN?
    switch (fiber.tag) {
      case HostRoot:
      case HostComponent:
      case HostText:
      case HostPortal:
      case ReturnComponent:
      case Fragment:
        return true;
      default:
        return false;
    }
  };

  var clearPendingPhaseMeasurement = function () {
    if (currentPhase !== null && currentPhaseFiber !== null) {
      clearFiberMark(currentPhaseFiber, currentPhase);
    }
    currentPhaseFiber = null;
    currentPhase = null;
    hasScheduledUpdateInCurrentPhase = false;
  };

  var pauseTimers = function () {
    // Stops all currently active measurements so that they can be resumed
    // if we continue in a later deferred loop from the same unit of work.
    var fiber = currentFiber;
    while (fiber) {
      if (fiber._debugIsCurrentlyTiming) {
        endFiberMark(fiber, null, null);
      }
      fiber = fiber['return'];
    }
  };

  var resumeTimersRecursively = function (fiber) {
    if (fiber['return'] !== null) {
      resumeTimersRecursively(fiber['return']);
    }
    if (fiber._debugIsCurrentlyTiming) {
      beginFiberMark(fiber, null);
    }
  };

  var resumeTimers = function () {
    // Resumes all measurements that were active during the last deferred loop.
    if (currentFiber !== null) {
      resumeTimersRecursively(currentFiber);
    }
  };

  function recordEffect() {
    if (enableUserTimingAPI) {
      effectCountInCurrentCommit++;
    }
  }

  function recordScheduleUpdate() {
    if (enableUserTimingAPI) {
      if (isCommitting) {
        hasScheduledUpdateInCurrentCommit = true;
      }
      if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
        hasScheduledUpdateInCurrentPhase = true;
      }
    }
  }

  function startRequestCallbackTimer() {
    if (enableUserTimingAPI) {
      if (supportsUserTiming && !isWaitingForCallback) {
        isWaitingForCallback = true;
        beginMark('(Waiting for async callback...)');
      }
    }
  }

  function stopRequestCallbackTimer(didExpire) {
    if (enableUserTimingAPI) {
      if (supportsUserTiming) {
        isWaitingForCallback = false;
        var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
        endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
      }
    }
  }

  function startWorkTimer(fiber) {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
        return;
      }
      // If we pause, this is the fiber to unwind from.
      currentFiber = fiber;
      if (!beginFiberMark(fiber, null)) {
        return;
      }
      fiber._debugIsCurrentlyTiming = true;
    }
  }

  function cancelWorkTimer(fiber) {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
        return;
      }
      // Remember we shouldn't complete measurement for this fiber.
      // Otherwise flamechart will be deep even for small updates.
      fiber._debugIsCurrentlyTiming = false;
      clearFiberMark(fiber, null);
    }
  }

  function stopWorkTimer(fiber) {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
        return;
      }
      // If we pause, its parent is the fiber to unwind from.
      currentFiber = fiber['return'];
      if (!fiber._debugIsCurrentlyTiming) {
        return;
      }
      fiber._debugIsCurrentlyTiming = false;
      endFiberMark(fiber, null, null);
    }
  }

  function stopFailedWorkTimer(fiber) {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
        return;
      }
      // If we pause, its parent is the fiber to unwind from.
      currentFiber = fiber['return'];
      if (!fiber._debugIsCurrentlyTiming) {
        return;
      }
      fiber._debugIsCurrentlyTiming = false;
      var warning$$1 = 'An error was thrown inside this error boundary';
      endFiberMark(fiber, null, warning$$1);
    }
  }

  function startPhaseTimer(fiber, phase) {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      clearPendingPhaseMeasurement();
      if (!beginFiberMark(fiber, phase)) {
        return;
      }
      currentPhaseFiber = fiber;
      currentPhase = phase;
    }
  }

  function stopPhaseTimer() {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      if (currentPhase !== null && currentPhaseFiber !== null) {
        var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
        endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
      }
      currentPhase = null;
      currentPhaseFiber = null;
    }
  }

  function startWorkLoopTimer(nextUnitOfWork) {
    if (enableUserTimingAPI) {
      currentFiber = nextUnitOfWork;
      if (!supportsUserTiming) {
        return;
      }
      commitCountInCurrentWorkLoop = 0;
      // This is top level call.
      // Any other measurements are performed within.
      beginMark('(React Tree Reconciliation)');
      // Resume any measurements that were in progress during the last loop.
      resumeTimers();
    }
  }

  function stopWorkLoopTimer(interruptedBy) {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      var warning$$1 = null;
      if (interruptedBy !== null) {
        if (interruptedBy.tag === HostRoot) {
          warning$$1 = 'A top-level update interrupted the previous render';
        } else {
          var componentName = getComponentName(interruptedBy) || 'Unknown';
          warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
        }
      } else if (commitCountInCurrentWorkLoop > 1) {
        warning$$1 = 'There were cascading updates';
      }
      commitCountInCurrentWorkLoop = 0;
      // Pause any measurements until the next loop.
      pauseTimers();
      endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
    }
  }

  function startCommitTimer() {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      isCommitting = true;
      hasScheduledUpdateInCurrentCommit = false;
      labelsInCurrentCommit.clear();
      beginMark('(Committing Changes)');
    }
  }

  function stopCommitTimer() {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }

      var warning$$1 = null;
      if (hasScheduledUpdateInCurrentCommit) {
        warning$$1 = 'Lifecycle hook scheduled a cascading update';
      } else if (commitCountInCurrentWorkLoop > 0) {
        warning$$1 = 'Caused by a cascading update in earlier commit';
      }
      hasScheduledUpdateInCurrentCommit = false;
      commitCountInCurrentWorkLoop++;
      isCommitting = false;
      labelsInCurrentCommit.clear();

      endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
    }
  }

  function startCommitHostEffectsTimer() {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      effectCountInCurrentCommit = 0;
      beginMark('(Committing Host Effects)');
    }
  }

  function stopCommitHostEffectsTimer() {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      var count = effectCountInCurrentCommit;
      effectCountInCurrentCommit = 0;
      endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
    }
  }

  function startCommitLifeCyclesTimer() {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      effectCountInCurrentCommit = 0;
      beginMark('(Calling Lifecycle Methods)');
    }
  }

  function stopCommitLifeCyclesTimer() {
    if (enableUserTimingAPI) {
      if (!supportsUserTiming) {
        return;
      }
      var count = effectCountInCurrentCommit;
      effectCountInCurrentCommit = 0;
      endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
    }
  }

  {
    var warnedAboutMissingGetChildContext = {};
  }

  // A cursor to the current merged context object on the stack.
  var contextStackCursor = createCursor(emptyObject);
  // A cursor to a boolean indicating whether the context has changed.
  var didPerformWorkStackCursor = createCursor(false);
  // Keep track of the previous context object that was on the stack.
  // We use this to get access to the parent context after we have already
  // pushed the next context provider, and now need to merge their contexts.
  var previousContext = emptyObject;

  function getUnmaskedContext(workInProgress) {
    var hasOwnContext = isContextProvider(workInProgress);
    if (hasOwnContext) {
      // If the fiber is a context provider itself, when we read its context
      // we have already pushed its own child context on the stack. A context
      // provider should not "see" its own child context. Therefore we read the
      // previous (parent) context instead for a context provider.
      return previousContext;
    }
    return contextStackCursor.current;
  }

  function cacheContext(workInProgress, unmaskedContext, maskedContext) {
    var instance = workInProgress.stateNode;
    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
  }

  function getMaskedContext(workInProgress, unmaskedContext) {
    var type = workInProgress.type;
    var contextTypes = type.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }

    // Avoid recreating masked context unless unmasked context has changed.
    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
    // This may trigger infinite loops if componentWillReceiveProps calls setState.
    var instance = workInProgress.stateNode;
    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
      return instance.__reactInternalMemoizedMaskedChildContext;
    }

    var context = {};
    for (var key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    {
      var name = getComponentName(workInProgress) || 'Unknown';
      checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
    }

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // Context is created before the class component is instantiated so check for instance.
    if (instance) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return context;
  }

  function hasContextChanged() {
    return didPerformWorkStackCursor.current;
  }

  function isContextConsumer(fiber) {
    return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
  }

  function isContextProvider(fiber) {
    return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
  }

  function popContextProvider(fiber) {
    if (!isContextProvider(fiber)) {
      return;
    }

    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }

  function popTopLevelContextObject(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }

  function pushTopLevelContextObject(fiber, context, didChange) {
    !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }

  function processChildContext(fiber, parentContext) {
    var instance = fiber.stateNode;
    var childContextTypes = fiber.type.childContextTypes;

    // TODO (bvaughn) Replace this behavior with an invariant() in the future.
    // It has only been added in Fiber to match the (unintentional) behavior in Stack.
    if (typeof instance.getChildContext !== 'function') {
      {
        var componentName = getComponentName(fiber) || 'Unknown';

        if (!warnedAboutMissingGetChildContext[componentName]) {
          warnedAboutMissingGetChildContext[componentName] = true;
          warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
        }
      }
      return parentContext;
    }

    var childContext = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
    }
    startPhaseTimer(fiber, 'getChildContext');
    childContext = instance.getChildContext();
    stopPhaseTimer();
    {
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    for (var contextKey in childContext) {
      !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
    }
    {
      var name = getComponentName(fiber) || 'Unknown';
      checkPropTypes(childContextTypes, childContext, 'child context', name,
      // In practice, there is one case in which we won't get a stack. It's when
      // somebody calls unstable_renderSubtreeIntoContainer() and we process
      // context from the parent component instance. The stack will be missing
      // because it's outside of the reconciliation, and so the pointer has not
      // been set. This is rare and doesn't matter. We'll also remove that API.
      ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
    }

    return _assign({}, parentContext, childContext);
  }

  function pushContextProvider(workInProgress) {
    if (!isContextProvider(workInProgress)) {
      return false;
    }

    var instance = workInProgress.stateNode;
    // We push the context as early as possible to ensure stack integrity.
    // If the instance does not exist yet, we will push null at first,
    // and replace it on the stack later when invalidating the context.
    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

    // Remember the parent context so we can merge with it later.
    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
    previousContext = contextStackCursor.current;
    push(contextStackCursor, memoizedMergedChildContext, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

    return true;
  }

  function invalidateContextProvider(workInProgress, didChange) {
    var instance = workInProgress.stateNode;
    !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    if (didChange) {
      // Merge parent and own context.
      // Skip this if we're not updating due to sCU.
      // This avoids unnecessarily recomputing memoized values.
      var mergedContext = processChildContext(workInProgress, previousContext);
      instance.__reactInternalMemoizedMergedChildContext = mergedContext;

      // Replace the old (or empty) context with the new one.
      // It is important to unwind the context in the reverse order.
      pop(didPerformWorkStackCursor, workInProgress);
      pop(contextStackCursor, workInProgress);
      // Now push the new context and mark that it has changed.
      push(contextStackCursor, mergedContext, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    } else {
      pop(didPerformWorkStackCursor, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    }
  }

  function resetContext() {
    previousContext = emptyObject;
    contextStackCursor.current = emptyObject;
    didPerformWorkStackCursor.current = false;
  }

  function findCurrentUnmaskedContext(fiber) {
    // Currently this is only used with renderSubtreeIntoContainer; not sure if it
    // makes sense elsewhere
    !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var node = fiber;
    while (node.tag !== HostRoot) {
      if (isContextProvider(node)) {
        return node.stateNode.__reactInternalMemoizedMergedChildContext;
      }
      var parent = node['return'];
      !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      node = parent;
    }
    return node.stateNode.context;
  }

  var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

  var Sync = 1;
  var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

  var UNIT_SIZE = 10;
  var MAGIC_NUMBER_OFFSET = 2;

  // 1 unit of expiration time represents 10ms.
  function msToExpirationTime(ms) {
    // Always add an offset so that we don't clash with the magic number for NoWork.
    return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
  }

  function expirationTimeToMs(expirationTime) {
    return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
  }

  function ceiling(num, precision) {
    return ((num / precision | 0) + 1) * precision;
  }

  function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
    return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
  }

  var NoContext = 0;
  var AsyncUpdates = 1;

  {
    var hasBadMapPolyfill = false;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      /* eslint-disable no-new */

      /* eslint-enable no-new */
    } catch (e) {
      // TODO: Consider warning about bad polyfills
      hasBadMapPolyfill = true;
    }
  }

  // A Fiber is work on a Component that needs to be done or was done. There can
  // be more than one per component.


  {
    var debugCounter = 1;
  }

  function FiberNode(tag, key, internalContextTag) {
    // Instance
    this.tag = tag;
    this.key = key;
    this.type = null;
    this.stateNode = null;

    // Fiber
    this['return'] = null;
    this.child = null;
    this.sibling = null;
    this.index = 0;

    this.ref = null;

    this.pendingProps = null;
    this.memoizedProps = null;
    this.updateQueue = null;
    this.memoizedState = null;

    this.internalContextTag = internalContextTag;

    // Effects
    this.effectTag = NoEffect;
    this.nextEffect = null;

    this.firstEffect = null;
    this.lastEffect = null;

    this.expirationTime = NoWork;

    this.alternate = null;

    {
      this._debugID = debugCounter++;
      this._debugSource = null;
      this._debugOwner = null;
      this._debugIsCurrentlyTiming = false;
      if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
        Object.preventExtensions(this);
      }
    }
  }

  // This is a constructor function, rather than a POJO constructor, still
  // please ensure we do the following:
  // 1) Nobody should add any instance methods on this. Instance methods can be
  //    more difficult to predict when they get optimized and they are almost
  //    never inlined properly in static compilers.
  // 2) Nobody should rely on `instanceof Fiber` for type testing. We should
  //    always know when it is a fiber.
  // 3) We might want to experiment with using numeric keys since they are easier
  //    to optimize in a non-JIT environment.
  // 4) We can easily go from a constructor to a createFiber object literal if that
  //    is faster.
  // 5) It should be easy to port this to a C struct and keep a C implementation
  //    compatible.
  var createFiber = function (tag, key, internalContextTag) {
    // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
    return new FiberNode(tag, key, internalContextTag);
  };

  function shouldConstruct(Component) {
    return !!(Component.prototype && Component.prototype.isReactComponent);
  }

  // This is used to create an alternate fiber to do work on.
  function createWorkInProgress(current, pendingProps, expirationTime) {
    var workInProgress = current.alternate;
    if (workInProgress === null) {
      // We use a double buffering pooling technique because we know that we'll
      // only ever need at most two versions of a tree. We pool the "other" unused
      // node that we're free to reuse. This is lazily created to avoid allocating
      // extra objects for things that are never updated. It also allow us to
      // reclaim the extra memory if needed.
      workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
      workInProgress.type = current.type;
      workInProgress.stateNode = current.stateNode;

      {
        // DEV-only fields
        workInProgress._debugID = current._debugID;
        workInProgress._debugSource = current._debugSource;
        workInProgress._debugOwner = current._debugOwner;
      }

      workInProgress.alternate = current;
      current.alternate = workInProgress;
    } else {
      // We already have an alternate.
      // Reset the effect tag.
      workInProgress.effectTag = NoEffect;

      // The effect list is no longer valid.
      workInProgress.nextEffect = null;
      workInProgress.firstEffect = null;
      workInProgress.lastEffect = null;
    }

    workInProgress.expirationTime = expirationTime;
    workInProgress.pendingProps = pendingProps;

    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;

    // These will be overridden during the parent's reconciliation
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;

    return workInProgress;
  }

  function createHostRootFiber() {
    var fiber = createFiber(HostRoot, null, NoContext);
    return fiber;
  }

  function createFiberFromElement(element, internalContextTag, expirationTime) {
    var owner = null;
    {
      owner = element._owner;
    }

    var fiber = void 0;
    var type = element.type,
        key = element.key;

    if (typeof type === 'function') {
      fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
      fiber.type = type;
      fiber.pendingProps = element.props;
    } else if (typeof type === 'string') {
      fiber = createFiber(HostComponent, key, internalContextTag);
      fiber.type = type;
      fiber.pendingProps = element.props;
    } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
      // Currently assumed to be a continuation and therefore is a fiber already.
      // TODO: The yield system is currently broken for updates in some cases.
      // The reified yield stores a fiber, but we don't know which fiber that is;
      // the current or a workInProgress? When the continuation gets rendered here
      // we don't know if we can reuse that fiber or if we need to clone it.
      // There is probably a clever way to restructure this.
      fiber = type;
      fiber.pendingProps = element.props;
    } else {
      var info = '';
      {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }
        var ownerName = owner ? getComponentName(owner) : null;
        if (ownerName) {
          info += '\n\nCheck the render method of `' + ownerName + '`.';
        }
      }
      invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
    }

    {
      fiber._debugSource = element._source;
      fiber._debugOwner = element._owner;
    }

    fiber.expirationTime = expirationTime;

    return fiber;
  }

  function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
    var fiber = createFiber(Fragment, key, internalContextTag);
    fiber.pendingProps = elements;
    fiber.expirationTime = expirationTime;
    return fiber;
  }

  function createFiberFromText(content, internalContextTag, expirationTime) {
    var fiber = createFiber(HostText, null, internalContextTag);
    fiber.pendingProps = content;
    fiber.expirationTime = expirationTime;
    return fiber;
  }

  function createFiberFromHostInstanceForDeletion() {
    var fiber = createFiber(HostComponent, null, NoContext);
    fiber.type = 'DELETED';
    return fiber;
  }

  function createFiberFromCall(call, internalContextTag, expirationTime) {
    var fiber = createFiber(CallComponent, call.key, internalContextTag);
    fiber.type = call.handler;
    fiber.pendingProps = call;
    fiber.expirationTime = expirationTime;
    return fiber;
  }

  function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
    var fiber = createFiber(ReturnComponent, null, internalContextTag);
    fiber.expirationTime = expirationTime;
    return fiber;
  }

  function createFiberFromPortal(portal, internalContextTag, expirationTime) {
    var fiber = createFiber(HostPortal, portal.key, internalContextTag);
    fiber.pendingProps = portal.children || [];
    fiber.expirationTime = expirationTime;
    fiber.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null, // Used by persistent updates
      implementation: portal.implementation
    };
    return fiber;
  }

  function createFiberRoot(containerInfo, hydrate) {
    // Cyclic construction. This cheats the type system right now because
    // stateNode is any.
    var uninitializedFiber = createHostRootFiber();
    var root = {
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,
      remainingExpirationTime: NoWork,
      isReadyForCommit: false,
      finishedWork: null,
      context: null,
      pendingContext: null,
      hydrate: hydrate,
      nextScheduledRoot: null
    };
    uninitializedFiber.stateNode = root;
    return root;
  }

  var onCommitFiberRoot = null;
  var onCommitFiberUnmount = null;
  var hasLoggedError = false;

  function catchErrors(fn) {
    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {
        if (true && !hasLoggedError) {
          hasLoggedError = true;
          warning(false, 'React DevTools encountered an error: %s', err);
        }
      }
    };
  }

  function injectInternals(internals) {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // No DevTools
      return false;
    }
    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook.isDisabled) {
      // This isn't a real property on the hook, but it can be set to opt out
      // of DevTools integration and associated warnings and logs.
      // https://github.com/facebook/react/issues/3877
      return true;
    }
    if (!hook.supportsFiber) {
      {
        warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
      }
      // DevTools exists, even though it doesn't support Fiber.
      return true;
    }
    try {
      var rendererID = hook.inject(internals);
      // We have successfully injected, so now it is safe to set up hooks.
      onCommitFiberRoot = catchErrors(function (root) {
        return hook.onCommitFiberRoot(rendererID, root);
      });
      onCommitFiberUnmount = catchErrors(function (fiber) {
        return hook.onCommitFiberUnmount(rendererID, fiber);
      });
    } catch (err) {
      // Catch all errors because it is unsafe to throw during initialization.
      {
        warning(false, 'React DevTools encountered an error: %s.', err);
      }
    }
    // DevTools exists
    return true;
  }

  function onCommitRoot(root) {
    if (typeof onCommitFiberRoot === 'function') {
      onCommitFiberRoot(root);
    }
  }

  function onCommitUnmount(fiber) {
    if (typeof onCommitFiberUnmount === 'function') {
      onCommitFiberUnmount(fiber);
    }
  }

  {
    var didWarnUpdateInsideUpdate = false;
  }

  // Callbacks are not validated until invocation


  // Singly linked-list of updates. When an update is scheduled, it is added to
  // the queue of the current fiber and the work-in-progress fiber. The two queues
  // are separate but they share a persistent structure.
  //
  // During reconciliation, updates are removed from the work-in-progress fiber,
  // but they remain on the current fiber. That ensures that if a work-in-progress
  // is aborted, the aborted updates are recovered by cloning from current.
  //
  // The work-in-progress queue is always a subset of the current queue.
  //
  // When the tree is committed, the work-in-progress becomes the current.


  function createUpdateQueue(baseState) {
    var queue = {
      baseState: baseState,
      expirationTime: NoWork,
      first: null,
      last: null,
      callbackList: null,
      hasForceUpdate: false,
      isInitialized: false
    };
    {
      queue.isProcessing = false;
    }
    return queue;
  }

  function insertUpdateIntoQueue(queue, update) {
    // Append the update to the end of the list.
    if (queue.last === null) {
      // Queue is empty
      queue.first = queue.last = update;
    } else {
      queue.last.next = update;
      queue.last = update;
    }
    if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
      queue.expirationTime = update.expirationTime;
    }
  }

  function insertUpdateIntoFiber(fiber, update) {
    // We'll have at least one and at most two distinct update queues.
    var alternateFiber = fiber.alternate;
    var queue1 = fiber.updateQueue;
    if (queue1 === null) {
      // TODO: We don't know what the base state will be until we begin work.
      // It depends on which fiber is the next current. Initialize with an empty
      // base state, then set to the memoizedState when rendering. Not super
      // happy with this approach.
      queue1 = fiber.updateQueue = createUpdateQueue(null);
    }

    var queue2 = void 0;
    if (alternateFiber !== null) {
      queue2 = alternateFiber.updateQueue;
      if (queue2 === null) {
        queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
      }
    } else {
      queue2 = null;
    }
    queue2 = queue2 !== queue1 ? queue2 : null;

    // Warn if an update is scheduled from inside an updater function.
    {
      if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
        warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
        didWarnUpdateInsideUpdate = true;
      }
    }

    // If there's only one queue, add the update to that queue and exit.
    if (queue2 === null) {
      insertUpdateIntoQueue(queue1, update);
      return;
    }

    // If either queue is empty, we need to add to both queues.
    if (queue1.last === null || queue2.last === null) {
      insertUpdateIntoQueue(queue1, update);
      insertUpdateIntoQueue(queue2, update);
      return;
    }

    // If both lists are not empty, the last update is the same for both lists
    // because of structural sharing. So, we should only append to one of
    // the lists.
    insertUpdateIntoQueue(queue1, update);
    // But we still need to update the `last` pointer of queue2.
    queue2.last = update;
  }

  function getUpdateExpirationTime(fiber) {
    if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
      return NoWork;
    }
    var updateQueue = fiber.updateQueue;
    if (updateQueue === null) {
      return NoWork;
    }
    return updateQueue.expirationTime;
  }

  function getStateFromUpdate(update, instance, prevState, props) {
    var partialState = update.partialState;
    if (typeof partialState === 'function') {
      var updateFn = partialState;

      // Invoke setState callback an extra time to help detect side-effects.
      if (debugRenderPhaseSideEffects) {
        updateFn.call(instance, prevState, props);
      }

      return updateFn.call(instance, prevState, props);
    } else {
      return partialState;
    }
  }

  function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
    if (current !== null && current.updateQueue === queue) {
      // We need to create a work-in-progress queue, by cloning the current queue.
      var currentQueue = queue;
      queue = workInProgress.updateQueue = {
        baseState: currentQueue.baseState,
        expirationTime: currentQueue.expirationTime,
        first: currentQueue.first,
        last: currentQueue.last,
        isInitialized: currentQueue.isInitialized,
        // These fields are no longer valid because they were already committed.
        // Reset them.
        callbackList: null,
        hasForceUpdate: false
      };
    }

    {
      // Set this flag so we can warn if setState is called inside the update
      // function of another setState.
      queue.isProcessing = true;
    }

    // Reset the remaining expiration time. If we skip over any updates, we'll
    // increase this accordingly.
    queue.expirationTime = NoWork;

    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    var state = void 0;
    if (queue.isInitialized) {
      state = queue.baseState;
    } else {
      state = queue.baseState = workInProgress.memoizedState;
      queue.isInitialized = true;
    }
    var dontMutatePrevState = true;
    var update = queue.first;
    var didSkip = false;
    while (update !== null) {
      var updateExpirationTime = update.expirationTime;
      if (updateExpirationTime > renderExpirationTime) {
        // This update does not have sufficient priority. Skip it.
        var remainingExpirationTime = queue.expirationTime;
        if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
          // Update the remaining expiration time.
          queue.expirationTime = updateExpirationTime;
        }
        if (!didSkip) {
          didSkip = true;
          queue.baseState = state;
        }
        // Continue to the next update.
        update = update.next;
        continue;
      }

      // This update does have sufficient priority.

      // If no previous updates were skipped, drop this update from the queue by
      // advancing the head of the list.
      if (!didSkip) {
        queue.first = update.next;
        if (queue.first === null) {
          queue.last = null;
        }
      }

      // Process the update
      var _partialState = void 0;
      if (update.isReplace) {
        state = getStateFromUpdate(update, instance, state, props);
        dontMutatePrevState = true;
      } else {
        _partialState = getStateFromUpdate(update, instance, state, props);
        if (_partialState) {
          if (dontMutatePrevState) {
            // $FlowFixMe: Idk how to type this properly.
            state = _assign({}, state, _partialState);
          } else {
            state = _assign(state, _partialState);
          }
          dontMutatePrevState = false;
        }
      }
      if (update.isForced) {
        queue.hasForceUpdate = true;
      }
      if (update.callback !== null) {
        // Append to list of callbacks.
        var _callbackList = queue.callbackList;
        if (_callbackList === null) {
          _callbackList = queue.callbackList = [];
        }
        _callbackList.push(update);
      }
      update = update.next;
    }

    if (queue.callbackList !== null) {
      workInProgress.effectTag |= Callback;
    } else if (queue.first === null && !queue.hasForceUpdate) {
      // The queue is empty. We can reset it.
      workInProgress.updateQueue = null;
    }

    if (!didSkip) {
      didSkip = true;
      queue.baseState = state;
    }

    {
      // No longer processing.
      queue.isProcessing = false;
    }

    return state;
  }

  function commitCallbacks(queue, context) {
    var callbackList = queue.callbackList;
    if (callbackList === null) {
      return;
    }
    // Set the list to null to make sure they don't get called more than once.
    queue.callbackList = null;
    for (var i = 0; i < callbackList.length; i++) {
      var update = callbackList[i];
      var _callback = update.callback;
      // This update might be processed again. Clear the callback so it's only
      // called once.
      update.callback = null;
      !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
      _callback.call(context);
    }
  }

  var fakeInternalInstance = {};
  var isArray = Array.isArray;

  {
    var didWarnAboutStateAssignmentForComponent = {};

    var warnOnInvalidCallback = function (callback, callerName) {
      warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    };

    // This is so gross but it's at least non-critical and can be removed if
    // it causes problems. This is meant to give a nicer error message for
    // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
    // ...)) which otherwise throws a "_processChildContext is not a function"
    // exception.
    Object.defineProperty(fakeInternalInstance, '_processChildContext', {
      enumerable: false,
      value: function () {
        invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
      }
    });
    Object.freeze(fakeInternalInstance);
  }

  var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
    // Class component state updater
    var updater = {
      isMounted: isMounted,
      enqueueSetState: function (instance, partialState, callback) {
        var fiber = get(instance);
        callback = callback === undefined ? null : callback;
        {
          warnOnInvalidCallback(callback, 'setState');
        }
        var expirationTime = computeExpirationForFiber(fiber);
        var update = {
          expirationTime: expirationTime,
          partialState: partialState,
          callback: callback,
          isReplace: false,
          isForced: false,
          nextCallback: null,
          next: null
        };
        insertUpdateIntoFiber(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      enqueueReplaceState: function (instance, state, callback) {
        var fiber = get(instance);
        callback = callback === undefined ? null : callback;
        {
          warnOnInvalidCallback(callback, 'replaceState');
        }
        var expirationTime = computeExpirationForFiber(fiber);
        var update = {
          expirationTime: expirationTime,
          partialState: state,
          callback: callback,
          isReplace: true,
          isForced: false,
          nextCallback: null,
          next: null
        };
        insertUpdateIntoFiber(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      enqueueForceUpdate: function (instance, callback) {
        var fiber = get(instance);
        callback = callback === undefined ? null : callback;
        {
          warnOnInvalidCallback(callback, 'forceUpdate');
        }
        var expirationTime = computeExpirationForFiber(fiber);
        var update = {
          expirationTime: expirationTime,
          partialState: null,
          callback: callback,
          isReplace: false,
          isForced: true,
          nextCallback: null,
          next: null
        };
        insertUpdateIntoFiber(fiber, update);
        scheduleWork(fiber, expirationTime);
      }
    };

    function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
      if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
        // If the workInProgress already has an Update effect, return true
        return true;
      }

      var instance = workInProgress.stateNode;
      var type = workInProgress.type;
      if (typeof instance.shouldComponentUpdate === 'function') {
        startPhaseTimer(workInProgress, 'shouldComponentUpdate');
        var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
        stopPhaseTimer();

        // Simulate an async bailout/interruption by invoking lifecycle twice.
        if (debugRenderPhaseSideEffects) {
          instance.shouldComponentUpdate(newProps, newState, newContext);
        }

        {
          warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
        }

        return shouldUpdate;
      }

      if (type.prototype && type.prototype.isPureReactComponent) {
        return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
      }

      return true;
    }

    function checkClassInstance(workInProgress) {
      var instance = workInProgress.stateNode;
      var type = workInProgress.type;
      {
        var name = getComponentName(workInProgress);
        var renderPresent = instance.render;

        if (!renderPresent) {
          if (type.prototype && typeof type.prototype.render === 'function') {
            warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
          } else {
            warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
          }
        }

        var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
        warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
        var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
        warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
        var noInstancePropTypes = !instance.propTypes;
        warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
        var noInstanceContextTypes = !instance.contextTypes;
        warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
        var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
        warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
        if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
          warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
        }
        var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
        warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
        var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
        warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
        var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
        warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
        var hasMutatedProps = instance.props !== workInProgress.pendingProps;
        warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
        var noInstanceDefaultProps = !instance.defaultProps;
        warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
      }

      var state = instance.state;
      if (state && (typeof state !== 'object' || isArray(state))) {
        warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
      }
      if (typeof instance.getChildContext === 'function') {
        warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
      }
    }

    function resetInputPointers(workInProgress, instance) {
      instance.props = workInProgress.memoizedProps;
      instance.state = workInProgress.memoizedState;
    }

    function adoptClassInstance(workInProgress, instance) {
      instance.updater = updater;
      workInProgress.stateNode = instance;
      // The instance needs access to the fiber so that it can schedule updates
      set(instance, workInProgress);
      {
        instance._reactInternalInstance = fakeInternalInstance;
      }
    }

    function constructClassInstance(workInProgress, props) {
      var ctor = workInProgress.type;
      var unmaskedContext = getUnmaskedContext(workInProgress);
      var needsContext = isContextConsumer(workInProgress);
      var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
      var instance = new ctor(props, context);
      adoptClassInstance(workInProgress, instance);

      // Cache unmasked context so we can avoid recreating masked context unless necessary.
      // ReactFiberContext usually updates this cache but can't for newly-created instances.
      if (needsContext) {
        cacheContext(workInProgress, unmaskedContext, context);
      }

      return instance;
    }

    function callComponentWillMount(workInProgress, instance) {
      startPhaseTimer(workInProgress, 'componentWillMount');
      var oldState = instance.state;
      instance.componentWillMount();
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.componentWillMount();
      }

      if (oldState !== instance.state) {
        {
          warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
        }
        updater.enqueueReplaceState(instance, instance.state, null);
      }
    }

    function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
      startPhaseTimer(workInProgress, 'componentWillReceiveProps');
      var oldState = instance.state;
      instance.componentWillReceiveProps(newProps, newContext);
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.componentWillReceiveProps(newProps, newContext);
      }

      if (instance.state !== oldState) {
        {
          var componentName = getComponentName(workInProgress) || 'Component';
          if (!didWarnAboutStateAssignmentForComponent[componentName]) {
            warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
            didWarnAboutStateAssignmentForComponent[componentName] = true;
          }
        }
        updater.enqueueReplaceState(instance, instance.state, null);
      }
    }

    // Invokes the mount life-cycles on a previously never rendered instance.
    function mountClassInstance(workInProgress, renderExpirationTime) {
      var current = workInProgress.alternate;

      {
        checkClassInstance(workInProgress);
      }

      var instance = workInProgress.stateNode;
      var state = instance.state || null;

      var props = workInProgress.pendingProps;
      !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      var unmaskedContext = getUnmaskedContext(workInProgress);

      instance.props = props;
      instance.state = workInProgress.memoizedState = state;
      instance.refs = emptyObject;
      instance.context = getMaskedContext(workInProgress, unmaskedContext);

      if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
        workInProgress.internalContextTag |= AsyncUpdates;
      }

      if (typeof instance.componentWillMount === 'function') {
        callComponentWillMount(workInProgress, instance);
        // If we had additional state updates during this life-cycle, let's
        // process them now.
        var updateQueue = workInProgress.updateQueue;
        if (updateQueue !== null) {
          instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
        }
      }
      if (typeof instance.componentDidMount === 'function') {
        workInProgress.effectTag |= Update;
      }
    }

    // Called on a preexisting class instance. Returns false if a resumed render
    // could be reused.
    // function resumeMountClassInstance(
    //   workInProgress: Fiber,
    //   priorityLevel: PriorityLevel,
    // ): boolean {
    //   const instance = workInProgress.stateNode;
    //   resetInputPointers(workInProgress, instance);

    //   let newState = workInProgress.memoizedState;
    //   let newProps = workInProgress.pendingProps;
    //   if (!newProps) {
    //     // If there isn't any new props, then we'll reuse the memoized props.
    //     // This could be from already completed work.
    //     newProps = workInProgress.memoizedProps;
    //     invariant(
    //       newProps != null,
    //       'There should always be pending or memoized props. This error is ' +
    //         'likely caused by a bug in React. Please file an issue.',
    //     );
    //   }
    //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
    //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    //   const oldContext = instance.context;
    //   const oldProps = workInProgress.memoizedProps;

    //   if (
    //     typeof instance.componentWillReceiveProps === 'function' &&
    //     (oldProps !== newProps || oldContext !== newContext)
    //   ) {
    //     callComponentWillReceiveProps(
    //       workInProgress,
    //       instance,
    //       newProps,
    //       newContext,
    //     );
    //   }

    //   // Process the update queue before calling shouldComponentUpdate
    //   const updateQueue = workInProgress.updateQueue;
    //   if (updateQueue !== null) {
    //     newState = processUpdateQueue(
    //       workInProgress,
    //       updateQueue,
    //       instance,
    //       newState,
    //       newProps,
    //       priorityLevel,
    //     );
    //   }

    //   // TODO: Should we deal with a setState that happened after the last
    //   // componentWillMount and before this componentWillMount? Probably
    //   // unsupported anyway.

    //   if (
    //     !checkShouldComponentUpdate(
    //       workInProgress,
    //       workInProgress.memoizedProps,
    //       newProps,
    //       workInProgress.memoizedState,
    //       newState,
    //       newContext,
    //     )
    //   ) {
    //     // Update the existing instance's state, props, and context pointers even
    //     // though we're bailing out.
    //     instance.props = newProps;
    //     instance.state = newState;
    //     instance.context = newContext;
    //     return false;
    //   }

    //   // Update the input pointers now so that they are correct when we call
    //   // componentWillMount
    //   instance.props = newProps;
    //   instance.state = newState;
    //   instance.context = newContext;

    //   if (typeof instance.componentWillMount === 'function') {
    //     callComponentWillMount(workInProgress, instance);
    //     // componentWillMount may have called setState. Process the update queue.
    //     const newUpdateQueue = workInProgress.updateQueue;
    //     if (newUpdateQueue !== null) {
    //       newState = processUpdateQueue(
    //         workInProgress,
    //         newUpdateQueue,
    //         instance,
    //         newState,
    //         newProps,
    //         priorityLevel,
    //       );
    //     }
    //   }

    //   if (typeof instance.componentDidMount === 'function') {
    //     workInProgress.effectTag |= Update;
    //   }

    //   instance.state = newState;

    //   return true;
    // }

    // Invokes the update life-cycles and returns false if it shouldn't rerender.
    function updateClassInstance(current, workInProgress, renderExpirationTime) {
      var instance = workInProgress.stateNode;
      resetInputPointers(workInProgress, instance);

      var oldProps = workInProgress.memoizedProps;
      var newProps = workInProgress.pendingProps;
      if (!newProps) {
        // If there aren't any new props, then we'll reuse the memoized props.
        // This could be from already completed work.
        newProps = oldProps;
        !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
      var oldContext = instance.context;
      var newUnmaskedContext = getUnmaskedContext(workInProgress);
      var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

      // Note: During these life-cycles, instance.props/instance.state are what
      // ever the previously attempted to render - not the "current". However,
      // during componentDidUpdate we pass the "current" props.

      if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
        callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
      }

      // Compute the next state using the memoized state and the update queue.
      var oldState = workInProgress.memoizedState;
      // TODO: Previous state can be null.
      var newState = void 0;
      if (workInProgress.updateQueue !== null) {
        newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
      } else {
        newState = oldState;
      }

      if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
        // If an update was already in progress, we should schedule an Update
        // effect even though we're bailing out, so that cWU/cDU are called.
        if (typeof instance.componentDidUpdate === 'function') {
          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Update;
          }
        }
        return false;
      }

      var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

      if (shouldUpdate) {
        if (typeof instance.componentWillUpdate === 'function') {
          startPhaseTimer(workInProgress, 'componentWillUpdate');
          instance.componentWillUpdate(newProps, newState, newContext);
          stopPhaseTimer();

          // Simulate an async bailout/interruption by invoking lifecycle twice.
          if (debugRenderPhaseSideEffects) {
            instance.componentWillUpdate(newProps, newState, newContext);
          }
        }
        if (typeof instance.componentDidUpdate === 'function') {
          workInProgress.effectTag |= Update;
        }
      } else {
        // If an update was already in progress, we should schedule an Update
        // effect even though we're bailing out, so that cWU/cDU are called.
        if (typeof instance.componentDidUpdate === 'function') {
          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Update;
          }
        }

        // If shouldComponentUpdate returned false, we should still update the
        // memoized props/state to indicate that this work can be reused.
        memoizeProps(workInProgress, newProps);
        memoizeState(workInProgress, newState);
      }

      // Update the existing instance's state, props, and context pointers even
      // if shouldComponentUpdate returns false.
      instance.props = newProps;
      instance.state = newState;
      instance.context = newContext;

      return shouldUpdate;
    }

    return {
      adoptClassInstance: adoptClassInstance,
      constructClassInstance: constructClassInstance,
      mountClassInstance: mountClassInstance,
      // resumeMountClassInstance,
      updateClassInstance: updateClassInstance
    };
  };

  // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.
  var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

  var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
  var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
  var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
  var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
  var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

  var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  function getIteratorFn(maybeIterable) {
    if (maybeIterable === null || typeof maybeIterable === 'undefined') {
      return null;
    }
    var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
    if (typeof maybeIterator === 'function') {
      return maybeIterator;
    }
    return null;
  }

  var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


  {
    var didWarnAboutMaps = false;
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};

    var warnForMissingKey = function (child) {
      if (child === null || typeof child !== 'object') {
        return;
      }
      if (!child._store || child._store.validated || child.key != null) {
        return;
      }
      !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      child._store.validated = true;

      var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
    };
  }

  var isArray$1 = Array.isArray;

  function coerceRef(current, element) {
    var mixedRef = element.ref;
    if (mixedRef !== null && typeof mixedRef !== 'function') {
      if (element._owner) {
        var owner = element._owner;
        var inst = void 0;
        if (owner) {
          var ownerFiber = owner;
          !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
          inst = ownerFiber.stateNode;
        }
        !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
        var stringRef = '' + mixedRef;
        // Check if previous string ref matches new string ref
        if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
          return current.ref;
        }
        var ref = function (value) {
          var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
          if (value === null) {
            delete refs[stringRef];
          } else {
            refs[stringRef] = value;
          }
        };
        ref._stringRef = stringRef;
        return ref;
      } else {
        !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
        !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
      }
    }
    return mixedRef;
  }

  function throwOnInvalidObjectType(returnFiber, newChild) {
    if (returnFiber.type !== 'textarea') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
      }
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
    }
  }

  function warnOnFunctionType() {
    var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

    if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

    warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
  }

  // This wrapper function exists because I expect to clone the code in each path
  // to be able to optimize each path individually by branching early. This needs
  // a compiler or we can do it manually. Helpers that don't need this branching
  // live outside of this function.
  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (!shouldTrackSideEffects) {
        // Noop.
        return;
      }
      // Deletions are added in reversed order so we add it to the front.
      // At this point, the return fiber's effect list is empty except for
      // deletions, so we can just append the deletion to the list. The remaining
      // effects aren't added until the complete phase. Once we implement
      // resuming, this may not be true.
      var last = returnFiber.lastEffect;
      if (last !== null) {
        last.nextEffect = childToDelete;
        returnFiber.lastEffect = childToDelete;
      } else {
        returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
      }
      childToDelete.nextEffect = null;
      childToDelete.effectTag = Deletion;
    }

    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) {
        // Noop.
        return null;
      }

      // TODO: For the shouldClone case, this could be micro-optimized a bit by
      // assuming that after the first child we've already added everything.
      var childToDelete = currentFirstChild;
      while (childToDelete !== null) {
        deleteChild(returnFiber, childToDelete);
        childToDelete = childToDelete.sibling;
      }
      return null;
    }

    function mapRemainingChildren(returnFiber, currentFirstChild) {
      // Add the remaining children to a temporary map so that we can find them by
      // keys quickly. Implicit (null) keys get added to this set with their index
      var existingChildren = new Map();

      var existingChild = currentFirstChild;
      while (existingChild !== null) {
        if (existingChild.key !== null) {
          existingChildren.set(existingChild.key, existingChild);
        } else {
          existingChildren.set(existingChild.index, existingChild);
        }
        existingChild = existingChild.sibling;
      }
      return existingChildren;
    }

    function useFiber(fiber, pendingProps, expirationTime) {
      // We currently set sibling to null and index to 0 here because it is easy
      // to forget to do before returning it. E.g. for the single child case.
      var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
      clone.index = 0;
      clone.sibling = null;
      return clone;
    }

    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) {
        // Noop.
        return lastPlacedIndex;
      }
      var current = newFiber.alternate;
      if (current !== null) {
        var oldIndex = current.index;
        if (oldIndex < lastPlacedIndex) {
          // This is a move.
          newFiber.effectTag = Placement;
          return lastPlacedIndex;
        } else {
          // This item can stay in place.
          return oldIndex;
        }
      } else {
        // This is an insertion.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      }
    }

    function placeSingleChild(newFiber) {
      // This is simpler for the single child case. We only need to do a
      // placement for inserting new children.
      if (shouldTrackSideEffects && newFiber.alternate === null) {
        newFiber.effectTag = Placement;
      }
      return newFiber;
    }

    function updateTextNode(returnFiber, current, textContent, expirationTime) {
      if (current === null || current.tag !== HostText) {
        // Insert
        var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
        created['return'] = returnFiber;
        return created;
      } else {
        // Update
        var existing = useFiber(current, textContent, expirationTime);
        existing['return'] = returnFiber;
        return existing;
      }
    }

    function updateElement(returnFiber, current, element, expirationTime) {
      if (current !== null && current.type === element.type) {
        // Move based on index
        var existing = useFiber(current, element.props, expirationTime);
        existing.ref = coerceRef(current, element);
        existing['return'] = returnFiber;
        {
          existing._debugSource = element._source;
          existing._debugOwner = element._owner;
        }
        return existing;
      } else {
        // Insert
        var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
        created.ref = coerceRef(current, element);
        created['return'] = returnFiber;
        return created;
      }
    }

    function updateCall(returnFiber, current, call, expirationTime) {
      // TODO: Should this also compare handler to determine whether to reuse?
      if (current === null || current.tag !== CallComponent) {
        // Insert
        var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
        created['return'] = returnFiber;
        return created;
      } else {
        // Move based on index
        var existing = useFiber(current, call, expirationTime);
        existing['return'] = returnFiber;
        return existing;
      }
    }

    function updateReturn(returnFiber, current, returnNode, expirationTime) {
      if (current === null || current.tag !== ReturnComponent) {
        // Insert
        var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
        created.type = returnNode.value;
        created['return'] = returnFiber;
        return created;
      } else {
        // Move based on index
        var existing = useFiber(current, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      }
    }

    function updatePortal(returnFiber, current, portal, expirationTime) {
      if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
        // Insert
        var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
        created['return'] = returnFiber;
        return created;
      } else {
        // Update
        var existing = useFiber(current, portal.children || [], expirationTime);
        existing['return'] = returnFiber;
        return existing;
      }
    }

    function updateFragment(returnFiber, current, fragment, expirationTime, key) {
      if (current === null || current.tag !== Fragment) {
        // Insert
        var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
        created['return'] = returnFiber;
        return created;
      } else {
        // Update
        var existing = useFiber(current, fragment, expirationTime);
        existing['return'] = returnFiber;
        return existing;
      }
    }

    function createChild(returnFiber, newChild, expirationTime) {
      if (typeof newChild === 'string' || typeof newChild === 'number') {
        // Text nodes don't have keys. If the previous node is implicitly keyed
        // we can continue to replace it without aborting even if it is not a text
        // node.
        var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
        created['return'] = returnFiber;
        return created;
      }

      if (typeof newChild === 'object' && newChild !== null) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
                _created['return'] = returnFiber;
                return _created;
              } else {
                var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
                _created2.ref = coerceRef(null, newChild);
                _created2['return'] = returnFiber;
                return _created2;
              }
            }

          case REACT_CALL_TYPE:
            {
              var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
              _created3['return'] = returnFiber;
              return _created3;
            }

          case REACT_RETURN_TYPE:
            {
              var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
              _created4.type = newChild.value;
              _created4['return'] = returnFiber;
              return _created4;
            }

          case REACT_PORTAL_TYPE:
            {
              var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
              _created5['return'] = returnFiber;
              return _created5;
            }
        }

        if (isArray$1(newChild) || getIteratorFn(newChild)) {
          var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
          _created6['return'] = returnFiber;
          return _created6;
        }

        throwOnInvalidObjectType(returnFiber, newChild);
      }

      {
        if (typeof newChild === 'function') {
          warnOnFunctionType();
        }
      }

      return null;
    }

    function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
      // Update the fiber if the keys match, otherwise return null.

      var key = oldFiber !== null ? oldFiber.key : null;

      if (typeof newChild === 'string' || typeof newChild === 'number') {
        // Text nodes don't have keys. If the previous node is implicitly keyed
        // we can continue to replace it without aborting even if it is not a text
        // node.
        if (key !== null) {
          return null;
        }
        return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
      }

      if (typeof newChild === 'object' && newChild !== null) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            {
              if (newChild.key === key) {
                if (newChild.type === REACT_FRAGMENT_TYPE) {
                  return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                }
                return updateElement(returnFiber, oldFiber, newChild, expirationTime);
              } else {
                return null;
              }
            }

          case REACT_CALL_TYPE:
            {
              if (newChild.key === key) {
                return updateCall(returnFiber, oldFiber, newChild, expirationTime);
              } else {
                return null;
              }
            }

          case REACT_RETURN_TYPE:
            {
              // Returns don't have keys. If the previous node is implicitly keyed
              // we can continue to replace it without aborting even if it is not a
              // yield.
              if (key === null) {
                return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
              } else {
                return null;
              }
            }

          case REACT_PORTAL_TYPE:
            {
              if (newChild.key === key) {
                return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
              } else {
                return null;
              }
            }
        }

        if (isArray$1(newChild) || getIteratorFn(newChild)) {
          if (key !== null) {
            return null;
          }

          return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
        }

        throwOnInvalidObjectType(returnFiber, newChild);
      }

      {
        if (typeof newChild === 'function') {
          warnOnFunctionType();
        }
      }

      return null;
    }

    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
      if (typeof newChild === 'string' || typeof newChild === 'number') {
        // Text nodes don't have keys, so we neither have to check the old nor
        // new node for the key. If both are text nodes, they match.
        var matchedFiber = existingChildren.get(newIdx) || null;
        return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
      }

      if (typeof newChild === 'object' && newChild !== null) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            {
              var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
              }
              return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
            }

          case REACT_CALL_TYPE:
            {
              var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
              return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
            }

          case REACT_RETURN_TYPE:
            {
              // Returns don't have keys, so we neither have to check the old nor
              // new node for the key. If both are returns, they match.
              var _matchedFiber3 = existingChildren.get(newIdx) || null;
              return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
            }

          case REACT_PORTAL_TYPE:
            {
              var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
              return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
            }
        }

        if (isArray$1(newChild) || getIteratorFn(newChild)) {
          var _matchedFiber5 = existingChildren.get(newIdx) || null;
          return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
        }

        throwOnInvalidObjectType(returnFiber, newChild);
      }

      {
        if (typeof newChild === 'function') {
          warnOnFunctionType();
        }
      }

      return null;
    }

    /**
     * Warns if there is a duplicate or missing key
     */
    function warnOnInvalidKey(child, knownKeys) {
      {
        if (typeof child !== 'object' || child === null) {
          return knownKeys;
        }
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_CALL_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(child);
            var key = child.key;
            if (typeof key !== 'string') {
              break;
            }
            if (knownKeys === null) {
              knownKeys = new Set();
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
            break;
          default:
            break;
        }
      }
      return knownKeys;
    }

    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
      // This algorithm can't optimize by searching from boths ends since we
      // don't have backpointers on fibers. I'm trying to see how far we can get
      // with that model. If it ends up not being worth the tradeoffs, we can
      // add it later.

      // Even with a two ended optimization, we'd want to optimize for the case
      // where there are few changes and brute force the comparison instead of
      // going for the Map. It'd like to explore hitting that path first in
      // forward-only mode and only go for the Map once we notice that we need
      // lots of look ahead. This doesn't handle reversal as well as two ended
      // search but that's unusual. Besides, for the two ended optimization to
      // work on Iterables, we'd need to copy the whole set.

      // In this first iteration, we'll just live with hitting the bad case
      // (adding everything to a Map) in for every insert/move.

      // If you change this code, also update reconcileChildrenIterator() which
      // uses the same algorithm.

      {
        // First, validate keys.
        var knownKeys = null;
        for (var i = 0; i < newChildren.length; i++) {
          var child = newChildren[i];
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }

      var resultingFirstChild = null;
      var previousNewFiber = null;

      var oldFiber = currentFirstChild;
      var lastPlacedIndex = 0;
      var newIdx = 0;
      var nextOldFiber = null;
      for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
        if (oldFiber.index > newIdx) {
          nextOldFiber = oldFiber;
          oldFiber = null;
        } else {
          nextOldFiber = oldFiber.sibling;
        }
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
        if (newFiber === null) {
          // TODO: This breaks on empty slots like null children. That's
          // unfortunate because it triggers the slow path all the time. We need
          // a better way to communicate whether this was a miss or null,
          // boolean, undefined, etc.
          if (oldFiber === null) {
            oldFiber = nextOldFiber;
          }
          break;
        }
        if (shouldTrackSideEffects) {
          if (oldFiber && newFiber.alternate === null) {
            // We matched the slot, but we didn't reuse the existing fiber, so we
            // need to delete the existing child.
            deleteChild(returnFiber, oldFiber);
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = newFiber;
        } else {
          // TODO: Defer siblings if we're not at the right index for this slot.
          // I.e. if we had null values before, then we want to defer this
          // for each null value. However, we also don't want to call updateSlot
          // with the previous one.
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (newIdx === newChildren.length) {
        // We've reached the end of the new children. We can delete the rest.
        deleteRemainingChildren(returnFiber, oldFiber);
        return resultingFirstChild;
      }

      if (oldFiber === null) {
        // If we don't have any more existing children we can choose a fast path
        // since the rest will all be insertions.
        for (; newIdx < newChildren.length; newIdx++) {
          var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
          if (!_newFiber) {
            continue;
          }
          lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {
            // TODO: Move out of the loop. This only happens for the first run.
            resultingFirstChild = _newFiber;
          } else {
            previousNewFiber.sibling = _newFiber;
          }
          previousNewFiber = _newFiber;
        }
        return resultingFirstChild;
      }

      // Add all children to a key map for quick lookups.
      var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

      // Keep scanning and use the map to restore deleted items as moves.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
        if (_newFiber2) {
          if (shouldTrackSideEffects) {
            if (_newFiber2.alternate !== null) {
              // The new fiber is a work in progress, but if there exists a
              // current, that means that we reused the fiber. We need to delete
              // it from the child list so that we don't add it to the deletion
              // list.
              existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
            }
          }
          lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {
            resultingFirstChild = _newFiber2;
          } else {
            previousNewFiber.sibling = _newFiber2;
          }
          previousNewFiber = _newFiber2;
        }
      }

      if (shouldTrackSideEffects) {
        // Any existing children that weren't consumed above were deleted. We need
        // to add them to the deletion list.
        existingChildren.forEach(function (child) {
          return deleteChild(returnFiber, child);
        });
      }

      return resultingFirstChild;
    }

    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
      // This is the same implementation as reconcileChildrenArray(),
      // but using the iterator instead.

      var iteratorFn = getIteratorFn(newChildrenIterable);
      !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      {
        // Warn about using Maps as children
        if (typeof newChildrenIterable.entries === 'function') {
          var possibleMap = newChildrenIterable;
          if (possibleMap.entries === iteratorFn) {
            warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
            didWarnAboutMaps = true;
          }
        }

        // First, validate keys.
        // We'll get a different iterator later for the main pass.
        var _newChildren = iteratorFn.call(newChildrenIterable);
        if (_newChildren) {
          var knownKeys = null;
          var _step = _newChildren.next();
          for (; !_step.done; _step = _newChildren.next()) {
            var child = _step.value;
            knownKeys = warnOnInvalidKey(child, knownKeys);
          }
        }
      }

      var newChildren = iteratorFn.call(newChildrenIterable);
      !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

      var resultingFirstChild = null;
      var previousNewFiber = null;

      var oldFiber = currentFirstChild;
      var lastPlacedIndex = 0;
      var newIdx = 0;
      var nextOldFiber = null;

      var step = newChildren.next();
      for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
        if (oldFiber.index > newIdx) {
          nextOldFiber = oldFiber;
          oldFiber = null;
        } else {
          nextOldFiber = oldFiber.sibling;
        }
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
        if (newFiber === null) {
          // TODO: This breaks on empty slots like null children. That's
          // unfortunate because it triggers the slow path all the time. We need
          // a better way to communicate whether this was a miss or null,
          // boolean, undefined, etc.
          if (!oldFiber) {
            oldFiber = nextOldFiber;
          }
          break;
        }
        if (shouldTrackSideEffects) {
          if (oldFiber && newFiber.alternate === null) {
            // We matched the slot, but we didn't reuse the existing fiber, so we
            // need to delete the existing child.
            deleteChild(returnFiber, oldFiber);
          }
        }
        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = newFiber;
        } else {
          // TODO: Defer siblings if we're not at the right index for this slot.
          // I.e. if we had null values before, then we want to defer this
          // for each null value. However, we also don't want to call updateSlot
          // with the previous one.
          previousNewFiber.sibling = newFiber;
        }
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (step.done) {
        // We've reached the end of the new children. We can delete the rest.
        deleteRemainingChildren(returnFiber, oldFiber);
        return resultingFirstChild;
      }

      if (oldFiber === null) {
        // If we don't have any more existing children we can choose a fast path
        // since the rest will all be insertions.
        for (; !step.done; newIdx++, step = newChildren.next()) {
          var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
          if (_newFiber3 === null) {
            continue;
          }
          lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {
            // TODO: Move out of the loop. This only happens for the first run.
            resultingFirstChild = _newFiber3;
          } else {
            previousNewFiber.sibling = _newFiber3;
          }
          previousNewFiber = _newFiber3;
        }
        return resultingFirstChild;
      }

      // Add all children to a key map for quick lookups.
      var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

      // Keep scanning and use the map to restore deleted items as moves.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
        if (_newFiber4 !== null) {
          if (shouldTrackSideEffects) {
            if (_newFiber4.alternate !== null) {
              // The new fiber is a work in progress, but if there exists a
              // current, that means that we reused the fiber. We need to delete
              // it from the child list so that we don't add it to the deletion
              // list.
              existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
            }
          }
          lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {
            resultingFirstChild = _newFiber4;
          } else {
            previousNewFiber.sibling = _newFiber4;
          }
          previousNewFiber = _newFiber4;
        }
      }

      if (shouldTrackSideEffects) {
        // Any existing children that weren't consumed above were deleted. We need
        // to add them to the deletion list.
        existingChildren.forEach(function (child) {
          return deleteChild(returnFiber, child);
        });
      }

      return resultingFirstChild;
    }

    function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
      // There's no need to check for keys on text nodes since we don't have a
      // way to define them.
      if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
        // We already have an existing node so let's just update it and delete
        // the rest.
        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
        var existing = useFiber(currentFirstChild, textContent, expirationTime);
        existing['return'] = returnFiber;
        return existing;
      }
      // The existing first child is not a text node so we need to create one
      // and delete the existing ones.
      deleteRemainingChildren(returnFiber, currentFirstChild);
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
      var key = element.key;
      var child = currentFirstChild;
      while (child !== null) {
        // TODO: If key === null and child.key === null, then this only applies to
        // the first item in the list.
        if (child.key === key) {
          if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
            deleteRemainingChildren(returnFiber, child.sibling);
            var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
            existing.ref = coerceRef(child, element);
            existing['return'] = returnFiber;
            {
              existing._debugSource = element._source;
              existing._debugOwner = element._owner;
            }
            return existing;
          } else {
            deleteRemainingChildren(returnFiber, child);
            break;
          }
        } else {
          deleteChild(returnFiber, child);
        }
        child = child.sibling;
      }

      if (element.type === REACT_FRAGMENT_TYPE) {
        var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
        created['return'] = returnFiber;
        return created;
      } else {
        var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
        _created7.ref = coerceRef(currentFirstChild, element);
        _created7['return'] = returnFiber;
        return _created7;
      }
    }

    function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
      var key = call.key;
      var child = currentFirstChild;
      while (child !== null) {
        // TODO: If key === null and child.key === null, then this only applies to
        // the first item in the list.
        if (child.key === key) {
          if (child.tag === CallComponent) {
            deleteRemainingChildren(returnFiber, child.sibling);
            var existing = useFiber(child, call, expirationTime);
            existing['return'] = returnFiber;
            return existing;
          } else {
            deleteRemainingChildren(returnFiber, child);
            break;
          }
        } else {
          deleteChild(returnFiber, child);
        }
        child = child.sibling;
      }

      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
      // There's no need to check for keys on yields since they're stateless.
      var child = currentFirstChild;
      if (child !== null) {
        if (child.tag === ReturnComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, null, expirationTime);
          existing.type = returnNode.value;
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
        }
      }

      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    }

    function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
      var key = portal.key;
      var child = currentFirstChild;
      while (child !== null) {
        // TODO: If key === null and child.key === null, then this only applies to
        // the first item in the list.
        if (child.key === key) {
          if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
            deleteRemainingChildren(returnFiber, child.sibling);
            var existing = useFiber(child, portal.children || [], expirationTime);
            existing['return'] = returnFiber;
            return existing;
          } else {
            deleteRemainingChildren(returnFiber, child);
            break;
          }
        } else {
          deleteChild(returnFiber, child);
        }
        child = child.sibling;
      }

      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    // This API will tag the children with the side-effect of the reconciliation
    // itself. They will be added to the side-effect list as we pass through the
    // children and the parent.
    function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
      // This function is not recursive.
      // If the top level item is an array, we treat it as a set of children,
      // not as a fragment. Nested arrays on the other hand will be treated as
      // fragment nodes. Recursion happens at the normal flow.

      // Handle top level unkeyed fragments as if they were arrays.
      // This leads to an ambiguity between <>{[...]}</> and <>...</>.
      // We treat the ambiguous cases above the same.
      if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
        newChild = newChild.props.children;
      }

      // Handle object types
      var isObject = typeof newChild === 'object' && newChild !== null;

      if (isObject) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

          case REACT_CALL_TYPE:
            return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
          case REACT_RETURN_TYPE:
            return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
          case REACT_PORTAL_TYPE:
            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
        }
      }

      if (typeof newChild === 'string' || typeof newChild === 'number') {
        return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
      }

      if (isArray$1(newChild)) {
        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
      }

      if (getIteratorFn(newChild)) {
        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
      }

      if (isObject) {
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      {
        if (typeof newChild === 'function') {
          warnOnFunctionType();
        }
      }
      if (typeof newChild === 'undefined') {
        // If the new child is undefined, and the return fiber is a composite
        // component, throw an error. If Fiber return types are disabled,
        // we already threw above.
        switch (returnFiber.tag) {
          case ClassComponent:
            {
              {
                var instance = returnFiber.stateNode;
                if (instance.render._isMockFunction) {
                  // We allow auto-mocks to proceed as if they're returning null.
                  break;
                }
              }
            }
          // Intentionally fall through to the next case, which handles both
          // functions and classes
          // eslint-disable-next-lined no-fallthrough
          case FunctionalComponent:
            {
              var Component = returnFiber.type;
              invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
            }
        }
      }

      // Remaining cases are all treated as empty.
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    }

    return reconcileChildFibers;
  }

  var reconcileChildFibers = ChildReconciler(true);
  var mountChildFibers = ChildReconciler(false);

  function cloneChildFibers(current, workInProgress) {
    !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

    if (workInProgress.child === null) {
      return;
    }

    var currentChild = workInProgress.child;
    var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    workInProgress.child = newChild;

    newChild['return'] = workInProgress;
    while (currentChild.sibling !== null) {
      currentChild = currentChild.sibling;
      newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
      newChild['return'] = workInProgress;
    }
    newChild.sibling = null;
  }

  {
    var warnedAboutStatelessRefs = {};
  }

  var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
    var shouldSetTextContent = config.shouldSetTextContent,
        useSyncScheduling = config.useSyncScheduling,
        shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
    var pushHostContext = hostContext.pushHostContext,
        pushHostContainer = hostContext.pushHostContainer;
    var enterHydrationState = hydrationContext.enterHydrationState,
        resetHydrationState = hydrationContext.resetHydrationState,
        tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

    var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
        adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
        constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
        mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
        updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

    // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


    function reconcileChildren(current, workInProgress, nextChildren) {
      reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
    }

    function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
      if (current === null) {
        // If this is a fresh new component that hasn't been rendered yet, we
        // won't update its child set by applying minimal side-effects. Instead,
        // we will add them all to the child before it gets rendered. That means
        // we can optimize this reconciliation pass by not tracking side-effects.
        workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      } else {
        // If the current child is the same as the work in progress, it means that
        // we haven't yet started any work on these children. Therefore, we use
        // the clone algorithm to create a copy of all the current children.

        // If we had any progressed work already, that is invalid at this point so
        // let's throw it out.
        workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
      }
    }

    function updateFragment(current, workInProgress) {
      var nextChildren = workInProgress.pendingProps;
      if (hasContextChanged()) {
        // Normally we can bail out on props equality but if context has changed
        // we don't do the bailout and we have to reuse existing props instead.
        if (nextChildren === null) {
          nextChildren = workInProgress.memoizedProps;
        }
      } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
      return workInProgress.child;
    }

    function markRef(current, workInProgress) {
      var ref = workInProgress.ref;
      if (ref !== null && (!current || current.ref !== ref)) {
        // Schedule a Ref effect
        workInProgress.effectTag |= Ref;
      }
    }

    function updateFunctionalComponent(current, workInProgress) {
      var fn = workInProgress.type;
      var nextProps = workInProgress.pendingProps;

      var memoizedProps = workInProgress.memoizedProps;
      if (hasContextChanged()) {
        // Normally we can bail out on props equality but if context has changed
        // we don't do the bailout and we have to reuse existing props instead.
        if (nextProps === null) {
          nextProps = memoizedProps;
        }
      } else {
        if (nextProps === null || memoizedProps === nextProps) {
          return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }
        // TODO: consider bringing fn.shouldComponentUpdate() back.
        // It used to be here.
      }

      var unmaskedContext = getUnmaskedContext(workInProgress);
      var context = getMaskedContext(workInProgress, unmaskedContext);

      var nextChildren;

      {
        ReactCurrentOwner.current = workInProgress;
        ReactDebugCurrentFiber.setCurrentPhase('render');
        nextChildren = fn(nextProps, context);
        ReactDebugCurrentFiber.setCurrentPhase(null);
      }
      // React DevTools reads this flag.
      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateClassComponent(current, workInProgress, renderExpirationTime) {
      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);

      var shouldUpdate = void 0;
      if (current === null) {
        if (!workInProgress.stateNode) {
          // In the initial pass we might need to construct the instance.
          constructClassInstance(workInProgress, workInProgress.pendingProps);
          mountClassInstance(workInProgress, renderExpirationTime);
          shouldUpdate = true;
        } else {
          invariant(false, 'Resuming work not yet implemented.');
          // In a resume, we'll already have an instance we can reuse.
          // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
        }
      } else {
        shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
      }
      return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
    }

    function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
      // Refs should update even if shouldComponentUpdate returns false
      markRef(current, workInProgress);

      if (!shouldUpdate) {
        // Context providers should defer to sCU for rendering
        if (hasContext) {
          invalidateContextProvider(workInProgress, false);
        }

        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }

      var instance = workInProgress.stateNode;

      // Rerender
      ReactCurrentOwner.current = workInProgress;
      var nextChildren = void 0;
      {
        ReactDebugCurrentFiber.setCurrentPhase('render');
        nextChildren = instance.render();
        if (debugRenderPhaseSideEffects) {
          instance.render();
        }
        ReactDebugCurrentFiber.setCurrentPhase(null);
      }
      // React DevTools reads this flag.
      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current, workInProgress, nextChildren);
      // Memoize props and state using the values we just used to render.
      // TODO: Restructure so we never read values from the instance.
      memoizeState(workInProgress, instance.state);
      memoizeProps(workInProgress, instance.props);

      // The context might have changed so we need to recalculate it.
      if (hasContext) {
        invalidateContextProvider(workInProgress, true);
      }

      return workInProgress.child;
    }

    function pushHostRootContext(workInProgress) {
      var root = workInProgress.stateNode;
      if (root.pendingContext) {
        pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
      } else if (root.context) {
        // Should always be set
        pushTopLevelContextObject(workInProgress, root.context, false);
      }
      pushHostContainer(workInProgress, root.containerInfo);
    }

    function updateHostRoot(current, workInProgress, renderExpirationTime) {
      pushHostRootContext(workInProgress);
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        var prevState = workInProgress.memoizedState;
        var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
        if (prevState === state) {
          // If the state is the same as before, that's a bailout because we had
          // no work that expires at this time.
          resetHydrationState();
          return bailoutOnAlreadyFinishedWork(current, workInProgress);
        }
        var element = state.element;
        var root = workInProgress.stateNode;
        if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
          // If we don't have any current children this might be the first pass.
          // We always try to hydrate. If this isn't a hydration pass there won't
          // be any children to hydrate which is effectively the same thing as
          // not hydrating.

          // This is a bit of a hack. We track the host root as a placement to
          // know that we're currently in a mounting state. That way isMounted
          // works as expected. We must reset this before committing.
          // TODO: Delete this when we delete isMounted and findDOMNode.
          workInProgress.effectTag |= Placement;

          // Ensure that children mount into this root without tracking
          // side-effects. This ensures that we don't store Placement effects on
          // nodes that will be hydrated.
          workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
        } else {
          // Otherwise reset hydration state in case we aborted and resumed another
          // root.
          resetHydrationState();
          reconcileChildren(current, workInProgress, element);
        }
        memoizeState(workInProgress, state);
        return workInProgress.child;
      }
      resetHydrationState();
      // If there is no update queue, that's a bailout because the root has no props.
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    function updateHostComponent(current, workInProgress, renderExpirationTime) {
      pushHostContext(workInProgress);

      if (current === null) {
        tryToClaimNextHydratableInstance(workInProgress);
      }

      var type = workInProgress.type;
      var memoizedProps = workInProgress.memoizedProps;
      var nextProps = workInProgress.pendingProps;
      if (nextProps === null) {
        nextProps = memoizedProps;
        !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
      var prevProps = current !== null ? current.memoizedProps : null;

      if (hasContextChanged()) {
        // Normally we can bail out on props equality but if context has changed
        // we don't do the bailout and we have to reuse existing props instead.
      } else if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }

      var nextChildren = nextProps.children;
      var isDirectTextChild = shouldSetTextContent(type, nextProps);

      if (isDirectTextChild) {
        // We special case a direct text child of a host node. This is a common
        // case. We won't handle it as a reified child. We will instead handle
        // this in the host environment that also have access to this prop. That
        // avoids allocating another HostText fiber and traversing it.
        nextChildren = null;
      } else if (prevProps && shouldSetTextContent(type, prevProps)) {
        // If we're switching from a direct text child to a normal child, or to
        // empty, we need to schedule the text content to be reset.
        workInProgress.effectTag |= ContentReset;
      }

      markRef(current, workInProgress);

      // Check the host config to see if the children are offscreen/hidden.
      if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
        // Down-prioritize the children.
        workInProgress.expirationTime = Never;
        // Bailout and come back to this fiber later.
        return null;
      }

      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateHostText(current, workInProgress) {
      if (current === null) {
        tryToClaimNextHydratableInstance(workInProgress);
      }
      var nextProps = workInProgress.pendingProps;
      if (nextProps === null) {
        nextProps = workInProgress.memoizedProps;
      }
      memoizeProps(workInProgress, nextProps);
      // Nothing to do here. This is terminal. We'll do the completion step
      // immediately after.
      return null;
    }

    function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
      !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      var fn = workInProgress.type;
      var props = workInProgress.pendingProps;
      var unmaskedContext = getUnmaskedContext(workInProgress);
      var context = getMaskedContext(workInProgress, unmaskedContext);

      var value;

      {
        if (fn.prototype && typeof fn.prototype.render === 'function') {
          var componentName = getComponentName(workInProgress);
          warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
        }
        ReactCurrentOwner.current = workInProgress;
        value = fn(props, context);
      }
      // React DevTools reads this flag.
      workInProgress.effectTag |= PerformedWork;

      if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
        // Proceed under the assumption that this is a class instance
        workInProgress.tag = ClassComponent;

        // Push context providers early to prevent context stack mismatches.
        // During mounting we don't know the child context yet as the instance doesn't exist.
        // We will invalidate the child context in finishClassComponent() right after rendering.
        var hasContext = pushContextProvider(workInProgress);
        adoptClassInstance(workInProgress, value);
        mountClassInstance(workInProgress, renderExpirationTime);
        return finishClassComponent(current, workInProgress, true, hasContext);
      } else {
        // Proceed under the assumption that this is a functional component
        workInProgress.tag = FunctionalComponent;
        {
          var Component = workInProgress.type;

          if (Component) {
            warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
          }
          if (workInProgress.ref !== null) {
            var info = '';
            var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
            if (ownerName) {
              info += '\n\nCheck the render method of `' + ownerName + '`.';
            }

            var warningKey = ownerName || workInProgress._debugID || '';
            var debugSource = workInProgress._debugSource;
            if (debugSource) {
              warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
            }
            if (!warnedAboutStatelessRefs[warningKey]) {
              warnedAboutStatelessRefs[warningKey] = true;
              warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
            }
          }
        }
        reconcileChildren(current, workInProgress, value);
        memoizeProps(workInProgress, props);
        return workInProgress.child;
      }
    }

    function updateCallComponent(current, workInProgress, renderExpirationTime) {
      var nextCall = workInProgress.pendingProps;
      if (hasContextChanged()) {
        // Normally we can bail out on props equality but if context has changed
        // we don't do the bailout and we have to reuse existing props instead.
        if (nextCall === null) {
          nextCall = current && current.memoizedProps;
          !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        }
      } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
        nextCall = workInProgress.memoizedProps;
        // TODO: When bailing out, we might need to return the stateNode instead
        // of the child. To check it for work.
        // return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }

      var nextChildren = nextCall.children;

      // The following is a fork of reconcileChildrenAtExpirationTime but using
      // stateNode to store the child.
      if (current === null) {
        workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
      } else {
        workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
      }

      memoizeProps(workInProgress, nextCall);
      // This doesn't take arbitrary time so we could synchronously just begin
      // eagerly do the work of workInProgress.child as an optimization.
      return workInProgress.stateNode;
    }

    function updatePortalComponent(current, workInProgress, renderExpirationTime) {
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      var nextChildren = workInProgress.pendingProps;
      if (hasContextChanged()) {
        // Normally we can bail out on props equality but if context has changed
        // we don't do the bailout and we have to reuse existing props instead.
        if (nextChildren === null) {
          nextChildren = current && current.memoizedProps;
          !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        }
      } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }

      if (current === null) {
        // Portals are special because we don't append the children during mount
        // but at commit. Therefore we need to track insertions which the normal
        // flow doesn't do during mount. This doesn't happen at the root because
        // the root always starts with a "current" with a null child.
        // TODO: Consider unifying this with how the root works.
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        memoizeProps(workInProgress, nextChildren);
      } else {
        reconcileChildren(current, workInProgress, nextChildren);
        memoizeProps(workInProgress, nextChildren);
      }
      return workInProgress.child;
    }

    /*
    function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
      let child = firstChild;
      do {
        // Ensure that the first and last effect of the parent corresponds
        // to the children's first and last effect.
        if (!returnFiber.firstEffect) {
          returnFiber.firstEffect = child.firstEffect;
        }
        if (child.lastEffect) {
          if (returnFiber.lastEffect) {
            returnFiber.lastEffect.nextEffect = child.firstEffect;
          }
          returnFiber.lastEffect = child.lastEffect;
        }
      } while (child = child.sibling);
    }
    */

    function bailoutOnAlreadyFinishedWork(current, workInProgress) {
      cancelWorkTimer(workInProgress);

      // TODO: We should ideally be able to bail out early if the children have no
      // more work to do. However, since we don't have a separation of this
      // Fiber's priority and its children yet - we don't know without doing lots
      // of the same work we do anyway. Once we have that separation we can just
      // bail out here if the children has no more work at this priority level.
      // if (workInProgress.priorityOfChildren <= priorityLevel) {
      //   // If there are side-effects in these children that have not yet been
      //   // committed we need to ensure that they get properly transferred up.
      //   if (current && current.child !== workInProgress.child) {
      //     reuseChildrenEffects(workInProgress, child);
      //   }
      //   return null;
      // }

      cloneChildFibers(current, workInProgress);
      return workInProgress.child;
    }

    function bailoutOnLowPriority(current, workInProgress) {
      cancelWorkTimer(workInProgress);

      // TODO: Handle HostComponent tags here as well and call pushHostContext()?
      // See PR 8590 discussion for context
      switch (workInProgress.tag) {
        case HostRoot:
          pushHostRootContext(workInProgress);
          break;
        case ClassComponent:
          pushContextProvider(workInProgress);
          break;
        case HostPortal:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;
      }
      // TODO: What if this is currently in progress?
      // How can that happen? How is this not being cloned?
      return null;
    }

    // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
    function memoizeProps(workInProgress, nextProps) {
      workInProgress.memoizedProps = nextProps;
    }

    function memoizeState(workInProgress, nextState) {
      workInProgress.memoizedState = nextState;
      // Don't reset the updateQueue, in case there are pending updates. Resetting
      // is handled by processUpdateQueue.
    }

    function beginWork(current, workInProgress, renderExpirationTime) {
      if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
        return bailoutOnLowPriority(current, workInProgress);
      }

      switch (workInProgress.tag) {
        case IndeterminateComponent:
          return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
        case FunctionalComponent:
          return updateFunctionalComponent(current, workInProgress);
        case ClassComponent:
          return updateClassComponent(current, workInProgress, renderExpirationTime);
        case HostRoot:
          return updateHostRoot(current, workInProgress, renderExpirationTime);
        case HostComponent:
          return updateHostComponent(current, workInProgress, renderExpirationTime);
        case HostText:
          return updateHostText(current, workInProgress);
        case CallHandlerPhase:
          // This is a restart. Reset the tag to the initial phase.
          workInProgress.tag = CallComponent;
        // Intentionally fall through since this is now the same.
        case CallComponent:
          return updateCallComponent(current, workInProgress, renderExpirationTime);
        case ReturnComponent:
          // A return component is just a placeholder, we can just run through the
          // next one immediately.
          return null;
        case HostPortal:
          return updatePortalComponent(current, workInProgress, renderExpirationTime);
        case Fragment:
          return updateFragment(current, workInProgress);
        default:
          invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
      }
    }

    function beginFailedWork(current, workInProgress, renderExpirationTime) {
      // Push context providers here to avoid a push/pop context mismatch.
      switch (workInProgress.tag) {
        case ClassComponent:
          pushContextProvider(workInProgress);
          break;
        case HostRoot:
          pushHostRootContext(workInProgress);
          break;
        default:
          invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
      }

      // Add an error effect so we can handle the error during the commit phase
      workInProgress.effectTag |= Err;

      // This is a weird case where we do "resume" work — work that failed on
      // our first attempt. Because we no longer have a notion of "progressed
      // deletions," reset the child to the current child to make sure we delete
      // it again. TODO: Find a better way to handle this, perhaps during a more
      // general overhaul of error handling.
      if (current === null) {
        workInProgress.child = null;
      } else if (workInProgress.child !== current.child) {
        workInProgress.child = current.child;
      }

      if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
        return bailoutOnLowPriority(current, workInProgress);
      }

      // If we don't bail out, we're going be recomputing our children so we need
      // to drop our effect list.
      workInProgress.firstEffect = null;
      workInProgress.lastEffect = null;

      // Unmount the current children as if the component rendered null
      var nextChildren = null;
      reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

      if (workInProgress.tag === ClassComponent) {
        var instance = workInProgress.stateNode;
        workInProgress.memoizedProps = instance.props;
        workInProgress.memoizedState = instance.state;
      }

      return workInProgress.child;
    }

    return {
      beginWork: beginWork,
      beginFailedWork: beginFailedWork
    };
  };

  var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
    var createInstance = config.createInstance,
        createTextInstance = config.createTextInstance,
        appendInitialChild = config.appendInitialChild,
        finalizeInitialChildren = config.finalizeInitialChildren,
        prepareUpdate = config.prepareUpdate,
        mutation = config.mutation,
        persistence = config.persistence;
    var getRootHostContainer = hostContext.getRootHostContainer,
        popHostContext = hostContext.popHostContext,
        getHostContext = hostContext.getHostContext,
        popHostContainer = hostContext.popHostContainer;
    var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
        prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
        popHydrationState = hydrationContext.popHydrationState;


    function markUpdate(workInProgress) {
      // Tag the fiber with an update effect. This turns a Placement into
      // an UpdateAndPlacement.
      workInProgress.effectTag |= Update;
    }

    function markRef(workInProgress) {
      workInProgress.effectTag |= Ref;
    }

    function appendAllReturns(returns, workInProgress) {
      var node = workInProgress.stateNode;
      if (node) {
        node['return'] = workInProgress;
      }
      while (node !== null) {
        if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
          invariant(false, 'A call cannot have host component children.');
        } else if (node.tag === ReturnComponent) {
          returns.push(node.type);
        } else if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
        while (node.sibling === null) {
          if (node['return'] === null || node['return'] === workInProgress) {
            return;
          }
          node = node['return'];
        }
        node.sibling['return'] = node['return'];
        node = node.sibling;
      }
    }

    function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
      var call = workInProgress.memoizedProps;
      !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      // First step of the call has completed. Now we need to do the second.
      // TODO: It would be nice to have a multi stage call represented by a
      // single component, or at least tail call optimize nested ones. Currently
      // that requires additional fields that we don't want to add to the fiber.
      // So this requires nested handlers.
      // Note: This doesn't mutate the alternate node. I don't think it needs to
      // since this stage is reset for every pass.
      workInProgress.tag = CallHandlerPhase;

      // Build up the returns.
      // TODO: Compare this to a generator or opaque helpers like Children.
      var returns = [];
      appendAllReturns(returns, workInProgress);
      var fn = call.handler;
      var props = call.props;
      var nextChildren = fn(props, returns);

      var currentFirstChild = current !== null ? current.child : null;
      workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
      return workInProgress.child;
    }

    function appendAllChildren(parent, workInProgress) {
      // We only have the top Fiber that was created but we need recurse down its
      // children to find all the terminal nodes.
      var node = workInProgress.child;
      while (node !== null) {
        if (node.tag === HostComponent || node.tag === HostText) {
          appendInitialChild(parent, node.stateNode);
        } else if (node.tag === HostPortal) {
          // If we have a portal child, then we don't want to traverse
          // down its children. Instead, we'll get insertions from each child in
          // the portal directly.
        } else if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
        if (node === workInProgress) {
          return;
        }
        while (node.sibling === null) {
          if (node['return'] === null || node['return'] === workInProgress) {
            return;
          }
          node = node['return'];
        }
        node.sibling['return'] = node['return'];
        node = node.sibling;
      }
    }

    var updateHostContainer = void 0;
    var updateHostComponent = void 0;
    var updateHostText = void 0;
    if (mutation) {
      if (enableMutatingReconciler) {
        // Mutation mode
        updateHostContainer = function (workInProgress) {
          // Noop
        };
        updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
          // TODO: Type this specific to this type of component.
          workInProgress.updateQueue = updatePayload;
          // If the update payload indicates that there is a change or if there
          // is a new ref we mark this as an update. All the work is done in commitWork.
          if (updatePayload) {
            markUpdate(workInProgress);
          }
        };
        updateHostText = function (current, workInProgress, oldText, newText) {
          // If the text differs, mark it as an update. All the work in done in commitWork.
          if (oldText !== newText) {
            markUpdate(workInProgress);
          }
        };
      } else {
        invariant(false, 'Mutating reconciler is disabled.');
      }
    } else if (persistence) {
      if (enablePersistentReconciler) {
        // Persistent host tree mode
        var cloneInstance = persistence.cloneInstance,
            createContainerChildSet = persistence.createContainerChildSet,
            appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
            finalizeContainerChildren = persistence.finalizeContainerChildren;

        // An unfortunate fork of appendAllChildren because we have two different parent types.

        var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
          // We only have the top Fiber that was created but we need recurse down its
          // children to find all the terminal nodes.
          var node = workInProgress.child;
          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendChildToContainerChildSet(containerChildSet, node.stateNode);
            } else if (node.tag === HostPortal) {
              // If we have a portal child, then we don't want to traverse
              // down its children. Instead, we'll get insertions from each child in
              // the portal directly.
            } else if (node.child !== null) {
              node.child['return'] = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress) {
              return;
            }
            while (node.sibling === null) {
              if (node['return'] === null || node['return'] === workInProgress) {
                return;
              }
              node = node['return'];
            }
            node.sibling['return'] = node['return'];
            node = node.sibling;
          }
        };
        updateHostContainer = function (workInProgress) {
          var portalOrRoot = workInProgress.stateNode;
          var childrenUnchanged = workInProgress.firstEffect === null;
          if (childrenUnchanged) {
            // No changes, just reuse the existing instance.
          } else {
            var container = portalOrRoot.containerInfo;
            var newChildSet = createContainerChildSet(container);
            if (finalizeContainerChildren(container, newChildSet)) {
              markUpdate(workInProgress);
            }
            portalOrRoot.pendingChildren = newChildSet;
            // If children might have changed, we have to add them all to the set.
            appendAllChildrenToContainer(newChildSet, workInProgress);
            // Schedule an update on the container to swap out the container.
            markUpdate(workInProgress);
          }
        };
        updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
          // If there are no effects associated with this node, then none of our children had any updates.
          // This guarantees that we can reuse all of them.
          var childrenUnchanged = workInProgress.firstEffect === null;
          var currentInstance = current.stateNode;
          if (childrenUnchanged && updatePayload === null) {
            // No changes, just reuse the existing instance.
            // Note that this might release a previous clone.
            workInProgress.stateNode = currentInstance;
          } else {
            var recyclableInstance = workInProgress.stateNode;
            var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
            if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
              markUpdate(workInProgress);
            }
            workInProgress.stateNode = newInstance;
            if (childrenUnchanged) {
              // If there are no other effects in this tree, we need to flag this node as having one.
              // Even though we're not going to use it for anything.
              // Otherwise parents won't know that there are new children to propagate upwards.
              markUpdate(workInProgress);
            } else {
              // If children might have changed, we have to add them all to the set.
              appendAllChildren(newInstance, workInProgress);
            }
          }
        };
        updateHostText = function (current, workInProgress, oldText, newText) {
          if (oldText !== newText) {
            // If the text content differs, we'll create a new text instance for it.
            var rootContainerInstance = getRootHostContainer();
            var currentHostContext = getHostContext();
            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
            // We'll have to mark it as having an effect, even though we won't use the effect for anything.
            // This lets the parents know that at least one of their children has changed.
            markUpdate(workInProgress);
          }
        };
      } else {
        invariant(false, 'Persistent reconciler is disabled.');
      }
    } else {
      if (enableNoopReconciler) {
        // No host operations
        updateHostContainer = function (workInProgress) {
          // Noop
        };
        updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
          // Noop
        };
        updateHostText = function (current, workInProgress, oldText, newText) {
          // Noop
        };
      } else {
        invariant(false, 'Noop reconciler is disabled.');
      }
    }

    function completeWork(current, workInProgress, renderExpirationTime) {
      // Get the latest props.
      var newProps = workInProgress.pendingProps;
      if (newProps === null) {
        newProps = workInProgress.memoizedProps;
      } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
        // Reset the pending props, unless this was a down-prioritization.
        workInProgress.pendingProps = null;
      }

      switch (workInProgress.tag) {
        case FunctionalComponent:
          return null;
        case ClassComponent:
          {
            // We are leaving this subtree, so pop context if any.
            popContextProvider(workInProgress);
            return null;
          }
        case HostRoot:
          {
            popHostContainer(workInProgress);
            popTopLevelContextObject(workInProgress);
            var fiberRoot = workInProgress.stateNode;
            if (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = null;
            }

            if (current === null || current.child === null) {
              // If we hydrated, pop so that we can delete any remaining children
              // that weren't hydrated.
              popHydrationState(workInProgress);
              // This resets the hacky state to fix isMounted before committing.
              // TODO: Delete this when we delete isMounted and findDOMNode.
              workInProgress.effectTag &= ~Placement;
            }
            updateHostContainer(workInProgress);
            return null;
          }
        case HostComponent:
          {
            popHostContext(workInProgress);
            var rootContainerInstance = getRootHostContainer();
            var type = workInProgress.type;
            if (current !== null && workInProgress.stateNode != null) {
              // If we have an alternate, that means this is an update and we need to
              // schedule a side-effect to do the updates.
              var oldProps = current.memoizedProps;
              // If we get updated because one of our children updated, we don't
              // have newProps so we'll have to reuse them.
              // TODO: Split the update API as separate for the props vs. children.
              // Even better would be if children weren't special cased at all tho.
              var instance = workInProgress.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

              updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

              if (current.ref !== workInProgress.ref) {
                markRef(workInProgress);
              }
            } else {
              if (!newProps) {
                !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
                // This can happen when we abort work.
                return null;
              }

              var _currentHostContext = getHostContext();
              // TODO: Move createInstance to beginWork and keep it on a context
              // "stack" as the parent. Then append children as we go in beginWork
              // or completeWork depending on we want to add then top->down or
              // bottom->up. Top->down is faster in IE11.
              var wasHydrated = popHydrationState(workInProgress);
              if (wasHydrated) {
                // TODO: Move this and createInstance step into the beginPhase
                // to consolidate.
                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                  // If changes to the hydrated node needs to be applied at the
                  // commit-phase we mark this as such.
                  markUpdate(workInProgress);
                }
              } else {
                var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

                appendAllChildren(_instance, workInProgress);

                // Certain renderers require commit-time effects for initial mount.
                // (eg DOM renderer supports auto-focus for certain elements).
                // Make sure such renderers get scheduled for later work.
                if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                  markUpdate(workInProgress);
                }
                workInProgress.stateNode = _instance;
              }

              if (workInProgress.ref !== null) {
                // If there is a ref on a host node we need to schedule a callback
                markRef(workInProgress);
              }
            }
            return null;
          }
        case HostText:
          {
            var newText = newProps;
            if (current && workInProgress.stateNode != null) {
              var oldText = current.memoizedProps;
              // If we have an alternate, that means this is an update and we need
              // to schedule a side-effect to do the updates.
              updateHostText(current, workInProgress, oldText, newText);
            } else {
              if (typeof newText !== 'string') {
                !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
                // This can happen when we abort work.
                return null;
              }
              var _rootContainerInstance = getRootHostContainer();
              var _currentHostContext2 = getHostContext();
              var _wasHydrated = popHydrationState(workInProgress);
              if (_wasHydrated) {
                if (prepareToHydrateHostTextInstance(workInProgress)) {
                  markUpdate(workInProgress);
                }
              } else {
                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
              }
            }
            return null;
          }
        case CallComponent:
          return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
        case CallHandlerPhase:
          // Reset the tag to now be a first phase call.
          workInProgress.tag = CallComponent;
          return null;
        case ReturnComponent:
          // Does nothing.
          return null;
        case Fragment:
          return null;
        case HostPortal:
          popHostContainer(workInProgress);
          updateHostContainer(workInProgress);
          return null;
        // Error cases
        case IndeterminateComponent:
          invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
        // eslint-disable-next-line no-fallthrough
        default:
          invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
      }
    }

    return {
      completeWork: completeWork
    };
  };

  var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
  var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
  var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


  var ReactFiberCommitWork = function (config, captureError) {
    var getPublicInstance = config.getPublicInstance,
        mutation = config.mutation,
        persistence = config.persistence;


    var callComponentWillUnmountWithTimer = function (current, instance) {
      startPhaseTimer(current, 'componentWillUnmount');
      instance.props = current.memoizedProps;
      instance.state = current.memoizedState;
      instance.componentWillUnmount();
      stopPhaseTimer();
    };

    // Capture errors so they don't interrupt unmounting.
    function safelyCallComponentWillUnmount(current, instance) {
      {
        invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
        if (hasCaughtError$1()) {
          var unmountError = clearCaughtError$1();
          captureError(current, unmountError);
        }
      }
    }

    function safelyDetachRef(current) {
      var ref = current.ref;
      if (ref !== null) {
        {
          invokeGuardedCallback$2(null, ref, null, null);
          if (hasCaughtError$1()) {
            var refError = clearCaughtError$1();
            captureError(current, refError);
          }
        }
      }
    }

    function commitLifeCycles(current, finishedWork) {
      switch (finishedWork.tag) {
        case ClassComponent:
          {
            var instance = finishedWork.stateNode;
            if (finishedWork.effectTag & Update) {
              if (current === null) {
                startPhaseTimer(finishedWork, 'componentDidMount');
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                instance.componentDidMount();
                stopPhaseTimer();
              } else {
                var prevProps = current.memoizedProps;
                var prevState = current.memoizedState;
                startPhaseTimer(finishedWork, 'componentDidUpdate');
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                instance.componentDidUpdate(prevProps, prevState);
                stopPhaseTimer();
              }
            }
            var updateQueue = finishedWork.updateQueue;
            if (updateQueue !== null) {
              commitCallbacks(updateQueue, instance);
            }
            return;
          }
        case HostRoot:
          {
            var _updateQueue = finishedWork.updateQueue;
            if (_updateQueue !== null) {
              var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
              commitCallbacks(_updateQueue, _instance);
            }
            return;
          }
        case HostComponent:
          {
            var _instance2 = finishedWork.stateNode;

            // Renderers may schedule work to be done after host components are mounted
            // (eg DOM renderer may schedule auto-focus for inputs and form controls).
            // These effects should only be committed when components are first mounted,
            // aka when there is no current/alternate.
            if (current === null && finishedWork.effectTag & Update) {
              var type = finishedWork.type;
              var props = finishedWork.memoizedProps;
              commitMount(_instance2, type, props, finishedWork);
            }

            return;
          }
        case HostText:
          {
            // We have no life-cycles associated with text.
            return;
          }
        case HostPortal:
          {
            // We have no life-cycles associated with portals.
            return;
          }
        default:
          {
            invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
          }
      }
    }

    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (ref !== null) {
        var instance = finishedWork.stateNode;
        switch (finishedWork.tag) {
          case HostComponent:
            ref(getPublicInstance(instance));
            break;
          default:
            ref(instance);
        }
      }
    }

    function commitDetachRef(current) {
      var currentRef = current.ref;
      if (currentRef !== null) {
        currentRef(null);
      }
    }

    // User-originating errors (lifecycles and refs) should not interrupt
    // deletion, so don't let them throw. Host-originating errors should
    // interrupt deletion, so it's okay
    function commitUnmount(current) {
      if (typeof onCommitUnmount === 'function') {
        onCommitUnmount(current);
      }

      switch (current.tag) {
        case ClassComponent:
          {
            safelyDetachRef(current);
            var instance = current.stateNode;
            if (typeof instance.componentWillUnmount === 'function') {
              safelyCallComponentWillUnmount(current, instance);
            }
            return;
          }
        case HostComponent:
          {
            safelyDetachRef(current);
            return;
          }
        case CallComponent:
          {
            commitNestedUnmounts(current.stateNode);
            return;
          }
        case HostPortal:
          {
            // TODO: this is recursive.
            // We are also not using this parent because
            // the portal will get pushed immediately.
            if (enableMutatingReconciler && mutation) {
              unmountHostComponents(current);
            } else if (enablePersistentReconciler && persistence) {
              emptyPortalContainer(current);
            }
            return;
          }
      }
    }

    function commitNestedUnmounts(root) {
      // While we're inside a removed host node we don't want to call
      // removeChild on the inner nodes because they're removed by the top
      // call anyway. We also want to call componentWillUnmount on all
      // composites before this host node is removed from the tree. Therefore
      var node = root;
      while (true) {
        commitUnmount(node);
        // Visit children because they may contain more composite or host nodes.
        // Skip portals because commitUnmount() currently visits them recursively.
        if (node.child !== null && (
        // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        !mutation || node.tag !== HostPortal)) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
        if (node === root) {
          return;
        }
        while (node.sibling === null) {
          if (node['return'] === null || node['return'] === root) {
            return;
          }
          node = node['return'];
        }
        node.sibling['return'] = node['return'];
        node = node.sibling;
      }
    }

    function detachFiber(current) {
      // Cut off the return pointers to disconnect it from the tree. Ideally, we
      // should clear the child pointer of the parent alternate to let this
      // get GC:ed but we don't know which for sure which parent is the current
      // one so we'll settle for GC:ing the subtree of this child. This child
      // itself will be GC:ed when the parent updates the next time.
      current['return'] = null;
      current.child = null;
      if (current.alternate) {
        current.alternate.child = null;
        current.alternate['return'] = null;
      }
    }

    if (!mutation) {
      var commitContainer = void 0;
      if (persistence) {
        var replaceContainerChildren = persistence.replaceContainerChildren,
            createContainerChildSet = persistence.createContainerChildSet;

        var emptyPortalContainer = function (current) {
          var portal = current.stateNode;
          var containerInfo = portal.containerInfo;

          var emptyChildSet = createContainerChildSet(containerInfo);
          replaceContainerChildren(containerInfo, emptyChildSet);
        };
        commitContainer = function (finishedWork) {
          switch (finishedWork.tag) {
            case ClassComponent:
              {
                return;
              }
            case HostComponent:
              {
                return;
              }
            case HostText:
              {
                return;
              }
            case HostRoot:
            case HostPortal:
              {
                var portalOrRoot = finishedWork.stateNode;
                var containerInfo = portalOrRoot.containerInfo,
                    _pendingChildren = portalOrRoot.pendingChildren;

                replaceContainerChildren(containerInfo, _pendingChildren);
                return;
              }
            default:
              {
                invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
              }
          }
        };
      } else {
        commitContainer = function (finishedWork) {
          // Noop
        };
      }
      if (enablePersistentReconciler || enableNoopReconciler) {
        return {
          commitResetTextContent: function (finishedWork) {},
          commitPlacement: function (finishedWork) {},
          commitDeletion: function (current) {
            // Detach refs and call componentWillUnmount() on the whole subtree.
            commitNestedUnmounts(current);
            detachFiber(current);
          },
          commitWork: function (current, finishedWork) {
            commitContainer(finishedWork);
          },

          commitLifeCycles: commitLifeCycles,
          commitAttachRef: commitAttachRef,
          commitDetachRef: commitDetachRef
        };
      } else if (persistence) {
        invariant(false, 'Persistent reconciler is disabled.');
      } else {
        invariant(false, 'Noop reconciler is disabled.');
      }
    }
    var commitMount = mutation.commitMount,
        commitUpdate = mutation.commitUpdate,
        resetTextContent = mutation.resetTextContent,
        commitTextUpdate = mutation.commitTextUpdate,
        appendChild = mutation.appendChild,
        appendChildToContainer = mutation.appendChildToContainer,
        insertBefore = mutation.insertBefore,
        insertInContainerBefore = mutation.insertInContainerBefore,
        removeChild = mutation.removeChild,
        removeChildFromContainer = mutation.removeChildFromContainer;


    function getHostParentFiber(fiber) {
      var parent = fiber['return'];
      while (parent !== null) {
        if (isHostParent(parent)) {
          return parent;
        }
        parent = parent['return'];
      }
      invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
    }

    function isHostParent(fiber) {
      return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
    }

    function getHostSibling(fiber) {
      // We're going to search forward into the tree until we find a sibling host
      // node. Unfortunately, if multiple insertions are done in a row we have to
      // search past them. This leads to exponential search for the next sibling.
      var node = fiber;
      siblings: while (true) {
        // If we didn't find anything, let's try the next sibling.
        while (node.sibling === null) {
          if (node['return'] === null || isHostParent(node['return'])) {
            // If we pop out of the root or hit the parent the fiber we are the
            // last sibling.
            return null;
          }
          node = node['return'];
        }
        node.sibling['return'] = node['return'];
        node = node.sibling;
        while (node.tag !== HostComponent && node.tag !== HostText) {
          // If it is not host node and, we might have a host node inside it.
          // Try to search down until we find one.
          if (node.effectTag & Placement) {
            // If we don't have a child, try the siblings instead.
            continue siblings;
          }
          // If we don't have a child, try the siblings instead.
          // We also skip portals because they are not part of this host tree.
          if (node.child === null || node.tag === HostPortal) {
            continue siblings;
          } else {
            node.child['return'] = node;
            node = node.child;
          }
        }
        // Check if this host node is stable or about to be placed.
        if (!(node.effectTag & Placement)) {
          // Found it!
          return node.stateNode;
        }
      }
    }

    function commitPlacement(finishedWork) {
      // Recursively insert all host nodes into the parent.
      var parentFiber = getHostParentFiber(finishedWork);
      var parent = void 0;
      var isContainer = void 0;
      switch (parentFiber.tag) {
        case HostComponent:
          parent = parentFiber.stateNode;
          isContainer = false;
          break;
        case HostRoot:
          parent = parentFiber.stateNode.containerInfo;
          isContainer = true;
          break;
        case HostPortal:
          parent = parentFiber.stateNode.containerInfo;
          isContainer = true;
          break;
        default:
          invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
      }
      if (parentFiber.effectTag & ContentReset) {
        // Reset the text content of the parent before doing any insertions
        resetTextContent(parent);
        // Clear ContentReset from the effect tag
        parentFiber.effectTag &= ~ContentReset;
      }

      var before = getHostSibling(finishedWork);
      // We only have the top Fiber that was inserted but we need recurse down its
      // children to find all the terminal nodes.
      var node = finishedWork;
      while (true) {
        if (node.tag === HostComponent || node.tag === HostText) {
          if (before) {
            if (isContainer) {
              insertInContainerBefore(parent, node.stateNode, before);
            } else {
              insertBefore(parent, node.stateNode, before);
            }
          } else {
            if (isContainer) {
              appendChildToContainer(parent, node.stateNode);
            } else {
              appendChild(parent, node.stateNode);
            }
          }
        } else if (node.tag === HostPortal) {
          // If the insertion itself is a portal, then we don't want to traverse
          // down its children. Instead, we'll get insertions from each child in
          // the portal directly.
        } else if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
        if (node === finishedWork) {
          return;
        }
        while (node.sibling === null) {
          if (node['return'] === null || node['return'] === finishedWork) {
            return;
          }
          node = node['return'];
        }
        node.sibling['return'] = node['return'];
        node = node.sibling;
      }
    }

    function unmountHostComponents(current) {
      // We only have the top Fiber that was inserted but we need recurse down its
      var node = current;

      // Each iteration, currentParent is populated with node's host parent if not
      // currentParentIsValid.
      var currentParentIsValid = false;
      var currentParent = void 0;
      var currentParentIsContainer = void 0;

      while (true) {
        if (!currentParentIsValid) {
          var parent = node['return'];
          findParent: while (true) {
            !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
            switch (parent.tag) {
              case HostComponent:
                currentParent = parent.stateNode;
                currentParentIsContainer = false;
                break findParent;
              case HostRoot:
                currentParent = parent.stateNode.containerInfo;
                currentParentIsContainer = true;
                break findParent;
              case HostPortal:
                currentParent = parent.stateNode.containerInfo;
                currentParentIsContainer = true;
                break findParent;
            }
            parent = parent['return'];
          }
          currentParentIsValid = true;
        }

        if (node.tag === HostComponent || node.tag === HostText) {
          commitNestedUnmounts(node);
          // After all the children have unmounted, it is now safe to remove the
          // node from the tree.
          if (currentParentIsContainer) {
            removeChildFromContainer(currentParent, node.stateNode);
          } else {
            removeChild(currentParent, node.stateNode);
          }
          // Don't visit children because we already visited them.
        } else if (node.tag === HostPortal) {
          // When we go into a portal, it becomes the parent to remove from.
          // We will reassign it back when we pop the portal on the way up.
          currentParent = node.stateNode.containerInfo;
          // Visit children because portals might contain host components.
          if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
        } else {
          commitUnmount(node);
          // Visit children because we may find more host components below.
          if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
        }
        if (node === current) {
          return;
        }
        while (node.sibling === null) {
          if (node['return'] === null || node['return'] === current) {
            return;
          }
          node = node['return'];
          if (node.tag === HostPortal) {
            // When we go out of the portal, we need to restore the parent.
            // Since we don't keep a stack of them, we will search for it.
            currentParentIsValid = false;
          }
        }
        node.sibling['return'] = node['return'];
        node = node.sibling;
      }
    }

    function commitDeletion(current) {
      // Recursively delete all host nodes from the parent.
      // Detach refs and call componentWillUnmount() on the whole subtree.
      unmountHostComponents(current);
      detachFiber(current);
    }

    function commitWork(current, finishedWork) {
      switch (finishedWork.tag) {
        case ClassComponent:
          {
            return;
          }
        case HostComponent:
          {
            var instance = finishedWork.stateNode;
            if (instance != null) {
              // Commit the work prepared earlier.
              var newProps = finishedWork.memoizedProps;
              // For hydration we reuse the update path but we treat the oldProps
              // as the newProps. The updatePayload will contain the real change in
              // this case.
              var oldProps = current !== null ? current.memoizedProps : newProps;
              var type = finishedWork.type;
              // TODO: Type the updateQueue to be specific to host components.
              var updatePayload = finishedWork.updateQueue;
              finishedWork.updateQueue = null;
              if (updatePayload !== null) {
                commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
              }
            }
            return;
          }
        case HostText:
          {
            !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
            var textInstance = finishedWork.stateNode;
            var newText = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldText = current !== null ? current.memoizedProps : newText;
            commitTextUpdate(textInstance, oldText, newText);
            return;
          }
        case HostRoot:
          {
            return;
          }
        default:
          {
            invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
          }
      }
    }

    function commitResetTextContent(current) {
      resetTextContent(current.stateNode);
    }

    if (enableMutatingReconciler) {
      return {
        commitResetTextContent: commitResetTextContent,
        commitPlacement: commitPlacement,
        commitDeletion: commitDeletion,
        commitWork: commitWork,
        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  };

  var NO_CONTEXT = {};

  var ReactFiberHostContext = function (config) {
    var getChildHostContext = config.getChildHostContext,
        getRootHostContext = config.getRootHostContext;


    var contextStackCursor = createCursor(NO_CONTEXT);
    var contextFiberStackCursor = createCursor(NO_CONTEXT);
    var rootInstanceStackCursor = createCursor(NO_CONTEXT);

    function requiredContext(c) {
      !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      return c;
    }

    function getRootHostContainer() {
      var rootInstance = requiredContext(rootInstanceStackCursor.current);
      return rootInstance;
    }

    function pushHostContainer(fiber, nextRootInstance) {
      // Push current root instance onto the stack;
      // This allows us to reset root when portals are popped.
      push(rootInstanceStackCursor, nextRootInstance, fiber);

      var nextRootContext = getRootHostContext(nextRootInstance);

      // Track the context and the Fiber that provided it.
      // This enables us to pop only Fibers that provide unique contexts.
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }

    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }

    function getHostContext() {
      var context = requiredContext(contextStackCursor.current);
      return context;
    }

    function pushHostContext(fiber) {
      var rootInstance = requiredContext(rootInstanceStackCursor.current);
      var context = requiredContext(contextStackCursor.current);
      var nextContext = getChildHostContext(context, fiber.type, rootInstance);

      // Don't push this Fiber's context unless it's unique.
      if (context === nextContext) {
        return;
      }

      // Track the context and the Fiber that provided it.
      // This enables us to pop only Fibers that provide unique contexts.
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, nextContext, fiber);
    }

    function popHostContext(fiber) {
      // Do not pop unless this Fiber provided the current context.
      // pushHostContext() only pushes Fibers that provide unique contexts.
      if (contextFiberStackCursor.current !== fiber) {
        return;
      }

      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
    }

    function resetHostContainer() {
      contextStackCursor.current = NO_CONTEXT;
      rootInstanceStackCursor.current = NO_CONTEXT;
    }

    return {
      getHostContext: getHostContext,
      getRootHostContainer: getRootHostContainer,
      popHostContainer: popHostContainer,
      popHostContext: popHostContext,
      pushHostContainer: pushHostContainer,
      pushHostContext: pushHostContext,
      resetHostContainer: resetHostContainer
    };
  };

  var ReactFiberHydrationContext = function (config) {
    var shouldSetTextContent = config.shouldSetTextContent,
        hydration = config.hydration;

    // If this doesn't have hydration mode.

    if (!hydration) {
      return {
        enterHydrationState: function () {
          return false;
        },
        resetHydrationState: function () {},
        tryToClaimNextHydratableInstance: function () {},
        prepareToHydrateHostInstance: function () {
          invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
        },
        prepareToHydrateHostTextInstance: function () {
          invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
        },
        popHydrationState: function (fiber) {
          return false;
        }
      };
    }

    var canHydrateInstance = hydration.canHydrateInstance,
        canHydrateTextInstance = hydration.canHydrateTextInstance,
        getNextHydratableSibling = hydration.getNextHydratableSibling,
        getFirstHydratableChild = hydration.getFirstHydratableChild,
        hydrateInstance = hydration.hydrateInstance,
        hydrateTextInstance = hydration.hydrateTextInstance,
        didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
        didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
        didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
        didNotHydrateInstance = hydration.didNotHydrateInstance,
        didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
        didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
        didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
        didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

    // The deepest Fiber on the stack involved in a hydration context.
    // This may have been an insertion or a hydration.

    var hydrationParentFiber = null;
    var nextHydratableInstance = null;
    var isHydrating = false;

    function enterHydrationState(fiber) {
      var parentInstance = fiber.stateNode.containerInfo;
      nextHydratableInstance = getFirstHydratableChild(parentInstance);
      hydrationParentFiber = fiber;
      isHydrating = true;
      return true;
    }

    function deleteHydratableInstance(returnFiber, instance) {
      {
        switch (returnFiber.tag) {
          case HostRoot:
            didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
            break;
          case HostComponent:
            didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
            break;
        }
      }

      var childToDelete = createFiberFromHostInstanceForDeletion();
      childToDelete.stateNode = instance;
      childToDelete['return'] = returnFiber;
      childToDelete.effectTag = Deletion;

      // This might seem like it belongs on progressedFirstDeletion. However,
      // these children are not part of the reconciliation list of children.
      // Even if we abort and rereconcile the children, that will try to hydrate
      // again and the nodes are still in the host tree so these will be
      // recreated.
      if (returnFiber.lastEffect !== null) {
        returnFiber.lastEffect.nextEffect = childToDelete;
        returnFiber.lastEffect = childToDelete;
      } else {
        returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
      }
    }

    function insertNonHydratedInstance(returnFiber, fiber) {
      fiber.effectTag |= Placement;
      {
        switch (returnFiber.tag) {
          case HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type;
                  var props = fiber.pendingProps;
                  didNotFindHydratableContainerInstance(parentContainer, type, props);
                  break;
                case HostText:
                  var text = fiber.pendingProps;
                  didNotFindHydratableContainerTextInstance(parentContainer, text);
                  break;
              }
              break;
            }
          case HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent:
                  var _type = fiber.type;
                  var _props = fiber.pendingProps;
                  didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                  break;
                case HostText:
                  var _text = fiber.pendingProps;
                  didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                  break;
              }
              break;
            }
          default:
            return;
        }
      }
    }

    function tryHydrate(fiber, nextInstance) {
      switch (fiber.tag) {
        case HostComponent:
          {
            var type = fiber.type;
            var props = fiber.pendingProps;
            var instance = canHydrateInstance(nextInstance, type, props);
            if (instance !== null) {
              fiber.stateNode = instance;
              return true;
            }
            return false;
          }
        case HostText:
          {
            var text = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text);
            if (textInstance !== null) {
              fiber.stateNode = textInstance;
              return true;
            }
            return false;
          }
        default:
          return false;
      }
    }

    function tryToClaimNextHydratableInstance(fiber) {
      if (!isHydrating) {
        return;
      }
      var nextInstance = nextHydratableInstance;
      if (!nextInstance) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      if (!tryHydrate(fiber, nextInstance)) {
        // If we can't hydrate this instance let's try the next one.
        // We use this as a heuristic. It's based on intuition and not data so it
        // might be flawed or unnecessary.
        nextInstance = getNextHydratableSibling(nextInstance);
        if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
          // Nothing to hydrate. Make it an insertion.
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }
        // We matched the next one, we'll now assume that the first one was
        // superfluous and we'll delete it. Since we can't eagerly delete it
        // we'll have to schedule a deletion. To do that, this node needs a dummy
        // fiber associated with it.
        deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
      }
      hydrationParentFiber = fiber;
      nextHydratableInstance = getFirstHydratableChild(nextInstance);
    }

    function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
      var instance = fiber.stateNode;
      var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
      // TODO: Type this specific to this type of component.
      fiber.updateQueue = updatePayload;
      // If the update payload indicates that there is a change or if there
      // is a new ref we mark this as an update.
      if (updatePayload !== null) {
        return true;
      }
      return false;
    }

    function prepareToHydrateHostTextInstance(fiber) {
      var textInstance = fiber.stateNode;
      var textContent = fiber.memoizedProps;
      var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
      {
        if (shouldUpdate) {
          // We assume that prepareToHydrateHostTextInstance is called in a context where the
          // hydration parent is the parent host component of this host text.
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null) {
            switch (returnFiber.tag) {
              case HostRoot:
                {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                  break;
                }
              case HostComponent:
                {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                  break;
                }
            }
          }
        }
      }
      return shouldUpdate;
    }

    function popToNextHostParent(fiber) {
      var parent = fiber['return'];
      while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
        parent = parent['return'];
      }
      hydrationParentFiber = parent;
    }

    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) {
        // We're deeper than the current hydration context, inside an inserted
        // tree.
        return false;
      }
      if (!isHydrating) {
        // If we're not currently hydrating but we're in a hydration context, then
        // we were an insertion and now need to pop up reenter hydration of our
        // siblings.
        popToNextHostParent(fiber);
        isHydrating = true;
        return false;
      }

      var type = fiber.type;

      // If we have any remaining hydratable nodes, we need to delete them now.
      // We only do this deeper than head and body since they tend to have random
      // other nodes in them. We also ignore components with pure text content in
      // side of them.
      // TODO: Better heuristic.
      if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
        var nextInstance = nextHydratableInstance;
        while (nextInstance) {
          deleteHydratableInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }

      popToNextHostParent(fiber);
      nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
      return true;
    }

    function resetHydrationState() {
      hydrationParentFiber = null;
      nextHydratableInstance = null;
      isHydrating = false;
    }

    return {
      enterHydrationState: enterHydrationState,
      resetHydrationState: resetHydrationState,
      tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
      prepareToHydrateHostInstance: prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
      popHydrationState: popHydrationState
    };
  };

  // This lets us hook into Fiber to debug what it's doing.
  // See https://github.com/facebook/react/pull/8033.
  // This is not part of the public API, not even for React DevTools.
  // You may only inject a debugTool if you work on React Fiber itself.
  var ReactFiberInstrumentation = {
    debugTool: null
  };

  var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

  var defaultShowDialog = function (capturedError) {
    return true;
  };

  var showDialog = defaultShowDialog;

  function logCapturedError(capturedError) {
    var logError = showDialog(capturedError);

    // Allow injected showDialog() to prevent default console.error logging.
    // This enables renderers like ReactNative to better manage redbox behavior.
    if (logError === false) {
      return;
    }

    var error = capturedError.error;
    var suppressLogging = error && error.suppressReactErrorLogging;
    if (suppressLogging) {
      return;
    }

    {
      var componentName = capturedError.componentName,
          componentStack = capturedError.componentStack,
          errorBoundaryName = capturedError.errorBoundaryName,
          errorBoundaryFound = capturedError.errorBoundaryFound,
          willRetry = capturedError.willRetry;


      var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

      var errorBoundaryMessage = void 0;
      // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
      if (errorBoundaryFound && errorBoundaryName) {
        if (willRetry) {
          errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
        } else {
          errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
        }
      } else {
        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
      }
      var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

      // In development, we provide our own message with just the component stack.
      // We don't include the original error message and JS stack because the browser
      // has already printed it. Even if the application swallows the error, it is still
      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
      console.error(combinedMessage);
    }
  }

  var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
  var hasCaughtError = ReactErrorUtils.hasCaughtError;
  var clearCaughtError = ReactErrorUtils.clearCaughtError;


  {
    var didWarnAboutStateTransition = false;
    var didWarnSetStateChildContext = false;
    var didWarnStateUpdateForUnmountedComponent = {};

    var warnAboutUpdateOnUnmounted = function (fiber) {
      var componentName = getComponentName(fiber) || 'ReactClass';
      if (didWarnStateUpdateForUnmountedComponent[componentName]) {
        return;
      }
      warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
      didWarnStateUpdateForUnmountedComponent[componentName] = true;
    };

    var warnAboutInvalidUpdates = function (instance) {
      switch (ReactDebugCurrentFiber.phase) {
        case 'getChildContext':
          if (didWarnSetStateChildContext) {
            return;
          }
          warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
          didWarnSetStateChildContext = true;
          break;
        case 'render':
          if (didWarnAboutStateTransition) {
            return;
          }
          warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
          didWarnAboutStateTransition = true;
          break;
      }
    };
  }

  var ReactFiberScheduler = function (config) {
    var hostContext = ReactFiberHostContext(config);
    var hydrationContext = ReactFiberHydrationContext(config);
    var popHostContainer = hostContext.popHostContainer,
        popHostContext = hostContext.popHostContext,
        resetHostContainer = hostContext.resetHostContainer;

    var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
        beginWork = _ReactFiberBeginWork.beginWork,
        beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

    var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
        completeWork = _ReactFiberCompleteWo.completeWork;

    var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
        commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
        commitPlacement = _ReactFiberCommitWork.commitPlacement,
        commitDeletion = _ReactFiberCommitWork.commitDeletion,
        commitWork = _ReactFiberCommitWork.commitWork,
        commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
        commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
        commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

    var now = config.now,
        scheduleDeferredCallback = config.scheduleDeferredCallback,
        cancelDeferredCallback = config.cancelDeferredCallback,
        useSyncScheduling = config.useSyncScheduling,
        prepareForCommit = config.prepareForCommit,
        resetAfterCommit = config.resetAfterCommit;

    // Represents the current time in ms.

    var startTime = now();
    var mostRecentCurrentTime = msToExpirationTime(0);

    // Represents the expiration time that incoming updates should use. (If this
    // is NoWork, use the default strategy: async updates in async mode, sync
    // updates in sync mode.)
    var expirationContext = NoWork;

    var isWorking = false;

    // The next work in progress fiber that we're currently working on.
    var nextUnitOfWork = null;
    var nextRoot = null;
    // The time at which we're currently rendering work.
    var nextRenderExpirationTime = NoWork;

    // The next fiber with an effect that we're currently committing.
    var nextEffect = null;

    // Keep track of which fibers have captured an error that need to be handled.
    // Work is removed from this collection after componentDidCatch is called.
    var capturedErrors = null;
    // Keep track of which fibers have failed during the current batch of work.
    // This is a different set than capturedErrors, because it is not reset until
    // the end of the batch. This is needed to propagate errors correctly if a
    // subtree fails more than once.
    var failedBoundaries = null;
    // Error boundaries that captured an error during the current commit.
    var commitPhaseBoundaries = null;
    var firstUncaughtError = null;
    var didFatal = false;

    var isCommitting = false;
    var isUnmounting = false;

    // Used for performance tracking.
    var interruptedBy = null;

    function resetContextStack() {
      // Reset the stack
      reset$1();
      // Reset the cursors
      resetContext();
      resetHostContainer();
    }

    function commitAllHostEffects() {
      while (nextEffect !== null) {
        {
          ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
        }
        recordEffect();

        var effectTag = nextEffect.effectTag;
        if (effectTag & ContentReset) {
          commitResetTextContent(nextEffect);
        }

        if (effectTag & Ref) {
          var current = nextEffect.alternate;
          if (current !== null) {
            commitDetachRef(current);
          }
        }

        // The following switch statement is only concerned about placement,
        // updates, and deletions. To avoid needing to add a case for every
        // possible bitmap value, we remove the secondary effects from the
        // effect tag and switch on that value.
        var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
        switch (primaryEffectTag) {
          case Placement:
            {
              commitPlacement(nextEffect);
              // Clear the "placement" from effect tag so that we know that this is inserted, before
              // any life-cycles like componentDidMount gets called.
              // TODO: findDOMNode doesn't rely on this any more but isMounted
              // does and isMounted is deprecated anyway so we should be able
              // to kill this.
              nextEffect.effectTag &= ~Placement;
              break;
            }
          case PlacementAndUpdate:
            {
              // Placement
              commitPlacement(nextEffect);
              // Clear the "placement" from effect tag so that we know that this is inserted, before
              // any life-cycles like componentDidMount gets called.
              nextEffect.effectTag &= ~Placement;

              // Update
              var _current = nextEffect.alternate;
              commitWork(_current, nextEffect);
              break;
            }
          case Update:
            {
              var _current2 = nextEffect.alternate;
              commitWork(_current2, nextEffect);
              break;
            }
          case Deletion:
            {
              isUnmounting = true;
              commitDeletion(nextEffect);
              isUnmounting = false;
              break;
            }
        }
        nextEffect = nextEffect.nextEffect;
      }

      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }
    }

    function commitAllLifeCycles() {
      while (nextEffect !== null) {
        var effectTag = nextEffect.effectTag;

        if (effectTag & (Update | Callback)) {
          recordEffect();
          var current = nextEffect.alternate;
          commitLifeCycles(current, nextEffect);
        }

        if (effectTag & Ref) {
          recordEffect();
          commitAttachRef(nextEffect);
        }

        if (effectTag & Err) {
          recordEffect();
          commitErrorHandling(nextEffect);
        }

        var next = nextEffect.nextEffect;
        // Ensure that we clean these up so that we don't accidentally keep them.
        // I'm not actually sure this matters because we can't reset firstEffect
        // and lastEffect since they're on every node, not just the effectful
        // ones. So we have to clean everything as we reuse nodes anyway.
        nextEffect.nextEffect = null;
        // Ensure that we reset the effectTag here so that we can rely on effect
        // tags to reason about the current life-cycle.
        nextEffect = next;
      }
    }

    function commitRoot(finishedWork) {
      // We keep track of this so that captureError can collect any boundaries
      // that capture an error during the commit phase. The reason these aren't
      // local to this function is because errors that occur during cWU are
      // captured elsewhere, to prevent the unmount from being interrupted.
      isWorking = true;
      isCommitting = true;
      startCommitTimer();

      var root = finishedWork.stateNode;
      !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      root.isReadyForCommit = false;

      // Reset this to null before calling lifecycles
      ReactCurrentOwner.current = null;

      var firstEffect = void 0;
      if (finishedWork.effectTag > PerformedWork) {
        // A fiber's effect list consists only of its children, not itself. So if
        // the root has an effect, we need to add it to the end of the list. The
        // resulting list is the set that would belong to the root's parent, if
        // it had one; that is, all the effects in the tree including the root.
        if (finishedWork.lastEffect !== null) {
          finishedWork.lastEffect.nextEffect = finishedWork;
          firstEffect = finishedWork.firstEffect;
        } else {
          firstEffect = finishedWork;
        }
      } else {
        // There is no effect on the root.
        firstEffect = finishedWork.firstEffect;
      }

      prepareForCommit();

      // Commit all the side-effects within a tree. We'll do this in two passes.
      // The first pass performs all the host insertions, updates, deletions and
      // ref unmounts.
      nextEffect = firstEffect;
      startCommitHostEffectsTimer();
      while (nextEffect !== null) {
        var didError = false;
        var _error = void 0;
        {
          invokeGuardedCallback$1(null, commitAllHostEffects, null);
          if (hasCaughtError()) {
            didError = true;
            _error = clearCaughtError();
          }
        }
        if (didError) {
          !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          captureError(nextEffect, _error);
          // Clean-up
          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }
      stopCommitHostEffectsTimer();

      resetAfterCommit();

      // The work-in-progress tree is now the current tree. This must come after
      // the first pass of the commit phase, so that the previous tree is still
      // current during componentWillUnmount, but before the second pass, so that
      // the finished work is current during componentDidMount/Update.
      root.current = finishedWork;

      // In the second pass we'll perform all life-cycles and ref callbacks.
      // Life-cycles happen as a separate pass so that all placements, updates,
      // and deletions in the entire tree have already been invoked.
      // This pass also triggers any renderer-specific initial effects.
      nextEffect = firstEffect;
      startCommitLifeCyclesTimer();
      while (nextEffect !== null) {
        var _didError = false;
        var _error2 = void 0;
        {
          invokeGuardedCallback$1(null, commitAllLifeCycles, null);
          if (hasCaughtError()) {
            _didError = true;
            _error2 = clearCaughtError();
          }
        }
        if (_didError) {
          !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          captureError(nextEffect, _error2);
          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }

      isCommitting = false;
      isWorking = false;
      stopCommitLifeCyclesTimer();
      stopCommitTimer();
      if (typeof onCommitRoot === 'function') {
        onCommitRoot(finishedWork.stateNode);
      }
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
      }

      // If we caught any errors during this commit, schedule their boundaries
      // to update.
      if (commitPhaseBoundaries) {
        commitPhaseBoundaries.forEach(scheduleErrorRecovery);
        commitPhaseBoundaries = null;
      }

      if (firstUncaughtError !== null) {
        var _error3 = firstUncaughtError;
        firstUncaughtError = null;
        onUncaughtError(_error3);
      }

      var remainingTime = root.current.expirationTime;

      if (remainingTime === NoWork) {
        capturedErrors = null;
        failedBoundaries = null;
      }

      return remainingTime;
    }

    function resetExpirationTime(workInProgress, renderTime) {
      if (renderTime !== Never && workInProgress.expirationTime === Never) {
        // The children of this component are hidden. Don't bubble their
        // expiration times.
        return;
      }

      // Check for pending updates.
      var newExpirationTime = getUpdateExpirationTime(workInProgress);

      // TODO: Calls need to visit stateNode

      // Bubble up the earliest expiration time.
      var child = workInProgress.child;
      while (child !== null) {
        if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
          newExpirationTime = child.expirationTime;
        }
        child = child.sibling;
      }
      workInProgress.expirationTime = newExpirationTime;
    }

    function completeUnitOfWork(workInProgress) {
      while (true) {
        // The current, flushed, state of this fiber is the alternate.
        // Ideally nothing should rely on this, but relying on it here
        // means that we don't need an additional field on the work in
        // progress.
        var current = workInProgress.alternate;
        {
          ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
        }
        var next = completeWork(current, workInProgress, nextRenderExpirationTime);
        {
          ReactDebugCurrentFiber.resetCurrentFiber();
        }

        var returnFiber = workInProgress['return'];
        var siblingFiber = workInProgress.sibling;

        resetExpirationTime(workInProgress, nextRenderExpirationTime);

        if (next !== null) {
          stopWorkTimer(workInProgress);
          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
          }
          // If completing this work spawned new work, do that next. We'll come
          // back here again.
          return next;
        }

        if (returnFiber !== null) {
          // Append all the effects of the subtree and this fiber onto the effect
          // list of the parent. The completion order of the children affects the
          // side-effect order.
          if (returnFiber.firstEffect === null) {
            returnFiber.firstEffect = workInProgress.firstEffect;
          }
          if (workInProgress.lastEffect !== null) {
            if (returnFiber.lastEffect !== null) {
              returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
            }
            returnFiber.lastEffect = workInProgress.lastEffect;
          }

          // If this fiber had side-effects, we append it AFTER the children's
          // side-effects. We can perform certain side-effects earlier if
          // needed, by doing multiple passes over the effect list. We don't want
          // to schedule our own side-effect on our own list because if end up
          // reusing children we'll schedule this effect onto itself since we're
          // at the end.
          var effectTag = workInProgress.effectTag;
          // Skip both NoWork and PerformedWork tags when creating the effect list.
          // PerformedWork effect is read by React DevTools but shouldn't be committed.
          if (effectTag > PerformedWork) {
            if (returnFiber.lastEffect !== null) {
              returnFiber.lastEffect.nextEffect = workInProgress;
            } else {
              returnFiber.firstEffect = workInProgress;
            }
            returnFiber.lastEffect = workInProgress;
          }
        }

        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }

        if (siblingFiber !== null) {
          // If there is more work to do in this returnFiber, do that next.
          return siblingFiber;
        } else if (returnFiber !== null) {
          // If there's no more work in this returnFiber. Complete the returnFiber.
          workInProgress = returnFiber;
          continue;
        } else {
          // We've reached the root.
          var root = workInProgress.stateNode;
          root.isReadyForCommit = true;
          return null;
        }
      }

      // Without this explicit null return Flow complains of invalid return type
      // TODO Remove the above while(true) loop
      // eslint-disable-next-line no-unreachable
      return null;
    }

    function performUnitOfWork(workInProgress) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;

      // See if beginning this work spawns more work.
      startWorkTimer(workInProgress);
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }

      var next = beginWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
      }

      if (next === null) {
        // If this doesn't spawn new work, complete the current work.
        next = completeUnitOfWork(workInProgress);
      }

      ReactCurrentOwner.current = null;

      return next;
    }

    function performFailedUnitOfWork(workInProgress) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;

      // See if beginning this work spawns more work.
      startWorkTimer(workInProgress);
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
      }

      if (next === null) {
        // If this doesn't spawn new work, complete the current work.
        next = completeUnitOfWork(workInProgress);
      }

      ReactCurrentOwner.current = null;

      return next;
    }

    function workLoop(expirationTime) {
      if (capturedErrors !== null) {
        // If there are unhandled errors, switch to the slow work loop.
        // TODO: How to avoid this check in the fast path? Maybe the renderer
        // could keep track of which roots have unhandled errors and call a
        // forked version of renderRoot.
        slowWorkLoopThatChecksForFailedWork(expirationTime);
        return;
      }
      if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
        return;
      }

      if (nextRenderExpirationTime <= mostRecentCurrentTime) {
        // Flush all expired work.
        while (nextUnitOfWork !== null) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      } else {
        // Flush asynchronous work until the deadline runs out of time.
        while (nextUnitOfWork !== null && !shouldYield()) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }

    function slowWorkLoopThatChecksForFailedWork(expirationTime) {
      if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
        return;
      }

      if (nextRenderExpirationTime <= mostRecentCurrentTime) {
        // Flush all expired work.
        while (nextUnitOfWork !== null) {
          if (hasCapturedError(nextUnitOfWork)) {
            // Use a forked version of performUnitOfWork
            nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
          } else {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        }
      } else {
        // Flush asynchronous work until the deadline runs out of time.
        while (nextUnitOfWork !== null && !shouldYield()) {
          if (hasCapturedError(nextUnitOfWork)) {
            // Use a forked version of performUnitOfWork
            nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
          } else {
            nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
          }
        }
      }
    }

    function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
      // We're going to restart the error boundary that captured the error.
      // Conceptually, we're unwinding the stack. We need to unwind the
      // context stack, too.
      unwindContexts(failedWork, boundary);

      // Restart the error boundary using a forked version of
      // performUnitOfWork that deletes the boundary's children. The entire
      // failed subree will be unmounted. During the commit phase, a special
      // lifecycle method is called on the error boundary, which triggers
      // a re-render.
      nextUnitOfWork = performFailedUnitOfWork(boundary);

      // Continue working.
      workLoop(expirationTime);
    }

    function renderRoot(root, expirationTime) {
      !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      isWorking = true;

      // We're about to mutate the work-in-progress tree. If the root was pending
      // commit, it no longer is: we'll need to complete it again.
      root.isReadyForCommit = false;

      // Check if we're starting from a fresh stack, or if we're resuming from
      // previously yielded work.
      if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
        // Reset the stack and start working from the root.
        resetContextStack();
        nextRoot = root;
        nextRenderExpirationTime = expirationTime;
        nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
      }

      startWorkLoopTimer(nextUnitOfWork);

      var didError = false;
      var error = null;
      {
        invokeGuardedCallback$1(null, workLoop, null, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
        }
      }

      // An error was thrown during the render phase.
      while (didError) {
        if (didFatal) {
          // This was a fatal error. Don't attempt to recover from it.
          firstUncaughtError = error;
          break;
        }

        var failedWork = nextUnitOfWork;
        if (failedWork === null) {
          // An error was thrown but there's no current unit of work. This can
          // happen during the commit phase if there's a bug in the renderer.
          didFatal = true;
          continue;
        }

        // "Capture" the error by finding the nearest boundary. If there is no
        // error boundary, we use the root.
        var boundary = captureError(failedWork, error);
        !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

        if (didFatal) {
          // The error we just captured was a fatal error. This happens
          // when the error propagates to the root more than once.
          continue;
        }

        didError = false;
        error = null;
        {
          invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
          if (hasCaughtError()) {
            didError = true;
            error = clearCaughtError();
            continue;
          }
        }
        // We're finished working. Exit the error loop.
        break;
      }

      var uncaughtError = firstUncaughtError;

      // We're done performing work. Time to clean up.
      stopWorkLoopTimer(interruptedBy);
      interruptedBy = null;
      isWorking = false;
      didFatal = false;
      firstUncaughtError = null;

      if (uncaughtError !== null) {
        onUncaughtError(uncaughtError);
      }

      return root.isReadyForCommit ? root.current.alternate : null;
    }

    // Returns the boundary that captured the error, or null if the error is ignored
    function captureError(failedWork, error) {
      // It is no longer valid because we exited the user code.
      ReactCurrentOwner.current = null;
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      // Search for the nearest error boundary.
      var boundary = null;

      // Passed to logCapturedError()
      var errorBoundaryFound = false;
      var willRetry = false;
      var errorBoundaryName = null;

      // Host containers are a special case. If the failed work itself is a host
      // container, then it acts as its own boundary. In all other cases, we
      // ignore the work itself and only search through the parents.
      if (failedWork.tag === HostRoot) {
        boundary = failedWork;

        if (isFailedBoundary(failedWork)) {
          // If this root already failed, there must have been an error when
          // attempting to unmount it. This is a worst-case scenario and
          // should only be possible if there's a bug in the renderer.
          didFatal = true;
        }
      } else {
        var node = failedWork['return'];
        while (node !== null && boundary === null) {
          if (node.tag === ClassComponent) {
            var instance = node.stateNode;
            if (typeof instance.componentDidCatch === 'function') {
              errorBoundaryFound = true;
              errorBoundaryName = getComponentName(node);

              // Found an error boundary!
              boundary = node;
              willRetry = true;
            }
          } else if (node.tag === HostRoot) {
            // Treat the root like a no-op error boundary
            boundary = node;
          }

          if (isFailedBoundary(node)) {
            // This boundary is already in a failed state.

            // If we're currently unmounting, that means this error was
            // thrown while unmounting a failed subtree. We should ignore
            // the error.
            if (isUnmounting) {
              return null;
            }

            // If we're in the commit phase, we should check to see if
            // this boundary already captured an error during this commit.
            // This case exists because multiple errors can be thrown during
            // a single commit without interruption.
            if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
              // If so, we should ignore this error.
              return null;
            }

            // The error should propagate to the next boundary -— we keep looking.
            boundary = null;
            willRetry = false;
          }

          node = node['return'];
        }
      }

      if (boundary !== null) {
        // Add to the collection of failed boundaries. This lets us know that
        // subsequent errors in this subtree should propagate to the next boundary.
        if (failedBoundaries === null) {
          failedBoundaries = new Set();
        }
        failedBoundaries.add(boundary);

        // This method is unsafe outside of the begin and complete phases.
        // We might be in the commit phase when an error is captured.
        // The risk is that the return path from this Fiber may not be accurate.
        // That risk is acceptable given the benefit of providing users more context.
        var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
        var _componentName = getComponentName(failedWork);

        // Add to the collection of captured errors. This is stored as a global
        // map of errors and their component stack location keyed by the boundaries
        // that capture them. We mostly use this Map as a Set; it's a Map only to
        // avoid adding a field to Fiber to store the error.
        if (capturedErrors === null) {
          capturedErrors = new Map();
        }

        var capturedError = {
          componentName: _componentName,
          componentStack: _componentStack,
          error: error,
          errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
          errorBoundaryFound: errorBoundaryFound,
          errorBoundaryName: errorBoundaryName,
          willRetry: willRetry
        };

        capturedErrors.set(boundary, capturedError);

        try {
          logCapturedError(capturedError);
        } catch (e) {
          // Prevent cycle if logCapturedError() throws.
          // A cycle may still occur if logCapturedError renders a component that throws.
          var suppressLogging = e && e.suppressReactErrorLogging;
          if (!suppressLogging) {
            console.error(e);
          }
        }

        // If we're in the commit phase, defer scheduling an update on the
        // boundary until after the commit is complete
        if (isCommitting) {
          if (commitPhaseBoundaries === null) {
            commitPhaseBoundaries = new Set();
          }
          commitPhaseBoundaries.add(boundary);
        } else {
          // Otherwise, schedule an update now.
          // TODO: Is this actually necessary during the render phase? Is it
          // possible to unwind and continue rendering at the same priority,
          // without corrupting internal state?
          scheduleErrorRecovery(boundary);
        }
        return boundary;
      } else if (firstUncaughtError === null) {
        // If no boundary is found, we'll need to throw the error
        firstUncaughtError = error;
      }
      return null;
    }

    function hasCapturedError(fiber) {
      // TODO: capturedErrors should store the boundary instance, to avoid needing
      // to check the alternate.
      return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
    }

    function isFailedBoundary(fiber) {
      // TODO: failedBoundaries should store the boundary instance, to avoid
      // needing to check the alternate.
      return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
    }

    function commitErrorHandling(effectfulFiber) {
      var capturedError = void 0;
      if (capturedErrors !== null) {
        capturedError = capturedErrors.get(effectfulFiber);
        capturedErrors['delete'](effectfulFiber);
        if (capturedError == null) {
          if (effectfulFiber.alternate !== null) {
            effectfulFiber = effectfulFiber.alternate;
            capturedError = capturedErrors.get(effectfulFiber);
            capturedErrors['delete'](effectfulFiber);
          }
        }
      }

      !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      switch (effectfulFiber.tag) {
        case ClassComponent:
          var instance = effectfulFiber.stateNode;

          var info = {
            componentStack: capturedError.componentStack
          };

          // Allow the boundary to handle the error, usually by scheduling
          // an update to itself
          instance.componentDidCatch(capturedError.error, info);
          return;
        case HostRoot:
          if (firstUncaughtError === null) {
            firstUncaughtError = capturedError.error;
          }
          return;
        default:
          invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
      }
    }

    function unwindContexts(from, to) {
      var node = from;
      while (node !== null) {
        switch (node.tag) {
          case ClassComponent:
            popContextProvider(node);
            break;
          case HostComponent:
            popHostContext(node);
            break;
          case HostRoot:
            popHostContainer(node);
            break;
          case HostPortal:
            popHostContainer(node);
            break;
        }
        if (node === to || node.alternate === to) {
          stopFailedWorkTimer(node);
          break;
        } else {
          stopWorkTimer(node);
        }
        node = node['return'];
      }
    }

    function computeAsyncExpiration() {
      // Given the current clock time, returns an expiration time. We use rounding
      // to batch like updates together.
      // Should complete within ~1000ms. 1200ms max.
      var currentTime = recalculateCurrentTime();
      var expirationMs = 1000;
      var bucketSizeMs = 200;
      return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
    }

    function computeExpirationForFiber(fiber) {
      var expirationTime = void 0;
      if (expirationContext !== NoWork) {
        // An explicit expiration context was set;
        expirationTime = expirationContext;
      } else if (isWorking) {
        if (isCommitting) {
          // Updates that occur during the commit phase should have sync priority
          // by default.
          expirationTime = Sync;
        } else {
          // Updates during the render phase should expire at the same time as
          // the work that is being rendered.
          expirationTime = nextRenderExpirationTime;
        }
      } else {
        // No explicit expiration context was set, and we're not currently
        // performing work. Calculate a new expiration time.
        if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
          // This is a sync update
          expirationTime = Sync;
        } else {
          // This is an async update
          expirationTime = computeAsyncExpiration();
        }
      }
      return expirationTime;
    }

    function scheduleWork(fiber, expirationTime) {
      return scheduleWorkImpl(fiber, expirationTime, false);
    }

    function checkRootNeedsClearing(root, fiber, expirationTime) {
      if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
        // Restart the root from the top.
        if (nextUnitOfWork !== null) {
          // This is an interruption. (Used for performance tracking.)
          interruptedBy = fiber;
        }
        nextRoot = null;
        nextUnitOfWork = null;
        nextRenderExpirationTime = NoWork;
      }
    }

    function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
      recordScheduleUpdate();

      {
        if (!isErrorRecovery && fiber.tag === ClassComponent) {
          var instance = fiber.stateNode;
          warnAboutInvalidUpdates(instance);
        }
      }

      var node = fiber;
      while (node !== null) {
        // Walk the parent path to the root and update each node's
        // expiration time.
        if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
          node.expirationTime = expirationTime;
        }
        if (node.alternate !== null) {
          if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
            node.alternate.expirationTime = expirationTime;
          }
        }
        if (node['return'] === null) {
          if (node.tag === HostRoot) {
            var root = node.stateNode;

            checkRootNeedsClearing(root, fiber, expirationTime);
            requestWork(root, expirationTime);
            checkRootNeedsClearing(root, fiber, expirationTime);
          } else {
            {
              if (!isErrorRecovery && fiber.tag === ClassComponent) {
                warnAboutUpdateOnUnmounted(fiber);
              }
            }
            return;
          }
        }
        node = node['return'];
      }
    }

    function scheduleErrorRecovery(fiber) {
      scheduleWorkImpl(fiber, Sync, true);
    }

    function recalculateCurrentTime() {
      // Subtract initial time so it fits inside 32bits
      var ms = now() - startTime;
      mostRecentCurrentTime = msToExpirationTime(ms);
      return mostRecentCurrentTime;
    }

    function deferredUpdates(fn) {
      var previousExpirationContext = expirationContext;
      expirationContext = computeAsyncExpiration();
      try {
        return fn();
      } finally {
        expirationContext = previousExpirationContext;
      }
    }

    function syncUpdates(fn) {
      var previousExpirationContext = expirationContext;
      expirationContext = Sync;
      try {
        return fn();
      } finally {
        expirationContext = previousExpirationContext;
      }
    }

    // TODO: Everything below this is written as if it has been lifted to the
    // renderers. I'll do this in a follow-up.

    // Linked-list of roots
    var firstScheduledRoot = null;
    var lastScheduledRoot = null;

    var callbackExpirationTime = NoWork;
    var callbackID = -1;
    var isRendering = false;
    var nextFlushedRoot = null;
    var nextFlushedExpirationTime = NoWork;
    var deadlineDidExpire = false;
    var hasUnhandledError = false;
    var unhandledError = null;
    var deadline = null;

    var isBatchingUpdates = false;
    var isUnbatchingUpdates = false;

    // Use these to prevent an infinite loop of nested updates
    var NESTED_UPDATE_LIMIT = 1000;
    var nestedUpdateCount = 0;

    var timeHeuristicForUnitOfWork = 1;

    function scheduleCallbackWithExpiration(expirationTime) {
      if (callbackExpirationTime !== NoWork) {
        // A callback is already scheduled. Check its expiration time (timeout).
        if (expirationTime > callbackExpirationTime) {
          // Existing callback has sufficient timeout. Exit.
          return;
        } else {
          // Existing callback has insufficient timeout. Cancel and schedule a
          // new one.
          cancelDeferredCallback(callbackID);
        }
        // The request callback timer is already running. Don't start a new one.
      } else {
        startRequestCallbackTimer();
      }

      // Compute a timeout for the given expiration time.
      var currentMs = now() - startTime;
      var expirationMs = expirationTimeToMs(expirationTime);
      var timeout = expirationMs - currentMs;

      callbackExpirationTime = expirationTime;
      callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
    }

    // requestWork is called by the scheduler whenever a root receives an update.
    // It's up to the renderer to call renderRoot at some point in the future.
    function requestWork(root, expirationTime) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
        invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
      }

      // Add the root to the schedule.
      // Check if this root is already part of the schedule.
      if (root.nextScheduledRoot === null) {
        // This root is not already scheduled. Add it.
        root.remainingExpirationTime = expirationTime;
        if (lastScheduledRoot === null) {
          firstScheduledRoot = lastScheduledRoot = root;
          root.nextScheduledRoot = root;
        } else {
          lastScheduledRoot.nextScheduledRoot = root;
          lastScheduledRoot = root;
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
        }
      } else {
        // This root is already scheduled, but its priority may have increased.
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
          // Update the priority.
          root.remainingExpirationTime = expirationTime;
        }
      }

      if (isRendering) {
        // Prevent reentrancy. Remaining work will be scheduled at the end of
        // the currently rendering batch.
        return;
      }

      if (isBatchingUpdates) {
        // Flush work at the end of the batch.
        if (isUnbatchingUpdates) {
          // ...unless we're inside unbatchedUpdates, in which case we should
          // flush it now.
          nextFlushedRoot = root;
          nextFlushedExpirationTime = Sync;
          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
        }
        return;
      }

      // TODO: Get rid of Sync and use current time?
      if (expirationTime === Sync) {
        performWork(Sync, null);
      } else {
        scheduleCallbackWithExpiration(expirationTime);
      }
    }

    function findHighestPriorityRoot() {
      var highestPriorityWork = NoWork;
      var highestPriorityRoot = null;

      if (lastScheduledRoot !== null) {
        var previousScheduledRoot = lastScheduledRoot;
        var root = firstScheduledRoot;
        while (root !== null) {
          var remainingExpirationTime = root.remainingExpirationTime;
          if (remainingExpirationTime === NoWork) {
            // This root no longer has work. Remove it from the scheduler.

            // TODO: This check is redudant, but Flow is confused by the branch
            // below where we set lastScheduledRoot to null, even though we break
            // from the loop right after.
            !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
            if (root === root.nextScheduledRoot) {
              // This is the only root in the list.
              root.nextScheduledRoot = null;
              firstScheduledRoot = lastScheduledRoot = null;
              break;
            } else if (root === firstScheduledRoot) {
              // This is the first root in the list.
              var next = root.nextScheduledRoot;
              firstScheduledRoot = next;
              lastScheduledRoot.nextScheduledRoot = next;
              root.nextScheduledRoot = null;
            } else if (root === lastScheduledRoot) {
              // This is the last root in the list.
              lastScheduledRoot = previousScheduledRoot;
              lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
              root.nextScheduledRoot = null;
              break;
            } else {
              previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
              root.nextScheduledRoot = null;
            }
            root = previousScheduledRoot.nextScheduledRoot;
          } else {
            if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
              // Update the priority, if it's higher
              highestPriorityWork = remainingExpirationTime;
              highestPriorityRoot = root;
            }
            if (root === lastScheduledRoot) {
              break;
            }
            previousScheduledRoot = root;
            root = root.nextScheduledRoot;
          }
        }
      }

      // If the next root is the same as the previous root, this is a nested
      // update. To prevent an infinite loop, increment the nested update count.
      var previousFlushedRoot = nextFlushedRoot;
      if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
        nestedUpdateCount++;
      } else {
        // Reset whenever we switch roots.
        nestedUpdateCount = 0;
      }
      nextFlushedRoot = highestPriorityRoot;
      nextFlushedExpirationTime = highestPriorityWork;
    }

    function performAsyncWork(dl) {
      performWork(NoWork, dl);
    }

    function performWork(minExpirationTime, dl) {
      deadline = dl;

      // Keep working on roots until there's no more work, or until the we reach
      // the deadline.
      findHighestPriorityRoot();

      if (enableUserTimingAPI && deadline !== null) {
        var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
        stopRequestCallbackTimer(didExpire);
      }

      while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
        // Find the next highest priority work.
        findHighestPriorityRoot();
      }

      // We're done flushing work. Either we ran out of time in this callback,
      // or there's no more work left with sufficient priority.

      // If we're inside a callback, set this to false since we just completed it.
      if (deadline !== null) {
        callbackExpirationTime = NoWork;
        callbackID = -1;
      }
      // If there's work left over, schedule a new callback.
      if (nextFlushedExpirationTime !== NoWork) {
        scheduleCallbackWithExpiration(nextFlushedExpirationTime);
      }

      // Clean-up.
      deadline = null;
      deadlineDidExpire = false;
      nestedUpdateCount = 0;

      if (hasUnhandledError) {
        var _error4 = unhandledError;
        unhandledError = null;
        hasUnhandledError = false;
        throw _error4;
      }
    }

    function performWorkOnRoot(root, expirationTime) {
      !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      isRendering = true;

      // Check if this is async work or sync/expired work.
      // TODO: Pass current time as argument to renderRoot, commitRoot
      if (expirationTime <= recalculateCurrentTime()) {
        // Flush sync work.
        var finishedWork = root.finishedWork;
        if (finishedWork !== null) {
          // This root is already complete. We can commit it.
          root.finishedWork = null;
          root.remainingExpirationTime = commitRoot(finishedWork);
        } else {
          root.finishedWork = null;
          finishedWork = renderRoot(root, expirationTime);
          if (finishedWork !== null) {
            // We've completed the root. Commit it.
            root.remainingExpirationTime = commitRoot(finishedWork);
          }
        }
      } else {
        // Flush async work.
        var _finishedWork = root.finishedWork;
        if (_finishedWork !== null) {
          // This root is already complete. We can commit it.
          root.finishedWork = null;
          root.remainingExpirationTime = commitRoot(_finishedWork);
        } else {
          root.finishedWork = null;
          _finishedWork = renderRoot(root, expirationTime);
          if (_finishedWork !== null) {
            // We've completed the root. Check the deadline one more time
            // before committing.
            if (!shouldYield()) {
              // Still time left. Commit the root.
              root.remainingExpirationTime = commitRoot(_finishedWork);
            } else {
              // There's no time left. Mark this root as complete. We'll come
              // back and commit it later.
              root.finishedWork = _finishedWork;
            }
          }
        }
      }

      isRendering = false;
    }

    // When working on async work, the reconciler asks the renderer if it should
    // yield execution. For DOM, we implement this with requestIdleCallback.
    function shouldYield() {
      if (deadline === null) {
        return false;
      }
      if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
        // Disregard deadline.didTimeout. Only expired work should be flushed
        // during a timeout. This path is only hit for non-expired work.
        return false;
      }
      deadlineDidExpire = true;
      return true;
    }

    // TODO: Not happy about this hook. Conceptually, renderRoot should return a
    // tuple of (isReadyForCommit, didError, error)
    function onUncaughtError(error) {
      !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      // Unschedule this root so we don't work on it again until there's
      // another update.
      nextFlushedRoot.remainingExpirationTime = NoWork;
      if (!hasUnhandledError) {
        hasUnhandledError = true;
        unhandledError = error;
      }
    }

    // TODO: Batching should be implemented at the renderer level, not inside
    // the reconciler.
    function batchedUpdates(fn, a) {
      var previousIsBatchingUpdates = isBatchingUpdates;
      isBatchingUpdates = true;
      try {
        return fn(a);
      } finally {
        isBatchingUpdates = previousIsBatchingUpdates;
        if (!isBatchingUpdates && !isRendering) {
          performWork(Sync, null);
        }
      }
    }

    // TODO: Batching should be implemented at the renderer level, not inside
    // the reconciler.
    function unbatchedUpdates(fn) {
      if (isBatchingUpdates && !isUnbatchingUpdates) {
        isUnbatchingUpdates = true;
        try {
          return fn();
        } finally {
          isUnbatchingUpdates = false;
        }
      }
      return fn();
    }

    // TODO: Batching should be implemented at the renderer level, not within
    // the reconciler.
    function flushSync(fn) {
      var previousIsBatchingUpdates = isBatchingUpdates;
      isBatchingUpdates = true;
      try {
        return syncUpdates(fn);
      } finally {
        isBatchingUpdates = previousIsBatchingUpdates;
        !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
        performWork(Sync, null);
      }
    }

    return {
      computeAsyncExpiration: computeAsyncExpiration,
      computeExpirationForFiber: computeExpirationForFiber,
      scheduleWork: scheduleWork,
      batchedUpdates: batchedUpdates,
      unbatchedUpdates: unbatchedUpdates,
      flushSync: flushSync,
      deferredUpdates: deferredUpdates
    };
  };

  {
    var didWarnAboutNestedUpdates = false;
  }

  // 0 is PROD, 1 is DEV.
  // Might add PROFILE later.


  function getContextForSubtree(parentComponent) {
    if (!parentComponent) {
      return emptyObject;
    }

    var fiber = get(parentComponent);
    var parentContext = findCurrentUnmaskedContext(fiber);
    return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
  }

  var ReactFiberReconciler$1 = function (config) {
    var getPublicInstance = config.getPublicInstance;

    var _ReactFiberScheduler = ReactFiberScheduler(config),
        computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
        computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
        scheduleWork = _ReactFiberScheduler.scheduleWork,
        batchedUpdates = _ReactFiberScheduler.batchedUpdates,
        unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
        flushSync = _ReactFiberScheduler.flushSync,
        deferredUpdates = _ReactFiberScheduler.deferredUpdates;

    function scheduleTopLevelUpdate(current, element, callback) {
      {
        if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
          didWarnAboutNestedUpdates = true;
          warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
        }
      }

      callback = callback === undefined ? null : callback;
      {
        warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
      }

      var expirationTime = void 0;
      // Check if the top-level element is an async wrapper component. If so,
      // treat updates to the root as async. This is a bit weird but lets us
      // avoid a separate `renderAsync` API.
      if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
        expirationTime = computeAsyncExpiration();
      } else {
        expirationTime = computeExpirationForFiber(current);
      }

      var update = {
        expirationTime: expirationTime,
        partialState: { element: element },
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(current, update);
      scheduleWork(current, expirationTime);
    }

    function findHostInstance(fiber) {
      var hostFiber = findCurrentHostFiber(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    }

    return {
      createContainer: function (containerInfo, hydrate) {
        return createFiberRoot(containerInfo, hydrate);
      },
      updateContainer: function (element, container, parentComponent, callback) {
        // TODO: If this is a nested container, this won't be the root.
        var current = container.current;

        {
          if (ReactFiberInstrumentation_1.debugTool) {
            if (current.alternate === null) {
              ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
            } else if (element === null) {
              ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
            } else {
              ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
            }
          }
        }

        var context = getContextForSubtree(parentComponent);
        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }

        scheduleTopLevelUpdate(current, element, callback);
      },


      batchedUpdates: batchedUpdates,

      unbatchedUpdates: unbatchedUpdates,

      deferredUpdates: deferredUpdates,

      flushSync: flushSync,

      getPublicRootInstance: function (container) {
        var containerFiber = container.current;
        if (!containerFiber.child) {
          return null;
        }
        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);
          default:
            return containerFiber.child.stateNode;
        }
      },


      findHostInstance: findHostInstance,

      findHostInstanceWithNoPortals: function (fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      },
      injectIntoDevTools: function (devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

        return injectInternals(_assign({}, devToolsConfig, {
          findHostInstanceByFiber: function (fiber) {
            return findHostInstance(fiber);
          },
          findFiberByHostInstance: function (instance) {
            if (!findFiberByHostInstance) {
              // Might not be implemented by the renderer.
              return null;
            }
            return findFiberByHostInstance(instance);
          }
        }));
      }
    };
  };

  var ReactFiberReconciler$2 = Object.freeze({
    default: ReactFiberReconciler$1
  });

  var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

  // TODO: bundle Flow types with the package.



  // TODO: decide on the top-level export form.
  // This is hacky but makes it work with both Rollup and Jest.
  var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

  function createPortal$1(children, containerInfo,
  // TODO: figure out the API for cross-renderer implementation.
  implementation) {
    var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    return {
      // This tag allow us to uniquely identify this as a React Portal
      $$typeof: REACT_PORTAL_TYPE,
      key: key == null ? null : '' + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }

  // TODO: this is special because it gets imported during build.

  var ReactVersion = '16.2.0';

  // a requestAnimationFrame, storing the time for the start of the frame, then
  // scheduling a postMessage which gets scheduled after paint. Within the
  // postMessage handler do as much work as possible until time + frame rate.
  // By separating the idle call into a separate event tick we ensure that
  // layout, paint and other browser work is counted against the available time.
  // The frame rate is dynamically adjusted.

  {
    if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
      warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
    }
  }

  var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

  var now = void 0;
  if (hasNativePerformanceNow) {
    now = function () {
      return performance.now();
    };
  } else {
    now = function () {
      return Date.now();
    };
  }

  // TODO: There's no way to cancel, because Fiber doesn't atm.
  var rIC = void 0;
  var cIC = void 0;

  if (!ExecutionEnvironment.canUseDOM) {
    rIC = function (frameCallback) {
      return setTimeout(function () {
        frameCallback({
          timeRemaining: function () {
            return Infinity;
          }
        });
      });
    };
    cIC = function (timeoutID) {
      clearTimeout(timeoutID);
    };
  } else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
    // Polyfill requestIdleCallback and cancelIdleCallback

    var scheduledRICCallback = null;
    var isIdleScheduled = false;
    var timeoutTime = -1;

    var isAnimationFrameScheduled = false;

    var frameDeadline = 0;
    // We start out assuming that we run at 30fps but then the heuristic tracking
    // will adjust this value to a faster fps if we get more frequent animation
    // frames.
    var previousFrameTime = 33;
    var activeFrameTime = 33;

    var frameDeadlineObject;
    if (hasNativePerformanceNow) {
      frameDeadlineObject = {
        didTimeout: false,
        timeRemaining: function () {
          // We assume that if we have a performance timer that the rAF callback
          // gets a performance timer value. Not sure if this is always true.
          var remaining = frameDeadline - performance.now();
          return remaining > 0 ? remaining : 0;
        }
      };
    } else {
      frameDeadlineObject = {
        didTimeout: false,
        timeRemaining: function () {
          // Fallback to Date.now()
          var remaining = frameDeadline - Date.now();
          return remaining > 0 ? remaining : 0;
        }
      };
    }

    // We use the postMessage trick to defer idle work until after the repaint.
    var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
    var idleTick = function (event) {
      if (event.source !== window || event.data !== messageKey) {
        return;
      }

      isIdleScheduled = false;

      var currentTime = now();
      if (frameDeadline - currentTime <= 0) {
        // There's no time left in this idle period. Check if the callback has
        // a timeout and whether it's been exceeded.
        if (timeoutTime !== -1 && timeoutTime <= currentTime) {
          // Exceeded the timeout. Invoke the callback even though there's no
          // time left.
          frameDeadlineObject.didTimeout = true;
        } else {
          // No timeout.
          if (!isAnimationFrameScheduled) {
            // Schedule another animation callback so we retry later.
            isAnimationFrameScheduled = true;
            requestAnimationFrame(animationTick);
          }
          // Exit without invoking the callback.
          return;
        }
      } else {
        // There's still time left in this idle period.
        frameDeadlineObject.didTimeout = false;
      }

      timeoutTime = -1;
      var callback = scheduledRICCallback;
      scheduledRICCallback = null;
      if (callback !== null) {
        callback(frameDeadlineObject);
      }
    };
    // Assumes that we have addEventListener in this environment. Might need
    // something better for old IE.
    window.addEventListener('message', idleTick, false);

    var animationTick = function (rafTime) {
      isAnimationFrameScheduled = false;
      var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
      if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
        if (nextFrameTime < 8) {
          // Defensive coding. We don't support higher frame rates than 120hz.
          // If we get lower than that, it is probably a bug.
          nextFrameTime = 8;
        }
        // If one frame goes long, then the next one can be short to catch up.
        // If two frames are short in a row, then that's an indication that we
        // actually have a higher frame rate than what we're currently optimizing.
        // We adjust our heuristic dynamically accordingly. For example, if we're
        // running on 120hz display or 90hz VR display.
        // Take the max of the two in case one of them was an anomaly due to
        // missed frame deadlines.
        activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
      } else {
        previousFrameTime = nextFrameTime;
      }
      frameDeadline = rafTime + activeFrameTime;
      if (!isIdleScheduled) {
        isIdleScheduled = true;
        window.postMessage(messageKey, '*');
      }
    };

    rIC = function (callback, options) {
      // This assumes that we only schedule one callback at a time because that's
      // how Fiber uses it.
      scheduledRICCallback = callback;
      if (options != null && typeof options.timeout === 'number') {
        timeoutTime = now() + options.timeout;
      }
      if (!isAnimationFrameScheduled) {
        // If rAF didn't already schedule one, we need to schedule a frame.
        // TODO: If this rAF doesn't materialize because the browser throttles, we
        // might want to still have setTimeout trigger rIC as a backup to ensure
        // that we keep performing work.
        isAnimationFrameScheduled = true;
        requestAnimationFrame(animationTick);
      }
      return 0;
    };

    cIC = function () {
      scheduledRICCallback = null;
      isIdleScheduled = false;
      timeoutTime = -1;
    };
  } else {
    rIC = window.requestIdleCallback;
    cIC = window.cancelIdleCallback;
  }

  /**
   * Forked from fbjs/warning:
   * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
   *
   * Only change is we use console.warn instead of console.error,
   * and do nothing when 'console' is not supported.
   * This really simplifies the code.
   * ---
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var lowPriorityWarning = function () {};

  {
    var printWarning = function (format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.warn(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    lowPriorityWarning = function (condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }
      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  }

  var lowPriorityWarning$1 = lowPriorityWarning;

  // isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
  // TODO: Find a better place for this.
  var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
  var illegalAttributeNameCache = {};
  var validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
      return true;
    }
    if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
      return false;
    }
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
      validatedAttributeNameCache[attributeName] = true;
      return true;
    }
    illegalAttributeNameCache[attributeName] = true;
    {
      warning(false, 'Invalid attribute name: `%s`', attributeName);
    }
    return false;
  }

  // shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
  // TODO: Find a better place for this.
  function shouldIgnoreValue(propertyInfo, value) {
    return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
  }

  /**
   * Operations for dealing with DOM properties.
   */





  /**
   * Get the value for a property on a node. Only used in DEV for SSR validation.
   * The "expected" argument is used as a hint of what the expected value is.
   * Some properties have multiple equivalent values.
   */
  function getValueForProperty(node, name, expected) {
    {
      var propertyInfo = getPropertyInfo(name);
      if (propertyInfo) {
        var mutationMethod = propertyInfo.mutationMethod;
        if (mutationMethod || propertyInfo.mustUseProperty) {
          return node[propertyInfo.propertyName];
        } else {
          var attributeName = propertyInfo.attributeName;

          var stringValue = null;

          if (propertyInfo.hasOverloadedBooleanValue) {
            if (node.hasAttribute(attributeName)) {
              var value = node.getAttribute(attributeName);
              if (value === '') {
                return true;
              }
              if (shouldIgnoreValue(propertyInfo, expected)) {
                return value;
              }
              if (value === '' + expected) {
                return expected;
              }
              return value;
            }
          } else if (node.hasAttribute(attributeName)) {
            if (shouldIgnoreValue(propertyInfo, expected)) {
              // We had an attribute but shouldn't have had one, so read it
              // for the error message.
              return node.getAttribute(attributeName);
            }
            if (propertyInfo.hasBooleanValue) {
              // If this was a boolean, it doesn't matter what the value is
              // the fact that we have it is the same as the expected.
              return expected;
            }
            // Even if this property uses a namespace we use getAttribute
            // because we assume its namespaced name is the same as our config.
            // To use getAttributeNS we need the local name which we don't have
            // in our config atm.
            stringValue = node.getAttribute(attributeName);
          }

          if (shouldIgnoreValue(propertyInfo, expected)) {
            return stringValue === null ? expected : stringValue;
          } else if (stringValue === '' + expected) {
            return expected;
          } else {
            return stringValue;
          }
        }
      }
    }
  }

  /**
   * Get the value for a attribute on a node. Only used in DEV for SSR validation.
   * The third argument is used as a hint of what the expected value is. Some
   * attributes have multiple equivalent values.
   */
  function getValueForAttribute(node, name, expected) {
    {
      if (!isAttributeNameSafe(name)) {
        return;
      }
      if (!node.hasAttribute(name)) {
        return expected === undefined ? undefined : null;
      }
      var value = node.getAttribute(name);
      if (value === '' + expected) {
        return expected;
      }
      return value;
    }
  }

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  function setValueForProperty(node, name, value) {
    var propertyInfo = getPropertyInfo(name);

    if (propertyInfo && shouldSetAttribute(name, value)) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else {
      setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
      return;
    }

    {

    }
  }

  function setValueForAttribute(node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    {

    }
  }

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  function deleteValueForAttribute(node, name) {
    node.removeAttribute(name);
  }

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  function deleteValueForProperty(node, name) {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else {
      node.removeAttribute(name);
    }
  }

  var ReactControlledValuePropTypes = {
    checkPropTypes: null
  };

  {
    var hasReadOnlyValue = {
      button: true,
      checkbox: true,
      image: true,
      hidden: true,
      radio: true,
      reset: true,
      submit: true
    };

    var propTypes = {
      value: function (props, propName, componentName) {
        if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      },
      checked: function (props, propName, componentName) {
        if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
          return null;
        }
        return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
      }
    };

    /**
     * Provide a linked `value` attribute for controlled forms. You should not use
     * this outside of the ReactDOM controlled form components.
     */
    ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
      checkPropTypes(propTypes, props, 'prop', tagName, getStack);
    };
  }

  // TODO: direct imports like some-package/src/* are bad. Fix me.
  var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
  var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

  var didWarnValueDefaultValue = false;
  var didWarnCheckedDefaultChecked = false;
  var didWarnControlledToUncontrolled = false;
  var didWarnUncontrolledToControlled = false;

  function isControlled(props) {
    var usesChecked = props.type === 'checkbox' || props.type === 'radio';
    return usesChecked ? props.checked != null : props.value != null;
  }

  /**
   * Implements an <input> host component that allows setting these optional
   * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
   *
   * If `checked` or `value` are not supplied (or null/undefined), user actions
   * that affect the checked state or value will trigger updates to the element.
   *
   * If they are supplied (and not null/undefined), the rendered element will not
   * trigger updates to the element. Instead, the props must change in order for
   * the rendered element to be updated.
   *
   * The rendered element will be initialized as unchecked (or `defaultChecked`)
   * with an empty value (or `defaultValue`).
   *
   * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
   */

  function getHostProps(element, props) {
    var node = element;
    var value = props.value;
    var checked = props.checked;

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : node._wrapperState.initialValue,
      checked: checked != null ? checked : node._wrapperState.initialChecked
    });

    return hostProps;
  }

  function initWrapperState(element, props) {
    {
      ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    var node = element;
    node._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      controlled: isControlled(props)
    };
  }

  function updateChecked(element, props) {
    var node = element;
    var checked = props.checked;
    if (checked != null) {
      setValueForProperty(node, 'checked', checked);
    }
  }

  function updateWrapper(element, props) {
    var node = element;
    {
      var controlled = isControlled(props);

      if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
        didWarnUncontrolledToControlled = true;
      }
      if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
        didWarnControlledToUncontrolled = true;
      }
    }

    updateChecked(element, props);

    var value = props.value;
    if (value != null) {
      if (value === 0 && node.value === '') {
        node.value = '0';
        // Note: IE9 reports a number inputs as 'text', so check props instead.
      } else if (props.type === 'number') {
        // Simulate `input.valueAsNumber`. IE9 does not support it
        var valueAsNumber = parseFloat(node.value) || 0;

        if (
        // eslint-disable-next-line
        value != valueAsNumber ||
        // eslint-disable-next-line
        value == valueAsNumber && node.value != value) {
          // Cast `value` to a string to ensure the value is set correctly. While
          // browsers typically do this as necessary, jsdom doesn't.
          node.value = '' + value;
        }
      } else if (node.value !== '' + value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  }

  function postMountWrapper(element, props) {
    var node = element;

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }

  function restoreControlledState$1(element, props) {
    var node = element;
    updateWrapper(node, props);
    updateNamedCousins(node, props);
  }

  function updateNamedCousins(rootNode, props) {
    var name = props.name;
    if (props.type === 'radio' && name != null) {
      var queryRoot = rootNode;

      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }

      // If `rootNode.form` was non-null, then we could try `form.elements`,
      // but that sometimes behaves strangely in IE8. We could also try using
      // `form.getElementsByName`, but that will only return direct children
      // and won't include inputs that use the HTML5 `form=` attribute. Since
      // the input might not even be in a form. It might not even be in the
      // document. Let's just use the local `querySelectorAll` to ensure we don't
      // miss anything.
      var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

      for (var i = 0; i < group.length; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode || otherNode.form !== rootNode.form) {
          continue;
        }
        // This will throw if radio buttons rendered by different copies of React
        // and the same name are rendered into the same form (same as #1939).
        // That's probably okay; we don't support it just as we don't support
        // mixing React radio buttons with non-React ones.
        var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
        !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

        // We need update the tracked value on the named cousin since the value
        // was changed but the input saw no event or value set
        updateValueIfChanged(otherNode);

        // If this is a controlled radio button group, forcing the input that
        // was previously checked to update will cause it to be come re-checked
        // as appropriate.
        updateWrapper(otherNode, otherProps);
      }
    }
  }

  function flattenChildren(children) {
    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    // We can silently skip them because invalid DOM nesting warning
    // catches these cases in Fiber.
    React.Children.forEach(children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      }
    });

    return content;
  }

  /**
   * Implements an <option> host component that warns when `selected` is set.
   */

  function validateProps(element, props) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    {
      warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
    }
  }

  function postMountWrapper$1(element, props) {
    // value="" should make a value attribute (#6219)
    if (props.value != null) {
      element.setAttribute('value', props.value);
    }
  }

  function getHostProps$1(element, props) {
    var hostProps = _assign({ children: undefined }, props);
    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }

  // TODO: direct imports like some-package/src/* are bad. Fix me.
  var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
  var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


  {
    var didWarnValueDefaultValue$1 = false;
  }

  function getDeclarationErrorAddendum() {
    var ownerName = getCurrentFiberOwnerName$3();
    if (ownerName) {
      return '\n\nCheck the render method of `' + ownerName + '`.';
    }
    return '';
  }

  var valuePropNames = ['value', 'defaultValue'];

  /**
   * Validation function for `value` and `defaultValue`.
   */
  function checkSelectPropTypes(props) {
    ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

    for (var i = 0; i < valuePropNames.length; i++) {
      var propName = valuePropNames[i];
      if (props[propName] == null) {
        continue;
      }
      var isArray = Array.isArray(props[propName]);
      if (props.multiple && !isArray) {
        warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
      } else if (!props.multiple && isArray) {
        warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
      }
    }
  }

  function updateOptions(node, multiple, propValue, setDefaultSelected) {
    var options = node.options;

    if (multiple) {
      var selectedValues = propValue;
      var selectedValue = {};
      for (var i = 0; i < selectedValues.length; i++) {
        // Prefix to avoid chaos with special keys.
        selectedValue['$' + selectedValues[i]] = true;
      }
      for (var _i = 0; _i < options.length; _i++) {
        var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
        if (options[_i].selected !== selected) {
          options[_i].selected = selected;
        }
        if (selected && setDefaultSelected) {
          options[_i].defaultSelected = true;
        }
      }
    } else {
      // Do not set `select.value` as exact behavior isn't consistent across all
      // browsers for all cases.
      var _selectedValue = '' + propValue;
      var defaultSelected = null;
      for (var _i2 = 0; _i2 < options.length; _i2++) {
        if (options[_i2].value === _selectedValue) {
          options[_i2].selected = true;
          if (setDefaultSelected) {
            options[_i2].defaultSelected = true;
          }
          return;
        }
        if (defaultSelected === null && !options[_i2].disabled) {
          defaultSelected = options[_i2];
        }
      }
      if (defaultSelected !== null) {
        defaultSelected.selected = true;
      }
    }
  }

  /**
   * Implements a <select> host component that allows optionally setting the
   * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
   * stringable. If `multiple` is true, the prop must be an array of stringables.
   *
   * If `value` is not supplied (or null/undefined), user actions that change the
   * selected option will trigger updates to the rendered options.
   *
   * If it is supplied (and not null/undefined), the rendered options will not
   * update in response to user actions. Instead, the `value` prop must change in
   * order for the rendered options to update.
   *
   * If `defaultValue` is provided, any options with the supplied values will be
   * selected.
   */

  function getHostProps$2(element, props) {
    return _assign({}, props, {
      value: undefined
    });
  }

  function initWrapperState$1(element, props) {
    var node = element;
    {
      checkSelectPropTypes(props);
    }

    var value = props.value;
    node._wrapperState = {
      initialValue: value != null ? value : props.defaultValue,
      wasMultiple: !!props.multiple
    };

    {
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
        warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
        didWarnValueDefaultValue$1 = true;
      }
    }
  }

  function postMountWrapper$2(element, props) {
    var node = element;
    node.multiple = !!props.multiple;
    var value = props.value;
    if (value != null) {
      updateOptions(node, !!props.multiple, value, false);
    } else if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    }
  }

  function postUpdateWrapper(element, props) {
    var node = element;
    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    node._wrapperState.initialValue = undefined;

    var wasMultiple = node._wrapperState.wasMultiple;
    node._wrapperState.wasMultiple = !!props.multiple;

    var value = props.value;
    if (value != null) {
      updateOptions(node, !!props.multiple, value, false);
    } else if (wasMultiple !== !!props.multiple) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(node, !!props.multiple, props.defaultValue, true);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
      }
    }
  }

  function restoreControlledState$2(element, props) {
    var node = element;
    var value = props.value;

    if (value != null) {
      updateOptions(node, !!props.multiple, value, false);
    }
  }

  // TODO: direct imports like some-package/src/* are bad. Fix me.
  var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

  var didWarnValDefaultVal = false;

  /**
   * Implements a <textarea> host component that allows setting `value`, and
   * `defaultValue`. This differs from the traditional DOM API because value is
   * usually set as PCDATA children.
   *
   * If `value` is not supplied (or null/undefined), user actions that affect the
   * value will trigger updates to the element.
   *
   * If `value` is supplied (and not null/undefined), the rendered element will
   * not trigger updates to the element. Instead, the `value` prop must change in
   * order for the rendered element to be updated.
   *
   * The rendered element will be initialized with an empty value, the prop
   * `defaultValue` if specified, or the children content (deprecated).
   */

  function getHostProps$3(element, props) {
    var node = element;
    !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
    // solution. The value can be a boolean or object so that's why it's forced
    // to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + node._wrapperState.initialValue
    });

    return hostProps;
  }

  function initWrapperState$2(element, props) {
    var node = element;
    {
      ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
        didWarnValDefaultVal = true;
      }
    }

    var initialValue = props.value;

    // Only bother fetching default value if we're going to use it
    if (initialValue == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        {
          warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
        }
        !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    node._wrapperState = {
      initialValue: '' + initialValue
    };
  }

  function updateWrapper$1(element, props) {
    var node = element;
    var value = props.value;
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  }

  function postMountWrapper$3(element, props) {
    var node = element;
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === node._wrapperState.initialValue) {
      node.value = textContent;
    }
  }

  function restoreControlledState$3(element, props) {
    // DOM component is still mounted; update
    updateWrapper$1(element, props);
  }

  var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
  var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

  var Namespaces = {
    html: HTML_NAMESPACE$1,
    mathml: MATH_NAMESPACE,
    svg: SVG_NAMESPACE
  };

  // Assumes there is no parent namespace.
  function getIntrinsicNamespace(type) {
    switch (type) {
      case 'svg':
        return SVG_NAMESPACE;
      case 'math':
        return MATH_NAMESPACE;
      default:
        return HTML_NAMESPACE$1;
    }
  }

  function getChildNamespace(parentNamespace, type) {
    if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
      // No (or default) parent namespace: potential entry point.
      return getIntrinsicNamespace(type);
    }
    if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
      // We're leaving SVG.
      return HTML_NAMESPACE$1;
    }
    // By default, pass namespace below.
    return parentNamespace;
  }

  /* globals MSApp */

  /**
   * Create a function which has 'unsafe' privileges (required by windows8 apps)
   */
  var createMicrosoftUnsafeLocalFunction = function (func) {
    if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
      return function (arg0, arg1, arg2, arg3) {
        MSApp.execUnsafeLocalFunction(function () {
          return func(arg0, arg1, arg2, arg3);
        });
      };
    } else {
      return func;
    }
  };

  // SVG temp container for IE lacking innerHTML
  var reusableSVGContainer = void 0;

  /**
   * Set the innerHTML property of a node
   *
   * @param {DOMElement} node
   * @param {string} html
   * @internal
   */
  var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
    // IE does not have innerHTML for SVG nodes, so instead we inject the
    // new markup in a temp node and then move the child nodes across into
    // the target node

    if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
      reusableSVGContainer = reusableSVGContainer || document.createElement('div');
      reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
      var svgNode = reusableSVGContainer.firstChild;
      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }
      while (svgNode.firstChild) {
        node.appendChild(svgNode.firstChild);
      }
    } else {
      node.innerHTML = html;
    }
  });

  /**
   * Set the textContent property of a node, ensuring that whitespace is preserved
   * even in IE8. innerText is a poor substitute for textContent and, among many
   * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
   * as it should.
   *
   * @param {DOMElement} node
   * @param {string} text
   * @internal
   */
  var setTextContent = function (node, text) {
    if (text) {
      var firstChild = node.firstChild;

      if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  };

  /**
   * CSS properties which accept numbers but are not in units of "px".
   */
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,

    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };

  /**
   * @param {string} prefix vendor-specific prefix, eg: Webkit
   * @param {string} key style name, eg: transitionDuration
   * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
   * WebkitTransitionDuration
   */
  function prefixKey(prefix, key) {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  }

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

  // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
  // infinite loop, because it iterates over the newly added props too.
  Object.keys(isUnitlessNumber).forEach(function (prop) {
    prefixes.forEach(function (prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });

  /**
   * Convert a value into the proper css writable value. The style name `name`
   * should be logical (no hyphens), as specified
   * in `CSSProperty.isUnitlessNumber`.
   *
   * @param {string} name CSS property name such as `topMargin`.
   * @param {*} value CSS property value such as `10px`.
   * @return {string} Normalized style value with dimensions applied.
   */
  function dangerousStyleValue(name, value, isCustomProperty) {
    // Note that we've removed escapeTextForBrowser() calls here since the
    // whole string will be escaped when the attribute is injected into
    // the markup. If you provide unsafe user data here they can inject
    // arbitrary CSS which may be problematic (I couldn't repro this):
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
    // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
    // This is not an XSS hole but instead a potential CSS injection issue
    // which has lead to a greater discussion about how we're going to
    // trust URLs moving forward. See #2115901

    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }

    if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
      return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
    }

    return ('' + value).trim();
  }

  var warnValidStyle = emptyFunction;

  {
    // 'msTransform' is correct, but the other prefixes should be capitalized
    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

    // style values shouldn't contain a semicolon
    var badStyleValueWithSemicolonPattern = /;\s*$/;

    var warnedStyleNames = {};
    var warnedStyleValues = {};
    var warnedForNaNValue = false;
    var warnedForInfinityValue = false;

    var warnHyphenatedStyleName = function (name, getStack) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }

      warnedStyleNames[name] = true;
      warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
    };

    var warnBadVendoredStyleName = function (name, getStack) {
      if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
        return;
      }

      warnedStyleNames[name] = true;
      warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
    };

    var warnStyleValueWithSemicolon = function (name, value, getStack) {
      if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
        return;
      }

      warnedStyleValues[value] = true;
      warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
    };

    var warnStyleValueIsNaN = function (name, value, getStack) {
      if (warnedForNaNValue) {
        return;
      }

      warnedForNaNValue = true;
      warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
    };

    var warnStyleValueIsInfinity = function (name, value, getStack) {
      if (warnedForInfinityValue) {
        return;
      }

      warnedForInfinityValue = true;
      warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
    };

    warnValidStyle = function (name, value, getStack) {
      if (name.indexOf('-') > -1) {
        warnHyphenatedStyleName(name, getStack);
      } else if (badVendoredStyleNamePattern.test(name)) {
        warnBadVendoredStyleName(name, getStack);
      } else if (badStyleValueWithSemicolonPattern.test(value)) {
        warnStyleValueWithSemicolon(name, value, getStack);
      }

      if (typeof value === 'number') {
        if (isNaN(value)) {
          warnStyleValueIsNaN(name, value, getStack);
        } else if (!isFinite(value)) {
          warnStyleValueIsInfinity(name, value, getStack);
        }
      }
    };
  }

  var warnValidStyle$1 = warnValidStyle;

  /**
   * Operations for dealing with CSS properties.
   */

  /**
   * This creates a string that is expected to be equivalent to the style
   * attribute generated by server-side rendering. It by-passes warnings and
   * security checks so it's not safe to use this value for anything other than
   * comparison. It is only used in DEV for SSR validation.
   */
  function createDangerousStringForStyles(styles) {
    {
      var serialized = '';
      var delimiter = '';
      for (var styleName in styles) {
        if (!styles.hasOwnProperty(styleName)) {
          continue;
        }
        var styleValue = styles[styleName];
        if (styleValue != null) {
          var isCustomProperty = styleName.indexOf('--') === 0;
          serialized += delimiter + hyphenateStyleName(styleName) + ':';
          serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

          delimiter = ';';
        }
      }
      return serialized || null;
    }
  }

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  function setValueForStyles(node, styles, getStack) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      {
        if (!isCustomProperty) {
          warnValidStyle$1(styleName, styles[styleName], getStack);
        }
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
      if (styleName === 'float') {
        styleName = 'cssFloat';
      }
      if (isCustomProperty) {
        style.setProperty(styleName, styleValue);
      } else {
        style[styleName] = styleValue;
      }
    }
  }

  // For HTML, certain tags should omit their close tag. We keep a whitelist for
  // those special-case tags.

  var omittedCloseTags = {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  };

  // For HTML, certain tags cannot have children. This has the same purpose as
  // `omittedCloseTags` except that `menuitem` should still have its closing tag.

  var voidElementTags = _assign({
    menuitem: true
  }, omittedCloseTags);

  var HTML$1 = '__html';

  function assertValidProps(tag, props, getStack) {
    if (!props) {
      return;
    }
    // Note the use of `==` which checks for null or undefined.
    if (voidElementTags[tag]) {
      !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
    }
    if (props.dangerouslySetInnerHTML != null) {
      !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
      !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
    }
    {
      warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
    }
    !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
  }

  function isCustomComponent(tagName, props) {
    if (tagName.indexOf('-') === -1) {
      return typeof props.is === 'string';
    }
    switch (tagName) {
      // These are reserved SVG and MathML elements.
      // We don't mind this whitelist too much because we expect it to never grow.
      // The alternative is to track the namespace in a few places which is convoluted.
      // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return false;
      default:
        return true;
    }
  }

  var ariaProperties = {
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  };

  var warnedProperties = {};
  var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function getStackAddendum() {
    var stack = ReactDebugCurrentFrame.getStackAddendum();
    return stack != null ? stack : '';
  }

  function validateProperty(tagName, name) {
    if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
      return true;
    }

    if (rARIACamel.test(name)) {
      var ariaName = 'aria-' + name.slice(4).toLowerCase();
      var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

      // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.
      if (correctName == null) {
        warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
        warnedProperties[name] = true;
        return true;
      }
      // aria-* attributes should be lowercase; suggest the lowercase version.
      if (name !== correctName) {
        warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
        warnedProperties[name] = true;
        return true;
      }
    }

    if (rARIA.test(name)) {
      var lowerCasedName = name.toLowerCase();
      var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

      // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.
      if (standardName == null) {
        warnedProperties[name] = true;
        return false;
      }
      // aria-* attributes should be lowercase; suggest the lowercase version.
      if (name !== standardName) {
        warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
        warnedProperties[name] = true;
        return true;
      }
    }

    return true;
  }

  function warnInvalidARIAProps(type, props) {
    var invalidProps = [];

    for (var key in props) {
      var isValid = validateProperty(type, key);
      if (!isValid) {
        invalidProps.push(key);
      }
    }

    var unknownPropString = invalidProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (invalidProps.length === 1) {
      warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
    } else if (invalidProps.length > 1) {
      warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
    }
  }

  function validateProperties(type, props) {
    if (isCustomComponent(type, props)) {
      return;
    }
    warnInvalidARIAProps(type, props);
  }

  var didWarnValueNull = false;

  function getStackAddendum$1() {
    var stack = ReactDebugCurrentFrame.getStackAddendum();
    return stack != null ? stack : '';
  }

  function validateProperties$1(type, props) {
    if (type !== 'input' && type !== 'textarea' && type !== 'select') {
      return;
    }

    if (props != null && props.value === null && !didWarnValueNull) {
      didWarnValueNull = true;
      if (type === 'select' && props.multiple) {
        warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
      } else {
        warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
      }
    }
  }

  // When adding attributes to the HTML or SVG whitelist, be sure to
  // also add them to this module to ensure casing and incorrect name
  // warnings.
  var possibleStandardNames = {
    // HTML
    accept: 'accept',
    acceptcharset: 'acceptCharset',
    'accept-charset': 'acceptCharset',
    accesskey: 'accessKey',
    action: 'action',
    allowfullscreen: 'allowFullScreen',
    alt: 'alt',
    as: 'as',
    async: 'async',
    autocapitalize: 'autoCapitalize',
    autocomplete: 'autoComplete',
    autocorrect: 'autoCorrect',
    autofocus: 'autoFocus',
    autoplay: 'autoPlay',
    autosave: 'autoSave',
    capture: 'capture',
    cellpadding: 'cellPadding',
    cellspacing: 'cellSpacing',
    challenge: 'challenge',
    charset: 'charSet',
    checked: 'checked',
    children: 'children',
    cite: 'cite',
    'class': 'className',
    classid: 'classID',
    classname: 'className',
    cols: 'cols',
    colspan: 'colSpan',
    content: 'content',
    contenteditable: 'contentEditable',
    contextmenu: 'contextMenu',
    controls: 'controls',
    controlslist: 'controlsList',
    coords: 'coords',
    crossorigin: 'crossOrigin',
    dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
    data: 'data',
    datetime: 'dateTime',
    'default': 'default',
    defaultchecked: 'defaultChecked',
    defaultvalue: 'defaultValue',
    defer: 'defer',
    dir: 'dir',
    disabled: 'disabled',
    download: 'download',
    draggable: 'draggable',
    enctype: 'encType',
    'for': 'htmlFor',
    form: 'form',
    formmethod: 'formMethod',
    formaction: 'formAction',
    formenctype: 'formEncType',
    formnovalidate: 'formNoValidate',
    formtarget: 'formTarget',
    frameborder: 'frameBorder',
    headers: 'headers',
    height: 'height',
    hidden: 'hidden',
    high: 'high',
    href: 'href',
    hreflang: 'hrefLang',
    htmlfor: 'htmlFor',
    httpequiv: 'httpEquiv',
    'http-equiv': 'httpEquiv',
    icon: 'icon',
    id: 'id',
    innerhtml: 'innerHTML',
    inputmode: 'inputMode',
    integrity: 'integrity',
    is: 'is',
    itemid: 'itemID',
    itemprop: 'itemProp',
    itemref: 'itemRef',
    itemscope: 'itemScope',
    itemtype: 'itemType',
    keyparams: 'keyParams',
    keytype: 'keyType',
    kind: 'kind',
    label: 'label',
    lang: 'lang',
    list: 'list',
    loop: 'loop',
    low: 'low',
    manifest: 'manifest',
    marginwidth: 'marginWidth',
    marginheight: 'marginHeight',
    max: 'max',
    maxlength: 'maxLength',
    media: 'media',
    mediagroup: 'mediaGroup',
    method: 'method',
    min: 'min',
    minlength: 'minLength',
    multiple: 'multiple',
    muted: 'muted',
    name: 'name',
    nonce: 'nonce',
    novalidate: 'noValidate',
    open: 'open',
    optimum: 'optimum',
    pattern: 'pattern',
    placeholder: 'placeholder',
    playsinline: 'playsInline',
    poster: 'poster',
    preload: 'preload',
    profile: 'profile',
    radiogroup: 'radioGroup',
    readonly: 'readOnly',
    referrerpolicy: 'referrerPolicy',
    rel: 'rel',
    required: 'required',
    reversed: 'reversed',
    role: 'role',
    rows: 'rows',
    rowspan: 'rowSpan',
    sandbox: 'sandbox',
    scope: 'scope',
    scoped: 'scoped',
    scrolling: 'scrolling',
    seamless: 'seamless',
    selected: 'selected',
    shape: 'shape',
    size: 'size',
    sizes: 'sizes',
    span: 'span',
    spellcheck: 'spellCheck',
    src: 'src',
    srcdoc: 'srcDoc',
    srclang: 'srcLang',
    srcset: 'srcSet',
    start: 'start',
    step: 'step',
    style: 'style',
    summary: 'summary',
    tabindex: 'tabIndex',
    target: 'target',
    title: 'title',
    type: 'type',
    usemap: 'useMap',
    value: 'value',
    width: 'width',
    wmode: 'wmode',
    wrap: 'wrap',

    // SVG
    about: 'about',
    accentheight: 'accentHeight',
    'accent-height': 'accentHeight',
    accumulate: 'accumulate',
    additive: 'additive',
    alignmentbaseline: 'alignmentBaseline',
    'alignment-baseline': 'alignmentBaseline',
    allowreorder: 'allowReorder',
    alphabetic: 'alphabetic',
    amplitude: 'amplitude',
    arabicform: 'arabicForm',
    'arabic-form': 'arabicForm',
    ascent: 'ascent',
    attributename: 'attributeName',
    attributetype: 'attributeType',
    autoreverse: 'autoReverse',
    azimuth: 'azimuth',
    basefrequency: 'baseFrequency',
    baselineshift: 'baselineShift',
    'baseline-shift': 'baselineShift',
    baseprofile: 'baseProfile',
    bbox: 'bbox',
    begin: 'begin',
    bias: 'bias',
    by: 'by',
    calcmode: 'calcMode',
    capheight: 'capHeight',
    'cap-height': 'capHeight',
    clip: 'clip',
    clippath: 'clipPath',
    'clip-path': 'clipPath',
    clippathunits: 'clipPathUnits',
    cliprule: 'clipRule',
    'clip-rule': 'clipRule',
    color: 'color',
    colorinterpolation: 'colorInterpolation',
    'color-interpolation': 'colorInterpolation',
    colorinterpolationfilters: 'colorInterpolationFilters',
    'color-interpolation-filters': 'colorInterpolationFilters',
    colorprofile: 'colorProfile',
    'color-profile': 'colorProfile',
    colorrendering: 'colorRendering',
    'color-rendering': 'colorRendering',
    contentscripttype: 'contentScriptType',
    contentstyletype: 'contentStyleType',
    cursor: 'cursor',
    cx: 'cx',
    cy: 'cy',
    d: 'd',
    datatype: 'datatype',
    decelerate: 'decelerate',
    descent: 'descent',
    diffuseconstant: 'diffuseConstant',
    direction: 'direction',
    display: 'display',
    divisor: 'divisor',
    dominantbaseline: 'dominantBaseline',
    'dominant-baseline': 'dominantBaseline',
    dur: 'dur',
    dx: 'dx',
    dy: 'dy',
    edgemode: 'edgeMode',
    elevation: 'elevation',
    enablebackground: 'enableBackground',
    'enable-background': 'enableBackground',
    end: 'end',
    exponent: 'exponent',
    externalresourcesrequired: 'externalResourcesRequired',
    fill: 'fill',
    fillopacity: 'fillOpacity',
    'fill-opacity': 'fillOpacity',
    fillrule: 'fillRule',
    'fill-rule': 'fillRule',
    filter: 'filter',
    filterres: 'filterRes',
    filterunits: 'filterUnits',
    floodopacity: 'floodOpacity',
    'flood-opacity': 'floodOpacity',
    floodcolor: 'floodColor',
    'flood-color': 'floodColor',
    focusable: 'focusable',
    fontfamily: 'fontFamily',
    'font-family': 'fontFamily',
    fontsize: 'fontSize',
    'font-size': 'fontSize',
    fontsizeadjust: 'fontSizeAdjust',
    'font-size-adjust': 'fontSizeAdjust',
    fontstretch: 'fontStretch',
    'font-stretch': 'fontStretch',
    fontstyle: 'fontStyle',
    'font-style': 'fontStyle',
    fontvariant: 'fontVariant',
    'font-variant': 'fontVariant',
    fontweight: 'fontWeight',
    'font-weight': 'fontWeight',
    format: 'format',
    from: 'from',
    fx: 'fx',
    fy: 'fy',
    g1: 'g1',
    g2: 'g2',
    glyphname: 'glyphName',
    'glyph-name': 'glyphName',
    glyphorientationhorizontal: 'glyphOrientationHorizontal',
    'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
    glyphorientationvertical: 'glyphOrientationVertical',
    'glyph-orientation-vertical': 'glyphOrientationVertical',
    glyphref: 'glyphRef',
    gradienttransform: 'gradientTransform',
    gradientunits: 'gradientUnits',
    hanging: 'hanging',
    horizadvx: 'horizAdvX',
    'horiz-adv-x': 'horizAdvX',
    horizoriginx: 'horizOriginX',
    'horiz-origin-x': 'horizOriginX',
    ideographic: 'ideographic',
    imagerendering: 'imageRendering',
    'image-rendering': 'imageRendering',
    in2: 'in2',
    'in': 'in',
    inlist: 'inlist',
    intercept: 'intercept',
    k1: 'k1',
    k2: 'k2',
    k3: 'k3',
    k4: 'k4',
    k: 'k',
    kernelmatrix: 'kernelMatrix',
    kernelunitlength: 'kernelUnitLength',
    kerning: 'kerning',
    keypoints: 'keyPoints',
    keysplines: 'keySplines',
    keytimes: 'keyTimes',
    lengthadjust: 'lengthAdjust',
    letterspacing: 'letterSpacing',
    'letter-spacing': 'letterSpacing',
    lightingcolor: 'lightingColor',
    'lighting-color': 'lightingColor',
    limitingconeangle: 'limitingConeAngle',
    local: 'local',
    markerend: 'markerEnd',
    'marker-end': 'markerEnd',
    markerheight: 'markerHeight',
    markermid: 'markerMid',
    'marker-mid': 'markerMid',
    markerstart: 'markerStart',
    'marker-start': 'markerStart',
    markerunits: 'markerUnits',
    markerwidth: 'markerWidth',
    mask: 'mask',
    maskcontentunits: 'maskContentUnits',
    maskunits: 'maskUnits',
    mathematical: 'mathematical',
    mode: 'mode',
    numoctaves: 'numOctaves',
    offset: 'offset',
    opacity: 'opacity',
    operator: 'operator',
    order: 'order',
    orient: 'orient',
    orientation: 'orientation',
    origin: 'origin',
    overflow: 'overflow',
    overlineposition: 'overlinePosition',
    'overline-position': 'overlinePosition',
    overlinethickness: 'overlineThickness',
    'overline-thickness': 'overlineThickness',
    paintorder: 'paintOrder',
    'paint-order': 'paintOrder',
    panose1: 'panose1',
    'panose-1': 'panose1',
    pathlength: 'pathLength',
    patterncontentunits: 'patternContentUnits',
    patterntransform: 'patternTransform',
    patternunits: 'patternUnits',
    pointerevents: 'pointerEvents',
    'pointer-events': 'pointerEvents',
    points: 'points',
    pointsatx: 'pointsAtX',
    pointsaty: 'pointsAtY',
    pointsatz: 'pointsAtZ',
    prefix: 'prefix',
    preservealpha: 'preserveAlpha',
    preserveaspectratio: 'preserveAspectRatio',
    primitiveunits: 'primitiveUnits',
    property: 'property',
    r: 'r',
    radius: 'radius',
    refx: 'refX',
    refy: 'refY',
    renderingintent: 'renderingIntent',
    'rendering-intent': 'renderingIntent',
    repeatcount: 'repeatCount',
    repeatdur: 'repeatDur',
    requiredextensions: 'requiredExtensions',
    requiredfeatures: 'requiredFeatures',
    resource: 'resource',
    restart: 'restart',
    result: 'result',
    results: 'results',
    rotate: 'rotate',
    rx: 'rx',
    ry: 'ry',
    scale: 'scale',
    security: 'security',
    seed: 'seed',
    shaperendering: 'shapeRendering',
    'shape-rendering': 'shapeRendering',
    slope: 'slope',
    spacing: 'spacing',
    specularconstant: 'specularConstant',
    specularexponent: 'specularExponent',
    speed: 'speed',
    spreadmethod: 'spreadMethod',
    startoffset: 'startOffset',
    stddeviation: 'stdDeviation',
    stemh: 'stemh',
    stemv: 'stemv',
    stitchtiles: 'stitchTiles',
    stopcolor: 'stopColor',
    'stop-color': 'stopColor',
    stopopacity: 'stopOpacity',
    'stop-opacity': 'stopOpacity',
    strikethroughposition: 'strikethroughPosition',
    'strikethrough-position': 'strikethroughPosition',
    strikethroughthickness: 'strikethroughThickness',
    'strikethrough-thickness': 'strikethroughThickness',
    string: 'string',
    stroke: 'stroke',
    strokedasharray: 'strokeDasharray',
    'stroke-dasharray': 'strokeDasharray',
    strokedashoffset: 'strokeDashoffset',
    'stroke-dashoffset': 'strokeDashoffset',
    strokelinecap: 'strokeLinecap',
    'stroke-linecap': 'strokeLinecap',
    strokelinejoin: 'strokeLinejoin',
    'stroke-linejoin': 'strokeLinejoin',
    strokemiterlimit: 'strokeMiterlimit',
    'stroke-miterlimit': 'strokeMiterlimit',
    strokewidth: 'strokeWidth',
    'stroke-width': 'strokeWidth',
    strokeopacity: 'strokeOpacity',
    'stroke-opacity': 'strokeOpacity',
    suppresscontenteditablewarning: 'suppressContentEditableWarning',
    suppresshydrationwarning: 'suppressHydrationWarning',
    surfacescale: 'surfaceScale',
    systemlanguage: 'systemLanguage',
    tablevalues: 'tableValues',
    targetx: 'targetX',
    targety: 'targetY',
    textanchor: 'textAnchor',
    'text-anchor': 'textAnchor',
    textdecoration: 'textDecoration',
    'text-decoration': 'textDecoration',
    textlength: 'textLength',
    textrendering: 'textRendering',
    'text-rendering': 'textRendering',
    to: 'to',
    transform: 'transform',
    'typeof': 'typeof',
    u1: 'u1',
    u2: 'u2',
    underlineposition: 'underlinePosition',
    'underline-position': 'underlinePosition',
    underlinethickness: 'underlineThickness',
    'underline-thickness': 'underlineThickness',
    unicode: 'unicode',
    unicodebidi: 'unicodeBidi',
    'unicode-bidi': 'unicodeBidi',
    unicoderange: 'unicodeRange',
    'unicode-range': 'unicodeRange',
    unitsperem: 'unitsPerEm',
    'units-per-em': 'unitsPerEm',
    unselectable: 'unselectable',
    valphabetic: 'vAlphabetic',
    'v-alphabetic': 'vAlphabetic',
    values: 'values',
    vectoreffect: 'vectorEffect',
    'vector-effect': 'vectorEffect',
    version: 'version',
    vertadvy: 'vertAdvY',
    'vert-adv-y': 'vertAdvY',
    vertoriginx: 'vertOriginX',
    'vert-origin-x': 'vertOriginX',
    vertoriginy: 'vertOriginY',
    'vert-origin-y': 'vertOriginY',
    vhanging: 'vHanging',
    'v-hanging': 'vHanging',
    videographic: 'vIdeographic',
    'v-ideographic': 'vIdeographic',
    viewbox: 'viewBox',
    viewtarget: 'viewTarget',
    visibility: 'visibility',
    vmathematical: 'vMathematical',
    'v-mathematical': 'vMathematical',
    vocab: 'vocab',
    widths: 'widths',
    wordspacing: 'wordSpacing',
    'word-spacing': 'wordSpacing',
    writingmode: 'writingMode',
    'writing-mode': 'writingMode',
    x1: 'x1',
    x2: 'x2',
    x: 'x',
    xchannelselector: 'xChannelSelector',
    xheight: 'xHeight',
    'x-height': 'xHeight',
    xlinkactuate: 'xlinkActuate',
    'xlink:actuate': 'xlinkActuate',
    xlinkarcrole: 'xlinkArcrole',
    'xlink:arcrole': 'xlinkArcrole',
    xlinkhref: 'xlinkHref',
    'xlink:href': 'xlinkHref',
    xlinkrole: 'xlinkRole',
    'xlink:role': 'xlinkRole',
    xlinkshow: 'xlinkShow',
    'xlink:show': 'xlinkShow',
    xlinktitle: 'xlinkTitle',
    'xlink:title': 'xlinkTitle',
    xlinktype: 'xlinkType',
    'xlink:type': 'xlinkType',
    xmlbase: 'xmlBase',
    'xml:base': 'xmlBase',
    xmllang: 'xmlLang',
    'xml:lang': 'xmlLang',
    xmlns: 'xmlns',
    'xml:space': 'xmlSpace',
    xmlnsxlink: 'xmlnsXlink',
    'xmlns:xlink': 'xmlnsXlink',
    xmlspace: 'xmlSpace',
    y1: 'y1',
    y2: 'y2',
    y: 'y',
    ychannelselector: 'yChannelSelector',
    z: 'z',
    zoomandpan: 'zoomAndPan'
  };

  function getStackAddendum$2() {
    var stack = ReactDebugCurrentFrame.getStackAddendum();
    return stack != null ? stack : '';
  }

  {
    var warnedProperties$1 = {};
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var EVENT_NAME_REGEX = /^on./;
    var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
    var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

    var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
      if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
        return true;
      }

      var lowerCasedName = name.toLowerCase();
      if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
        warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
        warnedProperties$1[name] = true;
        return true;
      }

      // We can't rely on the event system being injected on the server.
      if (canUseEventSystem) {
        if (registrationNameModules.hasOwnProperty(name)) {
          return true;
        }
        var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
        if (registrationName != null) {
          warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
          warnedProperties$1[name] = true;
          return true;
        }
        if (EVENT_NAME_REGEX.test(name)) {
          warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
          warnedProperties$1[name] = true;
          return true;
        }
      } else if (EVENT_NAME_REGEX.test(name)) {
        // If no event plugins have been injected, we are in a server environment.
        // So we can't tell if the event name is correct for sure, but we can filter
        // out known bad ones like `onclick`. We can't suggest a specific replacement though.
        if (INVALID_EVENT_NAME_REGEX.test(name)) {
          warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());
        }
        warnedProperties$1[name] = true;
        return true;
      }

      // Let the ARIA attribute hook validate ARIA attributes
      if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
        return true;
      }

      if (lowerCasedName === 'innerhtml') {
        warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
        warnedProperties$1[name] = true;
        return true;
      }

      if (lowerCasedName === 'aria') {
        warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
        warnedProperties$1[name] = true;
        return true;
      }

      if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
        warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }

      if (typeof value === 'number' && isNaN(value)) {
        warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }

      var isReserved = isReservedProp(name);

      // Known attributes should match the casing specified in the property config.
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        var standardName = possibleStandardNames[lowerCasedName];
        if (standardName !== name) {
          warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
          warnedProperties$1[name] = true;
          return true;
        }
      } else if (!isReserved && name !== lowerCasedName) {
        // Unknown attributes should have lowercase casing since that's how they
        // will be cased anyway with server rendering.
        warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }

      if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
        if (value) {
          warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
        } else {
          warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
        }
        warnedProperties$1[name] = true;
        return true;
      }

      // Now that we've validated casing, do not validate
      // data types for reserved props
      if (isReserved) {
        return true;
      }

      // Warn when a known attribute is a bad type
      if (!shouldSetAttribute(name, value)) {
        warnedProperties$1[name] = true;
        return false;
      }

      return true;
    };
  }

  var warnUnknownProperties = function (type, props, canUseEventSystem) {
    var unknownProps = [];
    for (var key in props) {
      var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
      if (!isValid) {
        unknownProps.push(key);
      }
    }

    var unknownPropString = unknownProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');
    if (unknownProps.length === 1) {
      warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
    } else if (unknownProps.length > 1) {
      warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
    }
  };

  function validateProperties$2(type, props, canUseEventSystem) {
    if (isCustomComponent(type, props)) {
      return;
    }
    warnUnknownProperties(type, props, canUseEventSystem);
  }

  // TODO: direct imports like some-package/src/* are bad. Fix me.
  var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
  var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

  var didWarnInvalidHydration = false;
  var didWarnShadyDOM = false;

  var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
  var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
  var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
  var AUTOFOCUS = 'autoFocus';
  var CHILDREN = 'children';
  var STYLE = 'style';
  var HTML = '__html';

  var HTML_NAMESPACE = Namespaces.html;


  var getStack = emptyFunction.thatReturns('');

  {
    getStack = getCurrentFiberStackAddendum$2;

    var warnedUnknownTags = {
      // Chrome is the only major browser not shipping <time>. But as of July
      // 2017 it intends to ship it due to widespread usage. We intentionally
      // *don't* warn for <time> even if it's unrecognized by Chrome because
      // it soon will be, and many apps have been using it anyway.
      time: true,
      // There are working polyfills for <dialog>. Let people use it.
      dialog: true
    };

    var validatePropertiesInDevelopment = function (type, props) {
      validateProperties(type, props);
      validateProperties$1(type, props);
      validateProperties$2(type, props, /* canUseEventSystem */true);
    };

    // HTML parsing normalizes CR and CRLF to LF.
    // It also can turn \u0000 into \uFFFD inside attributes.
    // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
    // If we have a mismatch, it might be caused by that.
    // We will still patch up in this case but not fire the warning.
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
    var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

    var normalizeMarkupForTextOrAttribute = function (markup) {
      var markupString = typeof markup === 'string' ? markup : '' + markup;
      return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
    };

    var warnForTextDifference = function (serverText, clientText) {
      if (didWarnInvalidHydration) {
        return;
      }
      var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
      var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
      if (normalizedServerText === normalizedClientText) {
        return;
      }
      didWarnInvalidHydration = true;
      warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
    };

    var warnForPropDifference = function (propName, serverValue, clientValue) {
      if (didWarnInvalidHydration) {
        return;
      }
      var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
      var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
      if (normalizedServerValue === normalizedClientValue) {
        return;
      }
      didWarnInvalidHydration = true;
      warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
    };

    var warnForExtraAttributes = function (attributeNames) {
      if (didWarnInvalidHydration) {
        return;
      }
      didWarnInvalidHydration = true;
      var names = [];
      attributeNames.forEach(function (name) {
        names.push(name);
      });
      warning(false, 'Extra attributes from the server: %s', names);
    };

    var warnForInvalidEventListener = function (registrationName, listener) {
      if (listener === false) {
        warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
      } else {
        warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
      }
    };

    // Parse the HTML and read it back to normalize the HTML string so that it
    // can be used for comparison.
    var normalizeHTML = function (parent, html) {
      // We could have created a separate document here to avoid
      // re-initializing custom elements if they exist. But this breaks
      // how <noscript> is being handled. So we use the same document.
      // See the discussion in https://github.com/facebook/react/pull/11157.
      var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
      testElement.innerHTML = html;
      return testElement.innerHTML;
    };
  }

  function ensureListeningTo(rootContainerElement, registrationName) {
    var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
    var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
    listenTo(registrationName, doc);
  }

  function getOwnerDocumentFromRootContainer(rootContainerElement) {
    return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
  }

  // There are so many media events, it makes sense to just
  // maintain a list rather than create a `trapBubbledEvent` for each
  var mediaEvents = {
    topAbort: 'abort',
    topCanPlay: 'canplay',
    topCanPlayThrough: 'canplaythrough',
    topDurationChange: 'durationchange',
    topEmptied: 'emptied',
    topEncrypted: 'encrypted',
    topEnded: 'ended',
    topError: 'error',
    topLoadedData: 'loadeddata',
    topLoadedMetadata: 'loadedmetadata',
    topLoadStart: 'loadstart',
    topPause: 'pause',
    topPlay: 'play',
    topPlaying: 'playing',
    topProgress: 'progress',
    topRateChange: 'ratechange',
    topSeeked: 'seeked',
    topSeeking: 'seeking',
    topStalled: 'stalled',
    topSuspend: 'suspend',
    topTimeUpdate: 'timeupdate',
    topVolumeChange: 'volumechange',
    topWaiting: 'waiting'
  };

  function trapClickOnNonInteractiveElement(node) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    // Just set it using the onclick property so that we don't have to manage any
    // bookkeeping for it. Not sure if we need to clear it when the listener is
    // removed.
    // TODO: Only do this for the relevant Safaris maybe?
    node.onclick = emptyFunction;
  }

  function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
    for (var propKey in nextProps) {
      if (!nextProps.hasOwnProperty(propKey)) {
        continue;
      }
      var nextProp = nextProps[propKey];
      if (propKey === STYLE) {
        {
          if (nextProp) {
            // Freeze the next style object so that we can assume it won't be
            // mutated. We have already warned for this in the past.
            Object.freeze(nextProp);
          }
        }
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        setValueForStyles(domElement, nextProp, getStack);
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var nextHtml = nextProp ? nextProp[HTML] : undefined;
        if (nextHtml != null) {
          setInnerHTML(domElement, nextHtml);
        }
      } else if (propKey === CHILDREN) {
        if (typeof nextProp === 'string') {
          // Avoid setting initial textContent when the text is empty. In IE11 setting
          // textContent on a <textarea> will cause the placeholder to not
          // show within the <textarea> until it has been focused and blurred again.
          // https://github.com/facebook/react/issues/6731#issuecomment-254874553
          var canSetTextContent = tag !== 'textarea' || nextProp !== '';
          if (canSetTextContent) {
            setTextContent(domElement, nextProp);
          }
        } else if (typeof nextProp === 'number') {
          setTextContent(domElement, '' + nextProp);
        }
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
        // Noop
      } else if (propKey === AUTOFOCUS) {
        // We polyfill it separately on the client during commit.
        // We blacklist it here rather than in the property list because we emit it in SSR.
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp != null) {
          if (true && typeof nextProp !== 'function') {
            warnForInvalidEventListener(propKey, nextProp);
          }
          ensureListeningTo(rootContainerElement, propKey);
        }
      } else if (isCustomComponentTag) {
        setValueForAttribute(domElement, propKey, nextProp);
      } else if (nextProp != null) {
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        setValueForProperty(domElement, propKey, nextProp);
      }
    }
  }

  function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
    // TODO: Handle wasCustomComponentTag
    for (var i = 0; i < updatePayload.length; i += 2) {
      var propKey = updatePayload[i];
      var propValue = updatePayload[i + 1];
      if (propKey === STYLE) {
        setValueForStyles(domElement, propValue, getStack);
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        setInnerHTML(domElement, propValue);
      } else if (propKey === CHILDREN) {
        setTextContent(domElement, propValue);
      } else if (isCustomComponentTag) {
        if (propValue != null) {
          setValueForAttribute(domElement, propKey, propValue);
        } else {
          deleteValueForAttribute(domElement, propKey);
        }
      } else if (propValue != null) {
        setValueForProperty(domElement, propKey, propValue);
      } else {
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        deleteValueForProperty(domElement, propKey);
      }
    }
  }

  function createElement$1(type, props, rootContainerElement, parentNamespace) {
    // We create tags in the namespace of their parent container, except HTML
    var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
    var domElement;
    var namespaceURI = parentNamespace;
    if (namespaceURI === HTML_NAMESPACE) {
      namespaceURI = getIntrinsicNamespace(type);
    }
    if (namespaceURI === HTML_NAMESPACE) {
      {
        var isCustomComponentTag = isCustomComponent(type, props);
        // Should this check be gated by parent namespace? Not sure we want to
        // allow <SVG> or <mATH>.
        warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
      }

      if (type === 'script') {
        // Create the script via .innerHTML so its "parser-inserted" flag is
        // set to true and it does not execute
        var div = ownerDocument.createElement('div');
        div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
        // This is guaranteed to yield a script element.
        var firstChild = div.firstChild;
        domElement = div.removeChild(firstChild);
      } else if (typeof props.is === 'string') {
        // $FlowIssue `createElement` should be updated for Web Components
        domElement = ownerDocument.createElement(type, { is: props.is });
      } else {
        // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
        // See discussion in https://github.com/facebook/react/pull/6896
        // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
        domElement = ownerDocument.createElement(type);
      }
    } else {
      domElement = ownerDocument.createElementNS(namespaceURI, type);
    }

    {
      if (namespaceURI === HTML_NAMESPACE) {
        if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
          warnedUnknownTags[type] = true;
          warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
        }
      }
    }

    return domElement;
  }

  function createTextNode$1(text, rootContainerElement) {
    return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
  }

  function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    {
      validatePropertiesInDevelopment(tag, rawProps);
      if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
        warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
        didWarnShadyDOM = true;
      }
    }

    // TODO: Make sure that we check isMounted before firing any of these events.
    var props;
    switch (tag) {
      case 'iframe':
      case 'object':
        trapBubbledEvent('topLoad', 'load', domElement);
        props = rawProps;
        break;
      case 'video':
      case 'audio':
        // Create listener for each media event
        for (var event in mediaEvents) {
          if (mediaEvents.hasOwnProperty(event)) {
            trapBubbledEvent(event, mediaEvents[event], domElement);
          }
        }
        props = rawProps;
        break;
      case 'source':
        trapBubbledEvent('topError', 'error', domElement);
        props = rawProps;
        break;
      case 'img':
      case 'image':
        trapBubbledEvent('topError', 'error', domElement);
        trapBubbledEvent('topLoad', 'load', domElement);
        props = rawProps;
        break;
      case 'form':
        trapBubbledEvent('topReset', 'reset', domElement);
        trapBubbledEvent('topSubmit', 'submit', domElement);
        props = rawProps;
        break;
      case 'details':
        trapBubbledEvent('topToggle', 'toggle', domElement);
        props = rawProps;
        break;
      case 'input':
        initWrapperState(domElement, rawProps);
        props = getHostProps(domElement, rawProps);
        trapBubbledEvent('topInvalid', 'invalid', domElement);
        // For controlled components we always need to ensure we're listening
        // to onChange. Even if there is no listener.
        ensureListeningTo(rootContainerElement, 'onChange');
        break;
      case 'option':
        validateProps(domElement, rawProps);
        props = getHostProps$1(domElement, rawProps);
        break;
      case 'select':
        initWrapperState$1(domElement, rawProps);
        props = getHostProps$2(domElement, rawProps);
        trapBubbledEvent('topInvalid', 'invalid', domElement);
        // For controlled components we always need to ensure we're listening
        // to onChange. Even if there is no listener.
        ensureListeningTo(rootContainerElement, 'onChange');
        break;
      case 'textarea':
        initWrapperState$2(domElement, rawProps);
        props = getHostProps$3(domElement, rawProps);
        trapBubbledEvent('topInvalid', 'invalid', domElement);
        // For controlled components we always need to ensure we're listening
        // to onChange. Even if there is no listener.
        ensureListeningTo(rootContainerElement, 'onChange');
        break;
      default:
        props = rawProps;
    }

    assertValidProps(tag, props, getStack);

    setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

    switch (tag) {
      case 'input':
        // TODO: Make sure we check if this is still unmounted or do any clean
        // up necessary since we never stop tracking anymore.
        track(domElement);
        postMountWrapper(domElement, rawProps);
        break;
      case 'textarea':
        // TODO: Make sure we check if this is still unmounted or do any clean
        // up necessary since we never stop tracking anymore.
        track(domElement);
        postMountWrapper$3(domElement, rawProps);
        break;
      case 'option':
        postMountWrapper$1(domElement, rawProps);
        break;
      case 'select':
        postMountWrapper$2(domElement, rawProps);
        break;
      default:
        if (typeof props.onClick === 'function') {
          // TODO: This cast may not be sound for SVG, MathML or custom elements.
          trapClickOnNonInteractiveElement(domElement);
        }
        break;
    }
  }

  // Calculate the diff between the two objects.
  function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
    {
      validatePropertiesInDevelopment(tag, nextRawProps);
    }

    var updatePayload = null;

    var lastProps;
    var nextProps;
    switch (tag) {
      case 'input':
        lastProps = getHostProps(domElement, lastRawProps);
        nextProps = getHostProps(domElement, nextRawProps);
        updatePayload = [];
        break;
      case 'option':
        lastProps = getHostProps$1(domElement, lastRawProps);
        nextProps = getHostProps$1(domElement, nextRawProps);
        updatePayload = [];
        break;
      case 'select':
        lastProps = getHostProps$2(domElement, lastRawProps);
        nextProps = getHostProps$2(domElement, nextRawProps);
        updatePayload = [];
        break;
      case 'textarea':
        lastProps = getHostProps$3(domElement, lastRawProps);
        nextProps = getHostProps$3(domElement, nextRawProps);
        updatePayload = [];
        break;
      default:
        lastProps = lastRawProps;
        nextProps = nextRawProps;
        if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
          // TODO: This cast may not be sound for SVG, MathML or custom elements.
          trapClickOnNonInteractiveElement(domElement);
        }
        break;
    }

    assertValidProps(tag, nextProps, getStack);

    var propKey;
    var styleName;
    var styleUpdates = null;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = lastProps[propKey];
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
        // Noop. This is handled by the clear text mechanism.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
        // Noop
      } else if (propKey === AUTOFOCUS) {
        // Noop. It doesn't work on updates anyway.
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" fiber pointer gets updated so we need a commit
        // to update this element.
        if (!updatePayload) {
          updatePayload = [];
        }
      } else {
        // For all other deleted properties we add it to the queue. We use
        // the whitelist in the commit phase instead.
        (updatePayload = updatePayload || []).push(propKey, null);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        {
          if (nextProp) {
            // Freeze the next style object so that we can assume it won't be
            // mutated. We have already warned for this in the past.
            Object.freeze(nextProp);
          }
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              if (!styleUpdates) {
                styleUpdates = {};
              }
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              if (!styleUpdates) {
                styleUpdates = {};
              }
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          if (!styleUpdates) {
            if (!updatePayload) {
              updatePayload = [];
            }
            updatePayload.push(propKey, styleUpdates);
          }
          styleUpdates = nextProp;
        }
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var nextHtml = nextProp ? nextProp[HTML] : undefined;
        var lastHtml = lastProp ? lastProp[HTML] : undefined;
        if (nextHtml != null) {
          if (lastHtml !== nextHtml) {
            (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
          }
        } else {
          // TODO: It might be too late to clear this if we have children
          // inserted already.
        }
      } else if (propKey === CHILDREN) {
        if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
        }
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
        // Noop
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp != null) {
          // We eagerly listen to this even though we haven't committed yet.
          if (true && typeof nextProp !== 'function') {
            warnForInvalidEventListener(propKey, nextProp);
          }
          ensureListeningTo(rootContainerElement, propKey);
        }
        if (!updatePayload && lastProp !== nextProp) {
          // This is a special case. If any listener updates we need to ensure
          // that the "current" props pointer gets updated so we need a commit
          // to update this element.
          updatePayload = [];
        }
      } else {
        // For any other property we always add it to the queue and then we
        // filter it out using the whitelist during the commit.
        (updatePayload = updatePayload || []).push(propKey, nextProp);
      }
    }
    if (styleUpdates) {
      (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
    }
    return updatePayload;
  }

  // Apply the diff.
  function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
    // Update checked *before* name.
    // In the middle of an update, it is possible to have multiple checked.
    // When a checked radio tries to change name, browser makes another radio's checked false.
    if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
      updateChecked(domElement, nextRawProps);
    }

    var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
    var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
    // Apply the diff.
    updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

    // TODO: Ensure that an update gets scheduled if any of the special props
    // changed.
    switch (tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        updateWrapper(domElement, nextRawProps);
        break;
      case 'textarea':
        updateWrapper$1(domElement, nextRawProps);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        postUpdateWrapper(domElement, nextRawProps);
        break;
    }
  }

  function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
    {
      var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
      var isCustomComponentTag = isCustomComponent(tag, rawProps);
      validatePropertiesInDevelopment(tag, rawProps);
      if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
        warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
        didWarnShadyDOM = true;
      }
    }

    // TODO: Make sure that we check isMounted before firing any of these events.
    switch (tag) {
      case 'iframe':
      case 'object':
        trapBubbledEvent('topLoad', 'load', domElement);
        break;
      case 'video':
      case 'audio':
        // Create listener for each media event
        for (var event in mediaEvents) {
          if (mediaEvents.hasOwnProperty(event)) {
            trapBubbledEvent(event, mediaEvents[event], domElement);
          }
        }
        break;
      case 'source':
        trapBubbledEvent('topError', 'error', domElement);
        break;
      case 'img':
      case 'image':
        trapBubbledEvent('topError', 'error', domElement);
        trapBubbledEvent('topLoad', 'load', domElement);
        break;
      case 'form':
        trapBubbledEvent('topReset', 'reset', domElement);
        trapBubbledEvent('topSubmit', 'submit', domElement);
        break;
      case 'details':
        trapBubbledEvent('topToggle', 'toggle', domElement);
        break;
      case 'input':
        initWrapperState(domElement, rawProps);
        trapBubbledEvent('topInvalid', 'invalid', domElement);
        // For controlled components we always need to ensure we're listening
        // to onChange. Even if there is no listener.
        ensureListeningTo(rootContainerElement, 'onChange');
        break;
      case 'option':
        validateProps(domElement, rawProps);
        break;
      case 'select':
        initWrapperState$1(domElement, rawProps);
        trapBubbledEvent('topInvalid', 'invalid', domElement);
        // For controlled components we always need to ensure we're listening
        // to onChange. Even if there is no listener.
        ensureListeningTo(rootContainerElement, 'onChange');
        break;
      case 'textarea':
        initWrapperState$2(domElement, rawProps);
        trapBubbledEvent('topInvalid', 'invalid', domElement);
        // For controlled components we always need to ensure we're listening
        // to onChange. Even if there is no listener.
        ensureListeningTo(rootContainerElement, 'onChange');
        break;
    }

    assertValidProps(tag, rawProps, getStack);

    {
      var extraAttributeNames = new Set();
      var attributes = domElement.attributes;
      for (var i = 0; i < attributes.length; i++) {
        var name = attributes[i].name.toLowerCase();
        switch (name) {
          // Built-in SSR attribute is whitelisted
          case 'data-reactroot':
            break;
          // Controlled attributes are not validated
          // TODO: Only ignore them on controlled tags.
          case 'value':
            break;
          case 'checked':
            break;
          case 'selected':
            break;
          default:
            // Intentionally use the original name.
            // See discussion in https://github.com/facebook/react/pull/10676.
            extraAttributeNames.add(attributes[i].name);
        }
      }
    }

    var updatePayload = null;
    for (var propKey in rawProps) {
      if (!rawProps.hasOwnProperty(propKey)) {
        continue;
      }
      var nextProp = rawProps[propKey];
      if (propKey === CHILDREN) {
        // For text content children we compare against textContent. This
        // might match additional HTML that is hidden when we read it using
        // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
        // satisfies our requirement. Our requirement is not to produce perfect
        // HTML and attributes. Ideally we should preserve structure but it's
        // ok not to if the visible content is still enough to indicate what
        // even listeners these nodes might be wired up to.
        // TODO: Warn if there is more than a single textNode as a child.
        // TODO: Should we use domElement.firstChild.nodeValue to compare?
        if (typeof nextProp === 'string') {
          if (domElement.textContent !== nextProp) {
            if (true && !suppressHydrationWarning) {
              warnForTextDifference(domElement.textContent, nextProp);
            }
            updatePayload = [CHILDREN, nextProp];
          }
        } else if (typeof nextProp === 'number') {
          if (domElement.textContent !== '' + nextProp) {
            if (true && !suppressHydrationWarning) {
              warnForTextDifference(domElement.textContent, nextProp);
            }
            updatePayload = [CHILDREN, '' + nextProp];
          }
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp != null) {
          if (true && typeof nextProp !== 'function') {
            warnForInvalidEventListener(propKey, nextProp);
          }
          ensureListeningTo(rootContainerElement, propKey);
        }
      } else {
        // Validate that the properties correspond to their expected values.
        var serverValue;
        var propertyInfo;
        if (suppressHydrationWarning) {
          // Don't bother comparing. We're ignoring all these warnings.
        } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
          // Noop
        } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
          var rawHtml = nextProp ? nextProp[HTML] || '' : '';
          var serverHTML = domElement.innerHTML;
          var expectedHTML = normalizeHTML(domElement, rawHtml);
          if (expectedHTML !== serverHTML) {
            warnForPropDifference(propKey, serverHTML, expectedHTML);
          }
        } else if (propKey === STYLE) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propKey);
          var expectedStyle = createDangerousStringForStyles(nextProp);
          serverValue = domElement.getAttribute('style');
          if (expectedStyle !== serverValue) {
            warnForPropDifference(propKey, serverValue, expectedStyle);
          }
        } else if (isCustomComponentTag) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propKey.toLowerCase());
          serverValue = getValueForAttribute(domElement, propKey, nextProp);

          if (nextProp !== serverValue) {
            warnForPropDifference(propKey, serverValue, nextProp);
          }
        } else if (shouldSetAttribute(propKey, nextProp)) {
          if (propertyInfo = getPropertyInfo(propKey)) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propertyInfo.attributeName);
            serverValue = getValueForProperty(domElement, propKey, nextProp);
          } else {
            var ownNamespace = parentNamespace;
            if (ownNamespace === HTML_NAMESPACE) {
              ownNamespace = getIntrinsicNamespace(tag);
            }
            if (ownNamespace === HTML_NAMESPACE) {
              // $FlowFixMe - Should be inferred as not undefined.
              extraAttributeNames['delete'](propKey.toLowerCase());
            } else {
              // $FlowFixMe - Should be inferred as not undefined.
              extraAttributeNames['delete'](propKey);
            }
            serverValue = getValueForAttribute(domElement, propKey, nextProp);
          }

          if (nextProp !== serverValue) {
            warnForPropDifference(propKey, serverValue, nextProp);
          }
        }
      }
    }

    {
      // $FlowFixMe - Should be inferred as not undefined.
      if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
        // $FlowFixMe - Should be inferred as not undefined.
        warnForExtraAttributes(extraAttributeNames);
      }
    }

    switch (tag) {
      case 'input':
        // TODO: Make sure we check if this is still unmounted or do any clean
        // up necessary since we never stop tracking anymore.
        track(domElement);
        postMountWrapper(domElement, rawProps);
        break;
      case 'textarea':
        // TODO: Make sure we check if this is still unmounted or do any clean
        // up necessary since we never stop tracking anymore.
        track(domElement);
        postMountWrapper$3(domElement, rawProps);
        break;
      case 'select':
      case 'option':
        // For input and textarea we current always set the value property at
        // post mount to force it to diverge from attributes. However, for
        // option and select we don't quite do the same thing and select
        // is not resilient to the DOM state changing so we don't do that here.
        // TODO: Consider not doing this for input and textarea.
        break;
      default:
        if (typeof rawProps.onClick === 'function') {
          // TODO: This cast may not be sound for SVG, MathML or custom elements.
          trapClickOnNonInteractiveElement(domElement);
        }
        break;
    }

    return updatePayload;
  }

  function diffHydratedText$1(textNode, text) {
    var isDifferent = textNode.nodeValue !== text;
    return isDifferent;
  }

  function warnForUnmatchedText$1(textNode, text) {
    {
      warnForTextDifference(textNode.nodeValue, text);
    }
  }

  function warnForDeletedHydratableElement$1(parentNode, child) {
    {
      if (didWarnInvalidHydration) {
        return;
      }
      didWarnInvalidHydration = true;
      warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
    }
  }

  function warnForDeletedHydratableText$1(parentNode, child) {
    {
      if (didWarnInvalidHydration) {
        return;
      }
      didWarnInvalidHydration = true;
      warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
    }
  }

  function warnForInsertedHydratedElement$1(parentNode, tag, props) {
    {
      if (didWarnInvalidHydration) {
        return;
      }
      didWarnInvalidHydration = true;
      warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
    }
  }

  function warnForInsertedHydratedText$1(parentNode, text) {
    {
      if (text === '') {
        // We expect to insert empty text nodes since they're not represented in
        // the HTML.
        // TODO: Remove this special case if we can just avoid inserting empty
        // text nodes.
        return;
      }
      if (didWarnInvalidHydration) {
        return;
      }
      didWarnInvalidHydration = true;
      warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
    }
  }

  function restoreControlledState(domElement, tag, props) {
    switch (tag) {
      case 'input':
        restoreControlledState$1(domElement, props);
        return;
      case 'textarea':
        restoreControlledState$3(domElement, props);
        return;
      case 'select':
        restoreControlledState$2(domElement, props);
        return;
    }
  }

  var ReactDOMFiberComponent = Object.freeze({
    createElement: createElement$1,
    createTextNode: createTextNode$1,
    setInitialProperties: setInitialProperties$1,
    diffProperties: diffProperties$1,
    updateProperties: updateProperties$1,
    diffHydratedProperties: diffHydratedProperties$1,
    diffHydratedText: diffHydratedText$1,
    warnForUnmatchedText: warnForUnmatchedText$1,
    warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
    warnForDeletedHydratableText: warnForDeletedHydratableText$1,
    warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
    warnForInsertedHydratedText: warnForInsertedHydratedText$1,
    restoreControlledState: restoreControlledState
  });

  // TODO: direct imports like some-package/src/* are bad. Fix me.
  var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

  var validateDOMNesting = emptyFunction;

  {
    // This validation code was written based on the HTML5 parsing spec:
    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    //
    // Note: this does not catch all invalid nesting, nor does it try to (as it's
    // not clear what practical benefit doing so provides); instead, we warn only
    // for cases where the parser will give a parse tree differing from what React
    // intended. For example, <b><div></div></b> is invalid but we don't warn
    // because it still parses correctly; we do warn for other cases like nested
    // <p> tags where the beginning of the second element implicitly closes the
    // first, causing a confusing mess.

    // https://html.spec.whatwg.org/multipage/syntax.html#special
    var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
    var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

    // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
    // TODO: Distinguish by namespace here -- for <title>, including it here
    // errs on the side of fewer warnings
    'foreignObject', 'desc', 'title'];

    // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
    var buttonScopeTags = inScopeTags.concat(['button']);

    // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
    var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

    var emptyAncestorInfo = {
      current: null,

      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,

      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null
    };

    var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
      var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
      var info = { tag: tag, instance: instance };

      if (inScopeTags.indexOf(tag) !== -1) {
        ancestorInfo.aTagInScope = null;
        ancestorInfo.buttonTagInScope = null;
        ancestorInfo.nobrTagInScope = null;
      }
      if (buttonScopeTags.indexOf(tag) !== -1) {
        ancestorInfo.pTagInButtonScope = null;
      }

      // See rules for 'li', 'dd', 'dt' start tags in
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
      if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
        ancestorInfo.listItemTagAutoclosing = null;
        ancestorInfo.dlItemTagAutoclosing = null;
      }

      ancestorInfo.current = info;

      if (tag === 'form') {
        ancestorInfo.formTag = info;
      }
      if (tag === 'a') {
        ancestorInfo.aTagInScope = info;
      }
      if (tag === 'button') {
        ancestorInfo.buttonTagInScope = info;
      }
      if (tag === 'nobr') {
        ancestorInfo.nobrTagInScope = info;
      }
      if (tag === 'p') {
        ancestorInfo.pTagInButtonScope = info;
      }
      if (tag === 'li') {
        ancestorInfo.listItemTagAutoclosing = info;
      }
      if (tag === 'dd' || tag === 'dt') {
        ancestorInfo.dlItemTagAutoclosing = info;
      }

      return ancestorInfo;
    };

    /**
     * Returns whether
     */
    var isTagValidWithParent = function (tag, parentTag) {
      // First, let's check if we're in an unusual parsing mode...
      switch (parentTag) {
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
        case 'select':
          return tag === 'option' || tag === 'optgroup' || tag === '#text';
        case 'optgroup':
          return tag === 'option' || tag === '#text';
        // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
        // but
        case 'option':
          return tag === '#text';
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
        // No special behavior since these rules fall back to "in body" mode for
        // all except special table nodes which cause bad parsing behavior anyway.

        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
        case 'tr':
          return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
        case 'tbody':
        case 'thead':
        case 'tfoot':
          return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
        case 'colgroup':
          return tag === 'col' || tag === 'template';
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
        case 'table':
          return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
        case 'head':
          return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
        // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
        case 'html':
          return tag === 'head' || tag === 'body';
        case '#document':
          return tag === 'html';
      }

      // Probably in the "in body" parsing mode, so we outlaw only tag combos
      // where the parsing rules cause implicit opens or closes to be added.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
      switch (tag) {
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
          return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

        case 'rp':
        case 'rt':
          return impliedEndTags.indexOf(parentTag) === -1;

        case 'body':
        case 'caption':
        case 'col':
        case 'colgroup':
        case 'frame':
        case 'head':
        case 'html':
        case 'tbody':
        case 'td':
        case 'tfoot':
        case 'th':
        case 'thead':
        case 'tr':
          // These tags are only valid with a few parents that have special child
          // parsing rules -- if we're down here, then none of those matched and
          // so we allow it only if we don't know what the parent is, as all other
          // cases are invalid.
          return parentTag == null;
      }

      return true;
    };

    /**
     * Returns whether
     */
    var findInvalidAncestorForTag = function (tag, ancestorInfo) {
      switch (tag) {
        case 'address':
        case 'article':
        case 'aside':
        case 'blockquote':
        case 'center':
        case 'details':
        case 'dialog':
        case 'dir':
        case 'div':
        case 'dl':
        case 'fieldset':
        case 'figcaption':
        case 'figure':
        case 'footer':
        case 'header':
        case 'hgroup':
        case 'main':
        case 'menu':
        case 'nav':
        case 'ol':
        case 'p':
        case 'section':
        case 'summary':
        case 'ul':
        case 'pre':
        case 'listing':
        case 'table':
        case 'hr':
        case 'xmp':
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
          return ancestorInfo.pTagInButtonScope;

        case 'form':
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

        case 'li':
          return ancestorInfo.listItemTagAutoclosing;

        case 'dd':
        case 'dt':
          return ancestorInfo.dlItemTagAutoclosing;

        case 'button':
          return ancestorInfo.buttonTagInScope;

        case 'a':
          // Spec says something about storing a list of markers, but it sounds
          // equivalent to this check.
          return ancestorInfo.aTagInScope;

        case 'nobr':
          return ancestorInfo.nobrTagInScope;
      }

      return null;
    };

    var didWarn = {};

    validateDOMNesting = function (childTag, childText, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfo;
      var parentInfo = ancestorInfo.current;
      var parentTag = parentInfo && parentInfo.tag;

      if (childText != null) {
        warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
        childTag = '#text';
      }

      var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
      var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
      var invalidParentOrAncestor = invalidParent || invalidAncestor;
      if (!invalidParentOrAncestor) {
        return;
      }

      var ancestorTag = invalidParentOrAncestor.tag;
      var addendum = getCurrentFiberStackAddendum$6();

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
      } else {
        warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
      }
    };

    // TODO: turn this into a named export
    validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

    // For testing
    validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfo;
      var parentInfo = ancestorInfo.current;
      var parentTag = parentInfo && parentInfo.tag;
      return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
    };
  }

  var validateDOMNesting$1 = validateDOMNesting;

  // TODO: direct imports like some-package/src/* are bad. Fix me.
  var createElement = createElement$1;
  var createTextNode = createTextNode$1;
  var setInitialProperties = setInitialProperties$1;
  var diffProperties = diffProperties$1;
  var updateProperties = updateProperties$1;
  var diffHydratedProperties = diffHydratedProperties$1;
  var diffHydratedText = diffHydratedText$1;
  var warnForUnmatchedText = warnForUnmatchedText$1;
  var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
  var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
  var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
  var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
  var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
  var precacheFiberNode = precacheFiberNode$1;
  var updateFiberProps = updateFiberProps$1;


  {
    var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
    if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
      warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
    }
  }

  injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

  var eventsEnabled = null;
  var selectionInformation = null;

  /**
   * True if the supplied DOM node is a valid node element.
   *
   * @param {?DOMElement} node The candidate DOM node.
   * @return {boolean} True if the DOM is a valid DOM node.
   * @internal
   */
  function isValidContainer(node) {
    return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
  }

  function getReactRootElementInContainer(container) {
    if (!container) {
      return null;
    }

    if (container.nodeType === DOCUMENT_NODE) {
      return container.documentElement;
    } else {
      return container.firstChild;
    }
  }

  function shouldHydrateDueToLegacyHeuristic(container) {
    var rootElement = getReactRootElementInContainer(container);
    return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
  }

  function shouldAutoFocusHostComponent(type, props) {
    switch (type) {
      case 'button':
      case 'input':
      case 'select':
      case 'textarea':
        return !!props.autoFocus;
    }
    return false;
  }

  var DOMRenderer = reactReconciler({
    getRootHostContext: function (rootContainerInstance) {
      var type = void 0;
      var namespace = void 0;
      var nodeType = rootContainerInstance.nodeType;
      switch (nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          {
            type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
            var root = rootContainerInstance.documentElement;
            namespace = root ? root.namespaceURI : getChildNamespace(null, '');
            break;
          }
        default:
          {
            var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
            var ownNamespace = container.namespaceURI || null;
            type = container.tagName;
            namespace = getChildNamespace(ownNamespace, type);
            break;
          }
      }
      {
        var validatedTag = type.toLowerCase();
        var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
        return { namespace: namespace, ancestorInfo: _ancestorInfo };
      }
      return namespace;
    },
    getChildHostContext: function (parentHostContext, type) {
      {
        var parentHostContextDev = parentHostContext;
        var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
        var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
        return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
      }
      var parentNamespace = parentHostContext;
      return getChildNamespace(parentNamespace, type);
    },
    getPublicInstance: function (instance) {
      return instance;
    },
    prepareForCommit: function () {
      eventsEnabled = isEnabled();
      selectionInformation = getSelectionInformation();
      setEnabled(false);
    },
    resetAfterCommit: function () {
      restoreSelection(selectionInformation);
      selectionInformation = null;
      setEnabled(eventsEnabled);
      eventsEnabled = null;
    },
    createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      var parentNamespace = void 0;
      {
        // TODO: take namespace into account when validating.
        var hostContextDev = hostContext;
        validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
        if (typeof props.children === 'string' || typeof props.children === 'number') {
          var string = '' + props.children;
          var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
          validateDOMNesting$1(null, string, ownAncestorInfo);
        }
        parentNamespace = hostContextDev.namespace;
      }
      var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
      precacheFiberNode(internalInstanceHandle, domElement);
      updateFiberProps(domElement, props);
      return domElement;
    },
    appendInitialChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
      setInitialProperties(domElement, type, props, rootContainerInstance);
      return shouldAutoFocusHostComponent(type, props);
    },
    prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
      {
        var hostContextDev = hostContext;
        if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
          var string = '' + newProps.children;
          var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
          validateDOMNesting$1(null, string, ownAncestorInfo);
        }
      }
      return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
    },
    shouldSetTextContent: function (type, props) {
      return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
    },
    shouldDeprioritizeSubtree: function (type, props) {
      return !!props.hidden;
    },
    createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
      {
        var hostContextDev = hostContext;
        validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
      }
      var textNode = createTextNode(text, rootContainerInstance);
      precacheFiberNode(internalInstanceHandle, textNode);
      return textNode;
    },


    now: now,

    mutation: {
      commitMount: function (domElement, type, newProps, internalInstanceHandle) {
        domElement.focus();
      },
      commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        // Update the props handle so that we know which props are the ones with
        // with current event handlers.
        updateFiberProps(domElement, newProps);
        // Apply the diff to the DOM node.
        updateProperties(domElement, updatePayload, type, oldProps, newProps);
      },
      resetTextContent: function (domElement) {
        domElement.textContent = '';
      },
      commitTextUpdate: function (textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
      },
      appendChild: function (parentInstance, child) {
        parentInstance.appendChild(child);
      },
      appendChildToContainer: function (container, child) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.insertBefore(child, container);
        } else {
          container.appendChild(child);
        }
      },
      insertBefore: function (parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
      },
      insertInContainerBefore: function (container, child, beforeChild) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.insertBefore(child, beforeChild);
        } else {
          container.insertBefore(child, beforeChild);
        }
      },
      removeChild: function (parentInstance, child) {
        parentInstance.removeChild(child);
      },
      removeChildFromContainer: function (container, child) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.removeChild(child);
        } else {
          container.removeChild(child);
        }
      }
    },

    hydration: {
      canHydrateInstance: function (instance, type, props) {
        if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
          return null;
        }
        // This has now been refined to an element node.
        return instance;
      },
      canHydrateTextInstance: function (instance, text) {
        if (text === '' || instance.nodeType !== TEXT_NODE) {
          // Empty strings are not parsed by HTML so there won't be a correct match here.
          return null;
        }
        // This has now been refined to a text node.
        return instance;
      },
      getNextHydratableSibling: function (instance) {
        var node = instance.nextSibling;
        // Skip non-hydratable nodes.
        while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
          node = node.nextSibling;
        }
        return node;
      },
      getFirstHydratableChild: function (parentInstance) {
        var next = parentInstance.firstChild;
        // Skip non-hydratable nodes.
        while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
          next = next.nextSibling;
        }
        return next;
      },
      hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, instance);
        // TODO: Possibly defer this until the commit phase where all the events
        // get attached.
        updateFiberProps(instance, props);
        var parentNamespace = void 0;
        {
          var hostContextDev = hostContext;
          parentNamespace = hostContextDev.namespace;
        }
        return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
      },
      hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, textInstance);
        return diffHydratedText(textInstance, text);
      },
      didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
        {
          warnForUnmatchedText(textInstance, text);
        }
      },
      didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
        if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
          warnForUnmatchedText(textInstance, text);
        }
      },
      didNotHydrateContainerInstance: function (parentContainer, instance) {
        {
          if (instance.nodeType === 1) {
            warnForDeletedHydratableElement(parentContainer, instance);
          } else {
            warnForDeletedHydratableText(parentContainer, instance);
          }
        }
      },
      didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
        if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
          if (instance.nodeType === 1) {
            warnForDeletedHydratableElement(parentInstance, instance);
          } else {
            warnForDeletedHydratableText(parentInstance, instance);
          }
        }
      },
      didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
        {
          warnForInsertedHydratedElement(parentContainer, type, props);
        }
      },
      didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
        {
          warnForInsertedHydratedText(parentContainer, text);
        }
      },
      didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
        if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
          warnForInsertedHydratedElement(parentInstance, type, props);
        }
      },
      didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
        if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
          warnForInsertedHydratedText(parentInstance, text);
        }
      }
    },

    scheduleDeferredCallback: rIC,
    cancelDeferredCallback: cIC,

    useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
  });

  injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

  var warnedAboutHydrateAPI = false;

  function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
    !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

    {
      if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
        var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
        if (hostInstance) {
          warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
        }
      }

      var isRootRenderedBySomeReact = !!container._reactRootContainer;
      var rootEl = getReactRootElementInContainer(container);
      var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

      warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

      warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
    }

    var root = container._reactRootContainer;
    if (!root) {
      var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
      // First clear any existing content.
      if (!shouldHydrate) {
        var warned = false;
        var rootSibling = void 0;
        while (rootSibling = container.lastChild) {
          {
            if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
              warned = true;
              warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
            }
          }
          container.removeChild(rootSibling);
        }
      }
      {
        if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
          warnedAboutHydrateAPI = true;
          lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
        }
      }
      var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
      root = container._reactRootContainer = newRoot;
      // Initial mount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
      });
    } else {
      DOMRenderer.updateContainer(children, root, parentComponent, callback);
    }
    return DOMRenderer.getPublicRootInstance(root);
  }

  function createPortal(children, container) {
    var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
    // TODO: pass ReactDOM portal implementation as third argument
    return createPortal$1(children, container, null, key);
  }

  function ReactRoot(container, hydrate) {
    var root = DOMRenderer.createContainer(container, hydrate);
    this._reactRootContainer = root;
  }
  ReactRoot.prototype.render = function (children, callback) {
    var root = this._reactRootContainer;
    DOMRenderer.updateContainer(children, root, null, callback);
  };
  ReactRoot.prototype.unmount = function (callback) {
    var root = this._reactRootContainer;
    DOMRenderer.updateContainer(null, root, null, callback);
  };

  var ReactDOM = {
    createPortal: createPortal,

    findDOMNode: function (componentOrElement) {
      {
        var owner = ReactCurrentOwner.current;
        if (owner !== null) {
          var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
          warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
          owner.stateNode._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrElement == null) {
        return null;
      }
      if (componentOrElement.nodeType === ELEMENT_NODE) {
        return componentOrElement;
      }

      var inst = get(componentOrElement);
      if (inst) {
        return DOMRenderer.findHostInstance(inst);
      }

      if (typeof componentOrElement.render === 'function') {
        invariant(false, 'Unable to find node on an unmounted component.');
      } else {
        invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
      }
    },
    hydrate: function (element, container, callback) {
      // TODO: throw or warn if we couldn't hydrate?
      return renderSubtreeIntoContainer(null, element, container, true, callback);
    },
    render: function (element, container, callback) {
      return renderSubtreeIntoContainer(null, element, container, false, callback);
    },
    unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
      !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
      return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
    },
    unmountComponentAtNode: function (container) {
      !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

      if (container._reactRootContainer) {
        {
          var rootEl = getReactRootElementInContainer(container);
          var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
          warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
        }

        // Unmount should not be batched.
        DOMRenderer.unbatchedUpdates(function () {
          renderSubtreeIntoContainer(null, null, container, false, function () {
            container._reactRootContainer = null;
          });
        });
        // If you call unmountComponentAtNode twice in quick succession, you'll
        // get `true` twice. That's probably fine?
        return true;
      } else {
        {
          var _rootEl = getReactRootElementInContainer(container);
          var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

          // Check if the container itself is a React root node.
          var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

          warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
        }

        return false;
      }
    },


    // Temporary alias since we already shipped React 16 RC with it.
    // TODO: remove in React 17.
    unstable_createPortal: createPortal,

    unstable_batchedUpdates: batchedUpdates,

    unstable_deferredUpdates: DOMRenderer.deferredUpdates,

    flushSync: DOMRenderer.flushSync,

    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      // For TapEventPlugin which is popular in open source
      EventPluginHub: EventPluginHub,
      // Used by test-utils
      EventPluginRegistry: EventPluginRegistry,
      EventPropagators: EventPropagators,
      ReactControlledComponent: ReactControlledComponent,
      ReactDOMComponentTree: ReactDOMComponentTree,
      ReactDOMEventListener: ReactDOMEventListener
    }
  };

  if (enableCreateRoot) {
    ReactDOM.createRoot = function createRoot(container, options) {
      var hydrate = options != null && options.hydrate === true;
      return new ReactRoot(container, hydrate);
    };
  }

  var foundDevTools = DOMRenderer.injectIntoDevTools({
    findFiberByHostInstance: getClosestInstanceFromNode,
    bundleType: 1,
    version: ReactVersion,
    rendererPackageName: 'react-dom'
  });

  {
    if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        var protocol = window.location.protocol;
        // Don't warn in exotic cases like chrome-extension://.
        if (/^(https?|file):$/.test(protocol)) {
          console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
        }
      }
    }
  }



  var ReactDOM$2 = Object.freeze({
    default: ReactDOM
  });

  var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

  // TODO: decide on the top-level export form.
  // This is hacky but makes it work with both Rollup and Jest.
  var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

  module.exports = reactDom;
    })();
  }

  },{"fbjs/lib/EventListener":710,"fbjs/lib/ExecutionEnvironment":711,"fbjs/lib/camelizeStyleName":713,"fbjs/lib/containsNode":714,"fbjs/lib/emptyFunction":715,"fbjs/lib/emptyObject":716,"fbjs/lib/focusNode":717,"fbjs/lib/getActiveElement":718,"fbjs/lib/hyphenateStyleName":720,"fbjs/lib/invariant":721,"fbjs/lib/shallowEqual":724,"fbjs/lib/warning":725,"object-assign":822,"prop-types/checkPropTypes":1158,"react":1253}],1156:[function(require,module,exports){
  /** @license React v16.2.0
   * react-dom.production.min.js
   *
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /*
   Modernizr 3.0.0pre (Custom Build) | MIT
  */
  'use strict';var aa=require("react"),l=require("fbjs/lib/ExecutionEnvironment"),B=require("object-assign"),C=require("fbjs/lib/emptyFunction"),ba=require("fbjs/lib/EventListener"),da=require("fbjs/lib/getActiveElement"),ea=require("fbjs/lib/shallowEqual"),fa=require("fbjs/lib/containsNode"),ia=require("fbjs/lib/focusNode"),D=require("fbjs/lib/emptyObject");
  function E(a){for(var b=arguments.length-1,c="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);b=Error(c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}aa?void 0:E("227");
  var oa={children:!0,dangerouslySetInnerHTML:!0,defaultValue:!0,defaultChecked:!0,innerHTML:!0,suppressContentEditableWarning:!0,suppressHydrationWarning:!0,style:!0};function pa(a,b){return(a&b)===b}
  var ta={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=ta,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){ua.hasOwnProperty(f)?E("48",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:pa(h,b.MUST_USE_PROPERTY),
  hasBooleanValue:pa(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:pa(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:pa(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:pa(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:pa(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:E("50",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);ua[f]=g}}},ua={};
  function va(a,b){if(oa.hasOwnProperty(a)||2<a.length&&("o"===a[0]||"O"===a[0])&&("n"===a[1]||"N"===a[1]))return!1;if(null===b)return!0;switch(typeof b){case "boolean":return oa.hasOwnProperty(a)?a=!0:(b=wa(a))?a=b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue:(a=a.toLowerCase().slice(0,5),a="data-"===a||"aria-"===a),a;case "undefined":case "number":case "string":case "object":return!0;default:return!1}}function wa(a){return ua.hasOwnProperty(a)?ua[a]:null}
  var xa=ta,ya=xa.MUST_USE_PROPERTY,K=xa.HAS_BOOLEAN_VALUE,za=xa.HAS_NUMERIC_VALUE,Aa=xa.HAS_POSITIVE_NUMERIC_VALUE,Ba=xa.HAS_OVERLOADED_BOOLEAN_VALUE,Ca=xa.HAS_STRING_BOOLEAN_VALUE,Da={Properties:{allowFullScreen:K,async:K,autoFocus:K,autoPlay:K,capture:Ba,checked:ya|K,cols:Aa,contentEditable:Ca,controls:K,"default":K,defer:K,disabled:K,download:Ba,draggable:Ca,formNoValidate:K,hidden:K,loop:K,multiple:ya|K,muted:ya|K,noValidate:K,open:K,playsInline:K,readOnly:K,required:K,reversed:K,rows:Aa,rowSpan:za,
  scoped:K,seamless:K,selected:ya|K,size:Aa,start:za,span:Aa,spellCheck:Ca,style:0,tabIndex:0,itemScope:K,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:Ca},DOMAttributeNames:{acceptCharset:"accept-charset",className:"class",htmlFor:"for",httpEquiv:"http-equiv"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute("value");"number"!==a.type||!1===a.hasAttribute("value")?a.setAttribute("value",""+b):a.validity&&!a.validity.badInput&&a.ownerDocument.activeElement!==a&&
  a.setAttribute("value",""+b)}}},Ea=xa.HAS_STRING_BOOLEAN_VALUE,M={xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace"},Ga={Properties:{autoReverse:Ea,externalResourcesRequired:Ea,preserveAlpha:Ea},DOMAttributeNames:{autoReverse:"autoReverse",externalResourcesRequired:"externalResourcesRequired",preserveAlpha:"preserveAlpha"},DOMAttributeNamespaces:{xlinkActuate:M.xlink,xlinkArcrole:M.xlink,xlinkHref:M.xlink,xlinkRole:M.xlink,xlinkShow:M.xlink,xlinkTitle:M.xlink,xlinkType:M.xlink,
  xmlBase:M.xml,xmlLang:M.xml,xmlSpace:M.xml}},Ha=/[\-\:]([a-z])/g;function Ia(a){return a[1].toUpperCase()}
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a){var b=a.replace(Ha,
  Ia);Ga.Properties[b]=0;Ga.DOMAttributeNames[b]=a});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
  var P={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){"function"!==typeof a.invokeGuardedCallback?E("197"):void 0;Ja=a.invokeGuardedCallback}},invokeGuardedCallback:function(a,b,c,d,e,f,g,h,k){Ja.apply(P,arguments)},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){P.invokeGuardedCallback.apply(this,arguments);if(P.hasCaughtError()){var q=P.clearCaughtError();P._hasRethrowError||(P._hasRethrowError=!0,P._rethrowError=
  q)}},rethrowCaughtError:function(){return Ka.apply(P,arguments)},hasCaughtError:function(){return P._hasCaughtError},clearCaughtError:function(){if(P._hasCaughtError){var a=P._caughtError;P._caughtError=null;P._hasCaughtError=!1;return a}E("198")}};function Ja(a,b,c,d,e,f,g,h,k){P._hasCaughtError=!1;P._caughtError=null;var q=Array.prototype.slice.call(arguments,3);try{b.apply(c,q)}catch(v){P._caughtError=v,P._hasCaughtError=!0}}
  function Ka(){if(P._hasRethrowError){var a=P._rethrowError;P._rethrowError=null;P._hasRethrowError=!1;throw a;}}var La=null,Ma={};
  function Na(){if(La)for(var a in Ma){var b=Ma[a],c=La.indexOf(a);-1<c?void 0:E("96",a);if(!Oa[c]){b.extractEvents?void 0:E("97",a);Oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Pa.hasOwnProperty(h)?E("99",h):void 0;Pa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Qa(k[e],g,h);e=!0}else f.registrationName?(Qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:E("98",d,a)}}}}
  function Qa(a,b,c){Ra[a]?E("100",a):void 0;Ra[a]=b;Sa[a]=b.eventTypes[c].dependencies}var Oa=[],Pa={},Ra={},Sa={};function Ta(a){La?E("101"):void 0;La=Array.prototype.slice.call(a);Na()}function Ua(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];Ma.hasOwnProperty(c)&&Ma[c]===d||(Ma[c]?E("102",c):void 0,Ma[c]=d,b=!0)}b&&Na()}
  var Va=Object.freeze({plugins:Oa,eventNameDispatchConfigs:Pa,registrationNameModules:Ra,registrationNameDependencies:Sa,possibleRegistrationNames:null,injectEventPluginOrder:Ta,injectEventPluginsByName:Ua}),Wa=null,Xa=null,Ya=null;function Za(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}
  function $a(a,b){null==b?E("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function ab(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var bb=null;
  function cb(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Za(a,b,c[e],d[e]);else c&&Za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function db(a){return cb(a,!0)}function gb(a){return cb(a,!1)}var hb={injectEventPluginOrder:Ta,injectEventPluginsByName:Ua};
  function ib(a,b){var c=a.stateNode;if(!c)return null;var d=Wa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?E("231",b,typeof c):void 0;
  return c}function jb(a,b,c,d){for(var e,f=0;f<Oa.length;f++){var g=Oa[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=$a(e,g))}return e}function kb(a){a&&(bb=$a(bb,a))}function lb(a){var b=bb;bb=null;b&&(a?ab(b,db):ab(b,gb),bb?E("95"):void 0,P.rethrowCaughtError())}var mb=Object.freeze({injection:hb,getListener:ib,extractEvents:jb,enqueueEvents:kb,processEventQueue:lb}),nb=Math.random().toString(36).slice(2),Q="__reactInternalInstance$"+nb,ob="__reactEventHandlers$"+nb;
  function pb(a){if(a[Q])return a[Q];for(var b=[];!a[Q];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=void 0,d=a[Q];if(5===d.tag||6===d.tag)return d;for(;a&&(d=a[Q]);a=b.pop())c=d;return c}function qb(a){if(5===a.tag||6===a.tag)return a.stateNode;E("33")}function rb(a){return a[ob]||null}
  var sb=Object.freeze({precacheFiberNode:function(a,b){b[Q]=a},getClosestInstanceFromNode:pb,getInstanceFromNode:function(a){a=a[Q];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:qb,getFiberCurrentPropsFromNode:rb,updateFiberProps:function(a,b){a[ob]=b}});function tb(a){do a=a["return"];while(a&&5!==a.tag);return a?a:null}function ub(a,b,c){for(var d=[];a;)d.push(a),a=tb(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c)}
  function vb(a,b,c){if(b=ib(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a)}function wb(a){a&&a.dispatchConfig.phasedRegistrationNames&&ub(a._targetInst,vb,a)}function xb(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?tb(b):null;ub(b,vb,a)}}
  function yb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=ib(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a))}function zb(a){a&&a.dispatchConfig.registrationName&&yb(a._targetInst,null,a)}function Ab(a){ab(a,wb)}
  function Bb(a,b,c,d){if(c&&d)a:{var e=c;for(var f=d,g=0,h=e;h;h=tb(h))g++;h=0;for(var k=f;k;k=tb(k))h++;for(;0<g-h;)e=tb(e),g--;for(;0<h-g;)f=tb(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=tb(e);f=tb(f)}e=null}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=tb(c)}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=tb(d)}for(d=0;d<e.length;d++)yb(e[d],"bubbled",a);for(a=c.length;0<a--;)yb(c[a],"captured",b)}
  var Cb=Object.freeze({accumulateTwoPhaseDispatches:Ab,accumulateTwoPhaseDispatchesSkipTarget:function(a){ab(a,xb)},accumulateEnterLeaveDispatches:Bb,accumulateDirectDispatches:function(a){ab(a,zb)}}),Db=null;function Eb(){!Db&&l.canUseDOM&&(Db="textContent"in document.documentElement?"textContent":"innerText");return Db}var S={_root:null,_startText:null,_fallbackText:null};
  function Fb(){if(S._fallbackText)return S._fallbackText;var a,b=S._startText,c=b.length,d,e=Gb(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);S._fallbackText=e.slice(a,1<d?1-d:void 0);return S._fallbackText}function Gb(){return"value"in S._root?S._root.value:S._root[Eb()]}
  var Hb="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),Ib={type:null,target:null,currentTarget:C.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
  function T(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?C.thatReturnsTrue:C.thatReturnsFalse;this.isPropagationStopped=C.thatReturnsFalse;return this}
  B(T.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=C.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=C.thatReturnsTrue)},persist:function(){this.isPersistent=C.thatReturnsTrue},isPersistent:C.thatReturnsFalse,
  destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Hb.length;a++)this[Hb[a]]=null}});T.Interface=Ib;T.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;B(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=B({},this.Interface,b);a.augmentClass=this.augmentClass;Jb(a)};Jb(T);function Kb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
  function Lb(a){a instanceof this?void 0:E("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Jb(a){a.eventPool=[];a.getPooled=Kb;a.release=Lb}function Mb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Mb,{data:null});function Nb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Nb,{data:null});var Pb=[9,13,27,32],Vb=l.canUseDOM&&"CompositionEvent"in window,Wb=null;l.canUseDOM&&"documentMode"in document&&(Wb=document.documentMode);var Xb;
  if(Xb=l.canUseDOM&&"TextEvent"in window&&!Wb){var Yb=window.opera;Xb=!("object"===typeof Yb&&"function"===typeof Yb.version&&12>=parseInt(Yb.version(),10))}
  var Zb=Xb,$b=l.canUseDOM&&(!Vb||Wb&&8<Wb&&11>=Wb),ac=String.fromCharCode(32),bc={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd","topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
  captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},cc=!1;
  function dc(a,b){switch(a){case "topKeyUp":return-1!==Pb.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function ec(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var fc=!1;function gc(a,b){switch(a){case "topCompositionEnd":return ec(b);case "topKeyPress":if(32!==b.which)return null;cc=!0;return ac;case "topTextInput":return a=b.data,a===ac&&cc?null:a;default:return null}}
  function hc(a,b){if(fc)return"topCompositionEnd"===a||!Vb&&dc(a,b)?(a=Fb(),S._root=null,S._startText=null,S._fallbackText=null,fc=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return $b?null:b.data;default:return null}}
  var ic={eventTypes:bc,extractEvents:function(a,b,c,d){var e;if(Vb)b:{switch(a){case "topCompositionStart":var f=bc.compositionStart;break b;case "topCompositionEnd":f=bc.compositionEnd;break b;case "topCompositionUpdate":f=bc.compositionUpdate;break b}f=void 0}else fc?dc(a,c)&&(f=bc.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(f=bc.compositionStart);f?($b&&(fc||f!==bc.compositionStart?f===bc.compositionEnd&&fc&&(e=Fb()):(S._root=d,S._startText=Gb(),fc=!0)),f=Mb.getPooled(f,b,c,d),e?f.data=
  e:(e=ec(c),null!==e&&(f.data=e)),Ab(f),e=f):e=null;(a=Zb?gc(a,c):hc(a,c))?(b=Nb.getPooled(bc.beforeInput,b,c,d),b.data=a,Ab(b)):b=null;return[e,b]}},jc=null,kc=null,lc=null;function mc(a){if(a=Xa(a)){jc&&"function"===typeof jc.restoreControlledState?void 0:E("194");var b=Wa(a.stateNode);jc.restoreControlledState(a.stateNode,a.type,b)}}var nc={injectFiberControlledHostComponent:function(a){jc=a}};function oc(a){kc?lc?lc.push(a):lc=[a]:kc=a}
  function pc(){if(kc){var a=kc,b=lc;lc=kc=null;mc(a);if(b)for(a=0;a<b.length;a++)mc(b[a])}}var qc=Object.freeze({injection:nc,enqueueStateRestore:oc,restoreStateIfNeeded:pc});function rc(a,b){return a(b)}var sc=!1;function tc(a,b){if(sc)return rc(a,b);sc=!0;try{return rc(a,b)}finally{sc=!1,pc()}}var uc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};
  function vc(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!uc[a.type]:"textarea"===b?!0:!1}function wc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xc;l.canUseDOM&&(xc=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature("",""));
  function yc(a,b){if(!l.canUseDOM||b&&!("addEventListener"in document))return!1;b="on"+a;var c=b in document;c||(c=document.createElement("div"),c.setAttribute(b,"return;"),c="function"===typeof c[b]);!c&&xc&&"wheel"===a&&(c=document.implementation.hasFeature("Events.wheel","3.0"));return c}function zc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
  function Ac(a){var b=zc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a)}}),{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}
  function Bc(a){a._valueTracker||(a._valueTracker=Ac(a))}function Cc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=zc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Dc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}};
  function Ec(a,b,c){a=T.getPooled(Dc.change,a,b,c);a.type="change";oc(c);Ab(a);return a}var Fc=null,Gc=null;function Hc(a){kb(a);lb(!1)}function Ic(a){var b=qb(a);if(Cc(b))return a}function Jc(a,b){if("topChange"===a)return b}var Kc=!1;l.canUseDOM&&(Kc=yc("input")&&(!document.documentMode||9<document.documentMode));function Lc(){Fc&&(Fc.detachEvent("onpropertychange",Mc),Gc=Fc=null)}function Mc(a){"value"===a.propertyName&&Ic(Gc)&&(a=Ec(Gc,a,wc(a)),tc(Hc,a))}
  function Nc(a,b,c){"topFocus"===a?(Lc(),Fc=b,Gc=c,Fc.attachEvent("onpropertychange",Mc)):"topBlur"===a&&Lc()}function Oc(a){if("topSelectionChange"===a||"topKeyUp"===a||"topKeyDown"===a)return Ic(Gc)}function Pc(a,b){if("topClick"===a)return Ic(b)}function $c(a,b){if("topInput"===a||"topChange"===a)return Ic(b)}
  var ad={eventTypes:Dc,_isInputEventSupported:Kc,extractEvents:function(a,b,c,d){var e=b?qb(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Jc;else if(vc(e))if(Kc)g=$c;else{g=Oc;var h=Nc}else f=e.nodeName,!f||"input"!==f.toLowerCase()||"checkbox"!==e.type&&"radio"!==e.type||(g=Pc);if(g&&(g=g(a,b)))return Ec(g,c,d);h&&h(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&(a=""+e.value,e.getAttribute("value")!==
  a&&e.setAttribute("value",a))}};function bd(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(bd,{view:null,detail:null});var cd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=cd[a])?!!b[a]:!1}function ed(){return dd}function fd(a,b,c,d){return T.call(this,a,b,c,d)}
  bd.augmentClass(fd,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ed,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});
  var gd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},hd={eventTypes:gd,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?pb(b):null):a=null;if(a===
  b)return null;var f=null==a?e:qb(a);e=null==b?e:qb(b);var g=fd.getPooled(gd.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=fd.getPooled(gd.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Bb(g,c,a,b);return[g,c]}},id=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a){a=a.type;return"string"===typeof a?a:"function"===typeof a?a.displayName||a.name:null}
  function kd(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if(0!==(b.effectTag&2))return 1;for(;b["return"];)if(b=b["return"],0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function ld(a){return(a=a._reactInternalFiber)?2===kd(a):!1}function md(a){2!==kd(a)?E("188"):void 0}
  function nd(a){var b=a.alternate;if(!b)return b=kd(a),3===b?E("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return md(e),a;if(g===d)return md(e),b;g=g.sibling}E("188")}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
  void 0:E("189")}}c.alternate!==d?E("190"):void 0}3!==c.tag?E("188"):void 0;return c.stateNode.current===c?a:b}function od(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}
  function pd(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}var qd=[];
  function rd(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c["return"];)c=c["return"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=pb(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],sd(a.topLevelType,b,a.nativeEvent,wc(a.nativeEvent))}var td=!0,sd=void 0;function ud(a){td=!!a}function U(a,b,c){return c?ba.listen(c,b,vd.bind(null,a)):null}function wd(a,b,c){return c?ba.capture(c,b,vd.bind(null,a)):null}
  function vd(a,b){if(td){var c=wc(b);c=pb(c);null===c||"number"!==typeof c.tag||2===kd(c)||(c=null);if(qd.length){var d=qd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{tc(rd,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>qd.length&&qd.push(a)}}}
  var xd=Object.freeze({get _enabled(){return td},get _handleTopLevel(){return sd},setHandleTopLevel:function(a){sd=a},setEnabled:ud,isEnabled:function(){return td},trapBubbledEvent:U,trapCapturedEvent:wd,dispatchEvent:vd});function yd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}
  var zd={animationend:yd("Animation","AnimationEnd"),animationiteration:yd("Animation","AnimationIteration"),animationstart:yd("Animation","AnimationStart"),transitionend:yd("Transition","TransitionEnd")},Ad={},Bd={};l.canUseDOM&&(Bd=document.createElement("div").style,"AnimationEvent"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),"TransitionEvent"in window||delete zd.transitionend.transition);
  function Cd(a){if(Ad[a])return Ad[a];if(!zd[a])return a;var b=zd[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Bd)return Ad[a]=b[c];return""}
  var Dd={topAbort:"abort",topAnimationEnd:Cd("animationend")||"animationend",topAnimationIteration:Cd("animationiteration")||"animationiteration",topAnimationStart:Cd("animationstart")||"animationstart",topBlur:"blur",topCancel:"cancel",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",topContextMenu:"contextmenu",topCopy:"copy",
  topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoadedData:"loadeddata",topLoad:"load",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",
  topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",topPaste:"paste",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topScroll:"scroll",topSeeked:"seeked",topSeeking:"seeking",topSelectionChange:"selectionchange",topStalled:"stalled",topSuspend:"suspend",topTextInput:"textInput",topTimeUpdate:"timeupdate",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",
  topTouchStart:"touchstart",topTransitionEnd:Cd("transitionend")||"transitionend",topVolumeChange:"volumechange",topWaiting:"waiting",topWheel:"wheel"},Ed={},Fd=0,Gd="_reactListenersID"+(""+Math.random()).slice(2);function Hd(a){Object.prototype.hasOwnProperty.call(a,Gd)||(a[Gd]=Fd++,Ed[a[Gd]]={});return Ed[a[Gd]]}function Id(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
  function Jd(a,b){var c=Id(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Id(c)}}function Kd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===a.contentEditable)}
  var Ld=l.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},Nd=null,Od=null,Pd=null,Qd=!1;
  function Rd(a,b){if(Qd||null==Nd||Nd!==da())return null;var c=Nd;"selectionStart"in c&&Kd(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Pd&&ea(Pd,c)?null:(Pd=c,a=T.getPooled(Md.select,Od,a,b),a.type="select",a.target=Nd,Ab(a),a)}
  var Sd={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Hd(e);f=Sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?qb(b):window;switch(a){case "topFocus":if(vc(e)||"true"===e.contentEditable)Nd=e,Od=b,Pd=null;break;case "topBlur":Pd=Od=Nd=null;break;case "topMouseDown":Qd=!0;break;case "topContextMenu":case "topMouseUp":return Qd=!1,Rd(c,d);case "topSelectionChange":if(Ld)break;
  case "topKeyDown":case "topKeyUp":return Rd(c,d)}return null}};function Td(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Td,{animationName:null,elapsedTime:null,pseudoElement:null});function Ud(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Ud,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}});function Vd(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(Vd,{relatedTarget:null});
  function Wd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}
  var Xd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Yd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
  116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function Zd(a,b,c,d){return T.call(this,a,b,c,d)}
  bd.augmentClass(Zd,{key:function(a){if(a.key){var b=Xd[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Wd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Yd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ed,charCode:function(a){return"keypress"===a.type?Wd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
  a.type?Wd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}});function $d(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass($d,{dataTransfer:null});function ae(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(ae,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ed});function be(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(be,{propertyName:null,elapsedTime:null,pseudoElement:null});
  function ce(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass(ce,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var de={},ee={};
  "abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a){var b=a[0].toUpperCase()+
  a.slice(1),c="on"+b;b="top"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+"Capture"},dependencies:[b]};de[a]=c;ee[b]=c});
  var fe={eventTypes:de,extractEvents:function(a,b,c,d){var e=ee[a];if(!e)return null;switch(a){case "topKeyPress":if(0===Wd(c))return null;case "topKeyDown":case "topKeyUp":a=Zd;break;case "topBlur":case "topFocus":a=Vd;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":a=fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":a=
  $d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":a=ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":a=Td;break;case "topTransitionEnd":a=be;break;case "topScroll":a=bd;break;case "topWheel":a=ce;break;case "topCopy":case "topCut":case "topPaste":a=Ud;break;default:a=T}b=a.getPooled(e,b,c,d);Ab(b);return b}};sd=function(a,b,c,d){a=jb(a,b,c,d);kb(a);lb(!1)};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
  Wa=sb.getFiberCurrentPropsFromNode;Xa=sb.getInstanceFromNode;Ya=sb.getNodeFromInstance;hb.injectEventPluginsByName({SimpleEventPlugin:fe,EnterLeaveEventPlugin:hd,ChangeEventPlugin:ad,SelectEventPlugin:Sd,BeforeInputEventPlugin:ic});var ge=[],he=-1;function V(a){0>he||(a.current=ge[he],ge[he]=null,he--)}function W(a,b){he++;ge[he]=a.current;a.current=b}new Set;var ie={current:D},X={current:!1},je=D;function ke(a){return le(a)?je:ie.current}
  function me(a,b){var c=a.type.contextTypes;if(!c)return D;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function le(a){return 2===a.tag&&null!=a.type.childContextTypes}function ne(a){le(a)&&(V(X,a),V(ie,a))}
  function oe(a,b,c){null!=ie.cursor?E("168"):void 0;W(ie,b,a);W(X,c,a)}function pe(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:E("108",jd(a)||"Unknown",e);return B({},b,c)}function qe(a){if(!le(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||D;je=ie.current;W(ie,b,a);W(X,X.current,a);return!0}
  function re(a,b){var c=a.stateNode;c?void 0:E("169");if(b){var d=pe(a,je);c.__reactInternalMemoizedMergedChildContext=d;V(X,a);V(ie,a);W(ie,d,a)}else V(X,a);W(X,b,a)}
  function Y(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this["return"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null}
  function se(a,b,c){var d=a.alternate;null===d?(d=new Y(a.tag,a.key,a.internalContextTag),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=c;d.pendingProps=b;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}
  function te(a,b,c){var d=void 0,e=a.type,f=a.key;"function"===typeof e?(d=e.prototype&&e.prototype.isReactComponent?new Y(2,f,b):new Y(0,f,b),d.type=e,d.pendingProps=a.props):"string"===typeof e?(d=new Y(5,f,b),d.type=e,d.pendingProps=a.props):"object"===typeof e&&null!==e&&"number"===typeof e.tag?(d=e,d.pendingProps=a.props):E("130",null==e?e:typeof e,"");d.expirationTime=c;return d}function ue(a,b,c,d){b=new Y(10,d,b);b.pendingProps=a;b.expirationTime=c;return b}
  function ve(a,b,c){b=new Y(6,null,b);b.pendingProps=a;b.expirationTime=c;return b}function we(a,b,c){b=new Y(7,a.key,b);b.type=a.handler;b.pendingProps=a;b.expirationTime=c;return b}function xe(a,b,c){a=new Y(9,null,b);a.expirationTime=c;return a}function ye(a,b,c){b=new Y(4,a.key,b);b.pendingProps=a.children||[];b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}var ze=null,Ae=null;
  function Be(a){return function(b){try{return a(b)}catch(c){}}}function Ce(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);ze=Be(function(a){return b.onCommitFiberRoot(c,a)});Ae=Be(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}function De(a){"function"===typeof ze&&ze(a)}function Ee(a){"function"===typeof Ae&&Ae(a)}
  function Fe(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1}}function Ge(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime}
  function He(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=Fe(null));null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=Fe(null))):a=null;a=a!==d?a:null;null===a?Ge(d,b):null===d.last||null===a.last?(Ge(d,b),Ge(a,b)):(Ge(d,b),a.last=b)}function Ie(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}
  function Je(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,callbackList:null,hasForceUpdate:!1});c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var q=h.expirationTime;if(q>f){var v=c.expirationTime;if(0===v||v>q)c.expirationTime=q;k||(k=!0,c.baseState=a)}else{k||(c.first=h.next,null===
  c.first&&(c.last=null));if(h.isReplace)a=Ie(h,d,a,e),g=!0;else if(q=Ie(h,d,a,e))a=g?B({},a,q):B(a,q),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(q=c.callbackList,null===q&&(q=c.callbackList=[]),q.push(h))}h=h.next}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||(b.updateQueue=null);k||(c.baseState=a);return a}
  function Ke(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;"function"!==typeof e?E("191",e):void 0;e.call(b)}}
  function Le(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;b._reactInternalFiber=a}var f={isMounted:ld,enqueueSetState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!1,isForced:!1,nextCallback:null,next:null});a(c,g)},enqueueReplaceState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!0,isForced:!1,nextCallback:null,next:null});
  a(c,g)},enqueueForceUpdate:function(c,d){c=c._reactInternalFiber;d=void 0===d?null:d;var e=b(c);He(c,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,nextCallback:null,next:null});a(c,e)}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=ke(a),f=2===a.tag&&null!=a.type.contextTypes,g=f?me(a,d):D;b=new c(b,g);e(a,b);f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=g);return b},mountClassInstance:function(a,
  b){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:E("158");var h=ke(a);d.props=g;d.state=a.memoizedState=e;d.refs=D;d.context=me(a,h);null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=1);"function"===typeof d.componentWillMount&&(e=d.state,d.componentWillMount(),e!==d.state&&f.enqueueReplaceState(d,d.state,null),e=a.updateQueue,null!==e&&(d.state=Je(c,a,e,d,g,b)));"function"===typeof d.componentDidMount&&(a.effectTag|=
  4)},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?E("159"):void 0);var u=g.context,z=ke(b);z=me(b,z);"function"!==typeof g.componentWillReceiveProps||h===k&&u===z||(u=g.state,g.componentWillReceiveProps(k,z),g.state!==u&&f.enqueueReplaceState(g,g.state,null));u=b.memoizedState;e=null!==b.updateQueue?Je(a,b,b.updateQueue,g,k,e):u;if(!(h!==k||u!==e||X.current||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==
  typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),!1;var G=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)G=!0;else{var I=b.stateNode,L=b.type;G="function"===typeof I.shouldComponentUpdate?I.shouldComponentUpdate(G,e,z):L.prototype&&L.prototype.isPureReactComponent?!ea(h,G)||!ea(u,e):!0}G?("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(k,e,z),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4)):("function"!==typeof g.componentDidUpdate||
  h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),c(b,k),d(b,e));g.props=k;g.state=e;g.context=z;return G}}}var Qe="function"===typeof Symbol&&Symbol["for"],Re=Qe?Symbol["for"]("react.element"):60103,Se=Qe?Symbol["for"]("react.call"):60104,Te=Qe?Symbol["for"]("react.return"):60105,Ue=Qe?Symbol["for"]("react.portal"):60106,Ve=Qe?Symbol["for"]("react.fragment"):60107,We="function"===typeof Symbol&&Symbol.iterator;
  function Xe(a){if(null===a||"undefined"===typeof a)return null;a=We&&a[We]||a["@@iterator"];return"function"===typeof a?a:null}var Ye=Array.isArray;
  function Ze(a,b){var c=b.ref;if(null!==c&&"function"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&(2!==b.tag?E("110"):void 0,d=b.stateNode);d?void 0:E("147",c);var e=""+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===D?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};a._stringRef=e;return a}"string"!==typeof c?E("148"):void 0;b._owner?void 0:E("149",c)}return c}
  function $e(a,b){"textarea"!==a.type&&E("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
  function af(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=se(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
  2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ve(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Ze(b,c),d["return"]=a,d;d=te(c,a.internalContextTag,d);d.ref=Ze(b,c);d["return"]=a;return d}function q(a,b,c,d){if(null===b||7!==b.tag)return b=we(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);
  b["return"]=a;return b}function v(a,b,c,d){if(null===b||9!==b.tag)return b=xe(c,a.internalContextTag,d),b.type=c.value,b["return"]=a,b;b=e(b,null,d);b.type=c.value;b["return"]=a;return b}function y(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ye(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c.children||[],d);b["return"]=a;return b}function u(a,b,c,d,f){if(null===b||10!==b.tag)return b=ue(c,a.internalContextTag,
  d,f),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function z(a,b,c){if("string"===typeof b||"number"===typeof b)return b=ve(""+b,a.internalContextTag,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Re:if(b.type===Ve)return b=ue(b.props.children,a.internalContextTag,c,b.key),b["return"]=a,b;c=te(b,a.internalContextTag,c);c.ref=Ze(null,b);c["return"]=a;return c;case Se:return b=we(b,a.internalContextTag,c),b["return"]=a,b;case Te:return c=xe(b,a.internalContextTag,
  c),c.type=b.value,c["return"]=a,c;case Ue:return b=ye(b,a.internalContextTag,c),b["return"]=a,b}if(Ye(b)||Xe(b))return b=ue(b,a.internalContextTag,c,null),b["return"]=a,b;$e(a,b)}return null}function G(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Re:return c.key===e?c.type===Ve?u(a,b,c.props.children,d,e):k(a,b,c,d):null;case Se:return c.key===e?q(a,b,c,d):null;case Te:return null===
  e?v(a,b,c,d):null;case Ue:return c.key===e?y(a,b,c,d):null}if(Ye(c)||Xe(c))return null!==e?null:u(a,b,c,d,null);$e(a,c)}return null}function I(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Re:return a=a.get(null===d.key?c:d.key)||null,d.type===Ve?u(b,a,d.props.children,e,d.key):k(b,a,d,e);case Se:return a=a.get(null===d.key?c:d.key)||null,q(b,a,d,e);case Te:return a=a.get(c)||null,v(b,a,d,e);case Ue:return a=
  a.get(null===d.key?c:d.key)||null,y(b,a,d,e)}if(Ye(d)||Xe(d))return a=a.get(c)||null,u(b,a,d,e,null);$e(b,d)}return null}function L(e,g,m,A){for(var h=null,r=null,n=g,w=g=0,k=null;null!==n&&w<m.length;w++){n.index>w?(k=n,n=null):k=n.sibling;var x=G(e,n,m[w],A);if(null===x){null===n&&(n=k);break}a&&n&&null===x.alternate&&b(e,n);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;n=k}if(w===m.length)return c(e,n),h;if(null===n){for(;w<m.length;w++)if(n=z(e,m[w],A))g=f(n,g,w),null===r?h=n:r.sibling=n,r=n;return h}for(n=
  d(e,n);w<m.length;w++)if(k=I(n,e,w,m[w],A)){if(a&&null!==k.alternate)n["delete"](null===k.key?w:k.key);g=f(k,g,w);null===r?h=k:r.sibling=k;r=k}a&&n.forEach(function(a){return b(e,a)});return h}function N(e,g,m,A){var h=Xe(m);"function"!==typeof h?E("150"):void 0;m=h.call(m);null==m?E("151"):void 0;for(var r=h=null,n=g,w=g=0,k=null,x=m.next();null!==n&&!x.done;w++,x=m.next()){n.index>w?(k=n,n=null):k=n.sibling;var J=G(e,n,x.value,A);if(null===J){n||(n=k);break}a&&n&&null===J.alternate&&b(e,n);g=f(J,
  g,w);null===r?h=J:r.sibling=J;r=J;n=k}if(x.done)return c(e,n),h;if(null===n){for(;!x.done;w++,x=m.next())x=z(e,x.value,A),null!==x&&(g=f(x,g,w),null===r?h=x:r.sibling=x,r=x);return h}for(n=d(e,n);!x.done;w++,x=m.next())if(x=I(n,e,w,x.value,A),null!==x){if(a&&null!==x.alternate)n["delete"](null===x.key?w:x.key);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x}a&&n.forEach(function(a){return b(e,a)});return h}return function(a,d,f,h){"object"===typeof f&&null!==f&&f.type===Ve&&null===f.key&&(f=f.props.children);
  var m="object"===typeof f&&null!==f;if(m)switch(f.$$typeof){case Re:a:{var r=f.key;for(m=d;null!==m;){if(m.key===r)if(10===m.tag?f.type===Ve:m.type===f.type){c(a,m.sibling);d=e(m,f.type===Ve?f.props.children:f.props,h);d.ref=Ze(m,f);d["return"]=a;a=d;break a}else{c(a,m);break}else b(a,m);m=m.sibling}f.type===Ve?(d=ue(f.props.children,a.internalContextTag,h,f.key),d["return"]=a,a=d):(h=te(f,a.internalContextTag,h),h.ref=Ze(d,f),h["return"]=a,a=h)}return g(a);case Se:a:{for(m=f.key;null!==d;){if(d.key===
  m)if(7===d.tag){c(a,d.sibling);d=e(d,f,h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=we(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a);case Te:a:{if(null!==d)if(9===d.tag){c(a,d.sibling);d=e(d,null,h);d.type=f.value;d["return"]=a;a=d;break a}else c(a,d);d=xe(f,a.internalContextTag,h);d.type=f.value;d["return"]=a;a=d}return g(a);case Ue:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===
  f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=ye(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h)):(c(a,d),d=ve(f,a.internalContextTag,h)),d["return"]=a,a=d,g(a);if(Ye(f))return L(a,d,f,h);if(Xe(f))return N(a,d,f,h);m&&$e(a,f);if("undefined"===typeof f)switch(a.tag){case 2:case 1:h=a.type,E("152",h.displayName||
  h.name||"Component")}return c(a,d)}}var bf=af(!0),cf=af(!1);
  function df(a,b,c,d,e){function f(a,b,c){var d=b.expirationTime;b.child=null===a?cf(b,null,c,d):bf(b,a.child,c,d)}function g(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=128)}function h(a,b,c,d){g(a,b);if(!c)return d&&re(b,!1),q(a,b);c=b.stateNode;id.current=b;var e=c.render();b.effectTag|=1;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&re(b,!0);return b.child}function k(a){var b=a.stateNode;b.pendingContext?oe(a,b.pendingContext,b.pendingContext!==b.context):b.context&&oe(a,
  b.context,!1);I(a,b.containerInfo)}function q(a,b){null!==a&&b.child!==a.child?E("153"):void 0;if(null!==b.child){a=b.child;var c=se(a,a.pendingProps,a.expirationTime);b.child=c;for(c["return"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=se(a,a.pendingProps,a.expirationTime),c["return"]=b;c.sibling=null}return b.child}function v(a,b){switch(b.tag){case 3:k(b);break;case 2:qe(b);break;case 4:I(b,b.stateNode.containerInfo)}return null}var y=a.shouldSetTextContent,u=a.useSyncScheduling,z=a.shouldDeprioritizeSubtree,
  G=b.pushHostContext,I=b.pushHostContainer,L=c.enterHydrationState,N=c.resetHydrationState,J=c.tryToClaimNextHydratableInstance;a=Le(d,e,function(a,b){a.memoizedProps=b},function(a,b){a.memoizedState=b});var w=a.adoptClassInstance,m=a.constructClassInstance,A=a.mountClassInstance,Ob=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c)return v(a,b);switch(b.tag){case 0:null!==a?E("155"):void 0;var d=b.type,e=b.pendingProps,r=ke(b);r=me(b,r);d=d(e,r);b.effectTag|=
  1;"object"===typeof d&&null!==d&&"function"===typeof d.render?(b.tag=2,e=qe(b),w(b,d),A(b,c),b=h(a,b,!0,e)):(b.tag=1,f(a,b,d),b.memoizedProps=e,b=b.child);return b;case 1:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(X.current)null===c&&(c=d);else if(null===c||d===c){b=q(a,b);break a}d=ke(b);d=me(b,d);e=e(c,d);b.effectTag|=1;f(a,b,e);b.memoizedProps=c;b=b.child}return b;case 2:return e=qe(b),d=void 0,null===a?b.stateNode?E("153"):(m(b,b.pendingProps),A(b,c),d=!0):d=Ob(a,b,c),h(a,b,d,e);case 3:return k(b),
  e=b.updateQueue,null!==e?(d=b.memoizedState,e=Je(a,b,e,null,null,c),d===e?(N(),b=q(a,b)):(d=e.element,r=b.stateNode,(null===a||null===a.child)&&r.hydrate&&L(b)?(b.effectTag|=2,b.child=cf(b,null,d,c)):(N(),f(a,b,d)),b.memoizedState=e,b=b.child)):(N(),b=q(a,b)),b;case 5:G(b);null===a&&J(b);e=b.type;var n=b.memoizedProps;d=b.pendingProps;null===d&&(d=n,null===d?E("154"):void 0);r=null!==a?a.memoizedProps:null;X.current||null!==d&&n!==d?(n=d.children,y(e,d)?n=null:r&&y(e,r)&&(b.effectTag|=16),g(a,b),
  2147483647!==c&&!u&&z(e,d)?(b.expirationTime=2147483647,b=null):(f(a,b,n),b.memoizedProps=d,b=b.child)):b=q(a,b);return b;case 6:return null===a&&J(b),a=b.pendingProps,null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case 8:b.tag=7;case 7:e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null===e?E("154"):void 0);else if(null===e||b.memoizedProps===e)e=b.memoizedProps;d=e.children;b.stateNode=null===a?cf(b,b.stateNode,d,c):bf(b,b.stateNode,d,c);b.memoizedProps=e;return b.stateNode;
  case 9:return null;case 4:a:{I(b,b.stateNode.containerInfo);e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null==e?E("154"):void 0);else if(null===e||b.memoizedProps===e){b=q(a,b);break a}null===a?b.child=bf(b,null,e,c):f(a,b,e);b.memoizedProps=e;b=b.child}return b;case 10:a:{c=b.pendingProps;if(X.current)null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=q(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child}return b;default:E("156")}},beginFailedWork:function(a,b,
  c){switch(b.tag){case 2:qe(b);break;case 3:k(b);break;default:E("157")}b.effectTag|=64;null===a?b.child=null:b.child!==a.child&&(b.child=a.child);if(0===b.expirationTime||b.expirationTime>c)return v(a,b);b.firstEffect=null;b.lastEffect=null;b.child=null===a?cf(b,null,null,c):bf(b,a.child,null,c);2===b.tag&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}
  function ef(a,b,c){function d(a){a.effectTag|=4}var e=a.createInstance,f=a.createTextInstance,g=a.appendInitialChild,h=a.finalizeInitialChildren,k=a.prepareUpdate,q=a.persistence,v=b.getRootHostContainer,y=b.popHostContext,u=b.getHostContext,z=b.popHostContainer,G=c.prepareToHydrateHostInstance,I=c.prepareToHydrateHostTextInstance,L=c.popHydrationState,N=void 0,J=void 0,w=void 0;a.mutation?(N=function(){},J=function(a,b,c){(b.updateQueue=c)&&d(b)},w=function(a,b,c,e){c!==e&&d(b)}):q?E("235"):E("236");
  return{completeWork:function(a,b,c){var m=b.pendingProps;if(null===m)m=b.memoizedProps;else if(2147483647!==b.expirationTime||2147483647===c)b.pendingProps=null;switch(b.tag){case 1:return null;case 2:return ne(b),null;case 3:z(b);V(X,b);V(ie,b);m=b.stateNode;m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null);if(null===a||null===a.child)L(b),b.effectTag&=-3;N(b);return null;case 5:y(b);c=v();var A=b.type;if(null!==a&&null!=b.stateNode){var p=a.memoizedProps,q=b.stateNode,x=u();q=
  k(q,A,p,m,c,x);J(a,b,q,A,p,m,c);a.ref!==b.ref&&(b.effectTag|=128)}else{if(!m)return null===b.stateNode?E("166"):void 0,null;a=u();if(L(b))G(b,c,a)&&d(b);else{a=e(A,m,c,a,b);a:for(p=b.child;null!==p;){if(5===p.tag||6===p.tag)g(a,p.stateNode);else if(4!==p.tag&&null!==p.child){p.child["return"]=p;p=p.child;continue}if(p===b)break;for(;null===p.sibling;){if(null===p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}h(a,A,m,c)&&d(b);b.stateNode=a}null!==b.ref&&
  (b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)w(a,b,a.memoizedProps,m);else{if("string"!==typeof m)return null===b.stateNode?E("166"):void 0,null;a=v();c=u();L(b)?I(b)&&d(b):b.stateNode=f(m,a,c,b)}return null;case 7:(m=b.memoizedProps)?void 0:E("165");b.tag=8;A=[];a:for((p=b.stateNode)&&(p["return"]=b);null!==p;){if(5===p.tag||6===p.tag||4===p.tag)E("247");else if(9===p.tag)A.push(p.type);else if(null!==p.child){p.child["return"]=p;p=p.child;continue}for(;null===p.sibling;){if(null===
  p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}p=m.handler;m=p(m.props,A);b.child=bf(b,null!==a?a.child:null,m,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 10:return null;case 4:return z(b),N(b),null;case 0:E("167");default:E("156")}}}}
  function ff(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null)}catch(A){b(a,A)}}function d(a){"function"===typeof Ee&&Ee(a);switch(a.tag){case 2:c(a);var d=a.stateNode;if("function"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount()}catch(A){b(a,A)}break;case 5:c(a);break;case 7:e(a.stateNode);break;case 4:k&&g(a)}}function e(a){for(var b=a;;)if(d(b),null===b.child||k&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||
  b["return"]===a)return;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}else b.child["return"]=b,b=b.child}function f(a){return 5===a.tag||3===a.tag||4===a.tag}function g(a){for(var b=a,c=!1,f=void 0,g=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?E("160"):void 0;switch(c.tag){case 5:f=c.stateNode;g=!1;break a;case 3:f=c.stateNode.containerInfo;g=!0;break a;case 4:f=c.stateNode.containerInfo;g=!0;break a}c=c["return"]}c=!0}if(5===b.tag||6===b.tag)e(b),g?J(f,b.stateNode):N(f,b.stateNode);
  else if(4===b.tag?f=b.stateNode.containerInfo:d(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"];4===b.tag&&(c=!1)}b.sibling["return"]=b["return"];b=b.sibling}}var h=a.getPublicInstance,k=a.mutation;a=a.persistence;k||(a?E("235"):E("236"));var q=k.commitMount,v=k.commitUpdate,y=k.resetTextContent,u=k.commitTextUpdate,z=k.appendChild,G=k.appendChildToContainer,I=k.insertBefore,L=k.insertInContainerBefore,
  N=k.removeChild,J=k.removeChildFromContainer;return{commitResetTextContent:function(a){y(a.stateNode)},commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(f(b)){var c=b;break a}b=b["return"]}E("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:E("161")}c.effectTag&16&&(y(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||f(c["return"])){c=
  null;break a}c=c["return"]}c.sibling["return"]=c["return"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child["return"]=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?L(b,e.stateNode,c):I(b,e.stateNode,c):d?G(b,e.stateNode):z(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child["return"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e["return"]||e["return"]===
  a)return;e=e["return"]}e.sibling["return"]=e["return"];e=e.sibling}},commitDeletion:function(a){g(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null)},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b)}break;case 6:null===b.stateNode?E("162"):void 0;c=b.memoizedProps;u(b.stateNode,null!==a?a.memoizedProps:
  c,c);break;case 3:break;default:E("163")}},commitLifeCycles:function(a,b){switch(b.tag){case 2:var c=b.stateNode;if(b.effectTag&4)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a)}b=b.updateQueue;null!==b&&Ke(b,c);break;case 3:c=b.updateQueue;null!==c&&Ke(c,null!==b.child?b.child.stateNode:null);break;case 5:c=b.stateNode;null===a&&b.effectTag&4&&q(c,
  b.type,b.memoizedProps,b);break;case 6:break;case 4:break;default:E("163")}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:b(h(c));break;default:b(c)}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null)}}}var gf={};
  function hf(a){function b(a){a===gf?E("174"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e={current:gf},f={current:gf},g={current:gf};return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){V(e,a);V(f,a);V(g,a)},popHostContext:function(a){f.current===a&&(V(e,a),V(f,a))},pushHostContainer:function(a,b){W(g,b,a);b=d(b);W(f,a,a);W(e,b,a)},pushHostContext:function(a){var d=b(g.current),h=b(e.current);
  d=c(h,a.type,d);h!==d&&(W(f,a,a),W(e,d,a))},resetHostContainer:function(){e.current=gf;g.current=gf}}}
  function jf(a){function b(a,b){var c=new Y(5,null,0);c.type="DELETED";c.stateNode=b;c["return"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a["return"];null!==a&&5!==a.tag&&3!==a.tag;)a=a["return"];y=a}var e=a.shouldSetTextContent;
  a=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){E("175")},prepareToHydrateHostTextInstance:function(){E("176")},popHydrationState:function(){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,q=a.hydrateInstance,v=a.hydrateTextInstance,y=null,u=null,z=!1;return{enterHydrationState:function(a){u=
  k(a.stateNode.containerInfo);y=a;return z=!0},resetHydrationState:function(){u=y=null;z=!1},tryToClaimNextHydratableInstance:function(a){if(z){var d=u;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;z=!1;y=a;return}b(y,u)}y=a;u=k(d)}else a.effectTag|=2,z=!1,y=a}},prepareToHydrateHostInstance:function(a,b,c){b=q(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return v(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==
  y)return!1;if(!z)return d(a),z=!0,!1;var c=a.type;if(5!==a.tag||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=u;c;)b(a,c),c=h(c);d(a);u=y?h(a.stateNode):null;return!0}}}
  function kf(a){function b(a){Qb=ja=!0;var b=a.stateNode;b.current===a?E("177"):void 0;b.isReadyForCommit=!1;id.current=null;if(1<a.effectTag)if(null!==a.lastEffect){a.lastEffect.nextEffect=a;var c=a.firstEffect}else c=a;else c=a.firstEffect;yg();for(t=c;null!==t;){var d=!1,e=void 0;try{for(;null!==t;){var f=t.effectTag;f&16&&zg(t);if(f&128){var g=t.alternate;null!==g&&Ag(g)}switch(f&-242){case 2:Ne(t);t.effectTag&=-3;break;case 6:Ne(t);t.effectTag&=-3;Oe(t.alternate,t);break;case 4:Oe(t.alternate,
  t);break;case 8:Sc=!0,Bg(t),Sc=!1}t=t.nextEffect}}catch(Tc){d=!0,e=Tc}d&&(null===t?E("178"):void 0,h(t,e),null!==t&&(t=t.nextEffect))}Cg();b.current=a;for(t=c;null!==t;){c=!1;d=void 0;try{for(;null!==t;){var k=t.effectTag;k&36&&Dg(t.alternate,t);k&128&&Eg(t);if(k&64)switch(e=t,f=void 0,null!==R&&(f=R.get(e),R["delete"](e),null==f&&null!==e.alternate&&(e=e.alternate,f=R.get(e),R["delete"](e))),null==f?E("184"):void 0,e.tag){case 2:e.stateNode.componentDidCatch(f.error,{componentStack:f.componentStack});
  break;case 3:null===ca&&(ca=f.error);break;default:E("157")}var Qc=t.nextEffect;t.nextEffect=null;t=Qc}}catch(Tc){c=!0,d=Tc}c&&(null===t?E("178"):void 0,h(t,d),null!==t&&(t=t.nextEffect))}ja=Qb=!1;"function"===typeof De&&De(a.stateNode);ha&&(ha.forEach(G),ha=null);null!==ca&&(a=ca,ca=null,Ob(a));b=b.current.expirationTime;0===b&&(qa=R=null);return b}function c(a){for(;;){var b=Fg(a.alternate,a,H),c=a["return"],d=a.sibling;var e=a;if(2147483647===H||2147483647!==e.expirationTime){if(2!==e.tag&&3!==
  e.tag)var f=0;else f=e.updateQueue,f=null===f?0:f.expirationTime;for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f}if(null!==b)return b;null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;
  if(null!==c)a=c;else{a.stateNode.isReadyForCommit=!0;break}}return null}function d(a){var b=rg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function e(a){var b=Gg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function f(a){if(null!==R){if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=k(F)?e(F):d(F);else for(;null!==F&&!A();)F=k(F)?e(F):d(F)}else if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=d(F);else for(;null!==F&&!A();)F=d(F)}function g(a,b){ja?E("243"):void 0;ja=!0;a.isReadyForCommit=
  !1;if(a!==ra||b!==H||null===F){for(;-1<he;)ge[he]=null,he--;je=D;ie.current=D;X.current=!1;x();ra=a;H=b;F=se(ra.current,null,b)}var c=!1,d=null;try{f(b)}catch(Rc){c=!0,d=Rc}for(;c;){if(eb){ca=d;break}var g=F;if(null===g)eb=!0;else{var k=h(g,d);null===k?E("183"):void 0;if(!eb){try{c=k;d=b;for(k=c;null!==g;){switch(g.tag){case 2:ne(g);break;case 5:qg(g);break;case 3:p(g);break;case 4:p(g)}if(g===k||g.alternate===k)break;g=g["return"]}F=e(c);f(d)}catch(Rc){c=!0;d=Rc;continue}break}}}b=ca;eb=ja=!1;ca=
  null;null!==b&&Ob(b);return a.isReadyForCommit?a.current.alternate:null}function h(a,b){var c=id.current=null,d=!1,e=!1,f=null;if(3===a.tag)c=a,q(a)&&(eb=!0);else for(var g=a["return"];null!==g&&null===c;){2===g.tag?"function"===typeof g.stateNode.componentDidCatch&&(d=!0,f=jd(g),c=g,e=!0):3===g.tag&&(c=g);if(q(g)){if(Sc||null!==ha&&(ha.has(g)||null!==g.alternate&&ha.has(g.alternate)))return null;c=null;e=!1}g=g["return"]}if(null!==c){null===qa&&(qa=new Set);qa.add(c);var h="";g=a;do{a:switch(g.tag){case 0:case 1:case 2:case 5:var k=
  g._debugOwner,Qc=g._debugSource;var m=jd(g);var n=null;k&&(n=jd(k));k=Qc;m="\n    in "+(m||"Unknown")+(k?" (at "+k.fileName.replace(/^.*[\\\/]/,"")+":"+k.lineNumber+")":n?" (created by "+n+")":"");break a;default:m=""}h+=m;g=g["return"]}while(g);g=h;a=jd(a);null===R&&(R=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};R.set(c,b);try{var p=b.error;p&&p.suppressReactErrorLogging||console.error(p)}catch(Vc){Vc&&
  Vc.suppressReactErrorLogging||console.error(Vc)}Qb?(null===ha&&(ha=new Set),ha.add(c)):G(c);return c}null===ca&&(ca=b);return null}function k(a){return null!==R&&(R.has(a)||null!==a.alternate&&R.has(a.alternate))}function q(a){return null!==qa&&(qa.has(a)||null!==a.alternate&&qa.has(a.alternate))}function v(){return 20*(((I()+100)/20|0)+1)}function y(a){return 0!==ka?ka:ja?Qb?1:H:!Hg||a.internalContextTag&1?v():1}function u(a,b){return z(a,b,!1)}function z(a,b){for(;null!==a;){if(0===a.expirationTime||
  a.expirationTime>b)a.expirationTime=b;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>b)&&(a.alternate.expirationTime=b);if(null===a["return"])if(3===a.tag){var c=a.stateNode;!ja&&c===ra&&b<H&&(F=ra=null,H=0);var d=c,e=b;Rb>Ig&&E("185");if(null===d.nextScheduledRoot)d.remainingExpirationTime=e,null===O?(sa=O=d,d.nextScheduledRoot=d):(O=O.nextScheduledRoot=d,O.nextScheduledRoot=sa);else{var f=d.remainingExpirationTime;if(0===f||e<f)d.remainingExpirationTime=e}Fa||(la?
  Sb&&(ma=d,na=1,m(ma,na)):1===e?w(1,null):L(e));!ja&&c===ra&&b<H&&(F=ra=null,H=0)}else break;a=a["return"]}}function G(a){z(a,1,!0)}function I(){return Uc=((Wc()-Pe)/10|0)+2}function L(a){if(0!==Tb){if(a>Tb)return;Jg(Xc)}var b=Wc()-Pe;Tb=a;Xc=Kg(J,{timeout:10*(a-2)-b})}function N(){var a=0,b=null;if(null!==O)for(var c=O,d=sa;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===O?E("244"):void 0;if(d===d.nextScheduledRoot){sa=O=d.nextScheduledRoot=null;break}else if(d===sa)sa=e=d.nextScheduledRoot,
  O.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===O){O=c;O.nextScheduledRoot=sa;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===O)break;c=d;d=d.nextScheduledRoot}}c=ma;null!==c&&c===b?Rb++:Rb=0;ma=b;na=a}function J(a){w(0,a)}function w(a,b){fb=b;for(N();null!==ma&&0!==na&&(0===a||na<=a)&&!Yc;)m(ma,na),N();null!==fb&&(Tb=0,Xc=-1);0!==na&&L(na);fb=null;Yc=!1;Rb=0;if(Ub)throw a=Zc,Zc=
  null,Ub=!1,a;}function m(a,c){Fa?E("245"):void 0;Fa=!0;if(c<=I()){var d=a.finishedWork;null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(a.remainingExpirationTime=b(d)))}else d=a.finishedWork,null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(A()?a.finishedWork=d:a.remainingExpirationTime=b(d)));Fa=!1}function A(){return null===fb||fb.timeRemaining()>Lg?!1:Yc=!0}function Ob(a){null===ma?E("246"):
  void 0;ma.remainingExpirationTime=0;Ub||(Ub=!0,Zc=a)}var r=hf(a),n=jf(a),p=r.popHostContainer,qg=r.popHostContext,x=r.resetHostContainer,Me=df(a,r,n,u,y),rg=Me.beginWork,Gg=Me.beginFailedWork,Fg=ef(a,r,n).completeWork;r=ff(a,h);var zg=r.commitResetTextContent,Ne=r.commitPlacement,Bg=r.commitDeletion,Oe=r.commitWork,Dg=r.commitLifeCycles,Eg=r.commitAttachRef,Ag=r.commitDetachRef,Wc=a.now,Kg=a.scheduleDeferredCallback,Jg=a.cancelDeferredCallback,Hg=a.useSyncScheduling,yg=a.prepareForCommit,Cg=a.resetAfterCommit,
  Pe=Wc(),Uc=2,ka=0,ja=!1,F=null,ra=null,H=0,t=null,R=null,qa=null,ha=null,ca=null,eb=!1,Qb=!1,Sc=!1,sa=null,O=null,Tb=0,Xc=-1,Fa=!1,ma=null,na=0,Yc=!1,Ub=!1,Zc=null,fb=null,la=!1,Sb=!1,Ig=1E3,Rb=0,Lg=1;return{computeAsyncExpiration:v,computeExpirationForFiber:y,scheduleWork:u,batchedUpdates:function(a,b){var c=la;la=!0;try{return a(b)}finally{(la=c)||Fa||w(1,null)}},unbatchedUpdates:function(a){if(la&&!Sb){Sb=!0;try{return a()}finally{Sb=!1}}return a()},flushSync:function(a){var b=la;la=!0;try{a:{var c=
  ka;ka=1;try{var d=a();break a}finally{ka=c}d=void 0}return d}finally{la=b,Fa?E("187"):void 0,w(1,null)}},deferredUpdates:function(a){var b=ka;ka=v();try{return a()}finally{ka=b}}}}
  function lf(a){function b(a){a=od(a);return null===a?null:a.stateNode}var c=a.getPublicInstance;a=kf(a);var d=a.computeAsyncExpiration,e=a.computeExpirationForFiber,f=a.scheduleWork;return{createContainer:function(a,b){var c=new Y(3,null,0);a={current:c,containerInfo:a,pendingChildren:null,remainingExpirationTime:0,isReadyForCommit:!1,finishedWork:null,context:null,pendingContext:null,hydrate:b,nextScheduledRoot:null};return c.stateNode=a},updateContainer:function(a,b,c,q){var g=b.current;if(c){c=
  c._reactInternalFiber;var h;b:{2===kd(c)&&2===c.tag?void 0:E("170");for(h=c;3!==h.tag;){if(le(h)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}(h=h["return"])?void 0:E("171")}h=h.stateNode.context}c=le(c)?pe(c,h):h}else c=D;null===b.context?b.context=c:b.pendingContext=c;b=q;b=void 0===b?null:b;q=null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent?d():e(g);He(g,{expirationTime:q,partialState:{element:a},callback:b,isReplace:!1,isForced:!1,
  nextCallback:null,next:null});f(g,q)},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:b,findHostInstanceWithNoPortals:function(a){a=pd(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var c=a.findFiberByHostInstance;return Ce(B({},
  a,{findHostInstanceByFiber:function(a){return b(a)},findFiberByHostInstance:function(a){return c?c(a):null}}))}}}var mf=Object.freeze({default:lf}),nf=mf&&lf||mf,of=nf["default"]?nf["default"]:nf;function pf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Ue,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}var qf="object"===typeof performance&&"function"===typeof performance.now,rf=void 0;rf=qf?function(){return performance.now()}:function(){return Date.now()};
  var sf=void 0,tf=void 0;
  if(l.canUseDOM)if("function"!==typeof requestIdleCallback||"function"!==typeof cancelIdleCallback){var uf=null,vf=!1,wf=-1,xf=!1,yf=0,zf=33,Af=33,Bf;Bf=qf?{didTimeout:!1,timeRemaining:function(){var a=yf-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=yf-Date.now();return 0<a?a:0}};var Cf="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){if(a.source===window&&a.data===Cf){vf=!1;a=rf();if(0>=yf-a)if(-1!==wf&&wf<=
  a)Bf.didTimeout=!0;else{xf||(xf=!0,requestAnimationFrame(Df));return}else Bf.didTimeout=!1;wf=-1;a=uf;uf=null;null!==a&&a(Bf)}},!1);var Df=function(a){xf=!1;var b=a-yf+Af;b<Af&&zf<Af?(8>b&&(b=8),Af=b<zf?zf:b):zf=b;yf=a+Af;vf||(vf=!0,window.postMessage(Cf,"*"))};sf=function(a,b){uf=a;null!=b&&"number"===typeof b.timeout&&(wf=rf()+b.timeout);xf||(xf=!0,requestAnimationFrame(Df));return 0};tf=function(){uf=null;vf=!1;wf=-1}}else sf=window.requestIdleCallback,tf=window.cancelIdleCallback;else sf=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity}})})},
  tf=function(a){clearTimeout(a)};var Ef=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Ff={},Gf={};
  function Hf(a){if(Gf.hasOwnProperty(a))return!0;if(Ff.hasOwnProperty(a))return!1;if(Ef.test(a))return Gf[a]=!0;Ff[a]=!0;return!1}
  function If(a,b,c){var d=wa(b);if(d&&va(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?Jf(a,b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,""+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,""):a.setAttribute(b,""+c))}else Kf(a,b,va(b,c)?c:null)}
  function Kf(a,b,c){Hf(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,""+c))}function Jf(a,b){var c=wa(b);c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:"":a.removeAttribute(c.attributeName):a.removeAttribute(b)}
  function Lf(a,b){var c=b.value,d=b.checked;return B({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?d:a._wrapperState.initialChecked})}function Mf(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}
  function Nf(a,b){b=b.checked;null!=b&&If(a,"checked",b)}function Of(a,b){Nf(a,b);var c=b.value;if(null!=c)if(0===c&&""===a.value)a.value="0";else if("number"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==""+b.defaultValue&&(a.defaultValue=""+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
  function Pf(a,b){switch(b.type){case "submit":case "reset":break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":a.value="";a.value=a.defaultValue;break;default:a.value=a.value}b=a.name;""!==b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b)}function Qf(a){var b="";aa.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a)});return b}
  function Rf(a,b){a=B({children:void 0},b);if(b=Qf(b.children))a.children=b;return a}function Sf(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
  function Tf(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}}function Uf(a,b){null!=b.dangerouslySetInnerHTML?E("91"):void 0;return B({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Vf(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?E("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:E("93"),b=b[0]),c=""+b),null==c&&(c=""));a._wrapperState={initialValue:""+c}}
  function Wf(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)}function Xf(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var Yf={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
  function Zf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function $f(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Zf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
  var ag=void 0,bg=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Yf.svg||"innerHTML"in a)a.innerHTML=b;else{ag=ag||document.createElement("div");ag.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e";for(b=ag.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
  function cg(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
  var dg={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,
  stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},eg=["Webkit","ms","Moz","O"];Object.keys(dg).forEach(function(a){eg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dg[b]=dg[a]})});
  function fg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||dg.hasOwnProperty(e)&&dg[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var gg=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
  function hg(a,b,c){b&&(gg[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?E("137",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?E("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:E("61")),null!=b.style&&"object"!==typeof b.style?E("62",c()):void 0)}
  function ig(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var jg=Yf.html,kg=C.thatReturns("");
  function lg(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Hd(a);b=Sa[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||("topScroll"===e?wd("topScroll","scroll",a):"topFocus"===e||"topBlur"===e?(wd("topFocus","focus",a),wd("topBlur","blur",a),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(yc("cancel",!0)&&wd("topCancel","cancel",a),c.topCancel=!0):"topClose"===e?(yc("close",!0)&&wd("topClose","close",a),c.topClose=!0):Dd.hasOwnProperty(e)&&U(e,Dd[e],a),c[e]=!0)}}
  var mg={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",
  topWaiting:"waiting"};function ng(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;d===jg&&(d=Zf(a));d===jg?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function og(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}
  function pg(a,b,c,d){var e=ig(b,c);switch(b){case "iframe":case "object":U("topLoad","load",a);var f=c;break;case "video":case "audio":for(f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);f=c;break;case "source":U("topError","error",a);f=c;break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);f=c;break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);f=c;break;case "details":U("topToggle","toggle",a);f=c;break;case "input":Mf(a,c);f=Lf(a,c);U("topInvalid","invalid",a);
  lg(d,"onChange");break;case "option":f=Rf(a,c);break;case "select":Tf(a,c);f=B({},c,{value:void 0});U("topInvalid","invalid",a);lg(d,"onChange");break;case "textarea":Vf(a,c);f=Uf(a,c);U("topInvalid","invalid",a);lg(d,"onChange");break;default:f=c}hg(b,f,kg);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===h?fg(a,k,kg):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&bg(a,k)):"children"===h?"string"===typeof k?("textarea"!==b||""!==k)&&cg(a,k):"number"===typeof k&&cg(a,
  ""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(Ra.hasOwnProperty(h)?null!=k&&lg(d,h):e?Kf(a,h,k):null!=k&&If(a,h,k))}switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "option":null!=c.value&&a.setAttribute("value",c.value);break;case "select":a.multiple=!!c.multiple;b=c.value;null!=b?Sf(a,!!c.multiple,b,!1):null!=c.defaultValue&&Sf(a,!!c.multiple,c.defaultValue,!0);break;default:"function"===typeof f.onClick&&(a.onclick=
  C)}}
  function sg(a,b,c,d,e){var f=null;switch(b){case "input":c=Lf(a,c);d=Lf(a,d);f=[];break;case "option":c=Rf(a,c);d=Rf(a,d);f=[];break;case "select":c=B({},c,{value:void 0});d=B({},d,{value:void 0});f=[];break;case "textarea":c=Uf(a,c);d=Uf(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=C)}hg(b,d,kg);var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if("style"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]=
  "");else"dangerouslySetInnerHTML"!==g&&"children"!==g&&"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&"autoFocus"!==g&&(Ra.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if("style"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]="");for(h in k)k.hasOwnProperty(h)&&b[h]!==k[h]&&(a||(a={}),a[h]=k[h])}else a||(f||(f=[]),f.push(g,a)),a=k;else"dangerouslySetInnerHTML"===
  g?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,""+k)):"children"===g?b===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(g,""+k):"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&(Ra.hasOwnProperty(g)?(null!=k&&lg(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k))}a&&(f=f||[]).push("style",a);return f}
  function tg(a,b,c,d,e){"input"===c&&"radio"===e.type&&null!=e.name&&Nf(a,e);ig(c,d);d=ig(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?fg(a,h,kg):"dangerouslySetInnerHTML"===g?bg(a,h):"children"===g?cg(a,h):d?null!=h?Kf(a,g,h):a.removeAttribute(g):null!=h?If(a,g,h):Jf(a,g)}switch(c){case "input":Of(a,e);break;case "textarea":Wf(a,e);break;case "select":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?Sf(a,
  !!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?Sf(a,!!e.multiple,e.defaultValue,!0):Sf(a,!!e.multiple,e.multiple?[]:"",!1))}}
  function ug(a,b,c,d,e){switch(b){case "iframe":case "object":U("topLoad","load",a);break;case "video":case "audio":for(var f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);break;case "source":U("topError","error",a);break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);break;case "details":U("topToggle","toggle",a);break;case "input":Mf(a,c);U("topInvalid","invalid",a);lg(e,"onChange");break;case "select":Tf(a,c);
  U("topInvalid","invalid",a);lg(e,"onChange");break;case "textarea":Vf(a,c),U("topInvalid","invalid",a),lg(e,"onChange")}hg(b,c,kg);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):Ra.hasOwnProperty(g)&&null!=f&&lg(e,g));switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "select":case "option":break;default:"function"===typeof c.onClick&&
  (a.onclick=C)}return d}function vg(a,b){return a.nodeValue!==b}
  var wg=Object.freeze({createElement:ng,createTextNode:og,setInitialProperties:pg,diffProperties:sg,updateProperties:tg,diffHydratedProperties:ug,diffHydratedText:vg,warnForUnmatchedText:function(){},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,b,c){switch(b){case "input":Of(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=
  c.parentNode;c=c.querySelectorAll("input[name\x3d"+JSON.stringify(""+b)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=rb(d);e?void 0:E("90");Cc(d);Of(d,e)}}}break;case "textarea":Wf(a,c);break;case "select":b=c.value,null!=b&&Sf(a,!!c.multiple,b,!1)}}});nc.injectFiberControlledHostComponent(wg);var xg=null,Mg=null;function Ng(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}
  function Og(a){a=a?9===a.nodeType?a.documentElement:a.firstChild:null;return!(!a||1!==a.nodeType||!a.hasAttribute("data-reactroot"))}
  var Z=of({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:$f(null,"");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=$f(a,b)}return a},getChildHostContext:function(a,b){return $f(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){xg=td;var a=da();if(Kd(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();
  if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(z){b=null;break a}var f=0,g=-1,h=-1,k=0,q=0,v=a,y=null;b:for(;;){for(var u;;){v!==b||0!==d&&3!==v.nodeType||(g=f+d);v!==e||0!==c&&3!==v.nodeType||(h=f+c);3===v.nodeType&&(f+=v.nodeValue.length);if(null===(u=v.firstChild))break;y=v;v=u}for(;;){if(v===a)break b;y===b&&++k===d&&(g=f);y===e&&++q===c&&(h=f);if(null!==(u=v.nextSibling))break;v=y;y=v.parentNode}v=u}b=-1===g||-1===h?null:
  {start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;Mg={focusedElem:a,selectionRange:b};ud(!1)},resetAfterCommit:function(){var a=Mg,b=da(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&fa(document.documentElement,c)){if(Kd(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Eb()].length;a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>
  d&&(e=d,d=a,a=e);e=Jd(c,a);var f=Jd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g))}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});ia(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=
  a.top}Mg=null;ud(xg);xg=null},createInstance:function(a,b,c,d,e){a=ng(a,b,c,d);a[Q]=e;a[ob]=b;return a},appendInitialChild:function(a,b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){pg(a,b,c,d);a:{switch(b){case "button":case "input":case "select":case "textarea":a=!!c.autoFocus;break a}a=!1}return a},prepareUpdate:function(a,b,c,d,e){return sg(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===
  typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&"string"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=og(a,b);a[Q]=d;return a},now:rf,mutation:{commitMount:function(a){a.focus()},commitUpdate:function(a,b,c,d,e){a[ob]=e;tg(a,b,c,d,e)},resetTextContent:function(a){a.textContent=""},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,
  b){8===a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b)}},hydration:{canHydrateInstance:function(a,b){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,
  b){return""===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[Q]=f;a[ob]=c;return ug(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[Q]=c;return vg(a,b)},didNotMatchHydratedContainerTextInstance:function(){},didNotMatchHydratedTextInstance:function(){},
  didNotHydrateContainerInstance:function(){},didNotHydrateInstance:function(){},didNotFindHydratableContainerInstance:function(){},didNotFindHydratableContainerTextInstance:function(){},didNotFindHydratableInstance:function(){},didNotFindHydratableTextInstance:function(){}},scheduleDeferredCallback:sf,cancelDeferredCallback:tf,useSyncScheduling:!0});rc=Z.batchedUpdates;
  function Pg(a,b,c,d,e){Ng(c)?void 0:E("200");var f=c._reactRootContainer;if(f)Z.updateContainer(b,f,a,e);else{d=d||Og(c);if(!d)for(f=void 0;f=c.lastChild;)c.removeChild(f);var g=Z.createContainer(c,d);f=c._reactRootContainer=g;Z.unbatchedUpdates(function(){Z.updateContainer(b,g,a,e)})}return Z.getPublicRootInstance(f)}function Qg(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Ng(b)?void 0:E("200");return pf(a,b,null,c)}
  function Rg(a,b){this._reactRootContainer=Z.createContainer(a,b)}Rg.prototype.render=function(a,b){Z.updateContainer(a,this._reactRootContainer,null,b)};Rg.prototype.unmount=function(a){Z.updateContainer(null,this._reactRootContainer,null,a)};
  var Sg={createPortal:Qg,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(b)return Z.findHostInstance(b);"function"===typeof a.render?E("188"):E("213",Object.keys(a))},hydrate:function(a,b,c){return Pg(null,a,b,!0,c)},render:function(a,b,c){return Pg(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?E("38"):void 0;return Pg(a,b,c,!1,d)},unmountComponentAtNode:function(a){Ng(a)?void 0:
  E("40");return a._reactRootContainer?(Z.unbatchedUpdates(function(){Pg(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:Qg,unstable_batchedUpdates:tc,unstable_deferredUpdates:Z.deferredUpdates,flushSync:Z.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:mb,EventPluginRegistry:Va,EventPropagators:Cb,ReactControlledComponent:qc,ReactDOMComponentTree:sb,ReactDOMEventListener:xd}};
  Z.injectIntoDevTools({findFiberByHostInstance:pb,bundleType:0,version:"16.2.0",rendererPackageName:"react-dom"});var Tg=Object.freeze({default:Sg}),Ug=Tg&&Sg||Tg;module.exports=Ug["default"]?Ug["default"]:Ug;

  },{"fbjs/lib/EventListener":710,"fbjs/lib/ExecutionEnvironment":711,"fbjs/lib/containsNode":714,"fbjs/lib/emptyFunction":715,"fbjs/lib/emptyObject":716,"fbjs/lib/focusNode":717,"fbjs/lib/getActiveElement":718,"fbjs/lib/shallowEqual":724,"object-assign":822,"react":1253}],1157:[function(require,module,exports){
  'use strict';

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
    ) {
      return;
    }
    if ("production" !== 'production') {
      // This branch is unreachable because this function is only called
      // in production, but the condition is true only in development.
      // Therefore if the branch is still here, dead code elimination wasn't
      // properly applied.
      // Don't change the message. React DevTools relies on it. Also make sure
      // this message doesn't occur elsewhere in this function, or it will cause
      // a false positive.
      throw new Error('^_^');
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }

  if ("production" === 'production') {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = require('./cjs/react-dom.production.min.js');
  } else {
    module.exports = require('./cjs/react-dom.development.js');
  }

  },{"./cjs/react-dom.development.js":1155,"./cjs/react-dom.production.min.js":1156}],1158:[function(require,module,exports){
  arguments[4][824][0].apply(exports,arguments)
  },{"./lib/ReactPropTypesSecret":1159,"dup":824,"fbjs/lib/invariant":721,"fbjs/lib/warning":725}],1159:[function(require,module,exports){
  arguments[4][828][0].apply(exports,arguments)
  },{"dup":828}],1160:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.createProvider = createProvider;

  var _react = require('react');

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _PropTypes = require('../utils/PropTypes');

  var _warning = require('../utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var didWarnAboutReceivingStore = false;
  function warnAboutReceivingStore() {
    if (didWarnAboutReceivingStore) {
      return;
    }
    didWarnAboutReceivingStore = true;

    (0, _warning2.default)('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
  }

  function createProvider() {
    var _Provider$childContex;

    var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
    var subKey = arguments[1];

    var subscriptionKey = subKey || storeKey + 'Subscription';

    var Provider = function (_Component) {
      _inherits(Provider, _Component);

      Provider.prototype.getChildContext = function getChildContext() {
        var _ref;

        return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
      };

      function Provider(props, context) {
        _classCallCheck(this, Provider);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this[storeKey] = props.store;
        return _this;
      }

      Provider.prototype.render = function render() {
        return _react.Children.only(this.props.children);
      };

      return Provider;
    }(_react.Component);

    if ("production" !== 'production') {
      Provider.prototype.componentWillReceiveProps = function (nextProps) {
        if (this[storeKey] !== nextProps.store) {
          warnAboutReceivingStore();
        }
      };
    }

    Provider.propTypes = {
      store: _PropTypes.storeShape.isRequired,
      children: _propTypes2.default.element.isRequired
    };
    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = _PropTypes.storeShape.isRequired, _Provider$childContex[subscriptionKey] = _PropTypes.subscriptionShape, _Provider$childContex);

    return Provider;
  }

  exports.default = createProvider();
  },{"../utils/PropTypes":1170,"../utils/warning":1174,"prop-types":1178,"react":1253}],1161:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.default = connectAdvanced;

  var _hoistNonReactStatics = require('hoist-non-react-statics');

  var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

  var _invariant = require('invariant');

  var _invariant2 = _interopRequireDefault(_invariant);

  var _react = require('react');

  var _Subscription = require('../utils/Subscription');

  var _Subscription2 = _interopRequireDefault(_Subscription);

  var _PropTypes = require('../utils/PropTypes');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  var hotReloadingVersion = 0;
  var dummyState = {};
  function noop() {}
  function makeSelectorStateful(sourceSelector, store) {
    // wrap the selector in an object that tracks its results between runs.
    var selector = {
      run: function runComponentSelector(props) {
        try {
          var nextProps = sourceSelector(store.getState(), props);
          if (nextProps !== selector.props || selector.error) {
            selector.shouldComponentUpdate = true;
            selector.props = nextProps;
            selector.error = null;
          }
        } catch (error) {
          selector.shouldComponentUpdate = true;
          selector.error = error;
        }
      }
    };

    return selector;
  }

  function connectAdvanced(
  /*
    selectorFactory is a func that is responsible for returning the selector function used to
    compute new props from state, props, and dispatch. For example:
       export default connectAdvanced((dispatch, options) => (state, props) => ({
        thing: state.things[props.thingId],
        saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
      }))(YourComponent)
     Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
    outside of their selector as an optimization. Options passed to connectAdvanced are passed to
    the selectorFactory, along with displayName and WrappedComponent, as the second argument.
     Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
    props. Do not use connectAdvanced directly without memoizing results between calls to your
    selector, otherwise the Connect component will re-render on every state or props change.
  */
  selectorFactory) {
    var _contextTypes, _childContextTypes;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$getDisplayName = _ref.getDisplayName,
        getDisplayName = _ref$getDisplayName === undefined ? function (name) {
      return 'ConnectAdvanced(' + name + ')';
    } : _ref$getDisplayName,
        _ref$methodName = _ref.methodName,
        methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
        _ref$renderCountProp = _ref.renderCountProp,
        renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
        _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
        shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
        _ref$storeKey = _ref.storeKey,
        storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
        _ref$withRef = _ref.withRef,
        withRef = _ref$withRef === undefined ? false : _ref$withRef,
        connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

    var subscriptionKey = storeKey + 'Subscription';
    var version = hotReloadingVersion++;

    var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = _PropTypes.storeShape, _contextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _contextTypes);
    var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _childContextTypes);

    return function wrapWithConnect(WrappedComponent) {
      (0, _invariant2.default)(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + (methodName + '. Instead received ' + JSON.stringify(WrappedComponent)));

      var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

      var displayName = getDisplayName(wrappedComponentName);

      var selectorFactoryOptions = _extends({}, connectOptions, {
        getDisplayName: getDisplayName,
        methodName: methodName,
        renderCountProp: renderCountProp,
        shouldHandleStateChanges: shouldHandleStateChanges,
        storeKey: storeKey,
        withRef: withRef,
        displayName: displayName,
        wrappedComponentName: wrappedComponentName,
        WrappedComponent: WrappedComponent
      });

      var Connect = function (_Component) {
        _inherits(Connect, _Component);

        function Connect(props, context) {
          _classCallCheck(this, Connect);

          var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

          _this.version = version;
          _this.state = {};
          _this.renderCount = 0;
          _this.store = props[storeKey] || context[storeKey];
          _this.propsMode = Boolean(props[storeKey]);
          _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

          (0, _invariant2.default)(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

          _this.initSelector();
          _this.initSubscription();
          return _this;
        }

        Connect.prototype.getChildContext = function getChildContext() {
          var _ref2;

          // If this component received store from props, its subscription should be transparent
          // to any descendants receiving store+subscription from context; it passes along
          // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
          // Connect to control ordering of notifications to flow top-down.
          var subscription = this.propsMode ? null : this.subscription;
          return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
        };

        Connect.prototype.componentDidMount = function componentDidMount() {
          if (!shouldHandleStateChanges) return;

          // componentWillMount fires during server side rendering, but componentDidMount and
          // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
          // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
          // To handle the case where a child component may have triggered a state change by
          // dispatching an action in its componentWillMount, we have to re-run the select and maybe
          // re-render.
          this.subscription.trySubscribe();
          this.selector.run(this.props);
          if (this.selector.shouldComponentUpdate) this.forceUpdate();
        };

        Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
          this.selector.run(nextProps);
        };

        Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
          return this.selector.shouldComponentUpdate;
        };

        Connect.prototype.componentWillUnmount = function componentWillUnmount() {
          if (this.subscription) this.subscription.tryUnsubscribe();
          this.subscription = null;
          this.notifyNestedSubs = noop;
          this.store = null;
          this.selector.run = noop;
          this.selector.shouldComponentUpdate = false;
        };

        Connect.prototype.getWrappedInstance = function getWrappedInstance() {
          (0, _invariant2.default)(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
          return this.wrappedInstance;
        };

        Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
          this.wrappedInstance = ref;
        };

        Connect.prototype.initSelector = function initSelector() {
          var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
          this.selector = makeSelectorStateful(sourceSelector, this.store);
          this.selector.run(this.props);
        };

        Connect.prototype.initSubscription = function initSubscription() {
          if (!shouldHandleStateChanges) return;

          // parentSub's source should match where store came from: props vs. context. A component
          // connected to the store via props shouldn't use subscription from context, or vice versa.
          var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
          this.subscription = new _Subscription2.default(this.store, parentSub, this.onStateChange.bind(this));

          // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
          // the middle of the notification loop, where `this.subscription` will then be null. An
          // extra null check every change can be avoided by copying the method onto `this` and then
          // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
          // listeners logic is changed to not call listeners that have been unsubscribed in the
          // middle of the notification loop.
          this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
        };

        Connect.prototype.onStateChange = function onStateChange() {
          this.selector.run(this.props);

          if (!this.selector.shouldComponentUpdate) {
            this.notifyNestedSubs();
          } else {
            this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
            this.setState(dummyState);
          }
        };

        Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
          // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
          // needs to notify nested subs. Once called, it unimplements itself until further state
          // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
          // a boolean check every time avoids an extra method call most of the time, resulting
          // in some perf boost.
          this.componentDidUpdate = undefined;
          this.notifyNestedSubs();
        };

        Connect.prototype.isSubscribed = function isSubscribed() {
          return Boolean(this.subscription) && this.subscription.isSubscribed();
        };

        Connect.prototype.addExtraProps = function addExtraProps(props) {
          if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
          // make a shallow copy so that fields added don't leak to the original selector.
          // this is especially important for 'ref' since that's a reference back to the component
          // instance. a singleton memoized selector would then be holding a reference to the
          // instance, preventing the instance from being garbage collected, and that would be bad
          var withExtras = _extends({}, props);
          if (withRef) withExtras.ref = this.setWrappedInstance;
          if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
          if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
          return withExtras;
        };

        Connect.prototype.render = function render() {
          var selector = this.selector;
          selector.shouldComponentUpdate = false;

          if (selector.error) {
            throw selector.error;
          } else {
            return (0, _react.createElement)(WrappedComponent, this.addExtraProps(selector.props));
          }
        };

        return Connect;
      }(_react.Component);

      Connect.WrappedComponent = WrappedComponent;
      Connect.displayName = displayName;
      Connect.childContextTypes = childContextTypes;
      Connect.contextTypes = contextTypes;
      Connect.propTypes = contextTypes;

      if ("production" !== 'production') {
        Connect.prototype.componentWillUpdate = function componentWillUpdate() {
          var _this2 = this;

          // We are hot reloading!
          if (this.version !== version) {
            this.version = version;
            this.initSelector();

            // If any connected descendants don't hot reload (and resubscribe in the process), their
            // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
            // listeners, this does mean that the old versions of connected descendants will still be
            // notified of state changes; however, their onStateChange function is a no-op so this
            // isn't a huge deal.
            var oldListeners = [];

            if (this.subscription) {
              oldListeners = this.subscription.listeners.get();
              this.subscription.tryUnsubscribe();
            }
            this.initSubscription();
            if (shouldHandleStateChanges) {
              this.subscription.trySubscribe();
              oldListeners.forEach(function (listener) {
                return _this2.subscription.listeners.subscribe(listener);
              });
            }
          }
        };
      }

      return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
    };
  }
  },{"../utils/PropTypes":1170,"../utils/Subscription":1171,"hoist-non-react-statics":746,"invariant":748,"react":1253}],1162:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.createConnect = createConnect;

  var _connectAdvanced = require('../components/connectAdvanced');

  var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

  var _shallowEqual = require('../utils/shallowEqual');

  var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

  var _mapDispatchToProps = require('./mapDispatchToProps');

  var _mapDispatchToProps2 = _interopRequireDefault(_mapDispatchToProps);

  var _mapStateToProps = require('./mapStateToProps');

  var _mapStateToProps2 = _interopRequireDefault(_mapStateToProps);

  var _mergeProps = require('./mergeProps');

  var _mergeProps2 = _interopRequireDefault(_mergeProps);

  var _selectorFactory = require('./selectorFactory');

  var _selectorFactory2 = _interopRequireDefault(_selectorFactory);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  /*
    connect is a facade over connectAdvanced. It turns its args into a compatible
    selectorFactory, which has the signature:

      (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps

    connect passes its args to connectAdvanced as options, which will in turn pass them to
    selectorFactory each time a Connect component instance is instantiated or hot reloaded.

    selectorFactory returns a final props selector from its mapStateToProps,
    mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
    mergePropsFactories, and pure args.

    The resulting final props selector is called by the Connect component instance whenever
    it receives new props or store state.
   */

  function match(arg, factories, name) {
    for (var i = factories.length - 1; i >= 0; i--) {
      var result = factories[i](arg);
      if (result) return result;
    }

    return function (dispatch, options) {
      throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
    };
  }

  function strictEqual(a, b) {
    return a === b;
  }

  // createConnect with default args builds the 'official' connect behavior. Calling it with
  // different options opens up some testing and extensibility scenarios
  function createConnect() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$connectHOC = _ref.connectHOC,
        connectHOC = _ref$connectHOC === undefined ? _connectAdvanced2.default : _ref$connectHOC,
        _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
        mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? _mapStateToProps2.default : _ref$mapStateToPropsF,
        _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
        mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? _mapDispatchToProps2.default : _ref$mapDispatchToPro,
        _ref$mergePropsFactor = _ref.mergePropsFactories,
        mergePropsFactories = _ref$mergePropsFactor === undefined ? _mergeProps2.default : _ref$mergePropsFactor,
        _ref$selectorFactory = _ref.selectorFactory,
        selectorFactory = _ref$selectorFactory === undefined ? _selectorFactory2.default : _ref$selectorFactory;

    return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
      var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
          _ref2$pure = _ref2.pure,
          pure = _ref2$pure === undefined ? true : _ref2$pure,
          _ref2$areStatesEqual = _ref2.areStatesEqual,
          areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
          _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
          areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? _shallowEqual2.default : _ref2$areOwnPropsEqua,
          _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
          areStatePropsEqual = _ref2$areStatePropsEq === undefined ? _shallowEqual2.default : _ref2$areStatePropsEq,
          _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
          areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? _shallowEqual2.default : _ref2$areMergedPropsE,
          extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

      var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
      var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
      var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

      return connectHOC(selectorFactory, _extends({
        // used in error messages
        methodName: 'connect',

        // used to compute Connect's displayName from the wrapped component's displayName.
        getDisplayName: function getDisplayName(name) {
          return 'Connect(' + name + ')';
        },

        // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
        shouldHandleStateChanges: Boolean(mapStateToProps),

        // passed through to selectorFactory
        initMapStateToProps: initMapStateToProps,
        initMapDispatchToProps: initMapDispatchToProps,
        initMergeProps: initMergeProps,
        pure: pure,
        areStatesEqual: areStatesEqual,
        areOwnPropsEqual: areOwnPropsEqual,
        areStatePropsEqual: areStatePropsEqual,
        areMergedPropsEqual: areMergedPropsEqual

      }, extraOptions));
    };
  }

  exports.default = createConnect();
  },{"../components/connectAdvanced":1161,"../utils/shallowEqual":1172,"./mapDispatchToProps":1163,"./mapStateToProps":1164,"./mergeProps":1165,"./selectorFactory":1166}],1163:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
  exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
  exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

  var _redux = require('redux');

  var _wrapMapToProps = require('./wrapMapToProps');

  function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
    return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
  }

  function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
    return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
      return { dispatch: dispatch };
    }) : undefined;
  }

  function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
      return (0, _redux.bindActionCreators)(mapDispatchToProps, dispatch);
    }) : undefined;
  }

  exports.default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
  },{"./wrapMapToProps":1168,"redux":1261}],1164:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
  exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

  var _wrapMapToProps = require('./wrapMapToProps');

  function whenMapStateToPropsIsFunction(mapStateToProps) {
    return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
  }

  function whenMapStateToPropsIsMissing(mapStateToProps) {
    return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
      return {};
    }) : undefined;
  }

  exports.default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
  },{"./wrapMapToProps":1168}],1165:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports.defaultMergeProps = defaultMergeProps;
  exports.wrapMergePropsFunc = wrapMergePropsFunc;
  exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
  exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;

  var _verifyPlainObject = require('../utils/verifyPlainObject');

  var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return _extends({}, ownProps, stateProps, dispatchProps);
  }

  function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch, _ref) {
      var displayName = _ref.displayName,
          pure = _ref.pure,
          areMergedPropsEqual = _ref.areMergedPropsEqual;

      var hasRunOnce = false;
      var mergedProps = void 0;

      return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
        var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

        if (hasRunOnce) {
          if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
        } else {
          hasRunOnce = true;
          mergedProps = nextMergedProps;

          if ("production" !== 'production') (0, _verifyPlainObject2.default)(mergedProps, displayName, 'mergeProps');
        }

        return mergedProps;
      };
    };
  }

  function whenMergePropsIsFunction(mergeProps) {
    return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
  }

  function whenMergePropsIsOmitted(mergeProps) {
    return !mergeProps ? function () {
      return defaultMergeProps;
    } : undefined;
  }

  exports.default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
  },{"../utils/verifyPlainObject":1173}],1166:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
  exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;
  exports.default = finalPropsSelectorFactory;

  var _verifySubselectors = require('./verifySubselectors');

  var _verifySubselectors2 = _interopRequireDefault(_verifySubselectors);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
    return function impureFinalPropsSelector(state, ownProps) {
      return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
    };
  }

  function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
    var areStatesEqual = _ref.areStatesEqual,
        areOwnPropsEqual = _ref.areOwnPropsEqual,
        areStatePropsEqual = _ref.areStatePropsEqual;

    var hasRunAtLeastOnce = false;
    var state = void 0;
    var ownProps = void 0;
    var stateProps = void 0;
    var dispatchProps = void 0;
    var mergedProps = void 0;

    function handleFirstCall(firstState, firstOwnProps) {
      state = firstState;
      ownProps = firstOwnProps;
      stateProps = mapStateToProps(state, ownProps);
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      hasRunAtLeastOnce = true;
      return mergedProps;
    }

    function handleNewPropsAndNewState() {
      stateProps = mapStateToProps(state, ownProps);

      if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleNewProps() {
      if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

      if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleNewState() {
      var nextStateProps = mapStateToProps(state, ownProps);
      var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
      stateProps = nextStateProps;

      if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      return mergedProps;
    }

    function handleSubsequentCalls(nextState, nextOwnProps) {
      var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
      var stateChanged = !areStatesEqual(nextState, state);
      state = nextState;
      ownProps = nextOwnProps;

      if (propsChanged && stateChanged) return handleNewPropsAndNewState();
      if (propsChanged) return handleNewProps();
      if (stateChanged) return handleNewState();
      return mergedProps;
    }

    return function pureFinalPropsSelector(nextState, nextOwnProps) {
      return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
  }

  // TODO: Add more comments

  // If pure is true, the selector returned by selectorFactory will memoize its results,
  // allowing connectAdvanced's shouldComponentUpdate to return false if final
  // props have not changed. If false, the selector will always return a new
  // object and shouldComponentUpdate will always return true.

  function finalPropsSelectorFactory(dispatch, _ref2) {
    var initMapStateToProps = _ref2.initMapStateToProps,
        initMapDispatchToProps = _ref2.initMapDispatchToProps,
        initMergeProps = _ref2.initMergeProps,
        options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

    var mapStateToProps = initMapStateToProps(dispatch, options);
    var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
    var mergeProps = initMergeProps(dispatch, options);

    if ("production" !== 'production') {
      (0, _verifySubselectors2.default)(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
    }

    var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

    return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
  }
  },{"./verifySubselectors":1167}],1167:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.default = verifySubselectors;

  var _warning = require('../utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function verify(selector, methodName, displayName) {
    if (!selector) {
      throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
    } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
      if (!selector.hasOwnProperty('dependsOnOwnProps')) {
        (0, _warning2.default)('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
      }
    }
  }

  function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
    verify(mapStateToProps, 'mapStateToProps', displayName);
    verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
    verify(mergeProps, 'mergeProps', displayName);
  }
  },{"../utils/warning":1174}],1168:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
  exports.getDependsOnOwnProps = getDependsOnOwnProps;
  exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

  var _verifyPlainObject = require('../utils/verifyPlainObject');

  var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch, options) {
      var constant = getConstant(dispatch, options);

      function constantSelector() {
        return constant;
      }
      constantSelector.dependsOnOwnProps = false;
      return constantSelector;
    };
  }

  // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
  // to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
  // whether mapToProps needs to be invoked when props have changed.
  //
  // A length of one signals that mapToProps does not depend on props from the parent component.
  // A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
  // therefore not reporting its length accurately..
  function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
  }

  // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
  // this function wraps mapToProps in a proxy function which does several things:
  //
  //  * Detects whether the mapToProps function being called depends on props, which
  //    is used by selectorFactory to decide if it should reinvoke on props changes.
  //
  //  * On first call, handles mapToProps if returns another function, and treats that
  //    new function as the true mapToProps for subsequent calls.
  //
  //  * On first call, verifies the first result is a plain object, in order to warn
  //    the developer that their mapToProps function is not returning a valid result.
  //
  function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch, _ref) {
      var displayName = _ref.displayName;

      var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
        return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
      };

      // allow detectFactoryAndVerify to get ownProps
      proxy.dependsOnOwnProps = true;

      proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
        proxy.mapToProps = mapToProps;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
        var props = proxy(stateOrDispatch, ownProps);

        if (typeof props === 'function') {
          proxy.mapToProps = props;
          proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
          props = proxy(stateOrDispatch, ownProps);
        }

        if ("production" !== 'production') (0, _verifyPlainObject2.default)(props, displayName, methodName);

        return props;
      };

      return proxy;
    };
  }
  },{"../utils/verifyPlainObject":1173}],1169:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.connect = exports.connectAdvanced = exports.createProvider = exports.Provider = undefined;

  var _Provider = require('./components/Provider');

  var _Provider2 = _interopRequireDefault(_Provider);

  var _connectAdvanced = require('./components/connectAdvanced');

  var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

  var _connect = require('./connect/connect');

  var _connect2 = _interopRequireDefault(_connect);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.Provider = _Provider2.default;
  exports.createProvider = _Provider.createProvider;
  exports.connectAdvanced = _connectAdvanced2.default;
  exports.connect = _connect2.default;
  },{"./components/Provider":1160,"./components/connectAdvanced":1161,"./connect/connect":1162}],1170:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.storeShape = exports.subscriptionShape = undefined;

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var subscriptionShape = exports.subscriptionShape = _propTypes2.default.shape({
    trySubscribe: _propTypes2.default.func.isRequired,
    tryUnsubscribe: _propTypes2.default.func.isRequired,
    notifyNestedSubs: _propTypes2.default.func.isRequired,
    isSubscribed: _propTypes2.default.func.isRequired
  });

  var storeShape = exports.storeShape = _propTypes2.default.shape({
    subscribe: _propTypes2.default.func.isRequired,
    dispatch: _propTypes2.default.func.isRequired,
    getState: _propTypes2.default.func.isRequired
  });
  },{"prop-types":1178}],1171:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  // encapsulates the subscription logic for connecting a component to the redux store, as
  // well as nesting subscriptions of descendant components, so that we can ensure the
  // ancestor components re-render before descendants

  var CLEARED = null;
  var nullListeners = {
    notify: function notify() {}
  };

  function createListenerCollection() {
    // the current/next pattern is copied from redux's createStore code.
    // TODO: refactor+expose that code to be reusable here?
    var current = [];
    var next = [];

    return {
      clear: function clear() {
        next = CLEARED;
        current = CLEARED;
      },
      notify: function notify() {
        var listeners = current = next;
        for (var i = 0; i < listeners.length; i++) {
          listeners[i]();
        }
      },
      get: function get() {
        return next;
      },
      subscribe: function subscribe(listener) {
        var isSubscribed = true;
        if (next === current) next = current.slice();
        next.push(listener);

        return function unsubscribe() {
          if (!isSubscribed || current === CLEARED) return;
          isSubscribed = false;

          if (next === current) next = current.slice();
          next.splice(next.indexOf(listener), 1);
        };
      }
    };
  }

  var Subscription = function () {
    function Subscription(store, parentSub, onStateChange) {
      _classCallCheck(this, Subscription);

      this.store = store;
      this.parentSub = parentSub;
      this.onStateChange = onStateChange;
      this.unsubscribe = null;
      this.listeners = nullListeners;
    }

    Subscription.prototype.addNestedSub = function addNestedSub(listener) {
      this.trySubscribe();
      return this.listeners.subscribe(listener);
    };

    Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
      this.listeners.notify();
    };

    Subscription.prototype.isSubscribed = function isSubscribed() {
      return Boolean(this.unsubscribe);
    };

    Subscription.prototype.trySubscribe = function trySubscribe() {
      if (!this.unsubscribe) {
        this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

        this.listeners = createListenerCollection();
      }
    };

    Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
      if (this.unsubscribe) {
        this.unsubscribe();
        this.unsubscribe = null;
        this.listeners.clear();
        this.listeners = nullListeners;
      }
    };

    return Subscription;
  }();

  exports.default = Subscription;
  },{}],1172:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.default = shallowEqual;
  var hasOwn = Object.prototype.hasOwnProperty;

  function is(x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);

    if (keysA.length !== keysB.length) return false;

    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }
  },{}],1173:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.default = verifyPlainObject;

  var _isPlainObject = require('lodash/isPlainObject');

  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

  var _warning = require('./warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function verifyPlainObject(value, displayName, methodName) {
    if (!(0, _isPlainObject2.default)(value)) {
      (0, _warning2.default)(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
    }
  }
  },{"./warning":1174,"lodash/isPlainObject":766}],1174:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.default = warning;
  /**
   * Prints a warning in the console if it exists.
   *
   * @param {String} message The warning message.
   * @returns {void}
   */
  function warning(message) {
    /* eslint-disable no-console */
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    /* eslint-enable no-console */
    try {
      // This error was thrown as a convenience so that if you enable
      // "break on all exceptions" in your console,
      // it would pause the execution at this line.
      throw new Error(message);
      /* eslint-disable no-empty */
    } catch (e) {}
    /* eslint-enable no-empty */
  }
  },{}],1175:[function(require,module,exports){
  arguments[4][824][0].apply(exports,arguments)
  },{"./lib/ReactPropTypesSecret":1179,"dup":824,"fbjs/lib/invariant":721,"fbjs/lib/warning":725}],1176:[function(require,module,exports){
  arguments[4][825][0].apply(exports,arguments)
  },{"./lib/ReactPropTypesSecret":1179,"dup":825,"fbjs/lib/emptyFunction":715,"fbjs/lib/invariant":721}],1177:[function(require,module,exports){
  arguments[4][826][0].apply(exports,arguments)
  },{"./checkPropTypes":1175,"./lib/ReactPropTypesSecret":1179,"dup":826,"fbjs/lib/emptyFunction":715,"fbjs/lib/invariant":721,"fbjs/lib/warning":725,"object-assign":822}],1178:[function(require,module,exports){
  arguments[4][827][0].apply(exports,arguments)
  },{"./factoryWithThrowingShims":1176,"./factoryWithTypeCheckers":1177,"dup":827}],1179:[function(require,module,exports){
  arguments[4][828][0].apply(exports,arguments)
  },{"dup":828}],1180:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_RenderedSection = require('../Grid').babelPluginFlowReactPropTypes_proptype_RenderedSection || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_ScrollIndices = require('./types').babelPluginFlowReactPropTypes_proptype_ScrollIndices || require('prop-types').any;

  /**
   * This HOC decorates a virtualized component and responds to arrow-key events by scrolling one row or column at a time.
   */

  var ArrowKeyStepper = function (_React$PureComponent) {
    (0, _inherits3.default)(ArrowKeyStepper, _React$PureComponent);

    function ArrowKeyStepper(props) {
      (0, _classCallCheck3.default)(this, ArrowKeyStepper);

      var _this = (0, _possibleConstructorReturn3.default)(this, (ArrowKeyStepper.__proto__ || (0, _getPrototypeOf2.default)(ArrowKeyStepper)).call(this, props));

      _this._columnStartIndex = 0;
      _this._columnStopIndex = 0;
      _this._rowStartIndex = 0;
      _this._rowStopIndex = 0;

      _this._onKeyDown = function (event) {
        var _this$props = _this.props,
            columnCount = _this$props.columnCount,
            disabled = _this$props.disabled,
            mode = _this$props.mode,
            rowCount = _this$props.rowCount;


        if (disabled) {
          return;
        }

        var _this$_getScrollState = _this._getScrollState(),
            scrollToColumnPrevious = _this$_getScrollState.scrollToColumn,
            scrollToRowPrevious = _this$_getScrollState.scrollToRow;

        var _this$_getScrollState2 = _this._getScrollState(),
            scrollToColumn = _this$_getScrollState2.scrollToColumn,
            scrollToRow = _this$_getScrollState2.scrollToRow;

        // The above cases all prevent default event event behavior.
        // This is to keep the grid from scrolling after the snap-to update.


        switch (event.key) {
          case 'ArrowDown':
            scrollToRow = mode === 'cells' ? Math.min(scrollToRow + 1, rowCount - 1) : Math.min(_this._rowStopIndex + 1, rowCount - 1);
            break;
          case 'ArrowLeft':
            scrollToColumn = mode === 'cells' ? Math.max(scrollToColumn - 1, 0) : Math.max(_this._columnStartIndex - 1, 0);
            break;
          case 'ArrowRight':
            scrollToColumn = mode === 'cells' ? Math.min(scrollToColumn + 1, columnCount - 1) : Math.min(_this._columnStopIndex + 1, columnCount - 1);
            break;
          case 'ArrowUp':
            scrollToRow = mode === 'cells' ? Math.max(scrollToRow - 1, 0) : Math.max(_this._rowStartIndex - 1, 0);
            break;
        }

        if (scrollToColumn !== scrollToColumnPrevious || scrollToRow !== scrollToRowPrevious) {
          event.preventDefault();

          _this._updateScrollState({ scrollToColumn: scrollToColumn, scrollToRow: scrollToRow });
        }
      };

      _this._onSectionRendered = function (_ref) {
        var columnStartIndex = _ref.columnStartIndex,
            columnStopIndex = _ref.columnStopIndex,
            rowStartIndex = _ref.rowStartIndex,
            rowStopIndex = _ref.rowStopIndex;

        _this._columnStartIndex = columnStartIndex;
        _this._columnStopIndex = columnStopIndex;
        _this._rowStartIndex = rowStartIndex;
        _this._rowStopIndex = rowStopIndex;
      };

      _this.state = {
        scrollToColumn: props.scrollToColumn,
        scrollToRow: props.scrollToRow
      };
      return _this;
    }

    (0, _createClass3.default)(ArrowKeyStepper, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (this.props.isControlled) {
          return;
        }

        var scrollToColumn = nextProps.scrollToColumn,
            scrollToRow = nextProps.scrollToRow;
        var _props = this.props,
            prevScrollToColumn = _props.scrollToColumn,
            prevScrollToRow = _props.scrollToRow;


        if (prevScrollToColumn !== scrollToColumn && prevScrollToRow !== scrollToRow) {
          this.setState({
            scrollToColumn: scrollToColumn,
            scrollToRow: scrollToRow
          });
        } else if (prevScrollToColumn !== scrollToColumn) {
          this.setState({ scrollToColumn: scrollToColumn });
        } else if (prevScrollToRow !== scrollToRow) {
          this.setState({ scrollToRow: scrollToRow });
        }
      }
    }, {
      key: 'setScrollIndexes',
      value: function setScrollIndexes(_ref2) {
        var scrollToColumn = _ref2.scrollToColumn,
            scrollToRow = _ref2.scrollToRow;

        this.setState({
          scrollToRow: scrollToRow,
          scrollToColumn: scrollToColumn
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var _props2 = this.props,
            className = _props2.className,
            children = _props2.children;

        var _getScrollState2 = this._getScrollState(),
            scrollToColumn = _getScrollState2.scrollToColumn,
            scrollToRow = _getScrollState2.scrollToRow;

        return React.createElement(
          'div',
          { className: className, onKeyDown: this._onKeyDown },
          children({
            onSectionRendered: this._onSectionRendered,
            scrollToColumn: scrollToColumn,
            scrollToRow: scrollToRow
          })
        );
      }
    }, {
      key: '_getScrollState',
      value: function _getScrollState() {
        return this.props.isControlled ? this.props : this.state;
      }
    }, {
      key: '_updateScrollState',
      value: function _updateScrollState(_ref3) {
        var scrollToColumn = _ref3.scrollToColumn,
            scrollToRow = _ref3.scrollToRow;
        var _props3 = this.props,
            isControlled = _props3.isControlled,
            onScrollToChange = _props3.onScrollToChange;


        if (typeof onScrollToChange === 'function') {
          onScrollToChange({ scrollToColumn: scrollToColumn, scrollToRow: scrollToRow });
        }

        if (!isControlled) {
          this.setState({ scrollToColumn: scrollToColumn, scrollToRow: scrollToRow });
        }
      }
    }]);
    return ArrowKeyStepper;
  }(React.PureComponent);

  ArrowKeyStepper.defaultProps = {
    disabled: false,
    isControlled: false,
    mode: 'edges',
    scrollToColumn: 0,
    scrollToRow: 0
  };
  ArrowKeyStepper.propTypes = "production" === 'production' ? null : {
    children: require('prop-types').func.isRequired,
    className: require('prop-types').string,
    columnCount: require('prop-types').number.isRequired,
    disabled: require('prop-types').bool.isRequired,
    isControlled: require('prop-types').bool.isRequired,
    mode: require('prop-types').oneOf(['cells', 'edges']).isRequired,
    onScrollToChange: require('prop-types').func,
    rowCount: require('prop-types').number.isRequired,
    scrollToColumn: require('prop-types').number.isRequired,
    scrollToRow: require('prop-types').number.isRequired
  };
  exports.default = ArrowKeyStepper;
  },{"../Grid":1201,"./types":1182,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1181:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _ArrowKeyStepper = require('./ArrowKeyStepper');

  Object.defineProperty(exports, 'default', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_ArrowKeyStepper).default;
    }
  });
  Object.defineProperty(exports, 'ArrowKeyStepper', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_ArrowKeyStepper).default;
    }
  });

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  },{"./ArrowKeyStepper":1180}],1182:[function(require,module,exports){
  "use strict";

  var babelPluginFlowReactPropTypes_proptype_ScrollIndices = "production" === 'production' ? null : {
    scrollToColumn: require("prop-types").number.isRequired,
    scrollToRow: require("prop-types").number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_ScrollIndices", {
    value: babelPluginFlowReactPropTypes_proptype_ScrollIndices,
    configurable: true
  });
  },{"prop-types":1249}],1183:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  var _detectElementResize = require('../vendor/detectElementResize');

  var _detectElementResize2 = _interopRequireDefault(_detectElementResize);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var AutoSizer = function (_React$PureComponent) {
    (0, _inherits3.default)(AutoSizer, _React$PureComponent);

    function AutoSizer() {
      var _ref;

      var _temp, _this, _ret;

      (0, _classCallCheck3.default)(this, AutoSizer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = AutoSizer.__proto__ || (0, _getPrototypeOf2.default)(AutoSizer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        height: _this.props.defaultHeight || 0,
        width: _this.props.defaultWidth || 0
      }, _this._onResize = function () {
        var _this$props = _this.props,
            disableHeight = _this$props.disableHeight,
            disableWidth = _this$props.disableWidth,
            onResize = _this$props.onResize;


        if (_this._parentNode) {
          // Guard against AutoSizer component being removed from the DOM immediately after being added.
          // This can result in invalid style values which can result in NaN values if we don't handle them.
          // See issue #150 for more context.

          var _height = _this._parentNode.offsetHeight || 0;
          var _width = _this._parentNode.offsetWidth || 0;

          var _style = window.getComputedStyle(_this._parentNode) || {};
          var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;
          var paddingRight = parseInt(_style.paddingRight, 10) || 0;
          var paddingTop = parseInt(_style.paddingTop, 10) || 0;
          var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;

          var newHeight = _height - paddingTop - paddingBottom;
          var newWidth = _width - paddingLeft - paddingRight;

          if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {
            _this.setState({
              height: _height - paddingTop - paddingBottom,
              width: _width - paddingLeft - paddingRight
            });

            onResize({ height: _height, width: _width });
          }
        }
      }, _this._setRef = function (autoSizer) {
        _this._autoSizer = autoSizer;
      }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
    }

    (0, _createClass3.default)(AutoSizer, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var nonce = this.props.nonce;

        if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
          // Delay access of parentNode until mount.
          // This handles edge-cases where the component has already been unmounted before its ref has been set,
          // As well as libraries like react-lite which have a slightly different lifecycle.
          this._parentNode = this._autoSizer.parentNode;

          // Defer requiring resize handler in order to support server-side rendering.
          // See issue #41
          this._detectElementResize = (0, _detectElementResize2.default)(nonce);
          this._detectElementResize.addResizeListener(this._parentNode, this._onResize);

          this._onResize();
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this._detectElementResize && this._parentNode) {
          this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            children = _props.children,
            className = _props.className,
            disableHeight = _props.disableHeight,
            disableWidth = _props.disableWidth,
            style = _props.style;
        var _state = this.state,
            height = _state.height,
            width = _state.width;

        // Outer div should not force width/height since that may prevent containers from shrinking.
        // Inner component should overflow and use calculated width/height.
        // See issue #68 for more information.

        var outerStyle = { overflow: 'visible' };
        var childParams = {};

        if (!disableHeight) {
          outerStyle.height = 0;
          childParams.height = height;
        }

        if (!disableWidth) {
          outerStyle.width = 0;
          childParams.width = width;
        }

        /**
         * TODO: Avoid rendering children before the initial measurements have been collected.
         * At best this would just be wasting cycles.
         * Add this check into version 10 though as it could break too many ref callbacks in version 9.
         * Note that if default width/height props were provided this would still work with SSR.
        if (
          height !== 0 &&
          width !== 0
        ) {
          child = children({ height, width })
        }
        */

        return React.createElement(
          'div',
          {
            className: className,
            ref: this._setRef,
            style: (0, _extends3.default)({}, outerStyle, style) },
          children(childParams)
        );
      }
    }]);
    return AutoSizer;
  }(React.PureComponent);

  AutoSizer.defaultProps = {
    onResize: function onResize() {},
    disableHeight: false,
    disableWidth: false,
    style: {}
  };
  AutoSizer.propTypes = "production" === 'production' ? null : {
    /** Function responsible for rendering children.*/
    children: require('prop-types').func.isRequired,


    /** Optional custom CSS class name to attach to root AutoSizer element.  */
    className: require('prop-types').string,


    /** Default height to use for initial render; useful for SSR */
    defaultHeight: require('prop-types').number,


    /** Default width to use for initial render; useful for SSR */
    defaultWidth: require('prop-types').number,


    /** Disable dynamic :height property */
    disableHeight: require('prop-types').bool.isRequired,


    /** Disable dynamic :width property */
    disableWidth: require('prop-types').bool.isRequired,


    /** Nonce of the inlined stylesheet for Content Security Policy */
    nonce: require('prop-types').string,


    /** Callback to be invoked on-resize */
    onResize: require('prop-types').func.isRequired,


    /** Optional inline style */
    style: require('prop-types').object
  };
  exports.default = AutoSizer;
  },{"../vendor/detectElementResize":1244,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1184:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _AutoSizer = require('./AutoSizer');

  Object.defineProperty(exports, 'default', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_AutoSizer).default;
    }
  });
  Object.defineProperty(exports, 'AutoSizer', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_AutoSizer).default;
    }
  });

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  },{"./AutoSizer":1183}],1185:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  var _reactDom = require('react-dom');

  var _CellMeasurerCache = require('./CellMeasurerCache.js');

  var _CellMeasurerCache2 = _interopRequireDefault(_CellMeasurerCache);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Wraps a cell and measures its rendered content.
   * Measurements are stored in a per-cell cache.
   * Cached-content is not be re-measured.
   */
  var CellMeasurer = function (_React$PureComponent) {
    (0, _inherits3.default)(CellMeasurer, _React$PureComponent);

    function CellMeasurer() {
      var _ref;

      var _temp, _this, _ret;

      (0, _classCallCheck3.default)(this, CellMeasurer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = CellMeasurer.__proto__ || (0, _getPrototypeOf2.default)(CellMeasurer)).call.apply(_ref, [this].concat(args))), _this), _this._measure = function () {
        var _this$props = _this.props,
            cache = _this$props.cache,
            _this$props$columnInd = _this$props.columnIndex,
            columnIndex = _this$props$columnInd === undefined ? 0 : _this$props$columnInd,
            parent = _this$props.parent,
            _this$props$rowIndex = _this$props.rowIndex,
            rowIndex = _this$props$rowIndex === undefined ? _this.props.index || 0 : _this$props$rowIndex;

        var _this$_getCellMeasure = _this._getCellMeasurements(),
            height = _this$_getCellMeasure.height,
            width = _this$_getCellMeasure.width;

        if (height !== cache.getHeight(rowIndex, columnIndex) || width !== cache.getWidth(rowIndex, columnIndex)) {
          cache.set(rowIndex, columnIndex, width, height);

          if (parent && typeof parent.recomputeGridSize === 'function') {
            parent.recomputeGridSize({
              columnIndex: columnIndex,
              rowIndex: rowIndex
            });
          }
        }
      }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
    }

    (0, _createClass3.default)(CellMeasurer, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this._maybeMeasureCell();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this._maybeMeasureCell();
      }
    }, {
      key: 'render',
      value: function render() {
        var children = this.props.children;


        return typeof children === 'function' ? children({ measure: this._measure }) : children;
      }
    }, {
      key: '_getCellMeasurements',
      value: function _getCellMeasurements() {
        var cache = this.props.cache;


        var node = (0, _reactDom.findDOMNode)(this);

        // TODO Check for a bad combination of fixedWidth and missing numeric width or vice versa with height

        if (node && node.ownerDocument && node.ownerDocument.defaultView && node instanceof node.ownerDocument.defaultView.HTMLElement) {
          var styleWidth = node.style.width;
          var styleHeight = node.style.height;

          // If we are re-measuring a cell that has already been measured,
          // It will have a hard-coded width/height from the previous measurement.
          // The fact that we are measuring indicates this measurement is probably stale,
          // So explicitly clear it out (eg set to "auto") so we can recalculate.
          // See issue #593 for more info.
          // Even if we are measuring initially- if we're inside of a MultiGrid component,
          // Explicitly clear width/height before measuring to avoid being tainted by another Grid.
          // eg top/left Grid renders before bottom/right Grid
          // Since the CellMeasurerCache is shared between them this taints derived cell size values.
          if (!cache.hasFixedWidth()) {
            node.style.width = 'auto';
          }
          if (!cache.hasFixedHeight()) {
            node.style.height = 'auto';
          }

          var height = Math.ceil(node.offsetHeight);
          var width = Math.ceil(node.offsetWidth);

          // Reset after measuring to avoid breaking styles; see #660
          if (styleWidth) {
            node.style.width = styleWidth;
          }
          if (styleHeight) {
            node.style.height = styleHeight;
          }

          return { height: height, width: width };
        } else {
          return { height: 0, width: 0 };
        }
      }
    }, {
      key: '_maybeMeasureCell',
      value: function _maybeMeasureCell() {
        var _props = this.props,
            cache = _props.cache,
            _props$columnIndex = _props.columnIndex,
            columnIndex = _props$columnIndex === undefined ? 0 : _props$columnIndex,
            parent = _props.parent,
            _props$rowIndex = _props.rowIndex,
            rowIndex = _props$rowIndex === undefined ? this.props.index || 0 : _props$rowIndex;


        if (!cache.has(rowIndex, columnIndex)) {
          var _getCellMeasurements2 = this._getCellMeasurements(),
              height = _getCellMeasurements2.height,
              width = _getCellMeasurements2.width;

          cache.set(rowIndex, columnIndex, width, height);

          // If size has changed, let Grid know to re-render.
          if (parent && typeof parent.invalidateCellSizeAfterRender === 'function') {
            parent.invalidateCellSizeAfterRender({
              columnIndex: columnIndex,
              rowIndex: rowIndex
            });
          }
        }
      }
    }]);
    return CellMeasurer;
  }(React.PureComponent);

  // Used for DEV mode warning check


  CellMeasurer.__internalCellMeasurerFlag = false;
  CellMeasurer.propTypes = "production" === 'production' ? null : {
    cache: typeof _CellMeasurerCache2.default === 'function' ? require('prop-types').instanceOf(_CellMeasurerCache2.default).isRequired : require('prop-types').any.isRequired,
    children: require('prop-types').oneOfType([require('prop-types').func, require('prop-types').node]).isRequired,
    columnIndex: require('prop-types').number,
    index: require('prop-types').number,
    parent: require('prop-types').shape({
      invalidateCellSizeAfterRender: require('prop-types').func,
      recomputeGridSize: require('prop-types').func
    }).isRequired,
    rowIndex: require('prop-types').number
  };
  exports.default = CellMeasurer;
  if ("production" !== 'production') {
    CellMeasurer.__internalCellMeasurerFlag = true;
  }
  },{"./CellMeasurerCache.js":1186,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253,"react-dom":1157}],1186:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_WIDTH = exports.DEFAULT_HEIGHT = undefined;

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var DEFAULT_HEIGHT = exports.DEFAULT_HEIGHT = 30;
  var DEFAULT_WIDTH = exports.DEFAULT_WIDTH = 100;

  // Enables more intelligent mapping of a given column and row index to an item ID.
  // This prevents a cell cache from being invalidated when its parent collection is modified.

  /**
   * Caches measurements for a given cell.
   */
  var CellMeasurerCache = function () {
    function CellMeasurerCache() {
      var _this = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck3.default)(this, CellMeasurerCache);
      this._cellHeightCache = {};
      this._cellWidthCache = {};
      this._columnWidthCache = {};
      this._rowHeightCache = {};
      this._columnCount = 0;
      this._rowCount = 0;

      this.columnWidth = function (_ref) {
        var index = _ref.index;

        var key = _this._keyMapper(0, index);

        return _this._columnWidthCache.hasOwnProperty(key) ? _this._columnWidthCache[key] : _this._defaultWidth;
      };

      this.rowHeight = function (_ref2) {
        var index = _ref2.index;

        var key = _this._keyMapper(index, 0);

        return _this._rowHeightCache.hasOwnProperty(key) ? _this._rowHeightCache[key] : _this._defaultHeight;
      };

      var defaultHeight = params.defaultHeight,
          defaultWidth = params.defaultWidth,
          fixedHeight = params.fixedHeight,
          fixedWidth = params.fixedWidth,
          keyMapper = params.keyMapper,
          minHeight = params.minHeight,
          minWidth = params.minWidth;


      this._hasFixedHeight = fixedHeight === true;
      this._hasFixedWidth = fixedWidth === true;
      this._minHeight = minHeight || 0;
      this._minWidth = minWidth || 0;
      this._keyMapper = keyMapper || defaultKeyMapper;

      this._defaultHeight = Math.max(this._minHeight, typeof defaultHeight === 'number' ? defaultHeight : DEFAULT_HEIGHT);
      this._defaultWidth = Math.max(this._minWidth, typeof defaultWidth === 'number' ? defaultWidth : DEFAULT_WIDTH);

      if ("production" !== 'production') {
        if (this._hasFixedHeight === false && this._hasFixedWidth === false) {
          console.warn("CellMeasurerCache should only measure a cell's width or height. " + 'You have configured CellMeasurerCache to measure both. ' + 'This will result in poor performance.');
        }

        if (this._hasFixedHeight === false && this._defaultHeight === 0) {
          console.warn('Fixed height CellMeasurerCache should specify a :defaultHeight greater than 0. ' + 'Failing to do so will lead to unnecessary layout and poor performance.');
        }

        if (this._hasFixedWidth === false && this._defaultWidth === 0) {
          console.warn('Fixed width CellMeasurerCache should specify a :defaultWidth greater than 0. ' + 'Failing to do so will lead to unnecessary layout and poor performance.');
        }
      }
    }

    (0, _createClass3.default)(CellMeasurerCache, [{
      key: 'clear',
      value: function clear(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        var key = this._keyMapper(rowIndex, columnIndex);

        delete this._cellHeightCache[key];
        delete this._cellWidthCache[key];

        this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
      }
    }, {
      key: 'clearAll',
      value: function clearAll() {
        this._cellHeightCache = {};
        this._cellWidthCache = {};
        this._columnWidthCache = {};
        this._rowHeightCache = {};
        this._rowCount = 0;
        this._columnCount = 0;
      }
    }, {
      key: 'hasFixedHeight',
      value: function hasFixedHeight() {
        return this._hasFixedHeight;
      }
    }, {
      key: 'hasFixedWidth',
      value: function hasFixedWidth() {
        return this._hasFixedWidth;
      }
    }, {
      key: 'getHeight',
      value: function getHeight(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (this._hasFixedHeight) {
          return this._defaultHeight;
        } else {
          var _key = this._keyMapper(rowIndex, columnIndex);

          return this._cellHeightCache.hasOwnProperty(_key) ? Math.max(this._minHeight, this._cellHeightCache[_key]) : this._defaultHeight;
        }
      }
    }, {
      key: 'getWidth',
      value: function getWidth(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (this._hasFixedWidth) {
          return this._defaultWidth;
        } else {
          var _key2 = this._keyMapper(rowIndex, columnIndex);

          return this._cellWidthCache.hasOwnProperty(_key2) ? Math.max(this._minWidth, this._cellWidthCache[_key2]) : this._defaultWidth;
        }
      }
    }, {
      key: 'has',
      value: function has(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        var key = this._keyMapper(rowIndex, columnIndex);

        return this._cellHeightCache.hasOwnProperty(key);
      }
    }, {
      key: 'set',
      value: function set(rowIndex, columnIndex, width, height) {
        var key = this._keyMapper(rowIndex, columnIndex);

        if (columnIndex >= this._columnCount) {
          this._columnCount = columnIndex + 1;
        }
        if (rowIndex >= this._rowCount) {
          this._rowCount = rowIndex + 1;
        }

        // Size is cached per cell so we don't have to re-measure if cells are re-ordered.
        this._cellHeightCache[key] = height;
        this._cellWidthCache[key] = width;

        this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
      }
    }, {
      key: '_updateCachedColumnAndRowSizes',
      value: function _updateCachedColumnAndRowSizes(rowIndex, columnIndex) {
        // :columnWidth and :rowHeight are derived based on all cells in a column/row.
        // Pre-cache these derived values for faster lookup later.
        // Reads are expected to occur more frequently than writes in this case.
        // Only update non-fixed dimensions though to avoid doing unnecessary work.
        if (!this._hasFixedWidth) {
          var columnWidth = 0;
          for (var i = 0; i < this._rowCount; i++) {
            columnWidth = Math.max(columnWidth, this.getWidth(i, columnIndex));
          }
          var columnKey = this._keyMapper(0, columnIndex);
          this._columnWidthCache[columnKey] = columnWidth;
        }
        if (!this._hasFixedHeight) {
          var rowHeight = 0;
          for (var _i = 0; _i < this._columnCount; _i++) {
            rowHeight = Math.max(rowHeight, this.getHeight(rowIndex, _i));
          }
          var rowKey = this._keyMapper(rowIndex, 0);
          this._rowHeightCache[rowKey] = rowHeight;
        }
      }
    }, {
      key: 'defaultHeight',
      get: function get() {
        return this._defaultHeight;
      }
    }, {
      key: 'defaultWidth',
      get: function get() {
        return this._defaultWidth;
      }
    }]);
    return CellMeasurerCache;
  }();

  exports.default = CellMeasurerCache;


  function defaultKeyMapper(rowIndex, columnIndex) {
    return rowIndex + '-' + columnIndex;
  }
  },{"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585}],1187:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CellMeasurerCache = exports.CellMeasurer = undefined;

  var _CellMeasurer = require('./CellMeasurer');

  var _CellMeasurer2 = _interopRequireDefault(_CellMeasurer);

  var _CellMeasurerCache = require('./CellMeasurerCache');

  var _CellMeasurerCache2 = _interopRequireDefault(_CellMeasurerCache);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _CellMeasurer2.default;
  exports.CellMeasurer = _CellMeasurer2.default;
  exports.CellMeasurerCache = _CellMeasurerCache2.default;
  },{"./CellMeasurer":1185,"./CellMeasurerCache":1186}],1188:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

  var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _CollectionView = require('./CollectionView');

  var _CollectionView2 = _interopRequireDefault(_CollectionView);

  var _calculateSizeAndPositionData2 = require('./utils/calculateSizeAndPositionData');

  var _calculateSizeAndPositionData3 = _interopRequireDefault(_calculateSizeAndPositionData2);

  var _getUpdatedOffsetForIndex = require('../utils/getUpdatedOffsetForIndex');

  var _getUpdatedOffsetForIndex2 = _interopRequireDefault(_getUpdatedOffsetForIndex);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Renders scattered or non-linear data.
   * Unlike Grid, which renders checkerboard data, Collection can render arbitrarily positioned- even overlapping- data.
   */
  var babelPluginFlowReactPropTypes_proptype_SizeInfo = require('./types').babelPluginFlowReactPropTypes_proptype_SizeInfo || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_ScrollPosition = require('./types').babelPluginFlowReactPropTypes_proptype_ScrollPosition || require('prop-types').any;

  var Collection = function (_PureComponent) {
    (0, _inherits3.default)(Collection, _PureComponent);

    function Collection(props, context) {
      (0, _classCallCheck3.default)(this, Collection);

      var _this = (0, _possibleConstructorReturn3.default)(this, (Collection.__proto__ || (0, _getPrototypeOf2.default)(Collection)).call(this, props, context));

      _this._cellMetadata = [];
      _this._lastRenderedCellIndices = [];

      // Cell cache during scroll (for perforamnce)
      _this._cellCache = [];

      _this._isScrollingChange = _this._isScrollingChange.bind(_this);
      _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_this);
      return _this;
    }

    (0, _createClass3.default)(Collection, [{
      key: 'forceUpdate',
      value: function forceUpdate() {
        if (this._collectionView !== undefined) {
          this._collectionView.forceUpdate();
        }
      }

      /** See Collection#recomputeCellSizesAndPositions */

    }, {
      key: 'recomputeCellSizesAndPositions',
      value: function recomputeCellSizesAndPositions() {
        this._cellCache = [];
        this._collectionView.recomputeCellSizesAndPositions();
      }

      /** React lifecycle methods */

    }, {
      key: 'render',
      value: function render() {
        var props = (0, _objectWithoutProperties3.default)(this.props, []);


        return _react2.default.createElement(_CollectionView2.default, (0, _extends3.default)({
          cellLayoutManager: this,
          isScrollingChange: this._isScrollingChange,
          ref: this._setCollectionViewRef
        }, props));
      }

      /** CellLayoutManager interface */

    }, {
      key: 'calculateSizeAndPositionData',
      value: function calculateSizeAndPositionData() {
        var _props = this.props,
            cellCount = _props.cellCount,
            cellSizeAndPositionGetter = _props.cellSizeAndPositionGetter,
            sectionSize = _props.sectionSize;


        var data = (0, _calculateSizeAndPositionData3.default)({
          cellCount: cellCount,
          cellSizeAndPositionGetter: cellSizeAndPositionGetter,
          sectionSize: sectionSize
        });

        this._cellMetadata = data.cellMetadata;
        this._sectionManager = data.sectionManager;
        this._height = data.height;
        this._width = data.width;
      }

      /**
       * Returns the most recently rendered set of cell indices.
       */

    }, {
      key: 'getLastRenderedIndices',
      value: function getLastRenderedIndices() {
        return this._lastRenderedCellIndices;
      }

      /**
       * Calculates the minimum amount of change from the current scroll position to ensure the specified cell is (fully) visible.
       */

    }, {
      key: 'getScrollPositionForCell',
      value: function getScrollPositionForCell(_ref) {
        var align = _ref.align,
            cellIndex = _ref.cellIndex,
            height = _ref.height,
            scrollLeft = _ref.scrollLeft,
            scrollTop = _ref.scrollTop,
            width = _ref.width;
        var cellCount = this.props.cellCount;


        if (cellIndex >= 0 && cellIndex < cellCount) {
          var cellMetadata = this._cellMetadata[cellIndex];

          scrollLeft = (0, _getUpdatedOffsetForIndex2.default)({
            align: align,
            cellOffset: cellMetadata.x,
            cellSize: cellMetadata.width,
            containerSize: width,
            currentOffset: scrollLeft,
            targetIndex: cellIndex
          });

          scrollTop = (0, _getUpdatedOffsetForIndex2.default)({
            align: align,
            cellOffset: cellMetadata.y,
            cellSize: cellMetadata.height,
            containerSize: height,
            currentOffset: scrollTop,
            targetIndex: cellIndex
          });
        }

        return {
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        };
      }
    }, {
      key: 'getTotalSize',
      value: function getTotalSize() {
        return {
          height: this._height,
          width: this._width
        };
      }
    }, {
      key: 'cellRenderers',
      value: function cellRenderers(_ref2) {
        var _this2 = this;

        var height = _ref2.height,
            isScrolling = _ref2.isScrolling,
            width = _ref2.width,
            x = _ref2.x,
            y = _ref2.y;
        var _props2 = this.props,
            cellGroupRenderer = _props2.cellGroupRenderer,
            cellRenderer = _props2.cellRenderer;

        // Store for later calls to getLastRenderedIndices()

        this._lastRenderedCellIndices = this._sectionManager.getCellIndices({
          height: height,
          width: width,
          x: x,
          y: y
        });

        return cellGroupRenderer({
          cellCache: this._cellCache,
          cellRenderer: cellRenderer,
          cellSizeAndPositionGetter: function cellSizeAndPositionGetter(_ref3) {
            var index = _ref3.index;
            return _this2._sectionManager.getCellMetadata({ index: index });
          },
          indices: this._lastRenderedCellIndices,
          isScrolling: isScrolling
        });
      }
    }, {
      key: '_isScrollingChange',
      value: function _isScrollingChange(isScrolling) {
        if (!isScrolling) {
          this._cellCache = [];
        }
      }
    }, {
      key: '_setCollectionViewRef',
      value: function _setCollectionViewRef(ref) {
        this._collectionView = ref;
      }
    }]);
    return Collection;
  }(_react.PureComponent);

  Collection.defaultProps = {
    'aria-label': 'grid',
    cellGroupRenderer: defaultCellGroupRenderer
  };
  exports.default = Collection;
  Collection.propTypes = "production" !== "production" ? {
    'aria-label': _propTypes2.default.string,

    /**
     * Number of cells in Collection.
     */
    cellCount: _propTypes2.default.number.isRequired,

    /**
     * Responsible for rendering a group of cells given their indices.
     * Should implement the following interface: ({
     *   cellSizeAndPositionGetter:Function,
     *   indices: Array<number>,
     *   cellRenderer: Function
     * }): Array<PropTypes.node>
     */
    cellGroupRenderer: _propTypes2.default.func.isRequired,

    /**
     * Responsible for rendering a cell given an row and column index.
     * Should implement the following interface: ({ index: number, key: string, style: object }): PropTypes.element
     */
    cellRenderer: _propTypes2.default.func.isRequired,

    /**
     * Callback responsible for returning size and offset/position information for a given cell (index).
     * ({ index: number }): { height: number, width: number, x: number, y: number }
     */
    cellSizeAndPositionGetter: _propTypes2.default.func.isRequired,

    /**
     * Optionally override the size of the sections a Collection's cells are split into.
     */
    sectionSize: _propTypes2.default.number
  } : {};


  function defaultCellGroupRenderer(_ref4) {
    var cellCache = _ref4.cellCache,
        cellRenderer = _ref4.cellRenderer,
        cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter,
        indices = _ref4.indices,
        isScrolling = _ref4.isScrolling;

    return indices.map(function (index) {
      var cellMetadata = cellSizeAndPositionGetter({ index: index });
      console.log(cellMetadata.y);
      var cellRendererProps = {
        index: index,
        isScrolling: isScrolling,
        key: index,
        style: {
          height: cellMetadata.height,
          left: cellMetadata.x,
          position: 'absolute',
          top: cellMetadata.y,
          width: cellMetadata.width
        }
      };

      // Avoid re-creating cells while scrolling.
      // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
      // If a scroll is in progress- cache and reuse cells.
      // This cache will be thrown away once scrolling complets.
      if (isScrolling) {
        if (!(index in cellCache)) {
          cellCache[index] = cellRenderer(cellRendererProps);
        }

        return cellCache[index];
      } else {
        return cellRenderer(cellRendererProps);
      }
    }).filter(function (renderedCell) {
      return !!renderedCell;
    });
  }
  },{"../utils/getUpdatedOffsetForIndex":1241,"./CollectionView":1189,"./types":1193,"./utils/calculateSizeAndPositionData":1194,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/objectWithoutProperties":588,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1189:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _classnames = require('classnames');

  var _classnames2 = _interopRequireDefault(_classnames);

  var _createCallbackMemoizer = require('../utils/createCallbackMemoizer');

  var _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);

  var _scrollbarSize = require('dom-helpers/util/scrollbarSize');

  var _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // @TODO Merge Collection and CollectionView

  /**
   * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.
   * This improves performance and makes scrolling smoother.
   */
  var IS_SCROLLING_TIMEOUT = 150;

  /**
   * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.
   * This prevents Grid from interrupting mouse-wheel animations (see issue #2).
   */

  var SCROLL_POSITION_CHANGE_REASONS = {
    OBSERVED: 'observed',
    REQUESTED: 'requested'
  };

  /**
   * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.
   * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.
   */

  var CollectionView = function (_PureComponent) {
    (0, _inherits3.default)(CollectionView, _PureComponent);

    function CollectionView(props, context) {
      (0, _classCallCheck3.default)(this, CollectionView);

      var _this = (0, _possibleConstructorReturn3.default)(this, (CollectionView.__proto__ || (0, _getPrototypeOf2.default)(CollectionView)).call(this, props, context));

      _this.state = {
        isScrolling: false,
        scrollLeft: 0,
        scrollTop: 0
      };

      _this._calculateSizeAndPositionDataOnNextUpdate = false;

      // Invokes callbacks only when their values have changed.
      _this._onSectionRenderedMemoizer = (0, _createCallbackMemoizer2.default)();
      _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);

      // Bind functions to instance so they don't lose context when passed around.
      _this._invokeOnSectionRenderedHelper = _this._invokeOnSectionRenderedHelper.bind(_this);
      _this._onScroll = _this._onScroll.bind(_this);
      _this._setScrollingContainerRef = _this._setScrollingContainerRef.bind(_this);
      _this._updateScrollPositionForScrollToCell = _this._updateScrollPositionForScrollToCell.bind(_this);
      return _this;
    }

    /**
     * Forced recompute of cell sizes and positions.
     * This function should be called if cell sizes have changed but nothing else has.
     * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.
     */


    (0, _createClass3.default)(CollectionView, [{
      key: 'recomputeCellSizesAndPositions',
      value: function recomputeCellSizesAndPositions() {
        this._calculateSizeAndPositionDataOnNextUpdate = true;
        this.forceUpdate();
      }

      /* ---------------------------- Component lifecycle methods ---------------------------- */

    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _props = this.props,
            cellLayoutManager = _props.cellLayoutManager,
            scrollLeft = _props.scrollLeft,
            scrollToCell = _props.scrollToCell,
            scrollTop = _props.scrollTop;

        // If this component was first rendered server-side, scrollbar size will be undefined.
        // In that event we need to remeasure.

        if (!this._scrollbarSizeMeasured) {
          this._scrollbarSize = (0, _scrollbarSize2.default)();
          this._scrollbarSizeMeasured = true;
          this.setState({});
        }

        if (scrollToCell >= 0) {
          this._updateScrollPositionForScrollToCell();
        } else if (scrollLeft >= 0 || scrollTop >= 0) {
          this._setScrollPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });
        }

        // Update onSectionRendered callback.
        this._invokeOnSectionRenderedHelper();

        var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),
            totalHeight = _cellLayoutManager$ge.height,
            totalWidth = _cellLayoutManager$ge.width;

        // Initialize onScroll callback.


        this._invokeOnScrollMemoizer({
          scrollLeft: scrollLeft || 0,
          scrollTop: scrollTop || 0,
          totalHeight: totalHeight,
          totalWidth: totalWidth
        });
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var _props2 = this.props,
            height = _props2.height,
            scrollToAlignment = _props2.scrollToAlignment,
            scrollToCell = _props2.scrollToCell,
            width = _props2.width;
        var _state = this.state,
            scrollLeft = _state.scrollLeft,
            scrollPositionChangeReason = _state.scrollPositionChangeReason,
            scrollTop = _state.scrollTop;

        // Make sure requested changes to :scrollLeft or :scrollTop get applied.
        // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
        // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
        // So we only set these when we require an adjustment of the scroll position.
        // See issue #2 for more information.

        if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
          if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {
            this._scrollingContainer.scrollLeft = scrollLeft;
          }
          if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {
            this._scrollingContainer.scrollTop = scrollTop;
          }
        }

        // Update scroll offsets if the current :scrollToCell values requires it
        if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {
          this._updateScrollPositionForScrollToCell();
        }

        // Update onRowsRendered callback if start/stop indices have changed
        this._invokeOnSectionRenderedHelper();
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var cellLayoutManager = this.props.cellLayoutManager;


        cellLayoutManager.calculateSizeAndPositionData();

        // If this component is being rendered server-side, getScrollbarSize() will return undefined.
        // We handle this case in componentDidMount()
        this._scrollbarSize = (0, _scrollbarSize2.default)();
        if (this._scrollbarSize === undefined) {
          this._scrollbarSizeMeasured = false;
          this._scrollbarSize = 0;
        } else {
          this._scrollbarSizeMeasured = true;
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this._disablePointerEventsTimeoutId) {
          clearTimeout(this._disablePointerEventsTimeoutId);
        }
      }

      /**
       * @private
       * This method updates scrollLeft/scrollTop in state for the following conditions:
       * 1) Empty content (0 rows or columns)
       * 2) New scroll props overriding the current state
       * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid
       */

    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _state2 = this.state,
            scrollLeft = _state2.scrollLeft,
            scrollTop = _state2.scrollTop;


        if (nextProps.cellCount === 0 && (scrollLeft !== 0 || scrollTop !== 0)) {
          this._setScrollPosition({
            scrollLeft: 0,
            scrollTop: 0
          });
        } else if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
          this._setScrollPosition({
            scrollLeft: nextProps.scrollLeft,
            scrollTop: nextProps.scrollTop
          });
        }

        if (nextProps.cellCount !== this.props.cellCount || nextProps.cellLayoutManager !== this.props.cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {
          nextProps.cellLayoutManager.calculateSizeAndPositionData();
        }

        if (this._calculateSizeAndPositionDataOnNextUpdate) {
          this._calculateSizeAndPositionDataOnNextUpdate = false;
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props3 = this.props,
            autoHeight = _props3.autoHeight,
            cellCount = _props3.cellCount,
            cellLayoutManager = _props3.cellLayoutManager,
            className = _props3.className,
            height = _props3.height,
            horizontalOverscanSize = _props3.horizontalOverscanSize,
            id = _props3.id,
            noContentRenderer = _props3.noContentRenderer,
            style = _props3.style,
            verticalOverscanSize = _props3.verticalOverscanSize,
            width = _props3.width;
        var _state3 = this.state,
            isScrolling = _state3.isScrolling,
            scrollLeft = _state3.scrollLeft,
            scrollTop = _state3.scrollTop;

        var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),
            totalHeight = _cellLayoutManager$ge2.height,
            totalWidth = _cellLayoutManager$ge2.width;

        // Safely expand the rendered area by the specified overscan amount


        var left = Math.max(0, scrollLeft - horizontalOverscanSize);
        var top = Math.max(0, scrollTop - verticalOverscanSize);
        var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);
        var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);

        var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({
          height: bottom - top,
          isScrolling: isScrolling,
          width: right - left,
          x: left,
          y: top
        }) : [];

        var collectionStyle = {
          boxSizing: 'border-box',
          direction: 'ltr',
          height: autoHeight ? 'auto' : height,
          position: 'relative',
          WebkitOverflowScrolling: 'touch',
          width: width,
          willChange: 'transform'
        };

        // Force browser to hide scrollbars when we know they aren't necessary.
        // Otherwise once scrollbars appear they may not disappear again.
        // For more info see issue #116
        var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;
        var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;

        // Also explicitly init styles to 'auto' if scrollbars are required.
        // This works around an obscure edge case where external CSS styles have not yet been loaded,
        // But an initial scroll index of offset is set as an external prop.
        // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
        // This was originally reported via clauderic/react-infinite-calendar/issues/23
        collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';
        collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';

        return _react2.default.createElement(
          'div',
          {
            ref: this._setScrollingContainerRef,
            'aria-label': this.props['aria-label'],
            className: (0, _classnames2.default)('ReactVirtualized__Collection', className),
            id: id,
            onScroll: this._onScroll,
            role: 'grid',
            style: (0, _extends3.default)({}, collectionStyle, style),
            tabIndex: 0 },
          cellCount > 0 && _react2.default.createElement(
            'div',
            {
              className: 'ReactVirtualized__Collection__innerScrollContainer',
              style: {
                height: totalHeight,
                maxHeight: totalHeight,
                maxWidth: totalWidth,
                overflow: 'hidden',
                pointerEvents: isScrolling ? 'none' : '',
                width: totalWidth
              } },
            childrenToDisplay
          ),
          cellCount === 0 && noContentRenderer()
        );
      }

      /* ---------------------------- Helper methods ---------------------------- */

      /**
       * Sets an :isScrolling flag for a small window of time.
       * This flag is used to disable pointer events on the scrollable portion of the Collection.
       * This prevents jerky/stuttery mouse-wheel scrolling.
       */

    }, {
      key: '_enablePointerEventsAfterDelay',
      value: function _enablePointerEventsAfterDelay() {
        var _this2 = this;

        if (this._disablePointerEventsTimeoutId) {
          clearTimeout(this._disablePointerEventsTimeoutId);
        }

        this._disablePointerEventsTimeoutId = setTimeout(function () {
          var isScrollingChange = _this2.props.isScrollingChange;


          isScrollingChange(false);

          _this2._disablePointerEventsTimeoutId = null;
          _this2.setState({
            isScrolling: false
          });
        }, IS_SCROLLING_TIMEOUT);
      }
    }, {
      key: '_invokeOnSectionRenderedHelper',
      value: function _invokeOnSectionRenderedHelper() {
        var _props4 = this.props,
            cellLayoutManager = _props4.cellLayoutManager,
            onSectionRendered = _props4.onSectionRendered;


        this._onSectionRenderedMemoizer({
          callback: onSectionRendered,
          indices: {
            indices: cellLayoutManager.getLastRenderedIndices()
          }
        });
      }
    }, {
      key: '_invokeOnScrollMemoizer',
      value: function _invokeOnScrollMemoizer(_ref) {
        var _this3 = this;

        var scrollLeft = _ref.scrollLeft,
            scrollTop = _ref.scrollTop,
            totalHeight = _ref.totalHeight,
            totalWidth = _ref.totalWidth;

        this._onScrollMemoizer({
          callback: function callback(_ref2) {
            var scrollLeft = _ref2.scrollLeft,
                scrollTop = _ref2.scrollTop;
            var _props5 = _this3.props,
                height = _props5.height,
                onScroll = _props5.onScroll,
                width = _props5.width;


            onScroll({
              clientHeight: height,
              clientWidth: width,
              scrollHeight: totalHeight,
              scrollLeft: scrollLeft,
              scrollTop: scrollTop,
              scrollWidth: totalWidth
            });
          },
          indices: {
            scrollLeft: scrollLeft,
            scrollTop: scrollTop
          }
        });
      }
    }, {
      key: '_setScrollingContainerRef',
      value: function _setScrollingContainerRef(ref) {
        this._scrollingContainer = ref;
      }
    }, {
      key: '_setScrollPosition',
      value: function _setScrollPosition(_ref3) {
        var scrollLeft = _ref3.scrollLeft,
            scrollTop = _ref3.scrollTop;

        var newState = {
          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
        };

        if (scrollLeft >= 0) {
          newState.scrollLeft = scrollLeft;
        }

        if (scrollTop >= 0) {
          newState.scrollTop = scrollTop;
        }

        if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {
          this.setState(newState);
        }
      }
    }, {
      key: '_updateScrollPositionForScrollToCell',
      value: function _updateScrollPositionForScrollToCell() {
        var _props6 = this.props,
            cellLayoutManager = _props6.cellLayoutManager,
            height = _props6.height,
            scrollToAlignment = _props6.scrollToAlignment,
            scrollToCell = _props6.scrollToCell,
            width = _props6.width;
        var _state4 = this.state,
            scrollLeft = _state4.scrollLeft,
            scrollTop = _state4.scrollTop;


        if (scrollToCell >= 0) {
          var scrollPosition = cellLayoutManager.getScrollPositionForCell({
            align: scrollToAlignment,
            cellIndex: scrollToCell,
            height: height,
            scrollLeft: scrollLeft,
            scrollTop: scrollTop,
            width: width
          });

          if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {
            this._setScrollPosition(scrollPosition);
          }
        }
      }
    }, {
      key: '_onScroll',
      value: function _onScroll(event) {
        // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
        // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
        // See issue #404 for more information.
        if (event.target !== this._scrollingContainer) {
          return;
        }

        // Prevent pointer events from interrupting a smooth scroll
        this._enablePointerEventsAfterDelay();

        // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
        // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
        // This causes a series of rapid renders that is slow for long lists.
        // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.
        var _props7 = this.props,
            cellLayoutManager = _props7.cellLayoutManager,
            height = _props7.height,
            isScrollingChange = _props7.isScrollingChange,
            width = _props7.width;

        var scrollbarSize = this._scrollbarSize;

        var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),
            totalHeight = _cellLayoutManager$ge3.height,
            totalWidth = _cellLayoutManager$ge3.width;

        var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));
        var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));

        // Certain devices (like Apple touchpad) rapid-fire duplicate events.
        // Don't force a re-render if this is the case.
        // The mouse may move faster then the animation frame does.
        // Use requestAnimationFrame to avoid over-updating.
        if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
          // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.
          // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).
          // All things considered, this seems to be the best current work around that I'm aware of.
          // For more information see https://github.com/bvaughn/react-virtualized/pull/124
          var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;

          // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)
          if (!this.state.isScrolling) {
            isScrollingChange(true);
          }

          this.setState({
            isScrolling: true,
            scrollLeft: scrollLeft,
            scrollPositionChangeReason: scrollPositionChangeReason,
            scrollTop: scrollTop
          });
        }

        this._invokeOnScrollMemoizer({
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          totalWidth: totalWidth,
          totalHeight: totalHeight
        });
      }
    }]);
    return CollectionView;
  }(_react.PureComponent);

  CollectionView.defaultProps = {
    'aria-label': 'grid',
    horizontalOverscanSize: 0,
    noContentRenderer: function noContentRenderer() {
      return null;
    },
    onScroll: function onScroll() {
      return null;
    },
    onSectionRendered: function onSectionRendered() {
      return null;
    },
    scrollToAlignment: 'auto',
    scrollToCell: -1,
    style: {},
    verticalOverscanSize: 0
  };
  exports.default = CollectionView;
  CollectionView.propTypes = "production" !== "production" ? {
    'aria-label': _propTypes2.default.string,

    /**
     * Removes fixed height from the scrollingContainer so that the total height
     * of rows can stretch the window. Intended for use with WindowScroller
     */
    autoHeight: _propTypes2.default.bool,

    /**
     * Number of cells in collection.
     */
    cellCount: _propTypes2.default.number.isRequired,

    /**
     * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.
     */
    cellLayoutManager: _propTypes2.default.object.isRequired,

    /**
     * Optional custom CSS class name to attach to root Collection element.
     */
    className: _propTypes2.default.string,

    /**
     * Height of Collection; this property determines the number of visible (vs virtualized) rows.
     */
    height: _propTypes2.default.number.isRequired,

    /**
     * Optional custom id to attach to root Collection element.
     */
    id: _propTypes2.default.string,

    /**
     * Enables the `Collection` to horiontally "overscan" its content similar to how `Grid` does.
     * This can reduce flicker around the edges when a user scrolls quickly.
     */
    horizontalOverscanSize: _propTypes2.default.number.isRequired,

    isScrollingChange: _propTypes2.default.func,

    /**
     * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.
     */
    noContentRenderer: _propTypes2.default.func.isRequired,

    /**
     * Callback invoked whenever the scroll offset changes within the inner scrollable region.
     * This callback can be used to sync scrolling between lists, tables, or grids.
     * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void
     */
    onScroll: _propTypes2.default.func.isRequired,

    /**
     * Callback invoked with information about the section of the Collection that was just rendered.
     * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.
     */
    onSectionRendered: _propTypes2.default.func.isRequired,

    /**
     * Horizontal offset.
     */
    scrollLeft: _propTypes2.default.number,

    /**
     * Controls scroll-to-cell behavior of the Grid.
     * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
     * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
     */
    scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,

    /**
     * Cell index to ensure visible (by forcefully scrolling if necessary).
     */
    scrollToCell: _propTypes2.default.number.isRequired,

    /**
     * Vertical offset.
     */
    scrollTop: _propTypes2.default.number,

    /**
     * Optional custom inline style to attach to root Collection element.
     */
    style: _propTypes2.default.object,

    /**
     * Enables the `Collection` to vertically "overscan" its content similar to how `Grid` does.
     * This can reduce flicker around the edges when a user scrolls quickly.
     */
    verticalOverscanSize: _propTypes2.default.number.isRequired,

    /**
     * Width of Collection; this property determines the number of visible (vs virtualized) columns.
     */
    width: _propTypes2.default.number.isRequired
  } : {};
  },{"../utils/createCallbackMemoizer":1240,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"classnames":698,"dom-helpers/util/scrollbarSize":707,"prop-types":1249,"react":1253}],1190:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * A section of the Window.
   * Window Sections are used to group nearby cells.
   * This enables us to more quickly determine which cells to display in a given region of the Window.
   * Sections have a fixed size and contain 0 to many cells (tracked by their indices).
   */
  var babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo = require('./types').babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo || require('prop-types').any; /** @rlow */


  var babelPluginFlowReactPropTypes_proptype_Index = require('./types').babelPluginFlowReactPropTypes_proptype_Index || require('prop-types').any;

  var Section = function () {
    function Section(_ref) {
      var height = _ref.height,
          width = _ref.width,
          x = _ref.x,
          y = _ref.y;
      (0, _classCallCheck3.default)(this, Section);

      this.height = height;
      this.width = width;
      this.x = x;
      this.y = y;

      this._indexMap = {};
      this._indices = [];
    }

    /** Add a cell to this section. */


    (0, _createClass3.default)(Section, [{
      key: 'addCellIndex',
      value: function addCellIndex(_ref2) {
        var index = _ref2.index;

        if (!this._indexMap[index]) {
          this._indexMap[index] = true;
          this._indices.push(index);
        }
      }

      /** Get all cell indices that have been added to this section. */

    }, {
      key: 'getCellIndices',
      value: function getCellIndices() {
        return this._indices;
      }

      /** Intended for debugger/test purposes only */

    }, {
      key: 'toString',
      value: function toString() {
        return this.x + ',' + this.y + ' ' + this.width + 'x' + this.height;
      }
    }]);
    return Section;
  }();

  exports.default = Section;
  },{"./types":1193,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"prop-types":1249}],1191:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _keys = require('babel-runtime/core-js/object/keys');

  var _keys2 = _interopRequireDefault(_keys);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _Section = require('./Section');

  var _Section2 = _interopRequireDefault(_Section);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo = require('./types').babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo || require('prop-types').any; /**
                                                                                                                                                                                * Window Sections are used to group nearby cells.
                                                                                                                                                                                * This enables us to more quickly determine which cells to display in a given region of the Window.
                                                                                                                                                                                *
                                                                                                                                                                                */


  var babelPluginFlowReactPropTypes_proptype_Index = require('./types').babelPluginFlowReactPropTypes_proptype_Index || require('prop-types').any;

  var SECTION_SIZE = 100;

  /**
   * Contains 0 to many Sections.
   * Grows (and adds Sections) dynamically as cells are registered.
   * Automatically adds cells to the appropriate Section(s).
   */
  var SectionManager = function () {
    function SectionManager() {
      var sectionSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SECTION_SIZE;
      (0, _classCallCheck3.default)(this, SectionManager);

      this._sectionSize = sectionSize;

      this._cellMetadata = [];
      this._sections = {};
    }

    /**
     * Gets all cell indices contained in the specified region.
     * A region may encompass 1 or more Sections.
     */


    (0, _createClass3.default)(SectionManager, [{
      key: 'getCellIndices',
      value: function getCellIndices(_ref) {
        var height = _ref.height,
            width = _ref.width,
            x = _ref.x,
            y = _ref.y;

        var indices = {};

        this.getSections({ height: height, width: width, x: x, y: y }).forEach(function (section) {
          return section.getCellIndices().forEach(function (index) {
            indices[index] = index;
          });
        });

        // Object keys are strings; this function returns numbers
        return (0, _keys2.default)(indices).map(function (index) {
          return indices[index];
        });
      }

      /** Get size and position information for the cell specified. */

    }, {
      key: 'getCellMetadata',
      value: function getCellMetadata(_ref2) {
        var index = _ref2.index;

        return this._cellMetadata[index];
      }

      /** Get all Sections overlapping the specified region. */

    }, {
      key: 'getSections',
      value: function getSections(_ref3) {
        var height = _ref3.height,
            width = _ref3.width,
            x = _ref3.x,
            y = _ref3.y;

        var sectionXStart = Math.floor(x / this._sectionSize);
        var sectionXStop = Math.floor((x + width - 1) / this._sectionSize);
        var sectionYStart = Math.floor(y / this._sectionSize);
        var sectionYStop = Math.floor((y + height - 1) / this._sectionSize);

        var sections = [];

        for (var sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) {
          for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {
            var key = sectionX + '.' + sectionY;

            if (!this._sections[key]) {
              this._sections[key] = new _Section2.default({
                height: this._sectionSize,
                width: this._sectionSize,
                x: sectionX * this._sectionSize,
                y: sectionY * this._sectionSize
              });
            }

            sections.push(this._sections[key]);
          }
        }

        return sections;
      }

      /** Total number of Sections based on the currently registered cells. */

    }, {
      key: 'getTotalSectionCount',
      value: function getTotalSectionCount() {
        return (0, _keys2.default)(this._sections).length;
      }

      /** Intended for debugger/test purposes only */

    }, {
      key: 'toString',
      value: function toString() {
        var _this = this;

        return (0, _keys2.default)(this._sections).map(function (index) {
          return _this._sections[index].toString();
        });
      }

      /** Adds a cell to the appropriate Sections and registers it metadata for later retrievable. */

    }, {
      key: 'registerCell',
      value: function registerCell(_ref4) {
        var cellMetadatum = _ref4.cellMetadatum,
            index = _ref4.index;

        this._cellMetadata[index] = cellMetadatum;

        this.getSections(cellMetadatum).forEach(function (section) {
          return section.addCellIndex({ index: index });
        });
      }
    }]);
    return SectionManager;
  }();

  exports.default = SectionManager;
  },{"./Section":1190,"./types":1193,"babel-runtime/core-js/object/keys":580,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"prop-types":1249}],1192:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Collection = undefined;

  var _Collection = require('./Collection');

  var _Collection2 = _interopRequireDefault(_Collection);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _Collection2.default;
  exports.Collection = _Collection2.default;
  },{"./Collection":1188}],1193:[function(require,module,exports){
  "use strict";

  var babelPluginFlowReactPropTypes_proptype_Index = "production" === 'production' ? null : {
    index: require("prop-types").number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_Index", {
    value: babelPluginFlowReactPropTypes_proptype_Index,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_PositionInfo = "production" === 'production' ? null : {
    x: require("prop-types").number.isRequired,
    y: require("prop-types").number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_PositionInfo", {
    value: babelPluginFlowReactPropTypes_proptype_PositionInfo,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_ScrollPosition = "production" === 'production' ? null : {
    scrollLeft: require("prop-types").number.isRequired,
    scrollTop: require("prop-types").number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_ScrollPosition", {
    value: babelPluginFlowReactPropTypes_proptype_ScrollPosition,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo = "production" === 'production' ? null : {
    height: require("prop-types").number.isRequired,
    width: require("prop-types").number.isRequired,
    x: require("prop-types").number.isRequired,
    y: require("prop-types").number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo", {
    value: babelPluginFlowReactPropTypes_proptype_SizeAndPositionInfo,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_SizeInfo = "production" === 'production' ? null : {
    height: require("prop-types").number.isRequired,
    width: require("prop-types").number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_SizeInfo", {
    value: babelPluginFlowReactPropTypes_proptype_SizeInfo,
    configurable: true
  });
  },{"prop-types":1249}],1194:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = calculateSizeAndPositionData;

  var _SectionManager = require('../SectionManager');

  var _SectionManager2 = _interopRequireDefault(_SectionManager);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function calculateSizeAndPositionData(_ref) {
    var cellCount = _ref.cellCount,
        cellSizeAndPositionGetter = _ref.cellSizeAndPositionGetter,
        sectionSize = _ref.sectionSize;

    var cellMetadata = [];
    var sectionManager = new _SectionManager2.default(sectionSize);
    var height = 0;
    var width = 0;

    for (var index = 0; index < cellCount; index++) {
      var cellMetadatum = cellSizeAndPositionGetter({ index: index });

      if (cellMetadatum.height == null || isNaN(cellMetadatum.height) || cellMetadatum.width == null || isNaN(cellMetadatum.width) || cellMetadatum.x == null || isNaN(cellMetadatum.x) || cellMetadatum.y == null || isNaN(cellMetadatum.y)) {
        throw Error('Invalid metadata returned for cell ' + index + ':\n        x:' + cellMetadatum.x + ', y:' + cellMetadatum.y + ', width:' + cellMetadatum.width + ', height:' + cellMetadatum.height);
      }

      height = Math.max(height, cellMetadatum.y + cellMetadatum.height);
      width = Math.max(width, cellMetadatum.x + cellMetadatum.width);

      cellMetadata[index] = cellMetadatum;
      sectionManager.registerCell({
        cellMetadatum: cellMetadatum,
        index: index
      });
    }

    return {
      cellMetadata: cellMetadata,
      height: height,
      sectionManager: sectionManager,
      width: width
    };
  }
  },{"../SectionManager":1191}],1195:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * High-order component that auto-calculates column-widths for `Grid` cells.
   */
  var ColumnSizer = function (_PureComponent) {
    (0, _inherits3.default)(ColumnSizer, _PureComponent);

    function ColumnSizer(props, context) {
      (0, _classCallCheck3.default)(this, ColumnSizer);

      var _this = (0, _possibleConstructorReturn3.default)(this, (ColumnSizer.__proto__ || (0, _getPrototypeOf2.default)(ColumnSizer)).call(this, props, context));

      _this._registerChild = _this._registerChild.bind(_this);
      return _this;
    }

    (0, _createClass3.default)(ColumnSizer, [{
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        var _props = this.props,
            columnMaxWidth = _props.columnMaxWidth,
            columnMinWidth = _props.columnMinWidth,
            columnCount = _props.columnCount,
            width = _props.width;


        if (columnMaxWidth !== prevProps.columnMaxWidth || columnMinWidth !== prevProps.columnMinWidth || columnCount !== prevProps.columnCount || width !== prevProps.width) {
          if (this._registeredChild) {
            this._registeredChild.recomputeGridSize();
          }
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props2 = this.props,
            children = _props2.children,
            columnMaxWidth = _props2.columnMaxWidth,
            columnMinWidth = _props2.columnMinWidth,
            columnCount = _props2.columnCount,
            width = _props2.width;


        var safeColumnMinWidth = columnMinWidth || 1;

        var safeColumnMaxWidth = columnMaxWidth ? Math.min(columnMaxWidth, width) : width;

        var columnWidth = width / columnCount;
        columnWidth = Math.max(safeColumnMinWidth, columnWidth);
        columnWidth = Math.min(safeColumnMaxWidth, columnWidth);
        columnWidth = Math.floor(columnWidth);

        var adjustedWidth = Math.min(width, columnWidth * columnCount);

        return children({
          adjustedWidth: adjustedWidth,
          columnWidth: columnWidth,
          getColumnWidth: function getColumnWidth() {
            return columnWidth;
          },
          registerChild: this._registerChild
        });
      }
    }, {
      key: '_registerChild',
      value: function _registerChild(child) {
        if (child && typeof child.recomputeGridSize !== 'function') {
          throw Error('Unexpected child type registered; only Grid/MultiGrid children are supported.');
        }

        this._registeredChild = child;

        if (this._registeredChild) {
          this._registeredChild.recomputeGridSize();
        }
      }
    }]);
    return ColumnSizer;
  }(_react.PureComponent);

  exports.default = ColumnSizer;
  ColumnSizer.propTypes = "production" !== "production" ? {
    /**
     * Function responsible for rendering a virtualized Grid.
     * This function should implement the following signature:
     * ({ adjustedWidth, getColumnWidth, registerChild }) => PropTypes.element
     *
     * The specified :getColumnWidth function should be passed to the Grid's :columnWidth property.
     * The :registerChild should be passed to the Grid's :ref property.
     * The :adjustedWidth property is optional; it reflects the lesser of the overall width or the width of all columns.
     */
    children: _propTypes2.default.func.isRequired,

    /** Optional maximum allowed column width */
    columnMaxWidth: _propTypes2.default.number,

    /** Optional minimum allowed column width */
    columnMinWidth: _propTypes2.default.number,

    /** Number of columns in Grid or Table child */
    columnCount: _propTypes2.default.number.isRequired,

    /** Width of Grid or Table child */
    width: _propTypes2.default.number.isRequired
  } : {};
  },{"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1196:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ColumnSizer = undefined;

  var _ColumnSizer = require('./ColumnSizer');

  var _ColumnSizer2 = _interopRequireDefault(_ColumnSizer);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _ColumnSizer2.default;
  exports.ColumnSizer = _ColumnSizer2.default;
  },{"./ColumnSizer":1195}],1197:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  var _classnames = require('classnames');

  var _classnames2 = _interopRequireDefault(_classnames);

  var _calculateSizeAndPositionDataAndUpdateScrollOffset = require('./utils/calculateSizeAndPositionDataAndUpdateScrollOffset');

  var _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset);

  var _ScalingCellSizeAndPositionManager = require('./utils/ScalingCellSizeAndPositionManager');

  var _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);

  var _createCallbackMemoizer = require('../utils/createCallbackMemoizer');

  var _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);

  var _defaultOverscanIndicesGetter = require('./defaultOverscanIndicesGetter');

  var _defaultOverscanIndicesGetter2 = _interopRequireDefault(_defaultOverscanIndicesGetter);

  var _updateScrollIndexHelper = require('./utils/updateScrollIndexHelper');

  var _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper);

  var _defaultCellRangeRenderer = require('./defaultCellRangeRenderer');

  var _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer);

  var _scrollbarSize = require('dom-helpers/util/scrollbarSize');

  var _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);

  var _requestAnimationTimeout = require('../utils/requestAnimationTimeout');

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_Alignment = require('./types').babelPluginFlowReactPropTypes_proptype_Alignment || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter = require('./types').babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_RenderedSection = require('./types').babelPluginFlowReactPropTypes_proptype_RenderedSection || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange = require('./types').babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_Scroll = require('./types').babelPluginFlowReactPropTypes_proptype_Scroll || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_NoContentRenderer = require('./types').babelPluginFlowReactPropTypes_proptype_NoContentRenderer || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellSizeGetter = require('./types').babelPluginFlowReactPropTypes_proptype_CellSizeGetter || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellSize = require('./types').babelPluginFlowReactPropTypes_proptype_CellSize || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellPosition = require('./types').babelPluginFlowReactPropTypes_proptype_CellPosition || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellRangeRenderer = require('./types').babelPluginFlowReactPropTypes_proptype_CellRangeRenderer || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellRenderer = require('./types').babelPluginFlowReactPropTypes_proptype_CellRenderer || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId = require('../utils/requestAnimationTimeout').babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId || require('prop-types').any;

  /**
   * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.
   * This improves performance and makes scrolling smoother.
   */
  var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;

  /**
   * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.
   * This prevents Grid from interrupting mouse-wheel animations (see issue #2).
   */
  var SCROLL_POSITION_CHANGE_REASONS = {
    OBSERVED: 'observed',
    REQUESTED: 'requested'
  };

  var renderNull = function renderNull() {
    return null;
  };

  /**
   * Renders tabular data with virtualization along the vertical and horizontal axes.
   * Row heights and column widths must be known ahead of time and specified as properties.
   */
  var Grid = function (_React$PureComponent) {
    (0, _inherits3.default)(Grid, _React$PureComponent);

    // Invokes onSectionRendered callback only when start/stop row or column indices change
    function Grid(props) {
      (0, _classCallCheck3.default)(this, Grid);

      var _this = (0, _possibleConstructorReturn3.default)(this, (Grid.__proto__ || (0, _getPrototypeOf2.default)(Grid)).call(this, props));

      _this.state = {
        isScrolling: false,
        scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
        scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
        scrollLeft: 0,
        scrollTop: 0,
        scrollPositionChangeReason: null
      };
      _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)();
      _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);
      _this._deferredInvalidateColumnIndex = null;
      _this._deferredInvalidateRowIndex = null;
      _this._recomputeScrollLeftFlag = false;
      _this._recomputeScrollTopFlag = false;
      _this._horizontalScrollBarSize = 0;
      _this._verticalScrollBarSize = 0;
      _this._scrollbarPresenceChanged = false;
      _this._cellCache = {};
      _this._styleCache = {};
      _this._scrollbarSizeMeasured = false;
      _this._renderedColumnStartIndex = 0;
      _this._renderedColumnStopIndex = 0;
      _this._renderedRowStartIndex = 0;
      _this._renderedRowStopIndex = 0;

      _this._debounceScrollEndedCallback = function () {
        _this._disablePointerEventsTimeoutId = null;
        _this._resetStyleCache();
      };

      _this._invokeOnGridRenderedHelper = function () {
        var onSectionRendered = _this.props.onSectionRendered;


        _this._onGridRenderedMemoizer({
          callback: onSectionRendered,
          indices: {
            columnOverscanStartIndex: _this._columnStartIndex,
            columnOverscanStopIndex: _this._columnStopIndex,
            columnStartIndex: _this._renderedColumnStartIndex,
            columnStopIndex: _this._renderedColumnStopIndex,
            rowOverscanStartIndex: _this._rowStartIndex,
            rowOverscanStopIndex: _this._rowStopIndex,
            rowStartIndex: _this._renderedRowStartIndex,
            rowStopIndex: _this._renderedRowStopIndex
          }
        });
      };

      _this._setScrollingContainerRef = function (ref) {
        _this._scrollingContainer = ref;
      };

      _this._onScroll = function (event) {
        // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
        // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
        // See issue #404 for more information.
        if (event.target === _this._scrollingContainer) {
          _this.handleScrollEvent(event.target);
        }
      };

      _this._columnWidthGetter = _this._wrapSizeGetter(props.columnWidth);
      _this._rowHeightGetter = _this._wrapSizeGetter(props.rowHeight);

      _this._columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
        cellCount: props.columnCount,
        cellSizeGetter: function cellSizeGetter(params) {
          return _this._columnWidthGetter(params);
        },
        estimatedCellSize: _this._getEstimatedColumnSize(props)
      });
      _this._rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
        cellCount: props.rowCount,
        cellSizeGetter: function cellSizeGetter(params) {
          return _this._rowHeightGetter(params);
        },
        estimatedCellSize: _this._getEstimatedRowSize(props)
      });
      return _this;
    }

    /**
     * Gets offsets for a given cell and alignment.
     */


    // See defaultCellRangeRenderer() for more information on the usage of these caches


    (0, _createClass3.default)(Grid, [{
      key: 'getOffsetForCell',
      value: function getOffsetForCell() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$alignment = _ref.alignment,
            alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,
            _ref$columnIndex = _ref.columnIndex,
            columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,
            _ref$rowIndex = _ref.rowIndex,
            rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;

        var offsetProps = (0, _extends3.default)({}, this.props, {
          scrollToAlignment: alignment,
          scrollToColumn: columnIndex,
          scrollToRow: rowIndex
        });

        return {
          scrollLeft: this._getCalculatedScrollLeft(offsetProps),
          scrollTop: this._getCalculatedScrollTop(offsetProps)
        };
      }

      /**
       * This method handles a scroll event originating from an external scroll control.
       * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.
       */

    }, {
      key: 'handleScrollEvent',
      value: function handleScrollEvent(_ref2) {
        var _ref2$scrollLeft = _ref2.scrollLeft,
            scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,
            _ref2$scrollTop = _ref2.scrollTop,
            scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop;

        // On iOS, we can arrive at negative offsets by swiping past the start.
        // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.
        if (scrollTopParam < 0) {
          return;
        }

        // Prevent pointer events from interrupting a smooth scroll
        this._debounceScrollEnded();

        var _props = this.props,
            autoHeight = _props.autoHeight,
            autoWidth = _props.autoWidth,
            height = _props.height,
            width = _props.width;

        // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
        // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
        // This causes a series of rapid renders that is slow for long lists.
        // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.

        var scrollbarSize = this._scrollbarSize;
        var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();
        var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
        var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);
        var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);

        // Certain devices (like Apple touchpad) rapid-fire duplicate events.
        // Don't force a re-render if this is the case.
        // The mouse may move faster then the animation frame does.
        // Use requestAnimationFrame to avoid over-updating.
        if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
          // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.
          // Don't change direction for an axis unless scroll offset has changed.
          var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;
          var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;

          var newState = {
            isScrolling: true,
            scrollDirectionHorizontal: _scrollDirectionHorizontal,
            scrollDirectionVertical: _scrollDirectionVertical,
            scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
          };

          if (!autoHeight) {
            newState.scrollTop = scrollTop;
          }

          if (!autoWidth) {
            newState.scrollLeft = scrollLeft;
          }

          this.setState(newState);
        }

        this._invokeOnScrollMemoizer({
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          totalColumnsWidth: totalColumnsWidth,
          totalRowsHeight: totalRowsHeight
        });
      }

      /**
       * Invalidate Grid size and recompute visible cells.
       * This is a deferred wrapper for recomputeGridSize().
       * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.
       * This method is intended for advanced use-cases like CellMeasurer.
       */
      // @TODO (bvaughn) Add automated test coverage for this.

    }, {
      key: 'invalidateCellSizeAfterRender',
      value: function invalidateCellSizeAfterRender(_ref3) {
        var columnIndex = _ref3.columnIndex,
            rowIndex = _ref3.rowIndex;

        this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
        this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
      }

      /**
       * Pre-measure all columns and rows in a Grid.
       * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.
       * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).
       */

    }, {
      key: 'measureAllCells',
      value: function measureAllCells() {
        var _props2 = this.props,
            columnCount = _props2.columnCount,
            rowCount = _props2.rowCount;


        this._columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);
        this._rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
      }

      /**
       * Forced recompute of row heights and column widths.
       * This function should be called if dynamic column or row sizes have changed but nothing else has.
       * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.
       */

    }, {
      key: 'recomputeGridSize',
      value: function recomputeGridSize() {
        var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref4$columnIndex = _ref4.columnIndex,
            columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,
            _ref4$rowIndex = _ref4.rowIndex,
            rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;

        var _props3 = this.props,
            scrollToColumn = _props3.scrollToColumn,
            scrollToRow = _props3.scrollToRow;


        this._columnSizeAndPositionManager.resetCell(columnIndex);
        this._rowSizeAndPositionManager.resetCell(rowIndex);

        // Cell sizes may be determined by a function property.
        // In this case the cDU handler can't know if they changed.
        // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.
        this._recomputeScrollLeftFlag = scrollToColumn >= 0 && columnIndex <= scrollToColumn;
        this._recomputeScrollTopFlag = scrollToRow >= 0 && rowIndex <= scrollToRow;

        // Clear cell cache in case we are scrolling;
        // Invalid row heights likely mean invalid cached content as well.
        this._cellCache = {};
        this._styleCache = {};

        this.forceUpdate();
      }

      /**
       * Ensure column and row are visible.
       */

    }, {
      key: 'scrollToCell',
      value: function scrollToCell(_ref5) {
        var columnIndex = _ref5.columnIndex,
            rowIndex = _ref5.rowIndex;
        var columnCount = this.props.columnCount;


        var props = this.props;

        // Don't adjust scroll offset for single-column grids (eg List, Table).
        // This can cause a funky scroll offset because of the vertical scrollbar width.
        if (columnCount > 1 && columnIndex !== undefined) {
          this._updateScrollLeftForScrollToColumn((0, _extends3.default)({}, props, {
            scrollToColumn: columnIndex
          }));
        }

        if (rowIndex !== undefined) {
          this._updateScrollTopForScrollToRow((0, _extends3.default)({}, props, {
            scrollToRow: rowIndex
          }));
        }
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _props4 = this.props,
            getScrollbarSize = _props4.getScrollbarSize,
            height = _props4.height,
            scrollLeft = _props4.scrollLeft,
            scrollToColumn = _props4.scrollToColumn,
            scrollTop = _props4.scrollTop,
            scrollToRow = _props4.scrollToRow,
            width = _props4.width;

        // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
        // We must do this at the start of the method as we may calculate and update scroll position below.

        this._handleInvalidatedGridSize();

        // If this component was first rendered server-side, scrollbar size will be undefined.
        // In that event we need to remeasure.
        if (!this._scrollbarSizeMeasured) {
          this._scrollbarSize = getScrollbarSize();
          this._scrollbarSizeMeasured = true;
          this.setState({});
        }

        if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {
          this.scrollToPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });
        }

        // Don't update scroll offset if the size is 0; we don't render any cells in this case.
        // Setting a state may cause us to later thing we've updated the offce when we haven't.
        var sizeIsBiggerThanZero = height > 0 && width > 0;
        if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {
          this._updateScrollLeftForScrollToColumn();
        }
        if (scrollToRow >= 0 && sizeIsBiggerThanZero) {
          this._updateScrollTopForScrollToRow();
        }

        // Update onRowsRendered callback
        this._invokeOnGridRenderedHelper();

        // Initialize onScroll callback
        this._invokeOnScrollMemoizer({
          scrollLeft: scrollLeft || 0,
          scrollTop: scrollTop || 0,
          totalColumnsWidth: this._columnSizeAndPositionManager.getTotalSize(),
          totalRowsHeight: this._rowSizeAndPositionManager.getTotalSize()
        });

        this._maybeCallOnScrollbarPresenceChange();
      }

      /**
       * @private
       * This method updates scrollLeft/scrollTop in state for the following conditions:
       * 1) New scroll-to-cell props have been set
       */

    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var _this2 = this;

        var _props5 = this.props,
            autoHeight = _props5.autoHeight,
            autoWidth = _props5.autoWidth,
            columnCount = _props5.columnCount,
            height = _props5.height,
            rowCount = _props5.rowCount,
            scrollToAlignment = _props5.scrollToAlignment,
            scrollToColumn = _props5.scrollToColumn,
            scrollToRow = _props5.scrollToRow,
            width = _props5.width;
        var _state = this.state,
            scrollLeft = _state.scrollLeft,
            scrollPositionChangeReason = _state.scrollPositionChangeReason,
            scrollTop = _state.scrollTop;

        // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.
        // We must do this at the start of the method as we may calculate and update scroll position below.

        this._handleInvalidatedGridSize();

        // Handle edge case where column or row count has only just increased over 0.
        // In this case we may have to restore a previously-specified scroll offset.
        // For more info see bvaughn/react-virtualized/issues/218
        var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;

        // Make sure requested changes to :scrollLeft or :scrollTop get applied.
        // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
        // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
        // So we only set these when we require an adjustment of the scroll position.
        // See issue #2 for more information.
        if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
          // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).
          // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.
          if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {
            this._scrollingContainer.scrollLeft = scrollLeft;
          }
          if (!autoHeight && scrollTop >= 0 && (scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {
            this._scrollingContainer.scrollTop = scrollTop;
          }
        }

        // Special case where the previous size was 0:
        // In this case we don't show any windowed cells at all.
        // So we should always recalculate offset afterwards.
        var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;

        // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it
        // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?
        if (this._recomputeScrollLeftFlag) {
          this._recomputeScrollLeftFlag = false;
          this._updateScrollLeftForScrollToColumn(this.props);
        } else {
          (0, _updateScrollIndexHelper2.default)({
            cellSizeAndPositionManager: this._columnSizeAndPositionManager,
            previousCellsCount: prevProps.columnCount,
            previousCellSize: prevProps.columnWidth,
            previousScrollToAlignment: prevProps.scrollToAlignment,
            previousScrollToIndex: prevProps.scrollToColumn,
            previousSize: prevProps.width,
            scrollOffset: scrollLeft,
            scrollToAlignment: scrollToAlignment,
            scrollToIndex: scrollToColumn,
            size: width,
            sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
            updateScrollIndexCallback: function updateScrollIndexCallback() {
              return _this2._updateScrollLeftForScrollToColumn(_this2.props);
            }
          });
        }

        if (this._recomputeScrollTopFlag) {
          this._recomputeScrollTopFlag = false;
          this._updateScrollTopForScrollToRow(this.props);
        } else {
          (0, _updateScrollIndexHelper2.default)({
            cellSizeAndPositionManager: this._rowSizeAndPositionManager,
            previousCellsCount: prevProps.rowCount,
            previousCellSize: prevProps.rowHeight,
            previousScrollToAlignment: prevProps.scrollToAlignment,
            previousScrollToIndex: prevProps.scrollToRow,
            previousSize: prevProps.height,
            scrollOffset: scrollTop,
            scrollToAlignment: scrollToAlignment,
            scrollToIndex: scrollToRow,
            size: height,
            sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,
            updateScrollIndexCallback: function updateScrollIndexCallback() {
              return _this2._updateScrollTopForScrollToRow(_this2.props);
            }
          });
        }

        // Update onRowsRendered callback if start/stop indices have changed
        this._invokeOnGridRenderedHelper();

        // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners
        if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
          var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();
          var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();

          this._invokeOnScrollMemoizer({
            scrollLeft: scrollLeft,
            scrollTop: scrollTop,
            totalColumnsWidth: totalColumnsWidth,
            totalRowsHeight: totalRowsHeight
          });
        }

        this._maybeCallOnScrollbarPresenceChange();
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var getScrollbarSize = this.props.getScrollbarSize;

        // If this component is being rendered server-side, getScrollbarSize() will return undefined.
        // We handle this case in componentDidMount()

        this._scrollbarSize = getScrollbarSize();
        if (this._scrollbarSize === undefined) {
          this._scrollbarSizeMeasured = false;
          this._scrollbarSize = 0;
        } else {
          this._scrollbarSizeMeasured = true;
        }

        this._calculateChildrenToRender();
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this._disablePointerEventsTimeoutId) {
          (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
        }
      }

      /**
       * @private
       * This method updates scrollLeft/scrollTop in state for the following conditions:
       * 1) Empty content (0 rows or columns)
       * 2) New scroll props overriding the current state
       * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid
       */

    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var _this3 = this;

        var _state2 = this.state,
            scrollLeft = _state2.scrollLeft,
            scrollTop = _state2.scrollTop;


        if (nextProps.columnCount === 0 && scrollLeft !== 0 || nextProps.rowCount === 0 && scrollTop !== 0) {
          this.scrollToPosition({
            scrollLeft: 0,
            scrollTop: 0
          });
        } else if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
          var newState = {};

          if (nextProps.scrollLeft != null) {
            newState.scrollLeft = nextProps.scrollLeft;
          }
          if (nextProps.scrollTop != null) {
            newState.scrollTop = nextProps.scrollTop;
          }

          this.scrollToPosition(newState);
        }

        if (nextProps.columnWidth !== this.props.columnWidth || nextProps.rowHeight !== this.props.rowHeight) {
          this._styleCache = {};
        }

        this._columnWidthGetter = this._wrapSizeGetter(nextProps.columnWidth);
        this._rowHeightGetter = this._wrapSizeGetter(nextProps.rowHeight);

        this._columnSizeAndPositionManager.configure({
          cellCount: nextProps.columnCount,
          estimatedCellSize: this._getEstimatedColumnSize(nextProps)
        });
        this._rowSizeAndPositionManager.configure({
          cellCount: nextProps.rowCount,
          estimatedCellSize: this._getEstimatedRowSize(nextProps)
        });

        var _props6 = this.props,
            columnCount = _props6.columnCount,
            rowCount = _props6.rowCount;

        // Special case when either cols or rows were 0
        // This would prevent any cells from rendering
        // So we need to reset row scroll if cols changed from 0 (and vice versa)

        if (columnCount === 0 || rowCount === 0) {
          columnCount = 0;
          rowCount = 0;
        }

        // If scrolling is controlled outside this component, clear cache when scrolling stops
        if (nextProps.autoHeight && nextProps.isScrolling === false && this.props.isScrolling === true) {
          this._resetStyleCache();
        }

        // Update scroll offsets if the size or number of cells have changed, invalidating the previous value
        (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
          cellCount: columnCount,
          cellSize: typeof this.props.columnWidth === 'number' ? this.props.columnWidth : null,
          computeMetadataCallback: function computeMetadataCallback() {
            return _this3._columnSizeAndPositionManager.resetCell(0);
          },
          computeMetadataCallbackProps: nextProps,
          nextCellsCount: nextProps.columnCount,
          nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,
          nextScrollToIndex: nextProps.scrollToColumn,
          scrollToIndex: this.props.scrollToColumn,
          updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
            return _this3._updateScrollLeftForScrollToColumn(nextProps, _this3.state);
          }
        });
        (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
          cellCount: rowCount,
          cellSize: typeof this.props.rowHeight === 'number' ? this.props.rowHeight : null,
          computeMetadataCallback: function computeMetadataCallback() {
            return _this3._rowSizeAndPositionManager.resetCell(0);
          },
          computeMetadataCallbackProps: nextProps,
          nextCellsCount: nextProps.rowCount,
          nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,
          nextScrollToIndex: nextProps.scrollToRow,
          scrollToIndex: this.props.scrollToRow,
          updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
            return _this3._updateScrollTopForScrollToRow(nextProps, _this3.state);
          }
        });
      }
    }, {
      key: 'componentWillUpdate',
      value: function componentWillUpdate(nextProps, nextState) {
        this._calculateChildrenToRender(nextProps, nextState);
      }
    }, {
      key: 'render',
      value: function render() {
        var _props7 = this.props,
            autoContainerWidth = _props7.autoContainerWidth,
            autoHeight = _props7.autoHeight,
            autoWidth = _props7.autoWidth,
            className = _props7.className,
            containerProps = _props7.containerProps,
            containerRole = _props7.containerRole,
            containerStyle = _props7.containerStyle,
            height = _props7.height,
            id = _props7.id,
            noContentRenderer = _props7.noContentRenderer,
            role = _props7.role,
            style = _props7.style,
            tabIndex = _props7.tabIndex,
            width = _props7.width;


        var isScrolling = this._isScrolling();

        var gridStyle = {
          boxSizing: 'border-box',
          direction: 'ltr',
          height: autoHeight ? 'auto' : height,
          position: 'relative',
          width: autoWidth ? 'auto' : width,
          WebkitOverflowScrolling: 'touch',
          willChange: 'transform'
        };

        var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
        var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();

        // Force browser to hide scrollbars when we know they aren't necessary.
        // Otherwise once scrollbars appear they may not disappear again.
        // For more info see issue #116
        var verticalScrollBarSize = totalRowsHeight > height ? this._scrollbarSize : 0;
        var horizontalScrollBarSize = totalColumnsWidth > width ? this._scrollbarSize : 0;

        if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {
          this._horizontalScrollBarSize = horizontalScrollBarSize;
          this._verticalScrollBarSize = verticalScrollBarSize;
          this._scrollbarPresenceChanged = true;
        }

        // Also explicitly init styles to 'auto' if scrollbars are required.
        // This works around an obscure edge case where external CSS styles have not yet been loaded,
        // But an initial scroll index of offset is set as an external prop.
        // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
        // This was originally reported via clauderic/react-infinite-calendar/issues/23
        gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';
        gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';

        var childrenToDisplay = this._childrenToDisplay;

        var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;

        return React.createElement(
          'div',
          (0, _extends3.default)({
            ref: this._setScrollingContainerRef
          }, containerProps, {
            'aria-label': this.props['aria-label'],
            'aria-readonly': this.props['aria-readonly'],
            className: (0, _classnames2.default)('ReactVirtualized__Grid', className),
            id: id,
            onScroll: this._onScroll,
            role: role,
            style: (0, _extends3.default)({}, gridStyle, style),
            tabIndex: tabIndex }),
          childrenToDisplay.length > 0 && React.createElement(
            'div',
            {
              className: 'ReactVirtualized__Grid__innerScrollContainer',
              role: containerRole,
              style: (0, _extends3.default)({
                width: autoContainerWidth ? 'auto' : totalColumnsWidth,
                height: totalRowsHeight,
                maxWidth: totalColumnsWidth,
                maxHeight: totalRowsHeight,
                overflow: 'hidden',
                pointerEvents: isScrolling ? 'none' : '',
                position: 'relative'
              }, containerStyle) },
            childrenToDisplay
          ),
          showNoContentRenderer && noContentRenderer()
        );
      }

      /* ---------------------------- Helper methods ---------------------------- */

    }, {
      key: '_calculateChildrenToRender',
      value: function _calculateChildrenToRender() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
        var cellRenderer = props.cellRenderer,
            cellRangeRenderer = props.cellRangeRenderer,
            columnCount = props.columnCount,
            deferredMeasurementCache = props.deferredMeasurementCache,
            height = props.height,
            overscanColumnCount = props.overscanColumnCount,
            overscanIndicesGetter = props.overscanIndicesGetter,
            overscanRowCount = props.overscanRowCount,
            rowCount = props.rowCount,
            width = props.width;
        var scrollDirectionHorizontal = state.scrollDirectionHorizontal,
            scrollDirectionVertical = state.scrollDirectionVertical,
            scrollLeft = state.scrollLeft,
            scrollTop = state.scrollTop;


        var isScrolling = this._isScrolling(props, state);

        this._childrenToDisplay = [];

        // Render only enough columns and rows to cover the visible area of the grid.
        if (height > 0 && width > 0) {
          var visibleColumnIndices = this._columnSizeAndPositionManager.getVisibleCellRange({
            containerSize: width,
            offset: scrollLeft
          });
          var visibleRowIndices = this._rowSizeAndPositionManager.getVisibleCellRange({
            containerSize: height,
            offset: scrollTop
          });

          var horizontalOffsetAdjustment = this._columnSizeAndPositionManager.getOffsetAdjustment({
            containerSize: width,
            offset: scrollLeft
          });
          var verticalOffsetAdjustment = this._rowSizeAndPositionManager.getOffsetAdjustment({
            containerSize: height,
            offset: scrollTop
          });

          // Store for _invokeOnGridRenderedHelper()
          this._renderedColumnStartIndex = visibleColumnIndices.start;
          this._renderedColumnStopIndex = visibleColumnIndices.stop;
          this._renderedRowStartIndex = visibleRowIndices.start;
          this._renderedRowStopIndex = visibleRowIndices.stop;

          var overscanColumnIndices = overscanIndicesGetter({
            direction: 'horizontal',
            cellCount: columnCount,
            overscanCellsCount: overscanColumnCount,
            scrollDirection: scrollDirectionHorizontal,
            startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,
            stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1
          });

          var overscanRowIndices = overscanIndicesGetter({
            direction: 'vertical',
            cellCount: rowCount,
            overscanCellsCount: overscanRowCount,
            scrollDirection: scrollDirectionVertical,
            startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,
            stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1
          });

          // Store for _invokeOnGridRenderedHelper()
          this._columnStartIndex = overscanColumnIndices.overscanStartIndex;
          this._columnStopIndex = overscanColumnIndices.overscanStopIndex;
          this._rowStartIndex = overscanRowIndices.overscanStartIndex;
          this._rowStopIndex = overscanRowIndices.overscanStopIndex;

          // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.
          if (deferredMeasurementCache) {
            // If rows have a dynamic height, scan the rows we are about to render.
            // If any have not yet been measured, then we need to render all columns initially,
            // Because the height of the row is equal to the tallest cell within that row,
            // (And so we can't know the height without measuring all column-cells first).
            if (!deferredMeasurementCache.hasFixedHeight()) {
              for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {
                if (!deferredMeasurementCache.has(rowIndex, 0)) {
                  this._columnStartIndex = 0;
                  this._columnStopIndex = columnCount - 1;
                  break;
                }
              }
            }

            // If columns have a dynamic width, scan the columns we are about to render.
            // If any have not yet been measured, then we need to render all rows initially,
            // Because the width of the column is equal to the widest cell within that column,
            // (And so we can't know the width without measuring all row-cells first).
            if (!deferredMeasurementCache.hasFixedWidth()) {
              for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
                if (!deferredMeasurementCache.has(0, columnIndex)) {
                  this._rowStartIndex = 0;
                  this._rowStopIndex = rowCount - 1;
                  break;
                }
              }
            }
          }

          this._childrenToDisplay = cellRangeRenderer({
            cellCache: this._cellCache,
            cellRenderer: cellRenderer,
            columnSizeAndPositionManager: this._columnSizeAndPositionManager,
            columnStartIndex: this._columnStartIndex,
            columnStopIndex: this._columnStopIndex,
            deferredMeasurementCache: deferredMeasurementCache,
            horizontalOffsetAdjustment: horizontalOffsetAdjustment,
            isScrolling: isScrolling,
            parent: this,
            rowSizeAndPositionManager: this._rowSizeAndPositionManager,
            rowStartIndex: this._rowStartIndex,
            rowStopIndex: this._rowStopIndex,
            scrollLeft: scrollLeft,
            scrollTop: scrollTop,
            styleCache: this._styleCache,
            verticalOffsetAdjustment: verticalOffsetAdjustment,
            visibleColumnIndices: visibleColumnIndices,
            visibleRowIndices: visibleRowIndices
          });
        }
      }

      /**
       * Sets an :isScrolling flag for a small window of time.
       * This flag is used to disable pointer events on the scrollable portion of the Grid.
       * This prevents jerky/stuttery mouse-wheel scrolling.
       */

    }, {
      key: '_debounceScrollEnded',
      value: function _debounceScrollEnded() {
        var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;


        if (this._disablePointerEventsTimeoutId) {
          (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
        }

        this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
      }
    }, {
      key: '_getEstimatedColumnSize',
      value: function _getEstimatedColumnSize(props) {
        return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;
      }
    }, {
      key: '_getEstimatedRowSize',
      value: function _getEstimatedRowSize(props) {
        return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;
      }

      /**
       * Check for batched CellMeasurer size invalidations.
       * This will occur the first time one or more previously unmeasured cells are rendered.
       */

    }, {
      key: '_handleInvalidatedGridSize',
      value: function _handleInvalidatedGridSize() {
        if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {
          var columnIndex = this._deferredInvalidateColumnIndex;
          var rowIndex = this._deferredInvalidateRowIndex;

          this._deferredInvalidateColumnIndex = null;
          this._deferredInvalidateRowIndex = null;

          this.recomputeGridSize({ columnIndex: columnIndex, rowIndex: rowIndex });
        }
      }
    }, {
      key: '_invokeOnScrollMemoizer',
      value: function _invokeOnScrollMemoizer(_ref6) {
        var _this4 = this;

        var scrollLeft = _ref6.scrollLeft,
            scrollTop = _ref6.scrollTop,
            totalColumnsWidth = _ref6.totalColumnsWidth,
            totalRowsHeight = _ref6.totalRowsHeight;

        this._onScrollMemoizer({
          callback: function callback(_ref7) {
            var scrollLeft = _ref7.scrollLeft,
                scrollTop = _ref7.scrollTop;
            var _props8 = _this4.props,
                height = _props8.height,
                onScroll = _props8.onScroll,
                width = _props8.width;


            onScroll({
              clientHeight: height,
              clientWidth: width,
              scrollHeight: totalRowsHeight,
              scrollLeft: scrollLeft,
              scrollTop: scrollTop,
              scrollWidth: totalColumnsWidth
            });
          },
          indices: {
            scrollLeft: scrollLeft,
            scrollTop: scrollTop
          }
        });
      }
    }, {
      key: '_isScrolling',
      value: function _isScrolling() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;

        // If isScrolling is defined in props, use it to override the value in state
        // This is a performance optimization for WindowScroller + Grid
        return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
      }
    }, {
      key: '_maybeCallOnScrollbarPresenceChange',
      value: function _maybeCallOnScrollbarPresenceChange() {
        if (this._scrollbarPresenceChanged) {
          var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;


          this._scrollbarPresenceChanged = false;

          _onScrollbarPresenceChange({
            horizontal: this._horizontalScrollBarSize > 0,
            size: this._scrollbarSize,
            vertical: this._verticalScrollBarSize > 0
          });
        }
      }
    }, {
      key: 'scrollToPosition',


      /**
       * Scroll to the specified offset(s).
       * Useful for animating position changes.
       */
      value: function scrollToPosition(_ref8) {
        var scrollLeft = _ref8.scrollLeft,
            scrollTop = _ref8.scrollTop;

        var newState = {
          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
        };

        if (typeof scrollLeft === 'number' && scrollLeft >= 0) {
          newState.scrollDirectionHorizontal = scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;
          newState.scrollLeft = scrollLeft;
        }

        if (typeof scrollTop === 'number' && scrollTop >= 0) {
          newState.scrollDirectionVertical = scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;
          newState.scrollTop = scrollTop;
        }

        if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== this.state.scrollTop) {
          this.setState(newState);
        }
      }
    }, {
      key: '_wrapSizeGetter',
      value: function _wrapSizeGetter(value) {
        return typeof value === 'function' ? value : function () {
          return value;
        };
      }
    }, {
      key: '_getCalculatedScrollLeft',
      value: function _getCalculatedScrollLeft() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
        var columnCount = props.columnCount,
            height = props.height,
            scrollToAlignment = props.scrollToAlignment,
            scrollToColumn = props.scrollToColumn,
            width = props.width;
        var scrollLeft = state.scrollLeft;


        if (columnCount > 0) {
          var finalColumn = columnCount - 1;
          var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);
          var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize();
          var scrollBarSize = totalRowsHeight > height ? this._scrollbarSize : 0;

          return this._columnSizeAndPositionManager.getUpdatedOffsetForIndex({
            align: scrollToAlignment,
            containerSize: width - scrollBarSize,
            currentOffset: scrollLeft,
            targetIndex: targetIndex
          });
        }
      }
    }, {
      key: '_updateScrollLeftForScrollToColumn',
      value: function _updateScrollLeftForScrollToColumn() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
        var scrollLeft = state.scrollLeft;

        var calculatedScrollLeft = this._getCalculatedScrollLeft(props, state);

        if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {
          this.scrollToPosition({
            scrollLeft: calculatedScrollLeft,
            scrollTop: -1
          });
        }
      }
    }, {
      key: '_getCalculatedScrollTop',
      value: function _getCalculatedScrollTop() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
        var height = props.height,
            rowCount = props.rowCount,
            scrollToAlignment = props.scrollToAlignment,
            scrollToRow = props.scrollToRow,
            width = props.width;
        var scrollTop = state.scrollTop;


        if (rowCount > 0) {
          var finalRow = rowCount - 1;
          var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);
          var totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
          var scrollBarSize = totalColumnsWidth > width ? this._scrollbarSize : 0;

          return this._rowSizeAndPositionManager.getUpdatedOffsetForIndex({
            align: scrollToAlignment,
            containerSize: height - scrollBarSize,
            currentOffset: scrollTop,
            targetIndex: targetIndex
          });
        }
      }
    }, {
      key: '_resetStyleCache',
      value: function _resetStyleCache() {
        var styleCache = this._styleCache;

        // Reset cell and style caches once scrolling stops.
        // This makes Grid simpler to use (since cells commonly change).
        // And it keeps the caches from growing too large.
        // Performance is most sensitive when a user is scrolling.
        this._cellCache = {};
        this._styleCache = {};

        // Copy over the visible cell styles so avoid unnecessary re-render.
        for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {
          for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
            var key = rowIndex + '-' + columnIndex;
            this._styleCache[key] = styleCache[key];
          }
        }

        this.setState({
          isScrolling: false
        });
      }
    }, {
      key: '_updateScrollTopForScrollToRow',
      value: function _updateScrollTopForScrollToRow() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;
        var scrollTop = state.scrollTop;

        var calculatedScrollTop = this._getCalculatedScrollTop(props, state);

        if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {
          this.scrollToPosition({
            scrollLeft: -1,
            scrollTop: calculatedScrollTop
          });
        }
      }
    }]);
    return Grid;
  }(React.PureComponent);

  Grid.defaultProps = {
    'aria-label': 'grid',
    'aria-readonly': true,
    autoContainerWidth: false,
    autoHeight: false,
    autoWidth: false,
    cellRangeRenderer: _defaultCellRangeRenderer2.default,
    containerRole: 'rowgroup',
    containerStyle: {},
    estimatedColumnSize: 100,
    estimatedRowSize: 30,
    getScrollbarSize: _scrollbarSize2.default,
    noContentRenderer: renderNull,
    onScroll: function onScroll() {},
    onScrollbarPresenceChange: function onScrollbarPresenceChange() {},
    onSectionRendered: function onSectionRendered() {},
    overscanColumnCount: 0,
    overscanIndicesGetter: _defaultOverscanIndicesGetter2.default,
    overscanRowCount: 10,
    role: 'grid',
    scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
    scrollToAlignment: 'auto',
    scrollToColumn: -1,
    scrollToRow: -1,
    style: {},
    tabIndex: 0
  };
  Grid.propTypes = "production" === 'production' ? null : {
    "aria-label": require('prop-types').string.isRequired,
    "aria-readonly": require('prop-types').bool,


    /**
     * Set the width of the inner scrollable container to 'auto'.
     * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.
     */
    autoContainerWidth: require('prop-types').bool.isRequired,


    /**
     * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.
     * Intended for use with WindowScroller
     */
    autoHeight: require('prop-types').bool.isRequired,


    /**
     * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.
     * Intended for use with WindowScroller
     */
    autoWidth: require('prop-types').bool.isRequired,


    /** Responsible for rendering a cell given an row and column index.  */
    cellRenderer: typeof babelPluginFlowReactPropTypes_proptype_CellRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_CellRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_CellRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_CellRenderer : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_CellRenderer).isRequired,


    /** Responsible for rendering a group of cells given their index ranges.  */
    cellRangeRenderer: typeof babelPluginFlowReactPropTypes_proptype_CellRangeRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_CellRangeRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_CellRangeRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_CellRangeRenderer : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_CellRangeRenderer).isRequired,


    /** Optional custom CSS class name to attach to root Grid element.  */
    className: require('prop-types').string,


    /** Number of columns in grid.  */
    columnCount: require('prop-types').number.isRequired,


    /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */
    columnWidth: typeof babelPluginFlowReactPropTypes_proptype_CellSize === 'function' ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,


    /** Unfiltered props for the Grid container. */
    containerProps: require('prop-types').object,


    /** ARIA role for the cell-container.  */
    containerRole: require('prop-types').string.isRequired,


    /** Optional inline style applied to inner cell-container */
    containerStyle: require('prop-types').object.isRequired,


    /**
     * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.
     * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.
     */
    deferredMeasurementCache: require('prop-types').object,


    /**
     * Used to estimate the total width of a Grid before all of its columns have actually been measured.
     * The estimated total width is adjusted as columns are rendered.
     */
    estimatedColumnSize: require('prop-types').number.isRequired,


    /**
     * Used to estimate the total height of a Grid before all of its rows have actually been measured.
     * The estimated total height is adjusted as rows are rendered.
     */
    estimatedRowSize: require('prop-types').number.isRequired,


    /** Exposed for testing purposes only.  */
    getScrollbarSize: require('prop-types').func.isRequired,


    /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */
    height: require('prop-types').number.isRequired,


    /** Optional custom id to attach to root Grid element.  */
    id: require('prop-types').string,


    /**
     * Override internal is-scrolling state tracking.
     * This property is primarily intended for use with the WindowScroller component.
     */
    isScrolling: require('prop-types').bool,


    /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */
    noContentRenderer: typeof babelPluginFlowReactPropTypes_proptype_NoContentRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_NoContentRenderer : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_NoContentRenderer).isRequired,


    /**
     * Callback invoked whenever the scroll offset changes within the inner scrollable region.
     * This callback can be used to sync scrolling between lists, tables, or grids.
     */
    onScroll: require('prop-types').func.isRequired,


    /**
     * Called whenever a horizontal or vertical scrollbar is added or removed.
     * This prop is not intended for end-user use;
     * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.
     */
    onScrollbarPresenceChange: require('prop-types').func.isRequired,


    /** Callback invoked with information about the section of the Grid that was just rendered.  */
    onSectionRendered: require('prop-types').func.isRequired,


    /**
     * Number of columns to render before/after the visible section of the grid.
     * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
     */
    overscanColumnCount: require('prop-types').number.isRequired,


    /**
     * Calculates the number of cells to overscan before and after a specified range.
     * This function ensures that overscanning doesn't exceed the available cells.
     */
    overscanIndicesGetter: typeof babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter === 'function' ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired : babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter).isRequired,


    /**
     * Number of rows to render above/below the visible section of the grid.
     * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
     */
    overscanRowCount: require('prop-types').number.isRequired,


    /** ARIA role for the grid element.  */
    role: require('prop-types').string.isRequired,


    /**
     * Either a fixed row height (number) or a function that returns the height of a row given its index.
     * Should implement the following interface: ({ index: number }): number
     */
    rowHeight: typeof babelPluginFlowReactPropTypes_proptype_CellSize === 'function' ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,


    /** Number of rows in grid.  */
    rowCount: require('prop-types').number.isRequired,


    /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */
    scrollingResetTimeInterval: require('prop-types').number.isRequired,


    /** Horizontal offset. */
    scrollLeft: require('prop-types').number,


    /**
     * Controls scroll-to-cell behavior of the Grid.
     * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
     * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
     */
    scrollToAlignment: typeof babelPluginFlowReactPropTypes_proptype_Alignment === 'function' ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired : babelPluginFlowReactPropTypes_proptype_Alignment : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_Alignment).isRequired,


    /** Column index to ensure visible (by forcefully scrolling if necessary) */
    scrollToColumn: require('prop-types').number.isRequired,


    /** Vertical offset. */
    scrollTop: require('prop-types').number,


    /** Row index to ensure visible (by forcefully scrolling if necessary) */
    scrollToRow: require('prop-types').number.isRequired,


    /** Optional inline style */
    style: require('prop-types').object.isRequired,


    /** Tab index for focus */
    tabIndex: require('prop-types').number,


    /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */
    width: require('prop-types').number.isRequired
  };
  exports.default = Grid;
  },{"../utils/createCallbackMemoizer":1240,"../utils/requestAnimationTimeout":1242,"./defaultCellRangeRenderer":1199,"./defaultOverscanIndicesGetter":1200,"./types":1202,"./utils/ScalingCellSizeAndPositionManager":1204,"./utils/calculateSizeAndPositionDataAndUpdateScrollOffset":1205,"./utils/updateScrollIndexHelper":1207,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"classnames":698,"dom-helpers/util/scrollbarSize":707,"prop-types":1249,"react":1253}],1198:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defaultOverscanIndicesGetter;

  var babelPluginFlowReactPropTypes_proptype_OverscanIndices = require('./types').babelPluginFlowReactPropTypes_proptype_OverscanIndices || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams = require('./types').babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams || require('prop-types').any;

  var SCROLL_DIRECTION_BACKWARD = exports.SCROLL_DIRECTION_BACKWARD = -1;
  var SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_FORWARD = 1;

  var SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_HORIZONTAL = 'horizontal';
  var SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_VERTICAL = 'vertical';

  /**
   * Calculates the number of cells to overscan before and after a specified range.
   * This function ensures that overscanning doesn't exceed the available cells.
   */

  function defaultOverscanIndicesGetter(_ref) {
    var cellCount = _ref.cellCount,
        overscanCellsCount = _ref.overscanCellsCount,
        scrollDirection = _ref.scrollDirection,
        startIndex = _ref.startIndex,
        stopIndex = _ref.stopIndex;

    // Make sure we render at least 1 cell extra before and after (except near boundaries)
    // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases
    // For more info see issues #625
    overscanCellsCount = Math.max(1, overscanCellsCount);

    if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
      return {
        overscanStartIndex: Math.max(0, startIndex - 1),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
      };
    } else {
      return {
        overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
      };
    }
  }
  },{"./types":1202,"prop-types":1249}],1199:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defaultCellRangeRenderer;

  /**
   * Default implementation of cellRangeRenderer used by Grid.
   * This renderer supports cell-caching while the user is scrolling.
   */

  var babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams = require('./types').babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams || require('prop-types').any;

  function defaultCellRangeRenderer(_ref) {
    var cellCache = _ref.cellCache,
        cellRenderer = _ref.cellRenderer,
        columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,
        columnStartIndex = _ref.columnStartIndex,
        columnStopIndex = _ref.columnStopIndex,
        deferredMeasurementCache = _ref.deferredMeasurementCache,
        horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,
        isScrolling = _ref.isScrolling,
        parent = _ref.parent,
        rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,
        rowStartIndex = _ref.rowStartIndex,
        rowStopIndex = _ref.rowStopIndex,
        styleCache = _ref.styleCache,
        verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,
        visibleColumnIndices = _ref.visibleColumnIndices,
        visibleRowIndices = _ref.visibleRowIndices;

    var renderedCells = [];

    // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).
    // User cannot scroll beyond these size limitations.
    // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.
    // We should never cache styles for compressed offsets though as this can lead to bugs.
    // See issue #576 for more.
    var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();

    var canCacheStyle = !isScrolling && !areOffsetsAdjusted;

    for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
      var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);

      for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
        var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);
        var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;
        var key = rowIndex + '-' + columnIndex;
        var style = void 0;

        // Cache style objects so shallow-compare doesn't re-render unnecessarily.
        if (canCacheStyle && styleCache[key]) {
          style = styleCache[key];
        } else {
          // In deferred mode, cells will be initially rendered before we know their size.
          // Don't interfere with CellMeasurer's measurements by setting an invalid size.
          if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {
            // Position not-yet-measured cells at top/left 0,0,
            // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.
            // Positioning them further to the right/bottom influences their measured size.
            style = {
              height: 'auto',
              left: 0,
              position: 'absolute',
              top: 0,
              width: 'auto'
            };
          } else {
            style = {
              height: rowDatum.size,
              left: columnDatum.offset + horizontalOffsetAdjustment,
              position: 'absolute',
              top: rowDatum.offset + verticalOffsetAdjustment,
              width: columnDatum.size
            };

            styleCache[key] = style;
          }
        }

        var cellRendererParams = {
          columnIndex: columnIndex,
          isScrolling: isScrolling,
          isVisible: isVisible,
          key: key,
          parent: parent,
          rowIndex: rowIndex,
          style: style
        };

        var renderedCell = void 0;

        // Avoid re-creating cells while scrolling.
        // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
        // If a scroll is in progress- cache and reuse cells.
        // This cache will be thrown away once scrolling completes.
        // However if we are scaling scroll positions and sizes, we should also avoid caching.
        // This is because the offset changes slightly as scroll position changes and caching leads to stale values.
        // For more info refer to issue #395
        if (isScrolling && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {
          if (!cellCache[key]) {
            cellCache[key] = cellRenderer(cellRendererParams);
          }

          renderedCell = cellCache[key];

          // If the user is no longer scrolling, don't cache cells.
          // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.
        } else {
          renderedCell = cellRenderer(cellRendererParams);
        }

        if (renderedCell == null || renderedCell === false) {
          continue;
        }

        if ("production" !== 'production') {
          warnAboutMissingStyle(parent, renderedCell);
        }

        renderedCells.push(renderedCell);
      }
    }

    return renderedCells;
  }

  function warnAboutMissingStyle(parent, renderedCell) {
    if ("production" !== 'production') {
      if (renderedCell) {
        // If the direct child is a CellMeasurer, then we should check its child
        // See issue #611
        if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {
          renderedCell = renderedCell.props.children;
        }

        if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {
          parent.__warnedAboutMissingStyle = true;

          console.warn('Rendered cell should include style property for positioning.');
        }
      }
    }
  }
  },{"./types":1202,"prop-types":1249}],1200:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defaultOverscanIndicesGetter;

  var babelPluginFlowReactPropTypes_proptype_OverscanIndices = require('./types').babelPluginFlowReactPropTypes_proptype_OverscanIndices || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams = require('./types').babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams || require('prop-types').any;

  var SCROLL_DIRECTION_BACKWARD = exports.SCROLL_DIRECTION_BACKWARD = -1;
  var SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_FORWARD = 1;

  var SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_HORIZONTAL = 'horizontal';
  var SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_VERTICAL = 'vertical';

  /**
   * Calculates the number of cells to overscan before and after a specified range.
   * This function ensures that overscanning doesn't exceed the available cells.
   */

  function defaultOverscanIndicesGetter(_ref) {
    var cellCount = _ref.cellCount,
        overscanCellsCount = _ref.overscanCellsCount,
        scrollDirection = _ref.scrollDirection,
        startIndex = _ref.startIndex,
        stopIndex = _ref.stopIndex;

    if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
      return {
        overscanStartIndex: Math.max(0, startIndex),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
      };
    } else {
      return {
        overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
        overscanStopIndex: Math.min(cellCount - 1, stopIndex)
      };
    }
  }
  },{"./types":1202,"prop-types":1249}],1201:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _Grid = require('./Grid');

  Object.defineProperty(exports, 'default', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_Grid).default;
    }
  });
  Object.defineProperty(exports, 'Grid', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_Grid).default;
    }
  });

  var _accessibilityOverscanIndicesGetter = require('./accessibilityOverscanIndicesGetter');

  Object.defineProperty(exports, 'accessibilityOverscanIndicesGetter', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_accessibilityOverscanIndicesGetter).default;
    }
  });

  var _defaultCellRangeRenderer = require('./defaultCellRangeRenderer');

  Object.defineProperty(exports, 'defaultCellRangeRenderer', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_defaultCellRangeRenderer).default;
    }
  });

  var _defaultOverscanIndicesGetter = require('./defaultOverscanIndicesGetter');

  Object.defineProperty(exports, 'defaultOverscanIndicesGetter', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_defaultOverscanIndicesGetter).default;
    }
  });

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  },{"./Grid":1197,"./accessibilityOverscanIndicesGetter":1198,"./defaultCellRangeRenderer":1199,"./defaultOverscanIndicesGetter":1200}],1202:[function(require,module,exports){
  'use strict';

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  var _ScalingCellSizeAndPositionManager = require('./utils/ScalingCellSizeAndPositionManager');

  var _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  var babelPluginFlowReactPropTypes_proptype_CellPosition = "production" === 'production' ? null : {
    columnIndex: require('prop-types').number.isRequired,
    rowIndex: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellPosition', {
    value: babelPluginFlowReactPropTypes_proptype_CellPosition,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_CellRendererParams = "production" === 'production' ? null : {
    columnIndex: require('prop-types').number.isRequired,
    isScrolling: require('prop-types').bool.isRequired,
    isVisible: require('prop-types').bool.isRequired,
    key: require('prop-types').string.isRequired,
    parent: require('prop-types').object.isRequired,
    rowIndex: require('prop-types').number.isRequired,
    style: require('prop-types').object.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRendererParams', {
    value: babelPluginFlowReactPropTypes_proptype_CellRendererParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_CellRenderer = "production" === 'production' ? null : require('prop-types').func;
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRenderer', {
    value: babelPluginFlowReactPropTypes_proptype_CellRenderer,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams = "production" === 'production' ? null : {
    cellCache: require('prop-types').object.isRequired,
    cellRenderer: require('prop-types').func.isRequired,
    columnSizeAndPositionManager: typeof _ScalingCellSizeAndPositionManager2.default === 'function' ? require('prop-types').instanceOf(_ScalingCellSizeAndPositionManager2.default).isRequired : require('prop-types').any.isRequired,
    columnStartIndex: require('prop-types').number.isRequired,
    columnStopIndex: require('prop-types').number.isRequired,
    deferredMeasurementCache: require('prop-types').object,
    horizontalOffsetAdjustment: require('prop-types').number.isRequired,
    isScrolling: require('prop-types').bool.isRequired,
    parent: require('prop-types').object.isRequired,
    rowSizeAndPositionManager: typeof _ScalingCellSizeAndPositionManager2.default === 'function' ? require('prop-types').instanceOf(_ScalingCellSizeAndPositionManager2.default).isRequired : require('prop-types').any.isRequired,
    rowStartIndex: require('prop-types').number.isRequired,
    rowStopIndex: require('prop-types').number.isRequired,
    scrollLeft: require('prop-types').number.isRequired,
    scrollTop: require('prop-types').number.isRequired,
    styleCache: require('prop-types').object.isRequired,
    verticalOffsetAdjustment: require('prop-types').number.isRequired,
    visibleColumnIndices: require('prop-types').object.isRequired,
    visibleRowIndices: require('prop-types').object.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams', {
    value: babelPluginFlowReactPropTypes_proptype_CellRangeRendererParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_CellRangeRenderer = "production" === 'production' ? null : require('prop-types').func;
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellRangeRenderer', {
    value: babelPluginFlowReactPropTypes_proptype_CellRangeRenderer,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_CellSizeGetter = "production" === 'production' ? null : require('prop-types').func;
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellSizeGetter', {
    value: babelPluginFlowReactPropTypes_proptype_CellSizeGetter,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_CellSize = "production" === 'production' ? null : require('prop-types').oneOfType([require('prop-types').func, require('prop-types').number]);
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellSize', {
    value: babelPluginFlowReactPropTypes_proptype_CellSize,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_NoContentRenderer = "production" === 'production' ? null : require('prop-types').func;
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_NoContentRenderer', {
    value: babelPluginFlowReactPropTypes_proptype_NoContentRenderer,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_Scroll = "production" === 'production' ? null : {
    clientHeight: require('prop-types').number.isRequired,
    clientWidth: require('prop-types').number.isRequired,
    scrollHeight: require('prop-types').number.isRequired,
    scrollLeft: require('prop-types').number.isRequired,
    scrollTop: require('prop-types').number.isRequired,
    scrollWidth: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Scroll', {
    value: babelPluginFlowReactPropTypes_proptype_Scroll,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange = "production" === 'production' ? null : {
    horizontal: require('prop-types').bool.isRequired,
    vertical: require('prop-types').bool.isRequired,
    size: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange', {
    value: babelPluginFlowReactPropTypes_proptype_ScrollbarPresenceChange,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_RenderedSection = "production" === 'production' ? null : {
    columnOverscanStartIndex: require('prop-types').number.isRequired,
    columnOverscanStopIndex: require('prop-types').number.isRequired,
    columnStartIndex: require('prop-types').number.isRequired,
    columnStopIndex: require('prop-types').number.isRequired,
    rowOverscanStartIndex: require('prop-types').number.isRequired,
    rowOverscanStopIndex: require('prop-types').number.isRequired,
    rowStartIndex: require('prop-types').number.isRequired,
    rowStopIndex: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RenderedSection', {
    value: babelPluginFlowReactPropTypes_proptype_RenderedSection,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams = "production" === 'production' ? null : {
    // One of SCROLL_DIRECTION_HORIZONTAL or SCROLL_DIRECTION_VERTICAL
    direction: require('prop-types').oneOf(['horizontal', 'vertical']).isRequired,


    // One of SCROLL_DIRECTION_BACKWARD or SCROLL_DIRECTION_FORWARD
    scrollDirection: require('prop-types').oneOf([-1, 1]).isRequired,


    // Number of rows or columns in the current axis
    cellCount: require('prop-types').number.isRequired,


    // Maximum number of cells to over-render in either direction
    overscanCellsCount: require('prop-types').number.isRequired,


    // Begin of range of visible cells
    startIndex: require('prop-types').number.isRequired,


    // End of range of visible cells
    stopIndex: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams', {
    value: babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetterParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_OverscanIndices = "production" === 'production' ? null : {
    overscanStartIndex: require('prop-types').number.isRequired,
    overscanStopIndex: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_OverscanIndices', {
    value: babelPluginFlowReactPropTypes_proptype_OverscanIndices,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter = "production" === 'production' ? null : require('prop-types').func;
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter', {
    value: babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_Alignment = "production" === 'production' ? null : require('prop-types').oneOf(['auto', 'end', 'start', 'center']);
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Alignment', {
    value: babelPluginFlowReactPropTypes_proptype_Alignment,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_VisibleCellRange = "production" === 'production' ? null : {
    start: require('prop-types').number,
    stop: require('prop-types').number
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_VisibleCellRange', {
    value: babelPluginFlowReactPropTypes_proptype_VisibleCellRange,
    configurable: true
  });
  },{"./utils/ScalingCellSizeAndPositionManager":1204,"prop-types":1249,"react":1253}],1203:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_VisibleCellRange = require('../types').babelPluginFlowReactPropTypes_proptype_VisibleCellRange || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellSizeGetter = require('../types').babelPluginFlowReactPropTypes_proptype_CellSizeGetter || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_Alignment = require('../types').babelPluginFlowReactPropTypes_proptype_Alignment || require('prop-types').any;

  /**
   * Just-in-time calculates and caches size and position information for a collection of cells.
   */

  var CellSizeAndPositionManager = function () {

    // Used in deferred mode to track which cells have been queued for measurement.

    // Cache of size and position data for cells, mapped by cell index.
    // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex
    function CellSizeAndPositionManager(_ref) {
      var cellCount = _ref.cellCount,
          cellSizeGetter = _ref.cellSizeGetter,
          estimatedCellSize = _ref.estimatedCellSize;
      (0, _classCallCheck3.default)(this, CellSizeAndPositionManager);
      this._cellSizeAndPositionData = {};
      this._lastMeasuredIndex = -1;
      this._lastBatchedIndex = -1;

      this._cellSizeGetter = cellSizeGetter;
      this._cellCount = cellCount;
      this._estimatedCellSize = estimatedCellSize;
    }

    // Measurements for cells up to this index can be trusted; cells afterward should be estimated.


    (0, _createClass3.default)(CellSizeAndPositionManager, [{
      key: 'areOffsetsAdjusted',
      value: function areOffsetsAdjusted() {
        return false;
      }
    }, {
      key: 'configure',
      value: function configure(_ref2) {
        var cellCount = _ref2.cellCount,
            estimatedCellSize = _ref2.estimatedCellSize;

        this._cellCount = cellCount;
        this._estimatedCellSize = estimatedCellSize;
      }
    }, {
      key: 'getCellCount',
      value: function getCellCount() {
        return this._cellCount;
      }
    }, {
      key: 'getEstimatedCellSize',
      value: function getEstimatedCellSize() {
        return this._estimatedCellSize;
      }
    }, {
      key: 'getLastMeasuredIndex',
      value: function getLastMeasuredIndex() {
        return this._lastMeasuredIndex;
      }
    }, {
      key: 'getOffsetAdjustment',
      value: function getOffsetAdjustment() {
        return 0;
      }

      /**
       * This method returns the size and position for the cell at the specified index.
       * It just-in-time calculates (or used cached values) for cells leading up to the index.
       */

    }, {
      key: 'getSizeAndPositionOfCell',
      value: function getSizeAndPositionOfCell(index) {
        if (index < 0 || index >= this._cellCount) {
          throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);
        }

        if (index > this._lastMeasuredIndex) {
          var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
          var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;

          for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {
            var _size = this._cellSizeGetter({ index: i });

            // undefined or NaN probably means a logic error in the size getter.
            // null means we're using CellMeasurer and haven't yet measured a given index.
            if (_size === undefined || isNaN(_size)) {
              throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);
            } else if (_size === null) {
              this._cellSizeAndPositionData[i] = {
                offset: _offset,
                size: 0
              };

              this._lastBatchedIndex = index;
            } else {
              this._cellSizeAndPositionData[i] = {
                offset: _offset,
                size: _size
              };

              _offset += _size;

              this._lastMeasuredIndex = index;
            }
          }
        }

        return this._cellSizeAndPositionData[index];
      }
    }, {
      key: 'getSizeAndPositionOfLastMeasuredCell',
      value: function getSizeAndPositionOfLastMeasuredCell() {
        return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
          offset: 0,
          size: 0
        };
      }

      /**
       * Total size of all cells being measured.
       * This value will be completely estimated initially.
       * As cells are measured, the estimate will be updated.
       */

    }, {
      key: 'getTotalSize',
      value: function getTotalSize() {
        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
        var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
        var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;
        var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
        return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
      }

      /**
       * Determines a new offset that ensures a certain cell is visible, given the current offset.
       * If the cell is already visible then the current offset will be returned.
       * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
       *
       * @param align Desired alignment within container; one of "auto" (default), "start", or "end"
       * @param containerSize Size (width or height) of the container viewport
       * @param currentOffset Container's current (x or y) offset
       * @param totalSize Total size (width or height) of all cells
       * @return Offset to use to ensure the specified cell is visible
       */

    }, {
      key: 'getUpdatedOffsetForIndex',
      value: function getUpdatedOffsetForIndex(_ref3) {
        var _ref3$align = _ref3.align,
            align = _ref3$align === undefined ? 'auto' : _ref3$align,
            containerSize = _ref3.containerSize,
            currentOffset = _ref3.currentOffset,
            targetIndex = _ref3.targetIndex;

        if (containerSize <= 0) {
          return 0;
        }

        var datum = this.getSizeAndPositionOfCell(targetIndex);
        var maxOffset = datum.offset;
        var minOffset = maxOffset - containerSize + datum.size;

        var idealOffset = void 0;

        switch (align) {
          case 'start':
            idealOffset = maxOffset;
            break;
          case 'end':
            idealOffset = minOffset;
            break;
          case 'center':
            idealOffset = maxOffset - (containerSize - datum.size) / 2;
            break;
          default:
            idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
            break;
        }

        var totalSize = this.getTotalSize();

        return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
      }
    }, {
      key: 'getVisibleCellRange',
      value: function getVisibleCellRange(params) {
        var containerSize = params.containerSize,
            offset = params.offset;


        var totalSize = this.getTotalSize();

        if (totalSize === 0) {
          return {};
        }

        var maxOffset = offset + containerSize;
        var start = this._findNearestCell(offset);

        var datum = this.getSizeAndPositionOfCell(start);
        offset = datum.offset + datum.size;

        var stop = start;

        while (offset < maxOffset && stop < this._cellCount - 1) {
          stop++;

          offset += this.getSizeAndPositionOfCell(stop).size;
        }

        return {
          start: start,
          stop: stop
        };
      }

      /**
       * Clear all cached values for cells after the specified index.
       * This method should be called for any cell that has changed its size.
       * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.
       */

    }, {
      key: 'resetCell',
      value: function resetCell(index) {
        this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
      }
    }, {
      key: '_binarySearch',
      value: function _binarySearch(high, low, offset) {
        while (low <= high) {
          var middle = low + Math.floor((high - low) / 2);
          var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;

          if (_currentOffset === offset) {
            return middle;
          } else if (_currentOffset < offset) {
            low = middle + 1;
          } else if (_currentOffset > offset) {
            high = middle - 1;
          }
        }

        if (low > 0) {
          return low - 1;
        } else {
          return 0;
        }
      }
    }, {
      key: '_exponentialSearch',
      value: function _exponentialSearch(index, offset) {
        var interval = 1;

        while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {
          index += interval;
          interval *= 2;
        }

        return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
      }

      /**
       * Searches for the cell (index) nearest the specified offset.
       *
       * If no exact match is found the next lowest cell index will be returned.
       * This allows partially visible cells (with offsets just before/above the fold) to be visible.
       */

    }, {
      key: '_findNearestCell',
      value: function _findNearestCell(offset) {
        if (isNaN(offset)) {
          throw Error('Invalid offset ' + offset + ' specified');
        }

        // Our search algorithms find the nearest match at or below the specified offset.
        // So make sure the offset is at least 0 or no match will be found.
        offset = Math.max(0, offset);

        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
        var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);

        if (lastMeasuredCellSizeAndPosition.offset >= offset) {
          // If we've already measured cells within this range just use a binary search as it's faster.
          return this._binarySearch(lastMeasuredIndex, 0, offset);
        } else {
          // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
          // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.
          // The overall complexity for this approach is O(log n).
          return this._exponentialSearch(lastMeasuredIndex, offset);
        }
      }
    }]);
    return CellSizeAndPositionManager;
  }();

  exports.default = CellSizeAndPositionManager;
  },{"../types":1202,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"prop-types":1249}],1204:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

  var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _CellSizeAndPositionManager = require('./CellSizeAndPositionManager');

  var _CellSizeAndPositionManager2 = _interopRequireDefault(_CellSizeAndPositionManager);

  var _maxElementSize = require('./maxElementSize.js');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_VisibleCellRange = require('../types').babelPluginFlowReactPropTypes_proptype_VisibleCellRange || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellSizeGetter = require('../types').babelPluginFlowReactPropTypes_proptype_CellSizeGetter || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_Alignment = require('../types').babelPluginFlowReactPropTypes_proptype_Alignment || require('prop-types').any;

  /**
   * Extends CellSizeAndPositionManager and adds scaling behavior for lists that are too large to fit within a browser's native limits.
   */


  /**
   * Browsers have scroll offset limitations (eg Chrome stops scrolling at ~33.5M pixels where as Edge tops out at ~1.5M pixels).
   * After a certain position, the browser won't allow the user to scroll further (even via JavaScript scroll offset adjustments).
   * This util picks a lower ceiling for max size and artificially adjusts positions within to make it transparent for users.
   */

  var ScalingCellSizeAndPositionManager = function () {
    function ScalingCellSizeAndPositionManager(_ref) {
      var _ref$maxScrollSize = _ref.maxScrollSize,
          maxScrollSize = _ref$maxScrollSize === undefined ? (0, _maxElementSize.getMaxElementSize)() : _ref$maxScrollSize,
          params = (0, _objectWithoutProperties3.default)(_ref, ['maxScrollSize']);
      (0, _classCallCheck3.default)(this, ScalingCellSizeAndPositionManager);

      // Favor composition over inheritance to simplify IE10 support
      this._cellSizeAndPositionManager = new _CellSizeAndPositionManager2.default(params);
      this._maxScrollSize = maxScrollSize;
    }

    (0, _createClass3.default)(ScalingCellSizeAndPositionManager, [{
      key: 'areOffsetsAdjusted',
      value: function areOffsetsAdjusted() {
        return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
      }
    }, {
      key: 'configure',
      value: function configure(params) {
        this._cellSizeAndPositionManager.configure(params);
      }
    }, {
      key: 'getCellCount',
      value: function getCellCount() {
        return this._cellSizeAndPositionManager.getCellCount();
      }
    }, {
      key: 'getEstimatedCellSize',
      value: function getEstimatedCellSize() {
        return this._cellSizeAndPositionManager.getEstimatedCellSize();
      }
    }, {
      key: 'getLastMeasuredIndex',
      value: function getLastMeasuredIndex() {
        return this._cellSizeAndPositionManager.getLastMeasuredIndex();
      }

      /**
       * Number of pixels a cell at the given position (offset) should be shifted in order to fit within the scaled container.
       * The offset passed to this function is scaled (safe) as well.
       */

    }, {
      key: 'getOffsetAdjustment',
      value: function getOffsetAdjustment(_ref2) {
        var containerSize = _ref2.containerSize,
            offset = _ref2.offset;

        var totalSize = this._cellSizeAndPositionManager.getTotalSize();
        var safeTotalSize = this.getTotalSize();
        var offsetPercentage = this._getOffsetPercentage({
          containerSize: containerSize,
          offset: offset,
          totalSize: safeTotalSize
        });

        return Math.round(offsetPercentage * (safeTotalSize - totalSize));
      }
    }, {
      key: 'getSizeAndPositionOfCell',
      value: function getSizeAndPositionOfCell(index) {
        return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
      }
    }, {
      key: 'getSizeAndPositionOfLastMeasuredCell',
      value: function getSizeAndPositionOfLastMeasuredCell() {
        return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
      }

      /** See CellSizeAndPositionManager#getTotalSize */

    }, {
      key: 'getTotalSize',
      value: function getTotalSize() {
        return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
      }

      /** See CellSizeAndPositionManager#getUpdatedOffsetForIndex */

    }, {
      key: 'getUpdatedOffsetForIndex',
      value: function getUpdatedOffsetForIndex(_ref3) {
        var _ref3$align = _ref3.align,
            align = _ref3$align === undefined ? 'auto' : _ref3$align,
            containerSize = _ref3.containerSize,
            currentOffset = _ref3.currentOffset,
            targetIndex = _ref3.targetIndex;

        currentOffset = this._safeOffsetToOffset({
          containerSize: containerSize,
          offset: currentOffset
        });

        var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
          align: align,
          containerSize: containerSize,
          currentOffset: currentOffset,
          targetIndex: targetIndex
        });

        return this._offsetToSafeOffset({
          containerSize: containerSize,
          offset: offset
        });
      }

      /** See CellSizeAndPositionManager#getVisibleCellRange */

    }, {
      key: 'getVisibleCellRange',
      value: function getVisibleCellRange(_ref4) {
        var containerSize = _ref4.containerSize,
            offset = _ref4.offset;

        offset = this._safeOffsetToOffset({
          containerSize: containerSize,
          offset: offset
        });

        return this._cellSizeAndPositionManager.getVisibleCellRange({
          containerSize: containerSize,
          offset: offset
        });
      }
    }, {
      key: 'resetCell',
      value: function resetCell(index) {
        this._cellSizeAndPositionManager.resetCell(index);
      }
    }, {
      key: '_getOffsetPercentage',
      value: function _getOffsetPercentage(_ref5) {
        var containerSize = _ref5.containerSize,
            offset = _ref5.offset,
            totalSize = _ref5.totalSize;

        return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
      }
    }, {
      key: '_offsetToSafeOffset',
      value: function _offsetToSafeOffset(_ref6) {
        var containerSize = _ref6.containerSize,
            offset = _ref6.offset;

        var totalSize = this._cellSizeAndPositionManager.getTotalSize();
        var safeTotalSize = this.getTotalSize();

        if (totalSize === safeTotalSize) {
          return offset;
        } else {
          var offsetPercentage = this._getOffsetPercentage({
            containerSize: containerSize,
            offset: offset,
            totalSize: totalSize
          });

          return Math.round(offsetPercentage * (safeTotalSize - containerSize));
        }
      }
    }, {
      key: '_safeOffsetToOffset',
      value: function _safeOffsetToOffset(_ref7) {
        var containerSize = _ref7.containerSize,
            offset = _ref7.offset;

        var totalSize = this._cellSizeAndPositionManager.getTotalSize();
        var safeTotalSize = this.getTotalSize();

        if (totalSize === safeTotalSize) {
          return offset;
        } else {
          var offsetPercentage = this._getOffsetPercentage({
            containerSize: containerSize,
            offset: offset,
            totalSize: safeTotalSize
          });

          return Math.round(offsetPercentage * (totalSize - containerSize));
        }
      }
    }]);
    return ScalingCellSizeAndPositionManager;
  }();

  exports.default = ScalingCellSizeAndPositionManager;
  },{"../types":1202,"./CellSizeAndPositionManager":1203,"./maxElementSize.js":1206,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/objectWithoutProperties":588,"prop-types":1249}],1205:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;
  function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
    var cellCount = _ref.cellCount,
        cellSize = _ref.cellSize,
        computeMetadataCallback = _ref.computeMetadataCallback,
        computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,
        nextCellsCount = _ref.nextCellsCount,
        nextCellSize = _ref.nextCellSize,
        nextScrollToIndex = _ref.nextScrollToIndex,
        scrollToIndex = _ref.scrollToIndex,
        updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;

    // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.
    // In that event users should use the manual recompute methods to inform of changes.
    if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {
      computeMetadataCallback(computeMetadataCallbackProps);

      // Updated cell metadata may have hidden the previous scrolled-to item.
      // In this case we should also update the scrollTop to ensure it stays visible.
      if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {
        updateScrollOffsetForScrollToIndex();
      }
    }
  }

  /**
   * Helper method that determines when to recalculate row or column metadata.
   */
  },{}],1206:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var DEFAULT_MAX_ELEMENT_SIZE = 1500000;
  var CHROME_MAX_ELEMENT_SIZE = 1.67771e7;

  var isBrowser = function isBrowser() {
    return typeof window !== 'undefined';
  };

  var isChrome = function isChrome() {
    return !!window.chrome && !!window.chrome.webstore;
  };

  var getMaxElementSize = exports.getMaxElementSize = function getMaxElementSize() {
    if (isBrowser()) {
      if (isChrome()) {
        return CHROME_MAX_ELEMENT_SIZE;
      }
    }
    return DEFAULT_MAX_ELEMENT_SIZE;
  };
  },{}],1207:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = updateScrollIndexHelper;

  var _ScalingCellSizeAndPositionManager = require('./ScalingCellSizeAndPositionManager.js');

  var _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_CellSize = require('../types').babelPluginFlowReactPropTypes_proptype_CellSize || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_Alignment = require('../types').babelPluginFlowReactPropTypes_proptype_Alignment || require('prop-types').any;

  /**
   * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.
   * This function also ensures that the scroll ofset isn't past the last column/row of cells.
   */

  function updateScrollIndexHelper(_ref) {
    var cellSize = _ref.cellSize,
        cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,
        previousCellsCount = _ref.previousCellsCount,
        previousCellSize = _ref.previousCellSize,
        previousScrollToAlignment = _ref.previousScrollToAlignment,
        previousScrollToIndex = _ref.previousScrollToIndex,
        previousSize = _ref.previousSize,
        scrollOffset = _ref.scrollOffset,
        scrollToAlignment = _ref.scrollToAlignment,
        scrollToIndex = _ref.scrollToIndex,
        size = _ref.size,
        sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,
        updateScrollIndexCallback = _ref.updateScrollIndexCallback;

    var cellCount = cellSizeAndPositionManager.getCellCount();
    var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;
    var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;

    // If we have a new scroll target OR if height/row-height has changed,
    // We should ensure that the scroll target is visible.
    if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {
      updateScrollIndexCallback(scrollToIndex);

      // If we don't have a selected item but list size or number of children have decreased,
      // Make sure we aren't scrolled too far past the current content.
    } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {
      // We need to ensure that the current scroll offset is still within the collection's range.
      // To do this, we don't need to measure everything; CellMeasurer would perform poorly.
      // Just check to make sure we're still okay.
      // Only adjust the scroll position if we've scrolled below the last set of rows.
      if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {
        updateScrollIndexCallback(cellCount - 1);
      }
    }
  }
  },{"../types":1202,"./ScalingCellSizeAndPositionManager.js":1204,"prop-types":1249}],1208:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  exports.isRangeVisible = isRangeVisible;
  exports.scanForUnloadedRanges = scanForUnloadedRanges;
  exports.forceUpdateReactVirtualizedComponent = forceUpdateReactVirtualizedComponent;

  var _react = require('react');

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _createCallbackMemoizer = require('../utils/createCallbackMemoizer');

  var _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Higher-order component that manages lazy-loading for "infinite" data.
   * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.
   * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.
   */
  var InfiniteLoader = function (_PureComponent) {
    (0, _inherits3.default)(InfiniteLoader, _PureComponent);

    function InfiniteLoader(props, context) {
      (0, _classCallCheck3.default)(this, InfiniteLoader);

      var _this = (0, _possibleConstructorReturn3.default)(this, (InfiniteLoader.__proto__ || (0, _getPrototypeOf2.default)(InfiniteLoader)).call(this, props, context));

      _this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();

      _this._onRowsRendered = _this._onRowsRendered.bind(_this);
      _this._registerChild = _this._registerChild.bind(_this);
      return _this;
    }

    (0, _createClass3.default)(InfiniteLoader, [{
      key: 'resetLoadMoreRowsCache',
      value: function resetLoadMoreRowsCache(autoReload) {
        this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();

        if (autoReload) {
          this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var children = this.props.children;


        return children({
          onRowsRendered: this._onRowsRendered,
          registerChild: this._registerChild
        });
      }
    }, {
      key: '_loadUnloadedRanges',
      value: function _loadUnloadedRanges(unloadedRanges) {
        var _this2 = this;

        var loadMoreRows = this.props.loadMoreRows;


        unloadedRanges.forEach(function (unloadedRange) {
          var promise = loadMoreRows(unloadedRange);
          if (promise) {
            promise.then(function () {
              // Refresh the visible rows if any of them have just been loaded.
              // Otherwise they will remain in their unloaded visual state.
              if (isRangeVisible({
                lastRenderedStartIndex: _this2._lastRenderedStartIndex,
                lastRenderedStopIndex: _this2._lastRenderedStopIndex,
                startIndex: unloadedRange.startIndex,
                stopIndex: unloadedRange.stopIndex
              })) {
                if (_this2._registeredChild) {
                  forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);
                }
              }
            });
          }
        });
      }
    }, {
      key: '_onRowsRendered',
      value: function _onRowsRendered(_ref) {
        var startIndex = _ref.startIndex,
            stopIndex = _ref.stopIndex;

        this._lastRenderedStartIndex = startIndex;
        this._lastRenderedStopIndex = stopIndex;

        this._doStuff(startIndex, stopIndex);
      }
    }, {
      key: '_doStuff',
      value: function _doStuff(startIndex, stopIndex) {
        var _this3 = this;

        var _props = this.props,
            isRowLoaded = _props.isRowLoaded,
            minimumBatchSize = _props.minimumBatchSize,
            rowCount = _props.rowCount,
            threshold = _props.threshold;


        var unloadedRanges = scanForUnloadedRanges({
          isRowLoaded: isRowLoaded,
          minimumBatchSize: minimumBatchSize,
          rowCount: rowCount,
          startIndex: Math.max(0, startIndex - threshold),
          stopIndex: Math.min(rowCount - 1, stopIndex + threshold)
        });

        // For memoize comparison
        var squashedUnloadedRanges = unloadedRanges.reduce(function (reduced, unloadedRange) {
          return reduced.concat([unloadedRange.startIndex, unloadedRange.stopIndex]);
        }, []);

        this._loadMoreRowsMemoizer({
          callback: function callback() {
            _this3._loadUnloadedRanges(unloadedRanges);
          },
          indices: { squashedUnloadedRanges: squashedUnloadedRanges }
        });
      }
    }, {
      key: '_registerChild',
      value: function _registerChild(registeredChild) {
        this._registeredChild = registeredChild;
      }
    }]);
    return InfiniteLoader;
  }(_react.PureComponent);

  /**
   * Determines if the specified start/stop range is visible based on the most recently rendered range.
   */


  InfiniteLoader.defaultProps = {
    minimumBatchSize: 10,
    rowCount: 0,
    threshold: 15
  };
  exports.default = InfiniteLoader;
  InfiniteLoader.propTypes = "production" !== "production" ? {
    /**
     * Function responsible for rendering a virtualized component.
     * This function should implement the following signature:
     * ({ onRowsRendered, registerChild }) => PropTypes.element
     *
     * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.
     * The :registerChild callback should be set as the virtualized component's :ref.
     */
    children: _propTypes2.default.func.isRequired,

    /**
     * Function responsible for tracking the loaded state of each row.
     * It should implement the following signature: ({ index: number }): boolean
     */
    isRowLoaded: _propTypes2.default.func.isRequired,

    /**
     * Callback to be invoked when more rows must be loaded.
     * It should implement the following signature: ({ startIndex, stopIndex }): Promise
     * The returned Promise should be resolved once row data has finished loading.
     * It will be used to determine when to refresh the list with the newly-loaded data.
     * This callback may be called multiple times in reaction to a single scroll event.
     */
    loadMoreRows: _propTypes2.default.func.isRequired,

    /**
     * Minimum number of rows to be loaded at a time.
     * This property can be used to batch requests to reduce HTTP requests.
     */
    minimumBatchSize: _propTypes2.default.number.isRequired,

    /**
     * Number of rows in list; can be arbitrary high number if actual number is unknown.
     */
    rowCount: _propTypes2.default.number.isRequired,

    /**
     * Threshold at which to pre-fetch data.
     * A threshold X means that data will start loading when a user scrolls within X rows.
     * This value defaults to 15.
     */
    threshold: _propTypes2.default.number.isRequired
  } : {};
  function isRangeVisible(_ref2) {
    var lastRenderedStartIndex = _ref2.lastRenderedStartIndex,
        lastRenderedStopIndex = _ref2.lastRenderedStopIndex,
        startIndex = _ref2.startIndex,
        stopIndex = _ref2.stopIndex;

    return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);
  }

  /**
   * Returns all of the ranges within a larger range that contain unloaded rows.
   */
  function scanForUnloadedRanges(_ref3) {
    var isRowLoaded = _ref3.isRowLoaded,
        minimumBatchSize = _ref3.minimumBatchSize,
        rowCount = _ref3.rowCount,
        startIndex = _ref3.startIndex,
        stopIndex = _ref3.stopIndex;

    var unloadedRanges = [];

    var rangeStartIndex = null;
    var rangeStopIndex = null;

    for (var index = startIndex; index <= stopIndex; index++) {
      var loaded = isRowLoaded({ index: index });

      if (!loaded) {
        rangeStopIndex = index;
        if (rangeStartIndex === null) {
          rangeStartIndex = index;
        }
      } else if (rangeStopIndex !== null) {
        unloadedRanges.push({
          startIndex: rangeStartIndex,
          stopIndex: rangeStopIndex
        });

        rangeStartIndex = rangeStopIndex = null;
      }
    }

    // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.
    // Scan forward to try filling our :minimumBatchSize.
    if (rangeStopIndex !== null) {
      var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);

      for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {
        if (!isRowLoaded({ index: _index })) {
          rangeStopIndex = _index;
        } else {
          break;
        }
      }

      unloadedRanges.push({
        startIndex: rangeStartIndex,
        stopIndex: rangeStopIndex
      });
    }

    // Check to see if our first range ended prematurely.
    // In this case we should scan backwards to try filling our :minimumBatchSize.
    if (unloadedRanges.length) {
      var firstUnloadedRange = unloadedRanges[0];

      while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {
        var _index2 = firstUnloadedRange.startIndex - 1;

        if (!isRowLoaded({ index: _index2 })) {
          firstUnloadedRange.startIndex = _index2;
        } else {
          break;
        }
      }
    }

    return unloadedRanges;
  }

  /**
   * Since RV components use shallowCompare we need to force a render (even though props haven't changed).
   * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.
   * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,
   * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.
   * Else the inner Grid will not be re-rendered and visuals may be stale.
   *
   * Additionally, while a Grid is scrolling the cells can be cached,
   * So it's important to invalidate that cache by recalculating sizes
   * before forcing a rerender.
   */
  function forceUpdateReactVirtualizedComponent(component) {
    var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;

    if (recomputeSize) {
      recomputeSize.call(component, currentIndex);
    } else {
      component.forceUpdate();
    }
  }
  },{"../utils/createCallbackMemoizer":1240,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1209:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.InfiniteLoader = undefined;

  var _InfiniteLoader = require('./InfiniteLoader');

  var _InfiniteLoader2 = _interopRequireDefault(_InfiniteLoader);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _InfiniteLoader2.default;
  exports.InfiniteLoader = _InfiniteLoader2.default;
  },{"./InfiniteLoader":1208}],1210:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

  var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _Grid = require('../Grid');

  var _Grid2 = _interopRequireDefault(_Grid);

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  var _classnames = require('classnames');

  var _classnames2 = _interopRequireDefault(_classnames);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_Scroll = require('../Grid').babelPluginFlowReactPropTypes_proptype_Scroll || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellRendererParams = require('../Grid').babelPluginFlowReactPropTypes_proptype_CellRendererParams || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_RenderedSection = require('../Grid').babelPluginFlowReactPropTypes_proptype_RenderedSection || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter = require('../Grid').babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellPosition = require('../Grid').babelPluginFlowReactPropTypes_proptype_CellPosition || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellSize = require('../Grid').babelPluginFlowReactPropTypes_proptype_CellSize || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_Alignment = require('../Grid').babelPluginFlowReactPropTypes_proptype_Alignment || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_NoContentRenderer = require('../Grid').babelPluginFlowReactPropTypes_proptype_NoContentRenderer || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_Scroll = require('./types').babelPluginFlowReactPropTypes_proptype_Scroll || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_RenderedRows = require('./types').babelPluginFlowReactPropTypes_proptype_RenderedRows || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_RowRenderer = require('./types').babelPluginFlowReactPropTypes_proptype_RowRenderer || require('prop-types').any;

  /**
   * It is inefficient to create and manage a large list of DOM elements within a scrolling container
   * if only a few of those elements are visible. The primary purpose of this component is to improve
   * performance by only rendering the DOM nodes that a user is able to see based on their current
   * scroll position.
   *
   * This component renders a virtualized list of elements with either fixed or dynamic heights.
   */

  var List = function (_React$PureComponent) {
    (0, _inherits3.default)(List, _React$PureComponent);

    function List() {
      var _ref;

      var _temp, _this, _ret;

      (0, _classCallCheck3.default)(this, List);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = List.__proto__ || (0, _getPrototypeOf2.default)(List)).call.apply(_ref, [this].concat(args))), _this), _this._cellRenderer = function (_ref2) {
        var parent = _ref2.parent,
            rowIndex = _ref2.rowIndex,
            style = _ref2.style,
            isScrolling = _ref2.isScrolling,
            isVisible = _ref2.isVisible,
            key = _ref2.key;
        var rowRenderer = _this.props.rowRenderer;

        // TRICKY The style object is sometimes cached by Grid.
        // This prevents new style objects from bypassing shallowCompare().
        // However as of React 16, style props are auto-frozen (at least in dev mode)
        // Check to make sure we can still modify the style before proceeding.
        // https://github.com/facebook/react/commit/977357765b44af8ff0cfea327866861073095c12#commitcomment-20648713

        var _Object$getOwnPropert = (0, _getOwnPropertyDescriptor2.default)(style, 'width'),
            writable = _Object$getOwnPropert.writable;

        if (writable) {
          // By default, List cells should be 100% width.
          // This prevents them from flowing under a scrollbar (if present).
          style.width = '100%';
        }

        return rowRenderer({
          index: rowIndex,
          style: style,
          isScrolling: isScrolling,
          isVisible: isVisible,
          key: key,
          parent: parent
        });
      }, _this._setRef = function (ref) {
        _this.Grid = ref;
      }, _this._onScroll = function (_ref3) {
        var clientHeight = _ref3.clientHeight,
            scrollHeight = _ref3.scrollHeight,
            scrollTop = _ref3.scrollTop;
        var onScroll = _this.props.onScroll;


        onScroll({ clientHeight: clientHeight, scrollHeight: scrollHeight, scrollTop: scrollTop });
      }, _this._onSectionRendered = function (_ref4) {
        var rowOverscanStartIndex = _ref4.rowOverscanStartIndex,
            rowOverscanStopIndex = _ref4.rowOverscanStopIndex,
            rowStartIndex = _ref4.rowStartIndex,
            rowStopIndex = _ref4.rowStopIndex;
        var onRowsRendered = _this.props.onRowsRendered;


        onRowsRendered({
          overscanStartIndex: rowOverscanStartIndex,
          overscanStopIndex: rowOverscanStopIndex,
          startIndex: rowStartIndex,
          stopIndex: rowStopIndex
        });
      }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
    }

    (0, _createClass3.default)(List, [{
      key: 'forceUpdateGrid',
      value: function forceUpdateGrid() {
        if (this.Grid) {
          this.Grid.forceUpdate();
        }
      }

      /** See Grid#getOffsetForCell */

    }, {
      key: 'getOffsetForRow',
      value: function getOffsetForRow(_ref5) {
        var alignment = _ref5.alignment,
            index = _ref5.index;

        if (this.Grid) {
          var _Grid$getOffsetForCel = this.Grid.getOffsetForCell({
            alignment: alignment,
            rowIndex: index,
            columnIndex: 0
          }),
              _scrollTop = _Grid$getOffsetForCel.scrollTop;

          return _scrollTop;
        }
        return 0;
      }

      /** CellMeasurer compatibility */

    }, {
      key: 'invalidateCellSizeAfterRender',
      value: function invalidateCellSizeAfterRender(_ref6) {
        var columnIndex = _ref6.columnIndex,
            rowIndex = _ref6.rowIndex;

        if (this.Grid) {
          this.Grid.invalidateCellSizeAfterRender({
            rowIndex: rowIndex,
            columnIndex: columnIndex
          });
        }
      }

      /** See Grid#measureAllCells */

    }, {
      key: 'measureAllRows',
      value: function measureAllRows() {
        if (this.Grid) {
          this.Grid.measureAllCells();
        }
      }

      /** CellMeasurer compatibility */

    }, {
      key: 'recomputeGridSize',
      value: function recomputeGridSize() {
        var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref7$columnIndex = _ref7.columnIndex,
            columnIndex = _ref7$columnIndex === undefined ? 0 : _ref7$columnIndex,
            _ref7$rowIndex = _ref7.rowIndex,
            rowIndex = _ref7$rowIndex === undefined ? 0 : _ref7$rowIndex;

        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex: rowIndex,
            columnIndex: columnIndex
          });
        }
      }

      /** See Grid#recomputeGridSize */

    }, {
      key: 'recomputeRowHeights',
      value: function recomputeRowHeights() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex: index,
            columnIndex: 0
          });
        }
      }

      /** See Grid#scrollToPosition */

    }, {
      key: 'scrollToPosition',
      value: function scrollToPosition() {
        var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (this.Grid) {
          this.Grid.scrollToPosition({ scrollTop: scrollTop });
        }
      }

      /** See Grid#scrollToCell */

    }, {
      key: 'scrollToRow',
      value: function scrollToRow() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (this.Grid) {
          this.Grid.scrollToCell({
            columnIndex: 0,
            rowIndex: index
          });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            className = _props.className,
            noRowsRenderer = _props.noRowsRenderer,
            scrollToIndex = _props.scrollToIndex,
            width = _props.width;


        var classNames = (0, _classnames2.default)('ReactVirtualized__List', className);

        return React.createElement(_Grid2.default, (0, _extends3.default)({}, this.props, {
          autoContainerWidth: true,
          cellRenderer: this._cellRenderer,
          className: classNames,
          columnWidth: width,
          columnCount: 1,
          noContentRenderer: noRowsRenderer,
          onScroll: this._onScroll,
          onSectionRendered: this._onSectionRendered,
          ref: this._setRef,
          scrollToRow: scrollToIndex
        }));
      }
    }]);
    return List;
  }(React.PureComponent);

  List.defaultProps = {
    autoHeight: false,
    estimatedRowSize: 30,
    onScroll: function onScroll() {},
    noRowsRenderer: function noRowsRenderer() {
      return null;
    },
    onRowsRendered: function onRowsRendered() {},
    overscanIndicesGetter: _Grid.accessibilityOverscanIndicesGetter,
    overscanRowCount: 10,
    scrollToAlignment: 'auto',
    scrollToIndex: -1,
    style: {}
  };
  List.propTypes = "production" === 'production' ? null : {
    "aria-label": require('prop-types').string,


    /**
     * Removes fixed height from the scrollingContainer so that the total height
     * of rows can stretch the window. Intended for use with WindowScroller
     */
    autoHeight: require('prop-types').bool.isRequired,


    /** Optional CSS class name */
    className: require('prop-types').string,


    /**
     * Used to estimate the total height of a List before all of its rows have actually been measured.
     * The estimated total height is adjusted as rows are rendered.
     */
    estimatedRowSize: require('prop-types').number.isRequired,


    /** Height constraint for list (determines how many actual rows are rendered) */
    height: require('prop-types').number.isRequired,


    /** Optional renderer to be used in place of rows when rowCount is 0 */
    noRowsRenderer: typeof babelPluginFlowReactPropTypes_proptype_NoContentRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_NoContentRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_NoContentRenderer : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_NoContentRenderer).isRequired,


    /** Callback invoked with information about the slice of rows that were just rendered.  */

    onRowsRendered: require('prop-types').func.isRequired,


    /**
     * Callback invoked whenever the scroll offset changes within the inner scrollable region.
     * This callback can be used to sync scrolling between lists, tables, or grids.
     */
    onScroll: require('prop-types').func.isRequired,


    /** See Grid#overscanIndicesGetter */
    overscanIndicesGetter: typeof babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter === 'function' ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired ? babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter.isRequired : babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_OverscanIndicesGetter).isRequired,


    /**
     * Number of rows to render above/below the visible bounds of the list.
     * These rows can help for smoother scrolling on touch devices.
     */
    overscanRowCount: require('prop-types').number.isRequired,


    /** Either a fixed row height (number) or a function that returns the height of a row given its index.  */
    rowHeight: typeof babelPluginFlowReactPropTypes_proptype_CellSize === 'function' ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired ? babelPluginFlowReactPropTypes_proptype_CellSize.isRequired : babelPluginFlowReactPropTypes_proptype_CellSize : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_CellSize).isRequired,


    /** Responsible for rendering a row given an index; ({ index: number }): node */
    rowRenderer: typeof babelPluginFlowReactPropTypes_proptype_RowRenderer === 'function' ? babelPluginFlowReactPropTypes_proptype_RowRenderer.isRequired ? babelPluginFlowReactPropTypes_proptype_RowRenderer.isRequired : babelPluginFlowReactPropTypes_proptype_RowRenderer : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_RowRenderer).isRequired,


    /** Number of rows in list. */
    rowCount: require('prop-types').number.isRequired,


    /** See Grid#scrollToAlignment */
    scrollToAlignment: typeof babelPluginFlowReactPropTypes_proptype_Alignment === 'function' ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired ? babelPluginFlowReactPropTypes_proptype_Alignment.isRequired : babelPluginFlowReactPropTypes_proptype_Alignment : require('prop-types').shape(babelPluginFlowReactPropTypes_proptype_Alignment).isRequired,


    /** Row index to ensure visible (by forcefully scrolling if necessary) */
    scrollToIndex: require('prop-types').number.isRequired,


    /** Vertical offset. */
    scrollTop: require('prop-types').number,


    /** Optional inline style */
    style: require('prop-types').object.isRequired,


    /** Tab index for focus */
    tabIndex: require('prop-types').number,


    /** Width of list */
    width: require('prop-types').number.isRequired
  };
  exports.default = List;
  },{"../Grid":1201,"./types":1212,"babel-runtime/core-js/object/get-own-property-descriptor":578,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"classnames":698,"prop-types":1249,"react":1253}],1211:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _List = require('./List');

  Object.defineProperty(exports, 'default', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_List).default;
    }
  });
  Object.defineProperty(exports, 'List', {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_List).default;
    }
  });

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  },{"./List":1210}],1212:[function(require,module,exports){
  'use strict';

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  var babelPluginFlowReactPropTypes_proptype_RowRendererParams = "production" === 'production' ? null : {
    index: require('prop-types').number.isRequired,
    isScrolling: require('prop-types').bool.isRequired,
    isVisible: require('prop-types').bool.isRequired,
    key: require('prop-types').string.isRequired,
    parent: require('prop-types').object.isRequired,
    style: require('prop-types').object.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RowRendererParams', {
    value: babelPluginFlowReactPropTypes_proptype_RowRendererParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_RowRenderer = "production" === 'production' ? null : require('prop-types').func;
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RowRenderer', {
    value: babelPluginFlowReactPropTypes_proptype_RowRenderer,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_RenderedRows = "production" === 'production' ? null : {
    overscanStartIndex: require('prop-types').number.isRequired,
    overscanStopIndex: require('prop-types').number.isRequired,
    startIndex: require('prop-types').number.isRequired,
    stopIndex: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_RenderedRows', {
    value: babelPluginFlowReactPropTypes_proptype_RenderedRows,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_Scroll = "production" === 'production' ? null : {
    clientHeight: require('prop-types').number.isRequired,
    scrollHeight: require('prop-types').number.isRequired,
    scrollTop: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Scroll', {
    value: babelPluginFlowReactPropTypes_proptype_Scroll,
    configurable: true
  });
  },{"prop-types":1249,"react":1253}],1213:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _classnames = require('classnames');

  var _classnames2 = _interopRequireDefault(_classnames);

  var _PositionCache = require('./PositionCache');

  var _PositionCache2 = _interopRequireDefault(_PositionCache);

  var _requestAnimationTimeout = require('../utils/requestAnimationTimeout');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId = require('../utils/requestAnimationTimeout').babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId || require('prop-types').any;

  var emptyObject = {};

  /**
   * Specifies the number of miliseconds during which to disable pointer events while a scroll is in progress.
   * This improves performance and makes scrolling smoother.
   */
  var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;

  /**
   * This component efficiently displays arbitrarily positioned cells using windowing techniques.
   * Cell position is determined by an injected `cellPositioner` property.
   * Windowing is vertical; this component does not support horizontal scrolling.
   *
   * Rendering occurs in two phases:
   * 1) First pass uses estimated cell sizes (provided by the cache) to determine how many cells to measure in a batch.
   *    Batch size is chosen using a fast, naive layout algorithm that stacks images in order until the viewport has been filled.
   *    After measurement is complete (componentDidMount or componentDidUpdate) this component evaluates positioned cells
   *    in order to determine if another measurement pass is required (eg if actual cell sizes were less than estimated sizes).
   *    All measurements are permanently cached (keyed by `keyMapper`) for performance purposes.
   * 2) Second pass uses the external `cellPositioner` to layout cells.
   *    At this time the positioner has access to cached size measurements for all cells.
   *    The positions it returns are cached by Masonry for fast access later.
   *    Phase one is repeated if the user scrolls beyond the current layout's bounds.
   *    If the layout is invalidated due to eg a resize, cached positions can be cleared using `recomputeCellPositions()`.
   *
   * Animation constraints:
   *   Simple animations are supported (eg translate/slide into place on initial reveal).
   *   More complex animations are not (eg flying from one position to another on resize).
   *
   * Layout constraints:
   *   This component supports multi-column layout.
   *   The height of each item may vary.
   *   The width of each item must not exceed the width of the column it is "in".
   *   The left position of all items within a column must align.
   *   (Items may not span multiple columns.)
   */

  var Masonry = function (_PureComponent) {
    (0, _inherits3.default)(Masonry, _PureComponent);

    function Masonry(props, context) {
      (0, _classCallCheck3.default)(this, Masonry);

      var _this = (0, _possibleConstructorReturn3.default)(this, (Masonry.__proto__ || (0, _getPrototypeOf2.default)(Masonry)).call(this, props, context));

      _this._invalidateOnUpdateStartIndex = null;
      _this._invalidateOnUpdateStopIndex = null;
      _this._positionCache = new _PositionCache2.default();
      _this._startIndex = null;
      _this._startIndexMemoized = null;
      _this._stopIndex = null;
      _this._stopIndexMemoized = null;


      _this.state = {
        isScrolling: false,
        scrollTop: 0
      };

      _this._debounceResetIsScrollingCallback = _this._debounceResetIsScrollingCallback.bind(_this);
      _this._setScrollingContainerRef = _this._setScrollingContainerRef.bind(_this);
      _this._onScroll = _this._onScroll.bind(_this);
      return _this;
    }

    (0, _createClass3.default)(Masonry, [{
      key: 'clearCellPositions',
      value: function clearCellPositions() {
        this._positionCache = new _PositionCache2.default();
        this.forceUpdate();
      }

      // HACK This method signature was intended for Grid

    }, {
      key: 'invalidateCellSizeAfterRender',
      value: function invalidateCellSizeAfterRender(_ref) {
        var index = _ref.rowIndex;

        if (this._invalidateOnUpdateStartIndex === null) {
          this._invalidateOnUpdateStartIndex = index;
          this._invalidateOnUpdateStopIndex = index;
        } else {
          this._invalidateOnUpdateStartIndex = Math.min(this._invalidateOnUpdateStartIndex, index);
          this._invalidateOnUpdateStopIndex = Math.max(this._invalidateOnUpdateStopIndex, index);
        }
      }
    }, {
      key: 'recomputeCellPositions',
      value: function recomputeCellPositions() {
        var stopIndex = this._positionCache.count - 1;

        this._positionCache = new _PositionCache2.default();
        this._populatePositionCache(0, stopIndex);

        this.forceUpdate();
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        this._checkInvalidateOnUpdate();
        this._invokeOnScrollCallback();
        this._invokeOnCellsRenderedCallback();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this._checkInvalidateOnUpdate();
        this._invokeOnScrollCallback();
        this._invokeOnCellsRenderedCallback();
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this._debounceResetIsScrollingId) {
          (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._debounceResetIsScrollingId);
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var scrollTop = this.props.scrollTop;


        if (scrollTop !== nextProps.scrollTop) {
          this._debounceResetIsScrolling();

          this.setState({
            isScrolling: true,
            scrollTop: nextProps.scrollTop
          });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            autoHeight = _props.autoHeight,
            cellCount = _props.cellCount,
            cellMeasurerCache = _props.cellMeasurerCache,
            cellRenderer = _props.cellRenderer,
            className = _props.className,
            height = _props.height,
            id = _props.id,
            keyMapper = _props.keyMapper,
            overscanByPixels = _props.overscanByPixels,
            role = _props.role,
            style = _props.style,
            tabIndex = _props.tabIndex,
            width = _props.width;
        var _state = this.state,
            isScrolling = _state.isScrolling,
            scrollTop = _state.scrollTop;


        var children = [];

        var estimateTotalHeight = this._getEstimatedTotalHeight();

        var shortestColumnSize = this._positionCache.shortestColumnSize;
        var measuredCellCount = this._positionCache.count;

        var startIndex = 0;
        var stopIndex = void 0;

        this._positionCache.range(Math.max(0, scrollTop - overscanByPixels), height + overscanByPixels * 2, function (index, left, top) {
          if (typeof stopIndex === 'undefined') {
            startIndex = index;
            stopIndex = index;
          } else {
            startIndex = Math.min(startIndex, index);
            stopIndex = Math.max(stopIndex, index);
          }

          children.push(cellRenderer({
            index: index,
            isScrolling: isScrolling,
            key: keyMapper(index),
            parent: _this2,
            style: {
              height: cellMeasurerCache.getHeight(index),
              left: left,
              position: 'absolute',
              top: top,
              width: cellMeasurerCache.getWidth(index)
            }
          }));
        });

        // We need to measure additional cells for this layout
        if (shortestColumnSize < scrollTop + height + overscanByPixels && measuredCellCount < cellCount) {
          var batchSize = Math.min(cellCount - measuredCellCount, Math.ceil((scrollTop + height + overscanByPixels - shortestColumnSize) / cellMeasurerCache.defaultHeight * width / cellMeasurerCache.defaultWidth));

          for (var _index = measuredCellCount; _index < measuredCellCount + batchSize; _index++) {
            stopIndex = _index;

            children.push(cellRenderer({
              index: _index,
              isScrolling: isScrolling,
              key: keyMapper(_index),
              parent: this,
              style: {
                width: cellMeasurerCache.getWidth(_index)
              }
            }));
          }
        }

        this._startIndex = startIndex;
        this._stopIndex = stopIndex;

        return _react2.default.createElement(
          'div',
          {
            ref: this._setScrollingContainerRef,
            'aria-label': this.props['aria-label'],
            className: (0, _classnames2.default)('ReactVirtualized__Masonry', className),
            id: id,
            onScroll: this._onScroll,
            role: role,
            style: (0, _extends3.default)({
              boxSizing: 'border-box',
              direction: 'ltr',
              height: autoHeight ? 'auto' : height,
              overflowX: 'hidden',
              overflowY: estimateTotalHeight < height ? 'hidden' : 'auto',
              position: 'relative',
              width: width,
              WebkitOverflowScrolling: 'touch',
              willChange: 'transform'
            }, style),
            tabIndex: tabIndex },
          _react2.default.createElement(
            'div',
            {
              className: 'ReactVirtualized__Masonry__innerScrollContainer',
              style: {
                width: '100%',
                height: estimateTotalHeight,
                maxWidth: '100%',
                maxHeight: estimateTotalHeight,
                overflow: 'hidden',
                pointerEvents: isScrolling ? 'none' : '',
                position: 'relative'
              } },
            children
          )
        );
      }
    }, {
      key: '_checkInvalidateOnUpdate',
      value: function _checkInvalidateOnUpdate() {
        if (typeof this._invalidateOnUpdateStartIndex === 'number') {
          var _startIndex = this._invalidateOnUpdateStartIndex;
          var _stopIndex = this._invalidateOnUpdateStopIndex;

          this._invalidateOnUpdateStartIndex = null;
          this._invalidateOnUpdateStopIndex = null;

          // Query external layout logic for position of newly-measured cells
          this._populatePositionCache(_startIndex, _stopIndex);

          this.forceUpdate();
        }
      }
    }, {
      key: '_debounceResetIsScrolling',
      value: function _debounceResetIsScrolling() {
        var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;


        if (this._debounceResetIsScrollingId) {
          (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._debounceResetIsScrollingId);
        }

        this._debounceResetIsScrollingId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceResetIsScrollingCallback, scrollingResetTimeInterval);
      }
    }, {
      key: '_debounceResetIsScrollingCallback',
      value: function _debounceResetIsScrollingCallback() {
        this.setState({
          isScrolling: false
        });
      }
    }, {
      key: '_getEstimatedTotalHeight',
      value: function _getEstimatedTotalHeight() {
        var _props2 = this.props,
            cellCount = _props2.cellCount,
            cellMeasurerCache = _props2.cellMeasurerCache,
            width = _props2.width;


        var estimatedColumnCount = Math.max(1, Math.floor(width / cellMeasurerCache.defaultWidth));

        return this._positionCache.estimateTotalHeight(cellCount, estimatedColumnCount, cellMeasurerCache.defaultHeight);
      }
    }, {
      key: '_invokeOnScrollCallback',
      value: function _invokeOnScrollCallback() {
        var _props3 = this.props,
            height = _props3.height,
            onScroll = _props3.onScroll;
        var scrollTop = this.state.scrollTop;


        if (this._onScrollMemoized !== scrollTop) {
          onScroll({
            clientHeight: height,
            scrollHeight: this._getEstimatedTotalHeight(),
            scrollTop: scrollTop
          });

          this._onScrollMemoized = scrollTop;
        }
      }
    }, {
      key: '_invokeOnCellsRenderedCallback',
      value: function _invokeOnCellsRenderedCallback() {
        if (this._startIndexMemoized !== this._startIndex || this._stopIndexMemoized !== this._stopIndex) {
          var _onCellsRendered = this.props.onCellsRendered;


          _onCellsRendered({
            startIndex: this._startIndex,
            stopIndex: this._stopIndex
          });

          this._startIndexMemoized = this._startIndex;
          this._stopIndexMemoized = this._stopIndex;
        }
      }
    }, {
      key: '_populatePositionCache',
      value: function _populatePositionCache(startIndex, stopIndex) {
        var _props4 = this.props,
            cellMeasurerCache = _props4.cellMeasurerCache,
            cellPositioner = _props4.cellPositioner;


        for (var _index2 = startIndex; _index2 <= stopIndex; _index2++) {
          var _cellPositioner = cellPositioner(_index2),
              _left = _cellPositioner.left,
              _top = _cellPositioner.top;

          this._positionCache.setPosition(_index2, _left, _top, cellMeasurerCache.getHeight(_index2));
        }
      }
    }, {
      key: '_setScrollingContainerRef',
      value: function _setScrollingContainerRef(ref) {
        this._scrollingContainer = ref;
      }
    }, {
      key: '_onScroll',
      value: function _onScroll(event) {
        var height = this.props.height;


        var eventScrollTop = event.target.scrollTop;

        // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
        // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
        // This causes a series of rapid renders that is slow for long lists.
        // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.
        var scrollTop = Math.min(Math.max(0, this._getEstimatedTotalHeight() - height), eventScrollTop);

        // On iOS, we can arrive at negative offsets by swiping past the start or end.
        // Avoid re-rendering in this case as it can cause problems; see #532 for more.
        if (eventScrollTop !== scrollTop) {
          return;
        }

        // Prevent pointer events from interrupting a smooth scroll
        this._debounceResetIsScrolling();

        // Certain devices (like Apple touchpad) rapid-fire duplicate events.
        // Don't force a re-render if this is the case.
        // The mouse may move faster then the animation frame does.
        // Use requestAnimationFrame to avoid over-updating.
        if (this.state.scrollTop !== scrollTop) {
          this.setState({
            isScrolling: true,
            scrollTop: scrollTop
          });
        }
      }
    }]);
    return Masonry;
  }(_react.PureComponent);

  Masonry.defaultProps = {
    autoHeight: false,
    keyMapper: identity,
    onCellsRendered: noop,
    onScroll: noop,
    overscanByPixels: 20,
    role: 'grid',
    scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
    style: emptyObject,
    tabIndex: 0
  };
  Masonry.propTypes = "production" === 'production' ? null : {
    autoHeight: require('prop-types').bool.isRequired,
    cellCount: require('prop-types').number.isRequired,
    cellMeasurerCache: typeof CellMeasurerCache === 'function' ? require('prop-types').instanceOf(CellMeasurerCache).isRequired : require('prop-types').any.isRequired,
    cellPositioner: typeof Positioner === 'function' ? require('prop-types').instanceOf(Positioner).isRequired : require('prop-types').any.isRequired,
    cellRenderer: typeof CellRenderer === 'function' ? require('prop-types').instanceOf(CellRenderer).isRequired : require('prop-types').any.isRequired,
    className: require('prop-types').string,
    height: require('prop-types').number.isRequired,
    id: require('prop-types').string,
    keyMapper: typeof KeyMapper === 'function' ? require('prop-types').instanceOf(KeyMapper).isRequired : require('prop-types').any.isRequired,
    onCellsRendered: typeof OnCellsRenderedCallback === 'function' ? require('prop-types').instanceOf(OnCellsRenderedCallback) : require('prop-types').any,
    onScroll: typeof OnScrollCallback === 'function' ? require('prop-types').instanceOf(OnScrollCallback) : require('prop-types').any,
    overscanByPixels: require('prop-types').number.isRequired,
    role: require('prop-types').string.isRequired,
    scrollingResetTimeInterval: require('prop-types').number.isRequired,
    style: function style(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error('Prop `' + propName + '` has type \'any\' or \'mixed\', but was not provided to `' + componentName + '`. Pass undefined or any other value.');
      }
    },
    tabIndex: require('prop-types').number.isRequired,
    width: require('prop-types').number.isRequired
  };
  exports.default = Masonry;


  function identity(value) {
    return value;
  }

  function noop() {}

  var babelPluginFlowReactPropTypes_proptype_CellMeasurerCache = "production" === 'production' ? null : {
    defaultHeight: require('prop-types').number.isRequired,
    defaultWidth: require('prop-types').number.isRequired,
    getHeight: require('prop-types').func.isRequired,
    getWidth: require('prop-types').func.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_CellMeasurerCache', {
    value: babelPluginFlowReactPropTypes_proptype_CellMeasurerCache,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_Positioner = "production" === 'production' ? null : require('prop-types').func;
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_Positioner', {
    value: babelPluginFlowReactPropTypes_proptype_Positioner,
    configurable: true
  });
  },{"../utils/requestAnimationTimeout":1242,"./PositionCache":1214,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"classnames":698,"prop-types":1249,"react":1253}],1214:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

  var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _intervalTree = require('../vendor/intervalTree');

  var _intervalTree2 = _interopRequireDefault(_intervalTree);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // Position cache requirements:
  //   O(log(n)) lookup of cells to render for a given viewport size
  //   O(1) lookup of shortest measured column (so we know when to enter phase 1)
  var PositionCache = function () {
    function PositionCache() {
      (0, _classCallCheck3.default)(this, PositionCache);
      this._columnSizeMap = {};
      this._intervalTree = (0, _intervalTree2.default)();
      this._leftMap = {};
    }
    // Tracks the height of each column


    // Store tops and bottoms of each cell for fast intersection lookup.


    // Maps cell index to x coordinates for quick lookup.


    (0, _createClass3.default)(PositionCache, [{
      key: 'estimateTotalHeight',
      value: function estimateTotalHeight(cellCount, columnCount, defaultCellHeight) {
        var unmeasuredCellCount = cellCount - this.count;
        return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;
      }

      // Render all cells visible within the viewport range defined.

    }, {
      key: 'range',
      value: function range(scrollTop, clientHeight, renderCallback) {
        var _this = this;

        this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, function (_ref) {
          var _ref2 = (0, _slicedToArray3.default)(_ref, 3),
              top = _ref2[0],
              _ = _ref2[1],
              index = _ref2[2];

          return renderCallback(index, _this._leftMap[index], top);
        });
      }
    }, {
      key: 'setPosition',
      value: function setPosition(index, left, top, height) {
        this._intervalTree.insert([top, top + height, index]);
        this._leftMap[index] = left;

        var columnSizeMap = this._columnSizeMap;
        var columnHeight = columnSizeMap[left];
        if (columnHeight === undefined) {
          columnSizeMap[left] = top + height;
        } else {
          columnSizeMap[left] = Math.max(columnHeight, top + height);
        }
      }
    }, {
      key: 'count',
      get: function get() {
        return this._intervalTree.count;
      }
    }, {
      key: 'shortestColumnSize',
      get: function get() {
        var columnSizeMap = this._columnSizeMap;

        var size = 0;

        for (var i in columnSizeMap) {
          var height = columnSizeMap[i];
          size = size === 0 ? height : Math.min(size, height);
        }

        return size;
      }
    }, {
      key: 'tallestColumnSize',
      get: function get() {
        var columnSizeMap = this._columnSizeMap;

        var size = 0;

        for (var i in columnSizeMap) {
          var height = columnSizeMap[i];
          size = Math.max(size, height);
        }

        return size;
      }
    }]);
    return PositionCache;
  }();

  exports.default = PositionCache;
  },{"../vendor/intervalTree":1245,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/slicedToArray":590}],1215:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createCellPositioner;

  var babelPluginFlowReactPropTypes_proptype_Positioner = require('./Masonry').babelPluginFlowReactPropTypes_proptype_Positioner || require('prop-types').any;

  var babelPluginFlowReactPropTypes_proptype_CellMeasurerCache = require('./Masonry').babelPluginFlowReactPropTypes_proptype_CellMeasurerCache || require('prop-types').any;

  function createCellPositioner(_ref) {
    var cellMeasurerCache = _ref.cellMeasurerCache,
        columnCount = _ref.columnCount,
        columnWidth = _ref.columnWidth,
        _ref$spacer = _ref.spacer,
        spacer = _ref$spacer === undefined ? 0 : _ref$spacer;

    var columnHeights = void 0;

    initOrResetDerivedValues();

    function cellPositioner(index) {
      // Find the shortest column and use it.
      var columnIndex = 0;
      for (var i = 1; i < columnHeights.length; i++) {
        if (columnHeights[i] < columnHeights[columnIndex]) {
          columnIndex = i;
        }
      }

      var left = columnIndex * (columnWidth + spacer);
      var top = columnHeights[columnIndex] || 0;

      columnHeights[columnIndex] = top + cellMeasurerCache.getHeight(index) + spacer;

      return {
        left: left,
        top: top
      };
    }

    function initOrResetDerivedValues() {
      // Track the height of each column.
      // Layout algorithm below always inserts into the shortest column.
      columnHeights = [];
      for (var i = 0; i < columnCount; i++) {
        columnHeights[i] = 0;
      }
    }

    function reset(params) {
      columnCount = params.columnCount;
      columnWidth = params.columnWidth;
      spacer = params.spacer;

      initOrResetDerivedValues();
    }

    cellPositioner.reset = reset;

    return cellPositioner;
  }
  },{"./Masonry":1213,"prop-types":1249}],1216:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Masonry = exports.createCellPositioner = undefined;

  var _createCellPositioner = require('./createCellPositioner');

  var _createCellPositioner2 = _interopRequireDefault(_createCellPositioner);

  var _Masonry = require('./Masonry');

  var _Masonry2 = _interopRequireDefault(_Masonry);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _Masonry2.default;
  exports.createCellPositioner = _createCellPositioner2.default;
  exports.Masonry = _Masonry2.default;
  },{"./Masonry":1213,"./createCellPositioner":1215}],1217:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _CellMeasurer = require('../CellMeasurer');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Caches measurements for a given cell.
   */
  var CellMeasurerCacheDecorator = function () {
    function CellMeasurerCacheDecorator() {
      var _this = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck3.default)(this, CellMeasurerCacheDecorator);

      this.columnWidth = function (_ref) {
        var index = _ref.index;

        _this._cellMeasurerCache.columnWidth({
          index: index + _this._columnIndexOffset
        });
      };

      this.rowHeight = function (_ref2) {
        var index = _ref2.index;

        _this._cellMeasurerCache.rowHeight({
          index: index + _this._rowIndexOffset
        });
      };

      var cellMeasurerCache = params.cellMeasurerCache,
          _params$columnIndexOf = params.columnIndexOffset,
          columnIndexOffset = _params$columnIndexOf === undefined ? 0 : _params$columnIndexOf,
          _params$rowIndexOffse = params.rowIndexOffset,
          rowIndexOffset = _params$rowIndexOffse === undefined ? 0 : _params$rowIndexOffse;


      this._cellMeasurerCache = cellMeasurerCache;
      this._columnIndexOffset = columnIndexOffset;
      this._rowIndexOffset = rowIndexOffset;
    }

    (0, _createClass3.default)(CellMeasurerCacheDecorator, [{
      key: 'clear',
      value: function clear(rowIndex, columnIndex) {
        this._cellMeasurerCache.clear(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: 'clearAll',
      value: function clearAll() {
        this._cellMeasurerCache.clearAll();
      }
    }, {
      key: 'hasFixedHeight',
      value: function hasFixedHeight() {
        return this._cellMeasurerCache.hasFixedHeight();
      }
    }, {
      key: 'hasFixedWidth',
      value: function hasFixedWidth() {
        return this._cellMeasurerCache.hasFixedWidth();
      }
    }, {
      key: 'getHeight',
      value: function getHeight(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        return this._cellMeasurerCache.getHeight(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: 'getWidth',
      value: function getWidth(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        return this._cellMeasurerCache.getWidth(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: 'has',
      value: function has(rowIndex) {
        var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        return this._cellMeasurerCache.has(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
      }
    }, {
      key: 'set',
      value: function set(rowIndex, columnIndex, width, height) {
        this._cellMeasurerCache.set(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset, width, height);
      }
    }, {
      key: 'defaultHeight',
      get: function get() {
        return this._cellMeasurerCache.defaultHeight;
      }
    }, {
      key: 'defaultWidth',
      get: function get() {
        return this._cellMeasurerCache.defaultWidth;
      }
    }]);
    return CellMeasurerCacheDecorator;
  }();

  exports.default = CellMeasurerCacheDecorator;
  },{"../CellMeasurer":1187,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585}],1218:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

  var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _CellMeasurerCacheDecorator = require('./CellMeasurerCacheDecorator');

  var _CellMeasurerCacheDecorator2 = _interopRequireDefault(_CellMeasurerCacheDecorator);

  var _Grid = require('../Grid');

  var _Grid2 = _interopRequireDefault(_Grid);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var SCROLLBAR_SIZE_BUFFER = 20;

  /**
   * Renders 1, 2, or 4 Grids depending on configuration.
   * A main (body) Grid will always be rendered.
   * Optionally, 1-2 Grids for sticky header rows will also be rendered.
   * If no sticky columns, only 1 sticky header Grid will be rendered.
   * If sticky columns, 2 sticky header Grids will be rendered.
   */

  var MultiGrid = function (_PureComponent) {
    (0, _inherits3.default)(MultiGrid, _PureComponent);

    function MultiGrid(props, context) {
      (0, _classCallCheck3.default)(this, MultiGrid);

      var _this = (0, _possibleConstructorReturn3.default)(this, (MultiGrid.__proto__ || (0, _getPrototypeOf2.default)(MultiGrid)).call(this, props, context));

      _this.state = {
        scrollLeft: 0,
        scrollTop: 0,
        scrollbarSize: 0,
        showHorizontalScrollbar: false,
        showVerticalScrollbar: false
      };

      _this._deferredInvalidateColumnIndex = null;
      _this._deferredInvalidateRowIndex = null;

      _this._bottomLeftGridRef = _this._bottomLeftGridRef.bind(_this);
      _this._bottomRightGridRef = _this._bottomRightGridRef.bind(_this);
      _this._cellRendererBottomLeftGrid = _this._cellRendererBottomLeftGrid.bind(_this);
      _this._cellRendererBottomRightGrid = _this._cellRendererBottomRightGrid.bind(_this);
      _this._cellRendererTopRightGrid = _this._cellRendererTopRightGrid.bind(_this);
      _this._columnWidthRightGrid = _this._columnWidthRightGrid.bind(_this);
      _this._onScroll = _this._onScroll.bind(_this);
      _this._onScrollbarPresenceChange = _this._onScrollbarPresenceChange.bind(_this);
      _this._onScrollLeft = _this._onScrollLeft.bind(_this);
      _this._onScrollTop = _this._onScrollTop.bind(_this);
      _this._rowHeightBottomGrid = _this._rowHeightBottomGrid.bind(_this);
      _this._topLeftGridRef = _this._topLeftGridRef.bind(_this);
      _this._topRightGridRef = _this._topRightGridRef.bind(_this);
      return _this;
    }

    (0, _createClass3.default)(MultiGrid, [{
      key: 'forceUpdateGrids',
      value: function forceUpdateGrids() {
        this._bottomLeftGrid && this._bottomLeftGrid.forceUpdate();
        this._bottomRightGrid && this._bottomRightGrid.forceUpdate();
        this._topLeftGrid && this._topLeftGrid.forceUpdate();
        this._topRightGrid && this._topRightGrid.forceUpdate();
      }

      /** See Grid#invalidateCellSizeAfterRender */

    }, {
      key: 'invalidateCellSizeAfterRender',
      value: function invalidateCellSizeAfterRender() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$columnIndex = _ref.columnIndex,
            columnIndex = _ref$columnIndex === undefined ? 0 : _ref$columnIndex,
            _ref$rowIndex = _ref.rowIndex,
            rowIndex = _ref$rowIndex === undefined ? 0 : _ref$rowIndex;

        this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
        this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
      }

      /** See Grid#measureAllCells */

    }, {
      key: 'measureAllCells',
      value: function measureAllCells() {
        this._bottomLeftGrid && this._bottomLeftGrid.measureAllCells();
        this._bottomRightGrid && this._bottomRightGrid.measureAllCells();
        this._topLeftGrid && this._topLeftGrid.measureAllCells();
        this._topRightGrid && this._topRightGrid.measureAllCells();
      }

      /** See Grid#recomputeGridSize */

    }, {
      key: 'recomputeGridSize',
      value: function recomputeGridSize() {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$columnIndex = _ref2.columnIndex,
            columnIndex = _ref2$columnIndex === undefined ? 0 : _ref2$columnIndex,
            _ref2$rowIndex = _ref2.rowIndex,
            rowIndex = _ref2$rowIndex === undefined ? 0 : _ref2$rowIndex;

        var _props = this.props,
            fixedColumnCount = _props.fixedColumnCount,
            fixedRowCount = _props.fixedRowCount;


        var adjustedColumnIndex = Math.max(0, columnIndex - fixedColumnCount);
        var adjustedRowIndex = Math.max(0, rowIndex - fixedRowCount);

        this._bottomLeftGrid && this._bottomLeftGrid.recomputeGridSize({
          columnIndex: columnIndex,
          rowIndex: adjustedRowIndex
        });
        this._bottomRightGrid && this._bottomRightGrid.recomputeGridSize({
          columnIndex: adjustedColumnIndex,
          rowIndex: adjustedRowIndex
        });
        this._topLeftGrid && this._topLeftGrid.recomputeGridSize({
          columnIndex: columnIndex,
          rowIndex: rowIndex
        });
        this._topRightGrid && this._topRightGrid.recomputeGridSize({
          columnIndex: adjustedColumnIndex,
          rowIndex: rowIndex
        });

        this._leftGridWidth = null;
        this._topGridHeight = null;
        this._maybeCalculateCachedStyles(null, this.props, null, this.state);
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _props2 = this.props,
            scrollLeft = _props2.scrollLeft,
            scrollTop = _props2.scrollTop;


        if (scrollLeft > 0 || scrollTop > 0) {
          var newState = {};

          if (scrollLeft > 0) {
            newState.scrollLeft = scrollLeft;
          }

          if (scrollTop > 0) {
            newState.scrollTop = scrollTop;
          }

          this.setState(newState);
        }
        this._handleInvalidatedGridSize();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this._handleInvalidatedGridSize();
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        var _props3 = this.props,
            deferredMeasurementCache = _props3.deferredMeasurementCache,
            fixedColumnCount = _props3.fixedColumnCount,
            fixedRowCount = _props3.fixedRowCount;


        this._maybeCalculateCachedStyles(null, this.props, null, this.state);

        if (deferredMeasurementCache) {
          this._deferredMeasurementCacheBottomLeftGrid = fixedRowCount > 0 ? new _CellMeasurerCacheDecorator2.default({
            cellMeasurerCache: deferredMeasurementCache,
            columnIndexOffset: 0,
            rowIndexOffset: fixedRowCount
          }) : deferredMeasurementCache;

          this._deferredMeasurementCacheBottomRightGrid = fixedColumnCount > 0 || fixedRowCount > 0 ? new _CellMeasurerCacheDecorator2.default({
            cellMeasurerCache: deferredMeasurementCache,
            columnIndexOffset: fixedColumnCount,
            rowIndexOffset: fixedRowCount
          }) : deferredMeasurementCache;

          this._deferredMeasurementCacheTopRightGrid = fixedColumnCount > 0 ? new _CellMeasurerCacheDecorator2.default({
            cellMeasurerCache: deferredMeasurementCache,
            columnIndexOffset: fixedColumnCount,
            rowIndexOffset: 0
          }) : deferredMeasurementCache;
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps, nextState) {
        var _props4 = this.props,
            columnWidth = _props4.columnWidth,
            fixedColumnCount = _props4.fixedColumnCount,
            fixedRowCount = _props4.fixedRowCount,
            rowHeight = _props4.rowHeight;


        if (columnWidth !== nextProps.columnWidth || fixedColumnCount !== nextProps.fixedColumnCount) {
          this._leftGridWidth = null;
        }

        if (fixedRowCount !== nextProps.fixedRowCount || rowHeight !== nextProps.rowHeight) {
          this._topGridHeight = null;
        }

        if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
          var newState = {};

          if (nextProps.scrollLeft != null && nextProps.scrollLeft >= 0) {
            newState.scrollLeft = nextProps.scrollLeft;
          }

          if (nextProps.scrollTop != null && nextProps.scrollTop >= 0) {
            newState.scrollTop = nextProps.scrollTop;
          }

          this.setState(newState);
        }

        this._maybeCalculateCachedStyles(this.props, nextProps, this.state, nextState);
      }
    }, {
      key: 'render',
      value: function render() {
        var _props5 = this.props,
            onScroll = _props5.onScroll,
            onSectionRendered = _props5.onSectionRendered,
            onScrollbarPresenceChange = _props5.onScrollbarPresenceChange,
            scrollLeftProp = _props5.scrollLeft,
            scrollToColumn = _props5.scrollToColumn,
            scrollTopProp = _props5.scrollTop,
            scrollToRow = _props5.scrollToRow,
            rest = (0, _objectWithoutProperties3.default)(_props5, ['onScroll', 'onSectionRendered', 'onScrollbarPresenceChange', 'scrollLeft', 'scrollToColumn', 'scrollTop', 'scrollToRow']);

        // Don't render any of our Grids if there are no cells.
        // This mirrors what Grid does,
        // And prevents us from recording inaccurage measurements when used with CellMeasurer.

        if (this.props.width === 0 || this.props.height === 0) {
          return null;
        }

        // scrollTop and scrollLeft props are explicitly filtered out and ignored

        var _state = this.state,
            scrollLeft = _state.scrollLeft,
            scrollTop = _state.scrollTop;


        return _react2.default.createElement(
          'div',
          { style: this._containerOuterStyle },
          _react2.default.createElement(
            'div',
            { style: this._containerTopStyle },
            this._renderTopLeftGrid(rest),
            this._renderTopRightGrid((0, _extends3.default)({}, rest, {
              onScroll: onScroll,
              scrollLeft: scrollLeft
            }))
          ),
          _react2.default.createElement(
            'div',
            { style: this._containerBottomStyle },
            this._renderBottomLeftGrid((0, _extends3.default)({}, rest, {
              onScroll: onScroll,
              scrollTop: scrollTop
            })),
            this._renderBottomRightGrid((0, _extends3.default)({}, rest, {
              onScroll: onScroll,
              onSectionRendered: onSectionRendered,
              scrollLeft: scrollLeft,
              scrollToColumn: scrollToColumn,
              scrollToRow: scrollToRow,
              scrollTop: scrollTop
            }))
          )
        );
      }
    }, {
      key: '_bottomLeftGridRef',
      value: function _bottomLeftGridRef(ref) {
        this._bottomLeftGrid = ref;
      }
    }, {
      key: '_bottomRightGridRef',
      value: function _bottomRightGridRef(ref) {
        this._bottomRightGrid = ref;
      }
    }, {
      key: '_cellRendererBottomLeftGrid',
      value: function _cellRendererBottomLeftGrid(_ref3) {
        var rowIndex = _ref3.rowIndex,
            rest = (0, _objectWithoutProperties3.default)(_ref3, ['rowIndex']);
        var _props6 = this.props,
            cellRenderer = _props6.cellRenderer,
            fixedRowCount = _props6.fixedRowCount,
            rowCount = _props6.rowCount;


        if (rowIndex === rowCount - fixedRowCount) {
          return _react2.default.createElement('div', {
            key: rest.key,
            style: (0, _extends3.default)({}, rest.style, {
              height: SCROLLBAR_SIZE_BUFFER
            })
          });
        } else {
          return cellRenderer((0, _extends3.default)({}, rest, {
            parent: this,
            rowIndex: rowIndex + fixedRowCount
          }));
        }
      }
    }, {
      key: '_cellRendererBottomRightGrid',
      value: function _cellRendererBottomRightGrid(_ref4) {
        var columnIndex = _ref4.columnIndex,
            rowIndex = _ref4.rowIndex,
            rest = (0, _objectWithoutProperties3.default)(_ref4, ['columnIndex', 'rowIndex']);
        var _props7 = this.props,
            cellRenderer = _props7.cellRenderer,
            fixedColumnCount = _props7.fixedColumnCount,
            fixedRowCount = _props7.fixedRowCount;


        return cellRenderer((0, _extends3.default)({}, rest, {
          columnIndex: columnIndex + fixedColumnCount,
          parent: this,
          rowIndex: rowIndex + fixedRowCount
        }));
      }
    }, {
      key: '_cellRendererTopRightGrid',
      value: function _cellRendererTopRightGrid(_ref5) {
        var columnIndex = _ref5.columnIndex,
            rest = (0, _objectWithoutProperties3.default)(_ref5, ['columnIndex']);
        var _props8 = this.props,
            cellRenderer = _props8.cellRenderer,
            columnCount = _props8.columnCount,
            fixedColumnCount = _props8.fixedColumnCount;


        if (columnIndex === columnCount - fixedColumnCount) {
          return _react2.default.createElement('div', {
            key: rest.key,
            style: (0, _extends3.default)({}, rest.style, {
              width: SCROLLBAR_SIZE_BUFFER
            })
          });
        } else {
          return cellRenderer((0, _extends3.default)({}, rest, {
            columnIndex: columnIndex + fixedColumnCount,
            parent: this
          }));
        }
      }
    }, {
      key: '_columnWidthRightGrid',
      value: function _columnWidthRightGrid(_ref6) {
        var index = _ref6.index;
        var _props9 = this.props,
            columnCount = _props9.columnCount,
            fixedColumnCount = _props9.fixedColumnCount,
            columnWidth = _props9.columnWidth;
        var _state2 = this.state,
            scrollbarSize = _state2.scrollbarSize,
            showHorizontalScrollbar = _state2.showHorizontalScrollbar;

        // An extra cell is added to the count
        // This gives the smaller Grid extra room for offset,
        // In case the main (bottom right) Grid has a scrollbar
        // If no scrollbar, the extra space is overflow:hidden anyway

        if (showHorizontalScrollbar && index === columnCount - fixedColumnCount) {
          return scrollbarSize;
        }

        return typeof columnWidth === 'function' ? columnWidth({ index: index + fixedColumnCount }) : columnWidth;
      }
    }, {
      key: '_getBottomGridHeight',
      value: function _getBottomGridHeight(props) {
        var height = props.height;


        var topGridHeight = this._getTopGridHeight(props);

        return height - topGridHeight;
      }
    }, {
      key: '_getLeftGridWidth',
      value: function _getLeftGridWidth(props) {
        var fixedColumnCount = props.fixedColumnCount,
            columnWidth = props.columnWidth;


        if (this._leftGridWidth == null) {
          if (typeof columnWidth === 'function') {
            var leftGridWidth = 0;

            for (var index = 0; index < fixedColumnCount; index++) {
              leftGridWidth += columnWidth({ index: index });
            }

            this._leftGridWidth = leftGridWidth;
          } else {
            this._leftGridWidth = columnWidth * fixedColumnCount;
          }
        }

        return this._leftGridWidth;
      }
    }, {
      key: '_getRightGridWidth',
      value: function _getRightGridWidth(props) {
        var width = props.width;


        var leftGridWidth = this._getLeftGridWidth(props);

        return width - leftGridWidth;
      }
    }, {
      key: '_getTopGridHeight',
      value: function _getTopGridHeight(props) {
        var fixedRowCount = props.fixedRowCount,
            rowHeight = props.rowHeight;


        if (this._topGridHeight == null) {
          if (typeof rowHeight === 'function') {
            var topGridHeight = 0;

            for (var index = 0; index < fixedRowCount; index++) {
              topGridHeight += rowHeight({ index: index });
            }

            this._topGridHeight = topGridHeight;
          } else {
            this._topGridHeight = rowHeight * fixedRowCount;
          }
        }

        return this._topGridHeight;
      }
    }, {
      key: '_handleInvalidatedGridSize',
      value: function _handleInvalidatedGridSize() {
        if (typeof this._deferredInvalidateColumnIndex === 'number') {
          var columnIndex = this._deferredInvalidateColumnIndex;
          var rowIndex = this._deferredInvalidateRowIndex;

          this._deferredInvalidateColumnIndex = null;
          this._deferredInvalidateRowIndex = null;

          this.recomputeGridSize({
            columnIndex: columnIndex,
            rowIndex: rowIndex
          });
          this.forceUpdate();
        }
      }

      /**
       * Avoid recreating inline styles each render; this bypasses Grid's shallowCompare.
       * This method recalculates styles only when specific props change.
       */

    }, {
      key: '_maybeCalculateCachedStyles',
      value: function _maybeCalculateCachedStyles(prevProps, props) {
        var columnWidth = props.columnWidth,
            enableFixedColumnScroll = props.enableFixedColumnScroll,
            enableFixedRowScroll = props.enableFixedRowScroll,
            height = props.height,
            fixedColumnCount = props.fixedColumnCount,
            fixedRowCount = props.fixedRowCount,
            rowHeight = props.rowHeight,
            style = props.style,
            styleBottomLeftGrid = props.styleBottomLeftGrid,
            styleBottomRightGrid = props.styleBottomRightGrid,
            styleTopLeftGrid = props.styleTopLeftGrid,
            styleTopRightGrid = props.styleTopRightGrid,
            width = props.width;


        var firstRender = !prevProps;
        var sizeChange = firstRender || height !== prevProps.height || width !== prevProps.width;
        var leftSizeChange = firstRender || columnWidth !== prevProps.columnWidth || fixedColumnCount !== prevProps.fixedColumnCount;
        var topSizeChange = firstRender || fixedRowCount !== prevProps.fixedRowCount || rowHeight !== prevProps.rowHeight;

        if (firstRender || sizeChange || style !== prevProps.style) {
          this._containerOuterStyle = (0, _extends3.default)({
            height: height,
            overflow: 'visible', // Let :focus outline show through
            width: width
          }, style);
        }

        if (firstRender || sizeChange || topSizeChange) {
          this._containerTopStyle = {
            height: this._getTopGridHeight(props),
            position: 'relative',
            width: width
          };

          this._containerBottomStyle = {
            height: height - this._getTopGridHeight(props),
            overflow: 'visible', // Let :focus outline show through
            position: 'relative',
            width: width
          };
        }

        if (firstRender || styleBottomLeftGrid !== prevProps.styleBottomLeftGrid) {
          this._bottomLeftGridStyle = (0, _extends3.default)({
            left: 0,
            overflowX: 'hidden',
            overflowY: enableFixedColumnScroll ? 'auto' : 'hidden',
            position: 'absolute'
          }, styleBottomLeftGrid);
        }

        if (firstRender || leftSizeChange || styleBottomRightGrid !== prevProps.styleBottomRightGrid) {
          this._bottomRightGridStyle = (0, _extends3.default)({
            left: this._getLeftGridWidth(props),
            position: 'absolute'
          }, styleBottomRightGrid);
        }

        if (firstRender || styleTopLeftGrid !== prevProps.styleTopLeftGrid) {
          this._topLeftGridStyle = (0, _extends3.default)({
            left: 0,
            overflowX: 'hidden',
            overflowY: 'hidden',
            position: 'absolute',
            top: 0
          }, styleTopLeftGrid);
        }

        if (firstRender || leftSizeChange || styleTopRightGrid !== prevProps.styleTopRightGrid) {
          this._topRightGridStyle = (0, _extends3.default)({
            left: this._getLeftGridWidth(props),
            overflowX: enableFixedRowScroll ? 'auto' : 'hidden',
            overflowY: 'hidden',
            position: 'absolute',
            top: 0
          }, styleTopRightGrid);
        }
      }
    }, {
      key: '_onScroll',
      value: function _onScroll(scrollInfo) {
        var scrollLeft = scrollInfo.scrollLeft,
            scrollTop = scrollInfo.scrollTop;

        this.setState({
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        });
        var onScroll = this.props.onScroll;
        if (onScroll) {
          onScroll(scrollInfo);
        }
      }
    }, {
      key: '_onScrollbarPresenceChange',
      value: function _onScrollbarPresenceChange(_ref7) {
        var horizontal = _ref7.horizontal,
            size = _ref7.size,
            vertical = _ref7.vertical;
        var _state3 = this.state,
            showHorizontalScrollbar = _state3.showHorizontalScrollbar,
            showVerticalScrollbar = _state3.showVerticalScrollbar;


        if (horizontal !== showHorizontalScrollbar || vertical !== showVerticalScrollbar) {
          this.setState({
            scrollbarSize: size,
            showHorizontalScrollbar: horizontal,
            showVerticalScrollbar: vertical
          });

          var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;

          if (typeof onScrollbarPresenceChange === 'function') {
            onScrollbarPresenceChange({
              horizontal: horizontal,
              size: size,
              vertical: vertical
            });
          }
        }
      }
    }, {
      key: '_onScrollLeft',
      value: function _onScrollLeft(scrollInfo) {
        var scrollLeft = scrollInfo.scrollLeft;

        this._onScroll({
          scrollLeft: scrollLeft,
          scrollTop: this.state.scrollTop
        });
      }
    }, {
      key: '_onScrollTop',
      value: function _onScrollTop(scrollInfo) {
        var scrollTop = scrollInfo.scrollTop;

        this._onScroll({
          scrollTop: scrollTop,
          scrollLeft: this.state.scrollLeft
        });
      }
    }, {
      key: '_renderBottomLeftGrid',
      value: function _renderBottomLeftGrid(props) {
        var enableFixedColumnScroll = props.enableFixedColumnScroll,
            fixedColumnCount = props.fixedColumnCount,
            fixedRowCount = props.fixedRowCount,
            rowCount = props.rowCount,
            scrollTop = props.scrollTop;
        var showVerticalScrollbar = this.state.showVerticalScrollbar;


        if (!fixedColumnCount) {
          return null;
        }

        var additionalRowCount = showVerticalScrollbar ? 1 : 0;

        return _react2.default.createElement(_Grid2.default, (0, _extends3.default)({}, props, {
          cellRenderer: this._cellRendererBottomLeftGrid,
          className: this.props.classNameBottomLeftGrid,
          columnCount: fixedColumnCount,
          deferredMeasurementCache: this._deferredMeasurementCacheBottomLeftGrid,
          height: this._getBottomGridHeight(props),
          onScroll: enableFixedColumnScroll ? this._onScrollTop : undefined,
          ref: this._bottomLeftGridRef,
          rowCount: Math.max(0, rowCount - fixedRowCount) + additionalRowCount,
          rowHeight: this._rowHeightBottomGrid,
          scrollTop: scrollTop,
          style: this._bottomLeftGridStyle,
          tabIndex: null,
          width: this._getLeftGridWidth(props)
        }));
      }
    }, {
      key: '_renderBottomRightGrid',
      value: function _renderBottomRightGrid(props) {
        var columnCount = props.columnCount,
            fixedColumnCount = props.fixedColumnCount,
            fixedRowCount = props.fixedRowCount,
            rowCount = props.rowCount,
            scrollToColumn = props.scrollToColumn,
            scrollToRow = props.scrollToRow;


        return _react2.default.createElement(_Grid2.default, (0, _extends3.default)({}, props, {
          cellRenderer: this._cellRendererBottomRightGrid,
          className: this.props.classNameBottomRightGrid,
          columnCount: Math.max(0, columnCount - fixedColumnCount),
          columnWidth: this._columnWidthRightGrid,
          deferredMeasurementCache: this._deferredMeasurementCacheBottomRightGrid,
          height: this._getBottomGridHeight(props),
          onScroll: this._onScroll,
          onScrollbarPresenceChange: this._onScrollbarPresenceChange,
          ref: this._bottomRightGridRef,
          rowCount: Math.max(0, rowCount - fixedRowCount),
          rowHeight: this._rowHeightBottomGrid,
          scrollToColumn: scrollToColumn - fixedColumnCount,
          scrollToRow: scrollToRow - fixedRowCount,
          style: this._bottomRightGridStyle,
          width: this._getRightGridWidth(props)
        }));
      }
    }, {
      key: '_renderTopLeftGrid',
      value: function _renderTopLeftGrid(props) {
        var fixedColumnCount = props.fixedColumnCount,
            fixedRowCount = props.fixedRowCount;


        if (!fixedColumnCount || !fixedRowCount) {
          return null;
        }

        return _react2.default.createElement(_Grid2.default, (0, _extends3.default)({}, props, {
          className: this.props.classNameTopLeftGrid,
          columnCount: fixedColumnCount,
          height: this._getTopGridHeight(props),
          ref: this._topLeftGridRef,
          rowCount: fixedRowCount,
          style: this._topLeftGridStyle,
          tabIndex: null,
          width: this._getLeftGridWidth(props)
        }));
      }
    }, {
      key: '_renderTopRightGrid',
      value: function _renderTopRightGrid(props) {
        var columnCount = props.columnCount,
            enableFixedRowScroll = props.enableFixedRowScroll,
            fixedColumnCount = props.fixedColumnCount,
            fixedRowCount = props.fixedRowCount,
            scrollLeft = props.scrollLeft;
        var showHorizontalScrollbar = this.state.showHorizontalScrollbar;


        if (!fixedRowCount) {
          return null;
        }

        var additionalColumnCount = showHorizontalScrollbar ? 1 : 0;

        return _react2.default.createElement(_Grid2.default, (0, _extends3.default)({}, props, {
          cellRenderer: this._cellRendererTopRightGrid,
          className: this.props.classNameTopRightGrid,
          columnCount: Math.max(0, columnCount - fixedColumnCount) + additionalColumnCount,
          columnWidth: this._columnWidthRightGrid,
          deferredMeasurementCache: this._deferredMeasurementCacheTopRightGrid,
          height: this._getTopGridHeight(props),
          onScroll: enableFixedRowScroll ? this._onScrollLeft : undefined,
          ref: this._topRightGridRef,
          rowCount: fixedRowCount,
          scrollLeft: scrollLeft,
          style: this._topRightGridStyle,
          tabIndex: null,
          width: this._getRightGridWidth(props)
        }));
      }
    }, {
      key: '_rowHeightBottomGrid',
      value: function _rowHeightBottomGrid(_ref8) {
        var index = _ref8.index;
        var _props10 = this.props,
            fixedRowCount = _props10.fixedRowCount,
            rowCount = _props10.rowCount,
            rowHeight = _props10.rowHeight;
        var _state4 = this.state,
            scrollbarSize = _state4.scrollbarSize,
            showVerticalScrollbar = _state4.showVerticalScrollbar;

        // An extra cell is added to the count
        // This gives the smaller Grid extra room for offset,
        // In case the main (bottom right) Grid has a scrollbar
        // If no scrollbar, the extra space is overflow:hidden anyway

        if (showVerticalScrollbar && index === rowCount - fixedRowCount) {
          return scrollbarSize;
        }

        return typeof rowHeight === 'function' ? rowHeight({ index: index + fixedRowCount }) : rowHeight;
      }
    }, {
      key: '_topLeftGridRef',
      value: function _topLeftGridRef(ref) {
        this._topLeftGrid = ref;
      }
    }, {
      key: '_topRightGridRef',
      value: function _topRightGridRef(ref) {
        this._topRightGrid = ref;
      }
    }]);
    return MultiGrid;
  }(_react.PureComponent);

  MultiGrid.defaultProps = {
    classNameBottomLeftGrid: '',
    classNameBottomRightGrid: '',
    classNameTopLeftGrid: '',
    classNameTopRightGrid: '',
    enableFixedColumnScroll: false,
    enableFixedRowScroll: false,
    fixedColumnCount: 0,
    fixedRowCount: 0,
    scrollToColumn: -1,
    scrollToRow: -1,
    style: {},
    styleBottomLeftGrid: {},
    styleBottomRightGrid: {},
    styleTopLeftGrid: {},
    styleTopRightGrid: {}
  };
  exports.default = MultiGrid;
  MultiGrid.propTypes = "production" !== "production" ? {
    classNameBottomLeftGrid: _propTypes2.default.string.isRequired,
    classNameBottomRightGrid: _propTypes2.default.string.isRequired,
    classNameTopLeftGrid: _propTypes2.default.string.isRequired,
    classNameTopRightGrid: _propTypes2.default.string.isRequired,
    enableFixedColumnScroll: _propTypes2.default.bool.isRequired,
    enableFixedRowScroll: _propTypes2.default.bool.isRequired,
    fixedColumnCount: _propTypes2.default.number.isRequired,
    fixedRowCount: _propTypes2.default.number.isRequired,
    onScrollbarPresenceChange: _propTypes2.default.func,
    style: _propTypes2.default.object.isRequired,
    styleBottomLeftGrid: _propTypes2.default.object.isRequired,
    styleBottomRightGrid: _propTypes2.default.object.isRequired,
    styleTopLeftGrid: _propTypes2.default.object.isRequired,
    styleTopRightGrid: _propTypes2.default.object.isRequired
  } : {};
  },{"../Grid":1201,"./CellMeasurerCacheDecorator":1217,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/objectWithoutProperties":588,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1219:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MultiGrid = undefined;

  var _MultiGrid = require('./MultiGrid');

  var _MultiGrid2 = _interopRequireDefault(_MultiGrid);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _MultiGrid2.default;
  exports.MultiGrid = _MultiGrid2.default;
  },{"./MultiGrid":1218}],1220:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * HOC that simplifies the process of synchronizing scrolling between two or more virtualized components.
   */
  var ScrollSync = function (_PureComponent) {
    (0, _inherits3.default)(ScrollSync, _PureComponent);

    function ScrollSync(props, context) {
      (0, _classCallCheck3.default)(this, ScrollSync);

      var _this = (0, _possibleConstructorReturn3.default)(this, (ScrollSync.__proto__ || (0, _getPrototypeOf2.default)(ScrollSync)).call(this, props, context));

      _this.state = {
        clientHeight: 0,
        clientWidth: 0,
        scrollHeight: 0,
        scrollLeft: 0,
        scrollTop: 0,
        scrollWidth: 0
      };

      _this._onScroll = _this._onScroll.bind(_this);
      return _this;
    }

    (0, _createClass3.default)(ScrollSync, [{
      key: 'render',
      value: function render() {
        var children = this.props.children;
        var _state = this.state,
            clientHeight = _state.clientHeight,
            clientWidth = _state.clientWidth,
            scrollHeight = _state.scrollHeight,
            scrollLeft = _state.scrollLeft,
            scrollTop = _state.scrollTop,
            scrollWidth = _state.scrollWidth;


        return children({
          clientHeight: clientHeight,
          clientWidth: clientWidth,
          onScroll: this._onScroll,
          scrollHeight: scrollHeight,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          scrollWidth: scrollWidth
        });
      }
    }, {
      key: '_onScroll',
      value: function _onScroll(_ref) {
        var clientHeight = _ref.clientHeight,
            clientWidth = _ref.clientWidth,
            scrollHeight = _ref.scrollHeight,
            scrollLeft = _ref.scrollLeft,
            scrollTop = _ref.scrollTop,
            scrollWidth = _ref.scrollWidth;

        this.setState({
          clientHeight: clientHeight,
          clientWidth: clientWidth,
          scrollHeight: scrollHeight,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          scrollWidth: scrollWidth
        });
      }
    }]);
    return ScrollSync;
  }(_react.PureComponent);

  exports.default = ScrollSync;
  ScrollSync.propTypes = "production" !== "production" ? {
    /**
     * Function responsible for rendering 2 or more virtualized components.
     * This function should implement the following signature:
     * ({ onScroll, scrollLeft, scrollTop }) => PropTypes.element
     */
    children: _propTypes2.default.func.isRequired
  } : {};
  },{"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1221:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ScrollSync = undefined;

  var _ScrollSync = require('./ScrollSync');

  var _ScrollSync2 = _interopRequireDefault(_ScrollSync);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _ScrollSync2.default;
  exports.ScrollSync = _ScrollSync2.default;
  },{"./ScrollSync":1220}],1222:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _defaultHeaderRenderer = require('./defaultHeaderRenderer');

  var _defaultHeaderRenderer2 = _interopRequireDefault(_defaultHeaderRenderer);

  var _defaultCellRenderer = require('./defaultCellRenderer');

  var _defaultCellRenderer2 = _interopRequireDefault(_defaultCellRenderer);

  var _defaultCellDataGetter = require('./defaultCellDataGetter');

  var _defaultCellDataGetter2 = _interopRequireDefault(_defaultCellDataGetter);

  var _SortDirection = require('./SortDirection');

  var _SortDirection2 = _interopRequireDefault(_SortDirection);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Describes the header and cell contents of a table column.
   */
  var Column = function (_Component) {
    (0, _inherits3.default)(Column, _Component);

    function Column() {
      (0, _classCallCheck3.default)(this, Column);
      return (0, _possibleConstructorReturn3.default)(this, (Column.__proto__ || (0, _getPrototypeOf2.default)(Column)).apply(this, arguments));
    }

    return Column;
  }(_react.Component);

  Column.defaultProps = {
    cellDataGetter: _defaultCellDataGetter2.default,
    cellRenderer: _defaultCellRenderer2.default,
    defaultSortDirection: _SortDirection2.default.ASC,
    flexGrow: 0,
    flexShrink: 1,
    headerRenderer: _defaultHeaderRenderer2.default,
    style: {}
  };
  exports.default = Column;
  Column.propTypes = "production" !== "production" ? {
    /** Optional aria-label value to set on the column header */
    'aria-label': _propTypes2.default.string,

    /**
     * Callback responsible for returning a cell's data, given its :dataKey
     * ({ columnData: any, dataKey: string, rowData: any }): any
     */
    cellDataGetter: _propTypes2.default.func,

    /**
     * Callback responsible for rendering a cell's contents.
     * ({ cellData: any, columnData: any, dataKey: string, rowData: any, rowIndex: number }): node
     */
    cellRenderer: _propTypes2.default.func,

    /** Optional CSS class to apply to cell */
    className: _propTypes2.default.string,

    /** Optional additional data passed to this column's :cellDataGetter */
    columnData: _propTypes2.default.object,

    /** Uniquely identifies the row-data attribute corresponding to this cell */
    dataKey: _propTypes2.default.any.isRequired,

    /** Optional direction to be used when clicked the first time */
    defaultSortDirection: _propTypes2.default.oneOf([_SortDirection2.default.ASC, _SortDirection2.default.DESC]),

    /** If sort is enabled for the table at large, disable it for this column */
    disableSort: _propTypes2.default.bool,

    /** Flex grow style; defaults to 0 */
    flexGrow: _propTypes2.default.number,

    /** Flex shrink style; defaults to 1 */
    flexShrink: _propTypes2.default.number,

    /** Optional CSS class to apply to this column's header */
    headerClassName: _propTypes2.default.string,

    /**
     * Optional callback responsible for rendering a column header contents.
     * ({ columnData: object, dataKey: string, disableSort: boolean, label: node, sortBy: string, sortDirection: string }): PropTypes.node
     */
    headerRenderer: _propTypes2.default.func.isRequired,

    /** Optional inline style to apply to this column's header */
    headerStyle: _propTypes2.default.object,

    /** Optional id to set on the column header */
    id: _propTypes2.default.string,

    /** Header label for this column */
    label: _propTypes2.default.node,

    /** Maximum width of column; this property will only be used if :flexGrow is > 0. */
    maxWidth: _propTypes2.default.number,

    /** Minimum width of column. */
    minWidth: _propTypes2.default.number,

    /** Optional inline style to apply to cell */
    style: _propTypes2.default.object,

    /** Flex basis (width) for this column; This value can grow or shrink based on :flexGrow and :flexShrink properties. */
    width: _propTypes2.default.number.isRequired
  } : {};
  },{"./SortDirection":1223,"./defaultCellDataGetter":1227,"./defaultCellRenderer":1228,"./defaultHeaderRenderer":1229,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253}],1223:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var SortDirection = {
    /**
     * Sort items in ascending order.
     * This means arranging from the lowest value to the highest (e.g. a-z, 0-9).
     */
    ASC: 'ASC',

    /**
     * Sort items in descending order.
     * This means arranging from the highest value to the lowest (e.g. z-a, 9-0).
     */
    DESC: 'DESC'
  };

  exports.default = SortDirection;
  },{}],1224:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = SortIndicator;

  var _classnames = require('classnames');

  var _classnames2 = _interopRequireDefault(_classnames);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _SortDirection = require('./SortDirection');

  var _SortDirection2 = _interopRequireDefault(_SortDirection);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Displayed beside a header to indicate that a Table is currently sorted by this column.
   */
  function SortIndicator(_ref) {
    var sortDirection = _ref.sortDirection;

    var classNames = (0, _classnames2.default)('ReactVirtualized__Table__sortableHeaderIcon', {
      'ReactVirtualized__Table__sortableHeaderIcon--ASC': sortDirection === _SortDirection2.default.ASC,
      'ReactVirtualized__Table__sortableHeaderIcon--DESC': sortDirection === _SortDirection2.default.DESC
    });

    return _react2.default.createElement(
      'svg',
      { className: classNames, width: 18, height: 18, viewBox: '0 0 24 24' },
      sortDirection === _SortDirection2.default.ASC ? _react2.default.createElement('path', { d: 'M7 14l5-5 5 5z' }) : _react2.default.createElement('path', { d: 'M7 10l5 5 5-5z' }),
      _react2.default.createElement('path', { d: 'M0 0h24v24H0z', fill: 'none' })
    );
  }

  SortIndicator.propTypes = "production" !== "production" ? {
    sortDirection: _propTypes2.default.oneOf([_SortDirection2.default.ASC, _SortDirection2.default.DESC])
  } : {};
  },{"./SortDirection":1223,"classnames":698,"prop-types":1249,"react":1253}],1225:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _classnames = require('classnames');

  var _classnames2 = _interopRequireDefault(_classnames);

  var _Column = require('./Column');

  var _Column2 = _interopRequireDefault(_Column);

  var _propTypes = require('prop-types');

  var _propTypes2 = _interopRequireDefault(_propTypes);

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _reactDom = require('react-dom');

  var _Grid2 = require('../Grid');

  var _Grid3 = _interopRequireDefault(_Grid2);

  var _defaultRowRenderer = require('./defaultRowRenderer');

  var _defaultRowRenderer2 = _interopRequireDefault(_defaultRowRenderer);

  var _defaultHeaderRowRenderer = require('./defaultHeaderRowRenderer');

  var _defaultHeaderRowRenderer2 = _interopRequireDefault(_defaultHeaderRowRenderer);

  var _SortDirection = require('./SortDirection');

  var _SortDirection2 = _interopRequireDefault(_SortDirection);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_CellPosition = require('../Grid').babelPluginFlowReactPropTypes_proptype_CellPosition || require('prop-types').any;

  /**
   * Table component with fixed headers and virtualized rows for improved performance with large data sets.
   * This component expects explicit width, height, and padding parameters.
   */
  var Table = function (_PureComponent) {
    (0, _inherits3.default)(Table, _PureComponent);

    function Table(props) {
      (0, _classCallCheck3.default)(this, Table);

      var _this = (0, _possibleConstructorReturn3.default)(this, (Table.__proto__ || (0, _getPrototypeOf2.default)(Table)).call(this, props));

      _this.state = {
        scrollbarWidth: 0
      };

      _this._createColumn = _this._createColumn.bind(_this);
      _this._createRow = _this._createRow.bind(_this);
      _this._onScroll = _this._onScroll.bind(_this);
      _this._onSectionRendered = _this._onSectionRendered.bind(_this);
      _this._setRef = _this._setRef.bind(_this);
      return _this;
    }

    (0, _createClass3.default)(Table, [{
      key: 'forceUpdateGrid',
      value: function forceUpdateGrid() {
        if (this.Grid) {
          this.Grid.forceUpdate();
        }
      }

      /** See Grid#getOffsetForCell */

    }, {
      key: 'getOffsetForRow',
      value: function getOffsetForRow(_ref) {
        var alignment = _ref.alignment,
            index = _ref.index;

        if (this.Grid) {
          var _Grid$getOffsetForCel = this.Grid.getOffsetForCell({
            alignment: alignment,
            rowIndex: index
          }),
              scrollTop = _Grid$getOffsetForCel.scrollTop;

          return scrollTop;
        }
        return 0;
      }

      /** CellMeasurer compatibility */

    }, {
      key: 'invalidateCellSizeAfterRender',
      value: function invalidateCellSizeAfterRender(_ref2) {
        var columnIndex = _ref2.columnIndex,
            rowIndex = _ref2.rowIndex;

        if (this.Grid) {
          this.Grid.invalidateCellSizeAfterRender({
            rowIndex: rowIndex,
            columnIndex: columnIndex
          });
        }
      }

      /** See Grid#measureAllCells */

    }, {
      key: 'measureAllRows',
      value: function measureAllRows() {
        if (this.Grid) {
          this.Grid.measureAllCells();
        }
      }

      /** CellMeasurer compatibility */

    }, {
      key: 'recomputeGridSize',
      value: function recomputeGridSize() {
        var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref3$columnIndex = _ref3.columnIndex,
            columnIndex = _ref3$columnIndex === undefined ? 0 : _ref3$columnIndex,
            _ref3$rowIndex = _ref3.rowIndex,
            rowIndex = _ref3$rowIndex === undefined ? 0 : _ref3$rowIndex;

        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex: rowIndex,
            columnIndex: columnIndex
          });
        }
      }

      /** See Grid#recomputeGridSize */

    }, {
      key: 'recomputeRowHeights',
      value: function recomputeRowHeights() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (this.Grid) {
          this.Grid.recomputeGridSize({
            rowIndex: index
          });
        }
      }

      /** See Grid#scrollToPosition */

    }, {
      key: 'scrollToPosition',
      value: function scrollToPosition() {
        var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (this.Grid) {
          this.Grid.scrollToPosition({ scrollTop: scrollTop });
        }
      }

      /** See Grid#scrollToCell */

    }, {
      key: 'scrollToRow',
      value: function scrollToRow() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        if (this.Grid) {
          this.Grid.scrollToCell({
            columnIndex: 0,
            rowIndex: index
          });
        }
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        this._setScrollbarWidth();
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this._setScrollbarWidth();
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            children = _props.children,
            className = _props.className,
            disableHeader = _props.disableHeader,
            gridClassName = _props.gridClassName,
            gridStyle = _props.gridStyle,
            headerHeight = _props.headerHeight,
            headerRowRenderer = _props.headerRowRenderer,
            height = _props.height,
            id = _props.id,
            noRowsRenderer = _props.noRowsRenderer,
            rowClassName = _props.rowClassName,
            rowStyle = _props.rowStyle,
            scrollToIndex = _props.scrollToIndex,
            style = _props.style,
            width = _props.width;
        var scrollbarWidth = this.state.scrollbarWidth;


        var availableRowsHeight = disableHeader ? height : height - headerHeight;

        var rowClass = typeof rowClassName === 'function' ? rowClassName({ index: -1 }) : rowClassName;
        var rowStyleObject = typeof rowStyle === 'function' ? rowStyle({ index: -1 }) : rowStyle;

        // Precompute and cache column styles before rendering rows and columns to speed things up
        this._cachedColumnStyles = [];
        _react2.default.Children.toArray(children).forEach(function (column, index) {
          var flexStyles = _this2._getFlexStyleForColumn(column, column.props.style);

          _this2._cachedColumnStyles[index] = (0, _extends3.default)({}, flexStyles, {
            overflow: 'hidden'
          });
        });

        // Note that we specify :rowCount, :scrollbarWidth, :sortBy, and :sortDirection as properties on Grid even though these have nothing to do with Grid.
        // This is done because Grid is a pure component and won't update unless its properties or state has changed.
        // Any property that should trigger a re-render of Grid then is specified here to avoid a stale display.
        return _react2.default.createElement(
          'div',
          {
            className: (0, _classnames2.default)('ReactVirtualized__Table', className),
            id: id,
            role: 'grid',
            style: style },
          !disableHeader && headerRowRenderer({
            className: (0, _classnames2.default)('ReactVirtualized__Table__headerRow', rowClass),
            columns: this._getHeaderColumns(),
            style: (0, _extends3.default)({}, rowStyleObject, {
              height: headerHeight,
              overflow: 'hidden',
              paddingRight: scrollbarWidth,
              width: width
            })
          }),
          _react2.default.createElement(_Grid3.default, (0, _extends3.default)({}, this.props, {
            autoContainerWidth: true,
            className: (0, _classnames2.default)('ReactVirtualized__Table__Grid', gridClassName),
            cellRenderer: this._createRow,
            columnWidth: width,
            columnCount: 1,
            height: availableRowsHeight,
            id: undefined,
            noContentRenderer: noRowsRenderer,
            onScroll: this._onScroll,
            onSectionRendered: this._onSectionRendered,
            ref: this._setRef,
            role: 'rowgroup',
            scrollbarWidth: scrollbarWidth,
            scrollToRow: scrollToIndex,
            style: (0, _extends3.default)({}, gridStyle, {
              overflowX: 'hidden'
            })
          }))
        );
      }
    }, {
      key: '_createColumn',
      value: function _createColumn(_ref4) {
        var column = _ref4.column,
            columnIndex = _ref4.columnIndex,
            isScrolling = _ref4.isScrolling,
            parent = _ref4.parent,
            rowData = _ref4.rowData,
            rowIndex = _ref4.rowIndex;
        var _column$props = column.props,
            cellDataGetter = _column$props.cellDataGetter,
            cellRenderer = _column$props.cellRenderer,
            className = _column$props.className,
            columnData = _column$props.columnData,
            dataKey = _column$props.dataKey,
            id = _column$props.id;


        var cellData = cellDataGetter({ columnData: columnData, dataKey: dataKey, rowData: rowData });
        var renderedCell = cellRenderer({
          cellData: cellData,
          columnData: columnData,
          columnIndex: columnIndex,
          dataKey: dataKey,
          isScrolling: isScrolling,
          parent: parent,
          rowData: rowData,
          rowIndex: rowIndex
        });

        var style = this._cachedColumnStyles[columnIndex];

        var title = typeof renderedCell === 'string' ? renderedCell : null;

        // Avoid using object-spread syntax with multiple objects here,
        // Since it results in an extra method call to 'babel-runtime/helpers/extends'
        // See PR https://github.com/bvaughn/react-virtualized/pull/942
        return _react2.default.createElement(
          'div',
          {
            'aria-describedby': id,
            className: (0, _classnames2.default)('ReactVirtualized__Table__rowColumn', className),
            key: 'Row' + rowIndex + '-' + 'Col' + columnIndex,
            role: 'gridcell',
            style: style,
            title: title },
          renderedCell
        );
      }
    }, {
      key: '_createHeader',
      value: function _createHeader(_ref5) {
        var column = _ref5.column,
            index = _ref5.index;
        var _props2 = this.props,
            headerClassName = _props2.headerClassName,
            headerStyle = _props2.headerStyle,
            onHeaderClick = _props2.onHeaderClick,
            sort = _props2.sort,
            sortBy = _props2.sortBy,
            sortDirection = _props2.sortDirection;
        var _column$props2 = column.props,
            columnData = _column$props2.columnData,
            dataKey = _column$props2.dataKey,
            defaultSortDirection = _column$props2.defaultSortDirection,
            disableSort = _column$props2.disableSort,
            headerRenderer = _column$props2.headerRenderer,
            id = _column$props2.id,
            label = _column$props2.label;

        var sortEnabled = !disableSort && sort;

        var classNames = (0, _classnames2.default)('ReactVirtualized__Table__headerColumn', headerClassName, column.props.headerClassName, {
          ReactVirtualized__Table__sortableHeaderColumn: sortEnabled
        });
        var style = this._getFlexStyleForColumn(column, (0, _extends3.default)({}, headerStyle, column.props.headerStyle));

        var renderedHeader = headerRenderer({
          columnData: columnData,
          dataKey: dataKey,
          disableSort: disableSort,
          label: label,
          sortBy: sortBy,
          sortDirection: sortDirection
        });

        var headerOnClick = void 0,
            headerOnKeyDown = void 0,
            headerTabIndex = void 0,
            headerAriaSort = void 0,
            headerAriaLabel = void 0;

        if (sortEnabled || onHeaderClick) {
          // If this is a sortable header, clicking it should update the table data's sorting.
          var isFirstTimeSort = sortBy !== dataKey;

          // If this is the firstTime sort of this column, use the column default sort order.
          // Otherwise, invert the direction of the sort.
          var newSortDirection = isFirstTimeSort ? defaultSortDirection : sortDirection === _SortDirection2.default.DESC ? _SortDirection2.default.ASC : _SortDirection2.default.DESC;

          var onClick = function onClick(event) {
            sortEnabled && sort({
              defaultSortDirection: defaultSortDirection,
              event: event,
              sortBy: dataKey,
              sortDirection: newSortDirection
            });
            onHeaderClick && onHeaderClick({ columnData: columnData, dataKey: dataKey, event: event });
          };

          var onKeyDown = function onKeyDown(event) {
            if (event.key === 'Enter' || event.key === ' ') {
              onClick(event);
            }
          };

          headerAriaLabel = column.props['aria-label'] || label || dataKey;
          headerTabIndex = 0;
          headerOnClick = onClick;
          headerOnKeyDown = onKeyDown;
        }

        if (sortBy === dataKey) {
          headerAriaSort = sortDirection === _SortDirection2.default.ASC ? 'ascending' : 'descending';
        }

        // Avoid using object-spread syntax with multiple objects here,
        // Since it results in an extra method call to 'babel-runtime/helpers/extends'
        // See PR https://github.com/bvaughn/react-virtualized/pull/942
        return _react2.default.createElement(
          'div',
          {
            'aria-label': headerAriaLabel,
            'aria-sort': headerAriaSort,
            className: classNames,
            id: id,
            key: 'Header-Col' + index,
            onClick: headerOnClick,
            onKeyDown: headerOnKeyDown,
            role: 'columnheader',
            style: style,
            tabIndex: headerTabIndex },
          renderedHeader
        );
      }
    }, {
      key: '_createRow',
      value: function _createRow(_ref6) {
        var _this3 = this;

        var index = _ref6.rowIndex,
            isScrolling = _ref6.isScrolling,
            key = _ref6.key,
            parent = _ref6.parent,
            style = _ref6.style;
        var _props3 = this.props,
            children = _props3.children,
            onRowClick = _props3.onRowClick,
            onRowDoubleClick = _props3.onRowDoubleClick,
            onRowRightClick = _props3.onRowRightClick,
            onRowMouseOver = _props3.onRowMouseOver,
            onRowMouseOut = _props3.onRowMouseOut,
            rowClassName = _props3.rowClassName,
            rowGetter = _props3.rowGetter,
            rowRenderer = _props3.rowRenderer,
            rowStyle = _props3.rowStyle;
        var scrollbarWidth = this.state.scrollbarWidth;


        var rowClass = typeof rowClassName === 'function' ? rowClassName({ index: index }) : rowClassName;
        var rowStyleObject = typeof rowStyle === 'function' ? rowStyle({ index: index }) : rowStyle;
        var rowData = rowGetter({ index: index });

        var columns = _react2.default.Children.toArray(children).map(function (column, columnIndex) {
          return _this3._createColumn({
            column: column,
            columnIndex: columnIndex,
            isScrolling: isScrolling,
            parent: parent,
            rowData: rowData,
            rowIndex: index,
            scrollbarWidth: scrollbarWidth
          });
        });

        var className = (0, _classnames2.default)('ReactVirtualized__Table__row', rowClass);
        var flattenedStyle = (0, _extends3.default)({}, style, rowStyleObject, {
          height: this._getRowHeight(index),
          overflow: 'hidden',
          paddingRight: scrollbarWidth
        });

        return rowRenderer({
          className: className,
          columns: columns,
          index: index,
          isScrolling: isScrolling,
          key: key,
          onRowClick: onRowClick,
          onRowDoubleClick: onRowDoubleClick,
          onRowRightClick: onRowRightClick,
          onRowMouseOver: onRowMouseOver,
          onRowMouseOut: onRowMouseOut,
          rowData: rowData,
          style: flattenedStyle
        });
      }

      /**
       * Determines the flex-shrink, flex-grow, and width values for a cell (header or column).
       */

    }, {
      key: '_getFlexStyleForColumn',
      value: function _getFlexStyleForColumn(column) {
        var customStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var flexValue = column.props.flexGrow + ' ' + column.props.flexShrink + ' ' + column.props.width + 'px';

        var style = (0, _extends3.default)({}, customStyle, {
          flex: flexValue,
          msFlex: flexValue,
          WebkitFlex: flexValue
        });

        if (column.props.maxWidth) {
          style.maxWidth = column.props.maxWidth;
        }

        if (column.props.minWidth) {
          style.minWidth = column.props.minWidth;
        }

        return style;
      }
    }, {
      key: '_getHeaderColumns',
      value: function _getHeaderColumns() {
        var _this4 = this;

        var _props4 = this.props,
            children = _props4.children,
            disableHeader = _props4.disableHeader;

        var items = disableHeader ? [] : _react2.default.Children.toArray(children);

        return items.map(function (column, index) {
          return _this4._createHeader({ column: column, index: index });
        });
      }
    }, {
      key: '_getRowHeight',
      value: function _getRowHeight(rowIndex) {
        var rowHeight = this.props.rowHeight;


        return typeof rowHeight === 'function' ? rowHeight({ index: rowIndex }) : rowHeight;
      }
    }, {
      key: '_onScroll',
      value: function _onScroll(_ref7) {
        var clientHeight = _ref7.clientHeight,
            scrollHeight = _ref7.scrollHeight,
            scrollTop = _ref7.scrollTop;
        var onScroll = this.props.onScroll;


        onScroll({ clientHeight: clientHeight, scrollHeight: scrollHeight, scrollTop: scrollTop });
      }
    }, {
      key: '_onSectionRendered',
      value: function _onSectionRendered(_ref8) {
        var rowOverscanStartIndex = _ref8.rowOverscanStartIndex,
            rowOverscanStopIndex = _ref8.rowOverscanStopIndex,
            rowStartIndex = _ref8.rowStartIndex,
            rowStopIndex = _ref8.rowStopIndex;
        var onRowsRendered = this.props.onRowsRendered;


        onRowsRendered({
          overscanStartIndex: rowOverscanStartIndex,
          overscanStopIndex: rowOverscanStopIndex,
          startIndex: rowStartIndex,
          stopIndex: rowStopIndex
        });
      }
    }, {
      key: '_setRef',
      value: function _setRef(ref) {
        this.Grid = ref;
      }
    }, {
      key: '_setScrollbarWidth',
      value: function _setScrollbarWidth() {
        if (this.Grid) {
          var _Grid = (0, _reactDom.findDOMNode)(this.Grid);
          var clientWidth = _Grid.clientWidth || 0;
          var offsetWidth = _Grid.offsetWidth || 0;
          var scrollbarWidth = offsetWidth - clientWidth;

          this.setState({ scrollbarWidth: scrollbarWidth });
        }
      }
    }]);
    return Table;
  }(_react.PureComponent);

  Table.defaultProps = {
    disableHeader: false,
    estimatedRowSize: 30,
    headerHeight: 0,
    headerStyle: {},
    noRowsRenderer: function noRowsRenderer() {
      return null;
    },
    onRowsRendered: function onRowsRendered() {
      return null;
    },
    onScroll: function onScroll() {
      return null;
    },
    overscanIndicesGetter: _Grid2.accessibilityOverscanIndicesGetter,
    overscanRowCount: 10,
    rowRenderer: _defaultRowRenderer2.default,
    headerRowRenderer: _defaultHeaderRowRenderer2.default,
    rowStyle: {},
    scrollToAlignment: 'auto',
    scrollToIndex: -1,
    style: {}
  };
  exports.default = Table;
  Table.propTypes = "production" !== "production" ? {
    'aria-label': _propTypes2.default.string,

    /**
     * Removes fixed height from the scrollingContainer so that the total height
     * of rows can stretch the window. Intended for use with WindowScroller
     */
    autoHeight: _propTypes2.default.bool,

    /** One or more Columns describing the data displayed in this row */
    children: function children(props) {
      var children = _react2.default.Children.toArray(props.children);
      for (var i = 0; i < children.length; i++) {
        var childType = children[i].type;
        if (childType !== _Column2.default && !(childType.prototype instanceof _Column2.default)) {
          return new Error('Table only accepts children of type Column');
        }
      }
    },

    /** Optional CSS class name */
    className: _propTypes2.default.string,

    /** Disable rendering the header at all */
    disableHeader: _propTypes2.default.bool,

    /**
     * Used to estimate the total height of a Table before all of its rows have actually been measured.
     * The estimated total height is adjusted as rows are rendered.
     */
    estimatedRowSize: _propTypes2.default.number.isRequired,

    /** Optional custom CSS class name to attach to inner Grid element. */
    gridClassName: _propTypes2.default.string,

    /** Optional inline style to attach to inner Grid element. */
    gridStyle: _propTypes2.default.object,

    /** Optional CSS class to apply to all column headers */
    headerClassName: _propTypes2.default.string,

    /** Fixed height of header row */
    headerHeight: _propTypes2.default.number.isRequired,

    /**
     * Responsible for rendering a table row given an array of columns:
     * Should implement the following interface: ({
     *   className: string,
     *   columns: any[],
     *   style: any
     * }): PropTypes.node
     */
    headerRowRenderer: _propTypes2.default.func,

    /** Optional custom inline style to attach to table header columns. */
    headerStyle: _propTypes2.default.object,

    /** Fixed/available height for out DOM element */
    height: _propTypes2.default.number.isRequired,

    /** Optional id */
    id: _propTypes2.default.string,

    /** Optional renderer to be used in place of table body rows when rowCount is 0 */
    noRowsRenderer: _propTypes2.default.func,

    /**
     * Optional callback when a column's header is clicked.
     * ({ columnData: any, dataKey: string }): void
     */
    onHeaderClick: _propTypes2.default.func,

    /**
     * Callback invoked when a user clicks on a table row.
     * ({ index: number }): void
     */
    onRowClick: _propTypes2.default.func,

    /**
     * Callback invoked when a user double-clicks on a table row.
     * ({ index: number }): void
     */
    onRowDoubleClick: _propTypes2.default.func,

    /**
     * Callback invoked when the mouse leaves a table row.
     * ({ index: number }): void
     */
    onRowMouseOut: _propTypes2.default.func,

    /**
     * Callback invoked when a user moves the mouse over a table row.
     * ({ index: number }): void
     */
    onRowMouseOver: _propTypes2.default.func,

    /**
     * Callback invoked when a user right-clicks on a table row.
     * ({ index: number }): void
     */
    onRowRightClick: _propTypes2.default.func,

    /**
     * Callback invoked with information about the slice of rows that were just rendered.
     * ({ startIndex, stopIndex }): void
     */
    onRowsRendered: _propTypes2.default.func,

    /**
     * Callback invoked whenever the scroll offset changes within the inner scrollable region.
     * This callback can be used to sync scrolling between lists, tables, or grids.
     * ({ clientHeight, scrollHeight, scrollTop }): void
     */
    onScroll: _propTypes2.default.func.isRequired,

    /** See Grid#overscanIndicesGetter */
    overscanIndicesGetter: _propTypes2.default.func.isRequired,

    /**
     * Number of rows to render above/below the visible bounds of the list.
     * These rows can help for smoother scrolling on touch devices.
     */
    overscanRowCount: _propTypes2.default.number.isRequired,

    /**
     * Optional CSS class to apply to all table rows (including the header row).
     * This property can be a CSS class name (string) or a function that returns a class name.
     * If a function is provided its signature should be: ({ index: number }): string
     */
    rowClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),

    /**
     * Callback responsible for returning a data row given an index.
     * ({ index: number }): any
     */
    rowGetter: _propTypes2.default.func.isRequired,

    /**
     * Either a fixed row height (number) or a function that returns the height of a row given its index.
     * ({ index: number }): number
     */
    rowHeight: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]).isRequired,

    /** Number of rows in table. */
    rowCount: _propTypes2.default.number.isRequired,

    /**
     * Responsible for rendering a table row given an array of columns:
     * Should implement the following interface: ({
     *   className: string,
     *   columns: Array,
     *   index: number,
     *   isScrolling: boolean,
     *   onRowClick: ?Function,
     *   onRowDoubleClick: ?Function,
     *   onRowMouseOver: ?Function,
     *   onRowMouseOut: ?Function,
     *   rowData: any,
     *   style: any
     * }): PropTypes.node
     */
    rowRenderer: _propTypes2.default.func,

    /** Optional custom inline style to attach to table rows. */
    rowStyle: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]).isRequired,

    /** See Grid#scrollToAlignment */
    scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,

    /** Row index to ensure visible (by forcefully scrolling if necessary) */
    scrollToIndex: _propTypes2.default.number.isRequired,

    /** Vertical offset. */
    scrollTop: _propTypes2.default.number,

    /**
     * Sort function to be called if a sortable header is clicked.
     * Should implement the following interface: ({
     *   defaultSortDirection: 'ASC' | 'DESC',
     *   event: MouseEvent,
     *   sortBy: string,
     *   sortDirection: SortDirection
     * }): void
     */
    sort: _propTypes2.default.func,

    /** Table data is currently sorted by this :dataKey (if it is sorted at all) */
    sortBy: _propTypes2.default.string,

    /** Table data is currently sorted in this direction (if it is sorted at all) */
    sortDirection: _propTypes2.default.oneOf([_SortDirection2.default.ASC, _SortDirection2.default.DESC]),

    /** Optional inline style */
    style: _propTypes2.default.object,

    /** Tab index for focus */
    tabIndex: _propTypes2.default.number,

    /** Width of list */
    width: _propTypes2.default.number.isRequired
  } : {};
  },{"../Grid":1201,"./Column":1222,"./SortDirection":1223,"./defaultHeaderRowRenderer":1230,"./defaultRowRenderer":1231,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"classnames":698,"prop-types":1249,"react":1253,"react-dom":1157}],1226:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createMultiSort;
  function createMultiSort(sortCallback) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        defaultSortBy = _ref.defaultSortBy,
        _ref$defaultSortDirec = _ref.defaultSortDirection,
        defaultSortDirection = _ref$defaultSortDirec === undefined ? {} : _ref$defaultSortDirec;

    if (!sortCallback) {
      throw Error('Required parameter "sortCallback" not specified');
    }

    var sortBy = defaultSortBy || [];
    var sortDirection = {};

    sortBy.forEach(function (dataKey) {
      sortDirection[dataKey] = defaultSortDirection.hasOwnProperty(dataKey) ? defaultSortDirection[dataKey] : 'ASC';
    });

    function sort(_ref2) {
      var defaultSortDirection = _ref2.defaultSortDirection,
          event = _ref2.event,
          dataKey = _ref2.sortBy;

      if (event.shiftKey) {
        // Shift + click appends a column to existing criteria
        if (sortDirection.hasOwnProperty(dataKey)) {
          sortDirection[dataKey] = sortDirection[dataKey] === 'ASC' ? 'DESC' : 'ASC';
        } else {
          sortDirection[dataKey] = defaultSortDirection;
          sortBy.push(dataKey);
        }
      } else if (event.ctrlKey || event.metaKey) {
        // Control + click removes column from sort (if pressent)
        var index = sortBy.indexOf(dataKey);
        if (index >= 0) {
          sortBy.splice(index, 1);
          delete sortDirection[dataKey];
        }
      } else {
        sortBy.length = 0;
        sortBy.push(dataKey);

        if (sortDirection.hasOwnProperty(dataKey)) {
          sortDirection[dataKey] = sortDirection[dataKey] === 'ASC' ? 'DESC' : 'ASC';
        } else {
          sortDirection[dataKey] = defaultSortDirection;
        }
      }

      // Notify application code
      sortCallback({
        sortBy: sortBy,
        sortDirection: sortDirection
      });
    }

    return {
      sort: sort,
      sortBy: sortBy,
      sortDirection: sortDirection
    };
  }
  },{}],1227:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defaultCellDataGetter;

  /**
   * Default accessor for returning a cell value for a given attribute.
   * This function expects to operate on either a vanilla Object or an Immutable Map.
   * You should override the column's cellDataGetter if your data is some other type of object.
   */
  var babelPluginFlowReactPropTypes_proptype_CellDataGetterParams = require('./types').babelPluginFlowReactPropTypes_proptype_CellDataGetterParams || require('prop-types').any;

  function defaultCellDataGetter(_ref) {
    var dataKey = _ref.dataKey,
        rowData = _ref.rowData;

    if (typeof rowData.get === 'function') {
      return rowData.get(dataKey);
    } else {
      return rowData[dataKey];
    }
  }
  },{"./types":1233,"prop-types":1249}],1228:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defaultCellRenderer;

  /**
   * Default cell renderer that displays an attribute as a simple string
   * You should override the column's cellRenderer if your data is some other type of object.
   */
  var babelPluginFlowReactPropTypes_proptype_CellRendererParams = require('./types').babelPluginFlowReactPropTypes_proptype_CellRendererParams || require('prop-types').any;

  function defaultCellRenderer(_ref) {
    var cellData = _ref.cellData;

    if (cellData == null) {
      return '';
    } else {
      return String(cellData);
    }
  }
  },{"./types":1233,"prop-types":1249}],1229:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defaultHeaderRenderer;

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  var _SortIndicator = require('./SortIndicator');

  var _SortIndicator2 = _interopRequireDefault(_SortIndicator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Default table header renderer.
   */
  var babelPluginFlowReactPropTypes_proptype_HeaderRendererParams = require('./types').babelPluginFlowReactPropTypes_proptype_HeaderRendererParams || require('prop-types').any;

  function defaultHeaderRenderer(_ref) {
    var dataKey = _ref.dataKey,
        label = _ref.label,
        sortBy = _ref.sortBy,
        sortDirection = _ref.sortDirection;

    var showSortIndicator = sortBy === dataKey;
    var children = [_react2.default.createElement(
      'span',
      {
        className: 'ReactVirtualized__Table__headerTruncatedText',
        key: 'label',
        title: label },
      label
    )];

    if (showSortIndicator) {
      children.push(_react2.default.createElement(_SortIndicator2.default, { key: 'SortIndicator', sortDirection: sortDirection }));
    }

    return children;
  }
  defaultHeaderRenderer.propTypes = "production" === 'production' ? null : babelPluginFlowReactPropTypes_proptype_HeaderRendererParams === require('prop-types').any ? {} : babelPluginFlowReactPropTypes_proptype_HeaderRendererParams;
  },{"./SortIndicator":1224,"./types":1233,"prop-types":1249,"react":1253}],1230:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = defaultHeaderRowRenderer;

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams = require('./types').babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams || require('prop-types').any;

  function defaultHeaderRowRenderer(_ref) {
    var className = _ref.className,
        columns = _ref.columns,
        style = _ref.style;

    return _react2.default.createElement(
      'div',
      { className: className, role: 'row', style: style },
      columns
    );
  }
  defaultHeaderRowRenderer.propTypes = "production" === 'production' ? null : babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams === require('prop-types').any ? {} : babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams;
  },{"./types":1233,"prop-types":1249,"react":1253}],1231:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  exports.default = defaultRowRenderer;

  var _react = require('react');

  var _react2 = _interopRequireDefault(_react);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Default row renderer for Table.
   */
  var babelPluginFlowReactPropTypes_proptype_RowRendererParams = require('./types').babelPluginFlowReactPropTypes_proptype_RowRendererParams || require('prop-types').any;

  function defaultRowRenderer(_ref) {
    var className = _ref.className,
        columns = _ref.columns,
        index = _ref.index,
        key = _ref.key,
        onRowClick = _ref.onRowClick,
        onRowDoubleClick = _ref.onRowDoubleClick,
        onRowMouseOut = _ref.onRowMouseOut,
        onRowMouseOver = _ref.onRowMouseOver,
        onRowRightClick = _ref.onRowRightClick,
        rowData = _ref.rowData,
        style = _ref.style;

    var a11yProps = {};

    if (onRowClick || onRowDoubleClick || onRowMouseOut || onRowMouseOver || onRowRightClick) {
      a11yProps['aria-label'] = 'row';
      a11yProps.tabIndex = 0;

      if (onRowClick) {
        a11yProps.onClick = function (event) {
          return onRowClick({ event: event, index: index, rowData: rowData });
        };
      }
      if (onRowDoubleClick) {
        a11yProps.onDoubleClick = function (event) {
          return onRowDoubleClick({ event: event, index: index, rowData: rowData });
        };
      }
      if (onRowMouseOut) {
        a11yProps.onMouseOut = function (event) {
          return onRowMouseOut({ event: event, index: index, rowData: rowData });
        };
      }
      if (onRowMouseOver) {
        a11yProps.onMouseOver = function (event) {
          return onRowMouseOver({ event: event, index: index, rowData: rowData });
        };
      }
      if (onRowRightClick) {
        a11yProps.onContextMenu = function (event) {
          return onRowRightClick({ event: event, index: index, rowData: rowData });
        };
      }
    }

    return _react2.default.createElement(
      'div',
      (0, _extends3.default)({}, a11yProps, {
        className: className,
        key: key,
        role: 'row',
        style: style }),
      columns
    );
  }
  defaultRowRenderer.propTypes = "production" === 'production' ? null : babelPluginFlowReactPropTypes_proptype_RowRendererParams === require('prop-types').any ? {} : babelPluginFlowReactPropTypes_proptype_RowRendererParams;
  },{"./types":1233,"babel-runtime/helpers/extends":586,"prop-types":1249,"react":1253}],1232:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Table = exports.SortIndicator = exports.SortDirection = exports.Column = exports.defaultRowRenderer = exports.defaultHeaderRenderer = exports.defaultHeaderRowRenderer = exports.defaultCellRenderer = exports.defaultCellDataGetter = exports.createMultiSort = undefined;

  var _createMultiSort = require('./createMultiSort');

  var _createMultiSort2 = _interopRequireDefault(_createMultiSort);

  var _defaultCellDataGetter = require('./defaultCellDataGetter');

  var _defaultCellDataGetter2 = _interopRequireDefault(_defaultCellDataGetter);

  var _defaultCellRenderer = require('./defaultCellRenderer');

  var _defaultCellRenderer2 = _interopRequireDefault(_defaultCellRenderer);

  var _defaultHeaderRowRenderer = require('./defaultHeaderRowRenderer.js');

  var _defaultHeaderRowRenderer2 = _interopRequireDefault(_defaultHeaderRowRenderer);

  var _defaultHeaderRenderer = require('./defaultHeaderRenderer');

  var _defaultHeaderRenderer2 = _interopRequireDefault(_defaultHeaderRenderer);

  var _defaultRowRenderer = require('./defaultRowRenderer');

  var _defaultRowRenderer2 = _interopRequireDefault(_defaultRowRenderer);

  var _Column = require('./Column');

  var _Column2 = _interopRequireDefault(_Column);

  var _SortDirection = require('./SortDirection');

  var _SortDirection2 = _interopRequireDefault(_SortDirection);

  var _SortIndicator = require('./SortIndicator');

  var _SortIndicator2 = _interopRequireDefault(_SortIndicator);

  var _Table = require('./Table');

  var _Table2 = _interopRequireDefault(_Table);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _Table2.default;
  exports.createMultiSort = _createMultiSort2.default;
  exports.defaultCellDataGetter = _defaultCellDataGetter2.default;
  exports.defaultCellRenderer = _defaultCellRenderer2.default;
  exports.defaultHeaderRowRenderer = _defaultHeaderRowRenderer2.default;
  exports.defaultHeaderRenderer = _defaultHeaderRenderer2.default;
  exports.defaultRowRenderer = _defaultRowRenderer2.default;
  exports.Column = _Column2.default;
  exports.SortDirection = _SortDirection2.default;
  exports.SortIndicator = _SortIndicator2.default;
  exports.Table = _Table2.default;
  },{"./Column":1222,"./SortDirection":1223,"./SortIndicator":1224,"./Table":1225,"./createMultiSort":1226,"./defaultCellDataGetter":1227,"./defaultCellRenderer":1228,"./defaultHeaderRenderer":1229,"./defaultHeaderRowRenderer.js":1230,"./defaultRowRenderer":1231}],1233:[function(require,module,exports){
  "use strict";

  var babelPluginFlowReactPropTypes_proptype_CellDataGetterParams = "production" === 'production' ? null : {
    columnData: require("prop-types").any,
    dataKey: require("prop-types").string.isRequired,
    rowData: function rowData(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `" + propName + "` has type 'any' or 'mixed', but was not provided to `" + componentName + "`. Pass undefined or any other value.");
      }
    }
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellDataGetterParams", {
    value: babelPluginFlowReactPropTypes_proptype_CellDataGetterParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_CellRendererParams = "production" === 'production' ? null : {
    cellData: require("prop-types").any,
    columnData: require("prop-types").any,
    dataKey: require("prop-types").string.isRequired,
    rowData: function rowData(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `" + propName + "` has type 'any' or 'mixed', but was not provided to `" + componentName + "`. Pass undefined or any other value.");
      }
    },
    rowIndex: require("prop-types").number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_CellRendererParams", {
    value: babelPluginFlowReactPropTypes_proptype_CellRendererParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams = "production" === 'production' ? null : {
    className: require("prop-types").string.isRequired,
    columns: require("prop-types").arrayOf(require("prop-types").any).isRequired,
    style: function style(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `" + propName + "` has type 'any' or 'mixed', but was not provided to `" + componentName + "`. Pass undefined or any other value.");
      }
    }
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams", {
    value: babelPluginFlowReactPropTypes_proptype_HeaderRowRendererParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_HeaderRendererParams = "production" === 'production' ? null : {
    columnData: require("prop-types").any,
    dataKey: require("prop-types").string.isRequired,
    disableSort: require("prop-types").bool,
    label: require("prop-types").any,
    sortBy: require("prop-types").string,
    sortDirection: require("prop-types").string
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_HeaderRendererParams", {
    value: babelPluginFlowReactPropTypes_proptype_HeaderRendererParams,
    configurable: true
  });
  var babelPluginFlowReactPropTypes_proptype_RowRendererParams = "production" === 'production' ? null : {
    className: require("prop-types").string.isRequired,
    columns: require("prop-types").arrayOf(require("prop-types").any).isRequired,
    index: require("prop-types").number.isRequired,
    isScrolling: require("prop-types").bool.isRequired,
    onRowClick: require("prop-types").func,
    onRowDoubleClick: require("prop-types").func,
    onRowMouseOver: require("prop-types").func,
    onRowMouseOut: require("prop-types").func,
    rowData: function rowData(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `" + propName + "` has type 'any' or 'mixed', but was not provided to `" + componentName + "`. Pass undefined or any other value.");
      }
    },
    style: function style(props, propName, componentName) {
      if (!Object.prototype.hasOwnProperty.call(props, propName)) {
        throw new Error("Prop `" + propName + "` has type 'any' or 'mixed', but was not provided to `" + componentName + "`. Pass undefined or any other value.");
      }
    }
  };
  if (!("production" === 'production') && typeof exports !== "undefined") Object.defineProperty(exports, "babelPluginFlowReactPropTypes_proptype_RowRendererParams", {
    value: babelPluginFlowReactPropTypes_proptype_RowRendererParams,
    configurable: true
  });
  },{"prop-types":1249}],1234:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.IS_SCROLLING_TIMEOUT = undefined;

  var _extends2 = require('babel-runtime/helpers/extends');

  var _extends3 = _interopRequireDefault(_extends2);

  var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

  var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

  var _createClass2 = require('babel-runtime/helpers/createClass');

  var _createClass3 = _interopRequireDefault(_createClass2);

  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

  var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

  var _inherits2 = require('babel-runtime/helpers/inherits');

  var _inherits3 = _interopRequireDefault(_inherits2);

  var _react = require('react');

  var React = _interopRequireWildcard(_react);

  var _reactDom = require('react-dom');

  var _reactDom2 = _interopRequireDefault(_reactDom);

  var _onScroll = require('./utils/onScroll');

  var _dimensions = require('./utils/dimensions');

  var _detectElementResize = require('../vendor/detectElementResize');

  var _detectElementResize2 = _interopRequireDefault(_detectElementResize);

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Specifies the number of miliseconds during which to disable pointer events while a scroll is in progress.
   * This improves performance and makes scrolling smoother.
   */
  var IS_SCROLLING_TIMEOUT = exports.IS_SCROLLING_TIMEOUT = 150;

  var getWindow = function getWindow() {
    return typeof window !== 'undefined' ? window : undefined;
  };

  var WindowScroller = function (_React$PureComponent) {
    (0, _inherits3.default)(WindowScroller, _React$PureComponent);

    function WindowScroller() {
      var _ref;

      var _temp, _this, _ret;

      (0, _classCallCheck3.default)(this, WindowScroller);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = WindowScroller.__proto__ || (0, _getPrototypeOf2.default)(WindowScroller)).call.apply(_ref, [this].concat(args))), _this), _this._window = getWindow(), _this._isMounted = false, _this._positionFromTop = 0, _this._positionFromLeft = 0, _this.state = (0, _extends3.default)({}, (0, _dimensions.getDimensions)(_this.props.scrollElement, _this.props), {
        isScrolling: false,
        scrollLeft: 0,
        scrollTop: 0
      }), _this._registerChild = function (element) {
        if (element && !(element instanceof Element)) {
          console.warn('WindowScroller registerChild expects to be passed Element or null');
        }
        _this._child = element;
        _this.updatePosition();
      }, _this._onChildScroll = function (_ref2) {
        var scrollTop = _ref2.scrollTop;

        if (_this.state.scrollTop === scrollTop) {
          return;
        }

        var scrollElement = _this.props.scrollElement;
        if (scrollElement) {
          if (typeof scrollElement.scrollTo === 'function') {
            scrollElement.scrollTo(0, scrollTop + _this._positionFromTop);
          } else {
            scrollElement.scrollTop = scrollTop + _this._positionFromTop;
          }
        }
      }, _this._registerResizeListener = function (element) {
        if (element === window) {
          window.addEventListener('resize', _this._onResize, false);
        } else {
          _this._detectElementResize.addResizeListener(element, _this._onResize);
        }
      }, _this._unregisterResizeListener = function (element) {
        if (element === window) {
          window.removeEventListener('resize', _this._onResize, false);
        } else if (element) {
          _this._detectElementResize.removeResizeListener(element, _this._onResize);
        }
      }, _this._onResize = function () {
        _this.updatePosition();
      }, _this.__handleWindowScrollEvent = function () {
        if (!_this._isMounted) {
          return;
        }

        var onScroll = _this.props.onScroll;


        var scrollElement = _this.props.scrollElement;
        if (scrollElement) {
          var scrollOffset = (0, _dimensions.getScrollOffset)(scrollElement);
          var _scrollLeft = Math.max(0, scrollOffset.left - _this._positionFromLeft);
          var _scrollTop = Math.max(0, scrollOffset.top - _this._positionFromTop);

          _this.setState({
            isScrolling: true,
            scrollLeft: _scrollLeft,
            scrollTop: _scrollTop
          });

          onScroll({
            scrollLeft: _scrollLeft,
            scrollTop: _scrollTop
          });
        }
      }, _this.__resetIsScrolling = function () {
        _this.setState({
          isScrolling: false
        });
      }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
    }

    (0, _createClass3.default)(WindowScroller, [{
      key: 'updatePosition',
      value: function updatePosition() {
        var scrollElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.scrollElement;
        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;
        var onResize = this.props.onResize;
        var _state = this.state,
            height = _state.height,
            width = _state.width;


        var thisNode = this._child || _reactDom2.default.findDOMNode(this);
        if (thisNode instanceof Element && scrollElement) {
          var offset = (0, _dimensions.getPositionOffset)(thisNode, scrollElement);
          this._positionFromTop = offset.top;
          this._positionFromLeft = offset.left;
        }

        var dimensions = (0, _dimensions.getDimensions)(scrollElement, props);
        if (height !== dimensions.height || width !== dimensions.width) {
          this.setState({
            height: dimensions.height,
            width: dimensions.width
          });
          onResize({
            height: dimensions.height,
            width: dimensions.width
          });
        }
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        var scrollElement = this.props.scrollElement;

        this._detectElementResize = (0, _detectElementResize2.default)();

        this.updatePosition(scrollElement);

        if (scrollElement) {
          (0, _onScroll.registerScrollListener)(this, scrollElement);
          this._registerResizeListener(scrollElement);
        }

        this._isMounted = true;
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        var scrollElement = this.props.scrollElement;
        var nextScrollElement = nextProps.scrollElement;

        if (scrollElement !== nextScrollElement && scrollElement && nextScrollElement) {
          this.updatePosition(nextScrollElement, nextProps);

          (0, _onScroll.unregisterScrollListener)(this, scrollElement);
          (0, _onScroll.registerScrollListener)(this, nextScrollElement);

          this._unregisterResizeListener(scrollElement);
          this._registerResizeListener(nextScrollElement);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        var scrollElement = this.props.scrollElement;
        if (scrollElement) {
          (0, _onScroll.unregisterScrollListener)(this, scrollElement);
          this._unregisterResizeListener(scrollElement);
        }

        this._isMounted = false;
      }
    }, {
      key: 'render',
      value: function render() {
        var children = this.props.children;
        var _state2 = this.state,
            isScrolling = _state2.isScrolling,
            scrollTop = _state2.scrollTop,
            scrollLeft = _state2.scrollLeft,
            height = _state2.height,
            width = _state2.width;


        return children({
          onChildScroll: this._onChildScroll,
          registerChild: this._registerChild,
          height: height,
          isScrolling: isScrolling,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop,
          width: width
        });
      }

      // Referenced by utils/onScroll


      // Referenced by utils/onScroll

    }]);
    return WindowScroller;
  }(React.PureComponent);

  WindowScroller.defaultProps = {
    onResize: function onResize() {},
    onScroll: function onScroll() {},
    scrollingResetTimeInterval: IS_SCROLLING_TIMEOUT,
    scrollElement: getWindow(),
    serverHeight: 0,
    serverWidth: 0
  };
  WindowScroller.propTypes = "production" === 'production' ? null : {
    /**
     * Function responsible for rendering children.
     * This function should implement the following signature:
     * ({ height, isScrolling, scrollLeft, scrollTop, width }) => PropTypes.element
     */
    children: require('prop-types').func.isRequired,


    /** Callback to be invoked on-resize: ({ height, width }) */
    onResize: require('prop-types').func.isRequired,


    /** Callback to be invoked on-scroll: ({ scrollLeft, scrollTop }) */
    onScroll: require('prop-types').func.isRequired,


    /** Element to attach scroll event listeners. Defaults to window. */
    scrollElement: require('prop-types').oneOfType([require('prop-types').any, typeof Element === 'function' ? require('prop-types').instanceOf(Element) : require('prop-types').any]),

    /**
     * Wait this amount of time after the last scroll event before resetting child `pointer-events`.
     */
    scrollingResetTimeInterval: require('prop-types').number.isRequired,


    /** Height used for server-side rendering */
    serverHeight: require('prop-types').number.isRequired,


    /** Width used for server-side rendering */
    serverWidth: require('prop-types').number.isRequired
  };
  exports.default = WindowScroller;
  },{"../vendor/detectElementResize":1244,"./utils/dimensions":1236,"./utils/onScroll":1237,"babel-runtime/core-js/object/get-prototype-of":579,"babel-runtime/helpers/classCallCheck":584,"babel-runtime/helpers/createClass":585,"babel-runtime/helpers/extends":586,"babel-runtime/helpers/inherits":587,"babel-runtime/helpers/possibleConstructorReturn":589,"prop-types":1249,"react":1253,"react-dom":1157}],1235:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.IS_SCROLLING_TIMEOUT = exports.WindowScroller = undefined;

  var _WindowScroller = require('./WindowScroller');

  var _WindowScroller2 = _interopRequireDefault(_WindowScroller);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _WindowScroller2.default;
  exports.WindowScroller = _WindowScroller2.default;
  exports.IS_SCROLLING_TIMEOUT = _WindowScroller.IS_SCROLLING_TIMEOUT;
  },{"./WindowScroller":1234}],1236:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getDimensions = getDimensions;
  exports.getPositionOffset = getPositionOffset;
  exports.getScrollOffset = getScrollOffset;


  /**
   * Gets the dimensions of the element, accounting for API differences between
   * `window` and other DOM elements.
   */

  var isWindow = function isWindow(element) {
    return element === window;
  };

  // TODO Move this into WindowScroller and import from there


  var getBoundingBox = function getBoundingBox(element) {
    return element.getBoundingClientRect();
  };

  function getDimensions(scrollElement, props) {
    if (!scrollElement) {
      return {
        height: props.serverHeight,
        width: props.serverWidth
      };
    } else if (isWindow(scrollElement)) {
      var _window = window,
          innerHeight = _window.innerHeight,
          innerWidth = _window.innerWidth;

      return {
        height: typeof innerHeight === 'number' ? innerHeight : 0,
        width: typeof innerWidth === 'number' ? innerWidth : 0
      };
    } else {
      return getBoundingBox(scrollElement);
    }
  }

  /**
   * Gets the vertical and horizontal position of an element within its scroll container.
   * Elements that have been “scrolled past” return negative values.
   * Handles edge-case where a user is navigating back (history) from an already-scrolled page.
   * In this case the body’s top or left position will be a negative number and this element’s top or left will be increased (by that amount).
   */
  function getPositionOffset(element, container) {
    if (isWindow(container) && document.documentElement) {
      var containerElement = document.documentElement;
      var elementRect = getBoundingBox(element);
      var containerRect = getBoundingBox(containerElement);
      return {
        top: elementRect.top - containerRect.top,
        left: elementRect.left - containerRect.left
      };
    } else {
      var scrollOffset = getScrollOffset(container);
      var _elementRect = getBoundingBox(element);
      var _containerRect = getBoundingBox(container);
      return {
        top: _elementRect.top + scrollOffset.top - _containerRect.top,
        left: _elementRect.left + scrollOffset.left - _containerRect.left
      };
    }
  }

  /**
   * Gets the vertical and horizontal scroll amount of the element, accounting for IE compatibility
   * and API differences between `window` and other DOM elements.
   */
  function getScrollOffset(element) {
    if (isWindow(element) && document.documentElement) {
      return {
        top: 'scrollY' in window ? window.scrollY : document.documentElement.scrollTop,
        left: 'scrollX' in window ? window.scrollX : document.documentElement.scrollLeft
      };
    } else {
      return {
        top: element.scrollTop,
        left: element.scrollLeft
      };
    }
  }
  },{}],1237:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.registerScrollListener = registerScrollListener;
  exports.unregisterScrollListener = unregisterScrollListener;

  var _requestAnimationTimeout = require('../../utils/requestAnimationTimeout');

  var _WindowScroller = require('../WindowScroller.js');

  var _WindowScroller2 = _interopRequireDefault(_WindowScroller);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var mountedInstances = [];
  var originalBodyPointerEvents = null;
  var disablePointerEventsTimeoutId = null;

  function enablePointerEventsIfDisabled() {
    if (disablePointerEventsTimeoutId) {
      disablePointerEventsTimeoutId = null;

      if (document.body && originalBodyPointerEvents != null) {
        document.body.style.pointerEvents = originalBodyPointerEvents;
      }

      originalBodyPointerEvents = null;
    }
  }

  function enablePointerEventsAfterDelayCallback() {
    enablePointerEventsIfDisabled();
    mountedInstances.forEach(function (instance) {
      return instance.__resetIsScrolling();
    });
  }

  function enablePointerEventsAfterDelay() {
    if (disablePointerEventsTimeoutId) {
      (0, _requestAnimationTimeout.cancelAnimationTimeout)(disablePointerEventsTimeoutId);
    }

    var maximumTimeout = 0;
    mountedInstances.forEach(function (instance) {
      maximumTimeout = Math.max(maximumTimeout, instance.props.scrollingResetTimeInterval);
    });

    disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(enablePointerEventsAfterDelayCallback, maximumTimeout);
  }

  function onScrollWindow(event) {
    if (event.currentTarget === window && originalBodyPointerEvents == null && document.body) {
      originalBodyPointerEvents = document.body.style.pointerEvents;

      document.body.style.pointerEvents = 'none';
    }
    enablePointerEventsAfterDelay();
    mountedInstances.forEach(function (instance) {
      if (instance.props.scrollElement === event.currentTarget) {
        instance.__handleWindowScrollEvent();
      }
    });
  }

  function registerScrollListener(component, element) {
    if (!mountedInstances.some(function (instance) {
      return instance.props.scrollElement === element;
    })) {
      element.addEventListener('scroll', onScrollWindow);
    }
    mountedInstances.push(component);
  }

  function unregisterScrollListener(component, element) {
    mountedInstances = mountedInstances.filter(function (instance) {
      return instance !== component;
    });
    if (!mountedInstances.length) {
      element.removeEventListener('scroll', onScrollWindow);
      if (disablePointerEventsTimeoutId) {
        (0, _requestAnimationTimeout.cancelAnimationTimeout)(disablePointerEventsTimeoutId);
        enablePointerEventsIfDisabled();
      }
    }
  }
  },{"../../utils/requestAnimationTimeout":1242,"../WindowScroller.js":1234}],1238:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _ArrowKeyStepper = require('./ArrowKeyStepper');

  Object.defineProperty(exports, 'ArrowKeyStepper', {
    enumerable: true,
    get: function get() {
      return _ArrowKeyStepper.ArrowKeyStepper;
    }
  });

  var _AutoSizer = require('./AutoSizer');

  Object.defineProperty(exports, 'AutoSizer', {
    enumerable: true,
    get: function get() {
      return _AutoSizer.AutoSizer;
    }
  });

  var _CellMeasurer = require('./CellMeasurer');

  Object.defineProperty(exports, 'CellMeasurer', {
    enumerable: true,
    get: function get() {
      return _CellMeasurer.CellMeasurer;
    }
  });
  Object.defineProperty(exports, 'CellMeasurerCache', {
    enumerable: true,
    get: function get() {
      return _CellMeasurer.CellMeasurerCache;
    }
  });

  var _Collection = require('./Collection');

  Object.defineProperty(exports, 'Collection', {
    enumerable: true,
    get: function get() {
      return _Collection.Collection;
    }
  });

  var _ColumnSizer = require('./ColumnSizer');

  Object.defineProperty(exports, 'ColumnSizer', {
    enumerable: true,
    get: function get() {
      return _ColumnSizer.ColumnSizer;
    }
  });

  var _Grid = require('./Grid');

  Object.defineProperty(exports, 'accessibilityOverscanIndicesGetter', {
    enumerable: true,
    get: function get() {
      return _Grid.accessibilityOverscanIndicesGetter;
    }
  });
  Object.defineProperty(exports, 'defaultCellRangeRenderer', {
    enumerable: true,
    get: function get() {
      return _Grid.defaultCellRangeRenderer;
    }
  });
  Object.defineProperty(exports, 'defaultOverscanIndicesGetter', {
    enumerable: true,
    get: function get() {
      return _Grid.defaultOverscanIndicesGetter;
    }
  });
  Object.defineProperty(exports, 'Grid', {
    enumerable: true,
    get: function get() {
      return _Grid.Grid;
    }
  });

  var _InfiniteLoader = require('./InfiniteLoader');

  Object.defineProperty(exports, 'InfiniteLoader', {
    enumerable: true,
    get: function get() {
      return _InfiniteLoader.InfiniteLoader;
    }
  });

  var _List = require('./List');

  Object.defineProperty(exports, 'List', {
    enumerable: true,
    get: function get() {
      return _List.List;
    }
  });

  var _Masonry = require('./Masonry');

  Object.defineProperty(exports, 'createMasonryCellPositioner', {
    enumerable: true,
    get: function get() {
      return _Masonry.createCellPositioner;
    }
  });
  Object.defineProperty(exports, 'Masonry', {
    enumerable: true,
    get: function get() {
      return _Masonry.Masonry;
    }
  });

  var _MultiGrid = require('./MultiGrid');

  Object.defineProperty(exports, 'MultiGrid', {
    enumerable: true,
    get: function get() {
      return _MultiGrid.MultiGrid;
    }
  });

  var _ScrollSync = require('./ScrollSync');

  Object.defineProperty(exports, 'ScrollSync', {
    enumerable: true,
    get: function get() {
      return _ScrollSync.ScrollSync;
    }
  });

  var _Table = require('./Table');

  Object.defineProperty(exports, 'createTableMultiSort', {
    enumerable: true,
    get: function get() {
      return _Table.createMultiSort;
    }
  });
  Object.defineProperty(exports, 'defaultTableCellDataGetter', {
    enumerable: true,
    get: function get() {
      return _Table.defaultCellDataGetter;
    }
  });
  Object.defineProperty(exports, 'defaultTableCellRenderer', {
    enumerable: true,
    get: function get() {
      return _Table.defaultCellRenderer;
    }
  });
  Object.defineProperty(exports, 'defaultTableHeaderRenderer', {
    enumerable: true,
    get: function get() {
      return _Table.defaultHeaderRenderer;
    }
  });
  Object.defineProperty(exports, 'defaultTableHeaderRowRenderer', {
    enumerable: true,
    get: function get() {
      return _Table.defaultHeaderRowRenderer;
    }
  });
  Object.defineProperty(exports, 'defaultTableRowRenderer', {
    enumerable: true,
    get: function get() {
      return _Table.defaultRowRenderer;
    }
  });
  Object.defineProperty(exports, 'Table', {
    enumerable: true,
    get: function get() {
      return _Table.Table;
    }
  });
  Object.defineProperty(exports, 'Column', {
    enumerable: true,
    get: function get() {
      return _Table.Column;
    }
  });
  Object.defineProperty(exports, 'SortDirection', {
    enumerable: true,
    get: function get() {
      return _Table.SortDirection;
    }
  });
  Object.defineProperty(exports, 'SortIndicator', {
    enumerable: true,
    get: function get() {
      return _Table.SortIndicator;
    }
  });

  var _WindowScroller = require('./WindowScroller');

  Object.defineProperty(exports, 'WindowScroller', {
    enumerable: true,
    get: function get() {
      return _WindowScroller.WindowScroller;
    }
  });
  },{"./ArrowKeyStepper":1181,"./AutoSizer":1184,"./CellMeasurer":1187,"./Collection":1192,"./ColumnSizer":1196,"./Grid":1201,"./InfiniteLoader":1209,"./List":1211,"./Masonry":1216,"./MultiGrid":1219,"./ScrollSync":1221,"./Table":1232,"./WindowScroller":1235}],1239:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });


  // Properly handle server-side rendering.
  var win = void 0;

  if (typeof window !== 'undefined') {
    win = window;
  } else if (typeof self !== 'undefined') {
    win = self;
  } else {
    win = {};
  }

  // requestAnimationFrame() shim by Paul Irish
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  var request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (callback) {
    return win.setTimeout(callback, 1000 / 60);
  };

  var cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function (id) {
    win.clearTimeout(id);
  };

  var raf = exports.raf = request;
  var caf = exports.caf = cancel;
  },{}],1240:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _keys = require('babel-runtime/core-js/object/keys');

  var _keys2 = _interopRequireDefault(_keys);

  exports.default = createCallbackMemoizer;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Helper utility that updates the specified callback whenever any of the specified indices have changed.
   */
  function createCallbackMemoizer() {
    var requireAllKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    var cachedIndices = {};

    return function (_ref) {
      var callback = _ref.callback,
          indices = _ref.indices;

      var keys = (0, _keys2.default)(indices);
      var allInitialized = !requireAllKeys || keys.every(function (key) {
        var value = indices[key];
        return Array.isArray(value) ? value.length > 0 : value >= 0;
      });
      var indexChanged = keys.length !== (0, _keys2.default)(cachedIndices).length || keys.some(function (key) {
        var cachedValue = cachedIndices[key];
        var value = indices[key];

        return Array.isArray(value) ? cachedValue.join(',') !== value.join(',') : cachedValue !== value;
      });

      cachedIndices = indices;

      if (allInitialized && indexChanged) {
        callback(indices);
      }
    };
  }
  },{"babel-runtime/core-js/object/keys":580}],1241:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getUpdatedOffsetForIndex;
  /**
   * Determines a new offset that ensures a certain cell is visible, given the current offset.
   * If the cell is already visible then the current offset will be returned.
   * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
   *
   * @param align Desired alignment within container; one of "auto" (default), "start", or "end"
   * @param cellOffset Offset (x or y) position for cell
   * @param cellSize Size (width or height) of cell
   * @param containerSize Total size (width or height) of the container
   * @param currentOffset Container's current (x or y) offset
   * @return Offset to use to ensure the specified cell is visible
   */
  function getUpdatedOffsetForIndex(_ref) {
    var _ref$align = _ref.align,
        align = _ref$align === undefined ? 'auto' : _ref$align,
        cellOffset = _ref.cellOffset,
        cellSize = _ref.cellSize,
        containerSize = _ref.containerSize,
        currentOffset = _ref.currentOffset;

    var maxOffset = cellOffset;
    var minOffset = maxOffset - containerSize + cellSize;

    switch (align) {
      case 'start':
        return maxOffset;
      case 'end':
        return minOffset;
      case 'center':
        return maxOffset - (containerSize - cellSize) / 2;
      default:
        return Math.max(minOffset, Math.min(maxOffset, currentOffset));
    }
  }
  },{}],1242:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.requestAnimationTimeout = exports.cancelAnimationTimeout = undefined;

  var _animationFrame = require('./animationFrame');

  var babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId = "production" === 'production' ? null : {
    id: require('prop-types').number.isRequired
  };
  if (!("production" === 'production') && typeof exports !== 'undefined') Object.defineProperty(exports, 'babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId', {
    value: babelPluginFlowReactPropTypes_proptype_AnimationTimeoutId,
    configurable: true
  });
  var cancelAnimationTimeout = exports.cancelAnimationTimeout = function cancelAnimationTimeout(frame) {
    return (0, _animationFrame.caf)(frame.id);
  };

  /**
   * Recursively calls requestAnimationFrame until a specified delay has been met or exceeded.
   * When the delay time has been reached the function you're timing out will be called.
   *
   * Credit: Joe Lambert (https://gist.github.com/joelambert/1002116#file-requesttimeout-js)
   */
  var requestAnimationTimeout = exports.requestAnimationTimeout = function requestAnimationTimeout(callback, delay) {
    var start = Date.now();

    var timeout = function timeout() {
      if (Date.now() - start >= delay) {
        callback.call();
      } else {
        frame.id = (0, _animationFrame.raf)(timeout);
      }
    };

    var frame = {
      id: (0, _animationFrame.raf)(timeout)
    };

    return frame;
  };
  },{"./animationFrame":1239,"prop-types":1249}],1243:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Binary Search Bounds
   * https://github.com/mikolalysenko/binary-search-bounds
   * Mikola Lysenko
   *
   * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax.
   * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5
   **/

  function _GEA(a, l, h, y) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (x >= y) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function _GEP(a, l, h, y, c) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (c(x, y) >= 0) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function dispatchBsearchGE(a, y, c, l, h) {
    if (typeof c === 'function') {
      return _GEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _GEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }

  function _GTA(a, l, h, y) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (x > y) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function _GTP(a, l, h, y, c) {
    var i = h + 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (c(x, y) > 0) {
        i = m;
        h = m - 1;
      } else {
        l = m + 1;
      }
    }
    return i;
  }
  function dispatchBsearchGT(a, y, c, l, h) {
    if (typeof c === 'function') {
      return _GTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _GTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }

  function _LTA(a, l, h, y) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (x < y) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function _LTP(a, l, h, y, c) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (c(x, y) < 0) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function dispatchBsearchLT(a, y, c, l, h) {
    if (typeof c === 'function') {
      return _LTP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _LTA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }

  function _LEA(a, l, h, y) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (x <= y) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function _LEP(a, l, h, y, c) {
    var i = l - 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (c(x, y) <= 0) {
        i = m;
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return i;
  }
  function dispatchBsearchLE(a, y, c, l, h) {
    if (typeof c === 'function') {
      return _LEP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _LEA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }

  function _EQA(a, l, h, y) {
    l - 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      if (x === y) {
        return m;
      } else if (x <= y) {
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return -1;
  }
  function _EQP(a, l, h, y, c) {
    l - 1;
    while (l <= h) {
      var m = l + h >>> 1,
          x = a[m];
      var p = c(x, y);
      if (p === 0) {
        return m;
      } else if (p <= 0) {
        l = m + 1;
      } else {
        h = m - 1;
      }
    }
    return -1;
  }
  function dispatchBsearchEQ(a, y, c, l, h) {
    if (typeof c === 'function') {
      return _EQP(a, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0, y, c);
    } else {
      return _EQA(a, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0, y);
    }
  }

  exports.default = {
    ge: dispatchBsearchGE,
    gt: dispatchBsearchGT,
    lt: dispatchBsearchLT,
    le: dispatchBsearchLE,
    eq: dispatchBsearchEQ
  };
  },{}],1244:[function(require,module,exports){
  (function (global){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createDetectElementResize;
  /**
   * Detect Element Resize.
   * https://github.com/sdecima/javascript-detect-element-resize
   * Sebastian Decima
   *
   * Forked from version 0.5.3; includes the following modifications:
   * 1) Guard against unsafe 'window' and 'document' references (to support SSR).
   * 2) Defer initialization code via a top-level function wrapper (to support SSR).
   * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
   * 4) Add nonce for style element.
   **/

  function createDetectElementResize(nonce) {
    // Check `document` and `window` in case of server-side rendering
    var _window;
    if (typeof window !== 'undefined') {
      _window = window;
    } else if (typeof self !== 'undefined') {
      _window = self;
    } else {
      _window = global;
    }

    var attachEvent = typeof document !== 'undefined' && document.attachEvent;

    if (!attachEvent) {
      var requestFrame = function () {
        var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function (fn) {
          return _window.setTimeout(fn, 20);
        };
        return function (fn) {
          return raf(fn);
        };
      }();

      var cancelFrame = function () {
        var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
        return function (id) {
          return cancel(id);
        };
      }();

      var resetTriggers = function resetTriggers(element) {
        var triggers = element.__resizeTriggers__,
            expand = triggers.firstElementChild,
            contract = triggers.lastElementChild,
            expandChild = expand.firstElementChild;
        contract.scrollLeft = contract.scrollWidth;
        contract.scrollTop = contract.scrollHeight;
        expandChild.style.width = expand.offsetWidth + 1 + 'px';
        expandChild.style.height = expand.offsetHeight + 1 + 'px';
        expand.scrollLeft = expand.scrollWidth;
        expand.scrollTop = expand.scrollHeight;
      };

      var checkTriggers = function checkTriggers(element) {
        return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
      };

      var scrollListener = function scrollListener(e) {
        // Don't measure (which forces) reflow for scrolls that happen inside of children!
        if (e.target.className.indexOf('contract-trigger') < 0 && e.target.className.indexOf('expand-trigger') < 0) {
          return;
        }

        var element = this;
        resetTriggers(this);
        if (this.__resizeRAF__) {
          cancelFrame(this.__resizeRAF__);
        }
        this.__resizeRAF__ = requestFrame(function () {
          if (checkTriggers(element)) {
            element.__resizeLast__.width = element.offsetWidth;
            element.__resizeLast__.height = element.offsetHeight;
            element.__resizeListeners__.forEach(function (fn) {
              fn.call(element, e);
            });
          }
        });
      };

      /* Detect CSS Animations support to detect element display/re-attach */
      var animation = false,
          keyframeprefix = '',
          animationstartevent = 'animationstart',
          domPrefixes = 'Webkit Moz O ms'.split(' '),
          startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
          pfx = '';
      {
        var elm = document.createElement('fakeelement');
        if (elm.style.animationName !== undefined) {
          animation = true;
        }

        if (animation === false) {
          for (var i = 0; i < domPrefixes.length; i++) {
            if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
              pfx = domPrefixes[i];
              keyframeprefix = '-' + pfx.toLowerCase() + '-';
              animationstartevent = startEvents[i];
              animation = true;
              break;
            }
          }
        }
      }

      var animationName = 'resizeanim';
      var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
      var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';
    }

    var createStyles = function createStyles(doc) {
      if (!doc.getElementById('detectElementResize')) {
        //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
        var css = (animationKeyframes ? animationKeyframes : '') + '.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' + '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
            head = doc.head || doc.getElementsByTagName('head')[0],
            style = doc.createElement('style');

        style.id = 'detectElementResize';
        style.type = 'text/css';

        if (nonce != null) {
          style.setAttribute('nonce', nonce);
        }

        if (style.styleSheet) {
          style.styleSheet.cssText = css;
        } else {
          style.appendChild(doc.createTextNode(css));
        }

        head.appendChild(style);
      }
    };

    var addResizeListener = function addResizeListener(element, fn) {
      if (attachEvent) {
        element.attachEvent('onresize', fn);
      } else {
        if (!element.__resizeTriggers__) {
          var doc = element.ownerDocument;
          var elementStyle = _window.getComputedStyle(element);
          if (elementStyle && elementStyle.position == 'static') {
            element.style.position = 'relative';
          }
          createStyles(doc);
          element.__resizeLast__ = {};
          element.__resizeListeners__ = [];
          (element.__resizeTriggers__ = doc.createElement('div')).className = 'resize-triggers';
          element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' + '<div class="contract-trigger"></div>';
          element.appendChild(element.__resizeTriggers__);
          resetTriggers(element);
          element.addEventListener('scroll', scrollListener, true);

          /* Listen for a css animation to detect element display/re-attach */
          if (animationstartevent) {
            element.__resizeTriggers__.__animationListener__ = function animationListener(e) {
              if (e.animationName == animationName) {
                resetTriggers(element);
              }
            };
            element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
          }
        }
        element.__resizeListeners__.push(fn);
      }
    };

    var removeResizeListener = function removeResizeListener(element, fn) {
      if (attachEvent) {
        element.detachEvent('onresize', fn);
      } else {
        element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
        if (!element.__resizeListeners__.length) {
          element.removeEventListener('scroll', scrollListener, true);
          if (element.__resizeTriggers__.__animationListener__) {
            element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
            element.__resizeTriggers__.__animationListener__ = null;
          }
          try {
            element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
          } catch (e) {
            // Preact compat; see developit/preact-compat/issues/228
          }
        }
      }
    };

    return {
      addResizeListener: addResizeListener,
      removeResizeListener: removeResizeListener
    };
  }
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{}],1245:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createWrapper;

  var _binarySearchBounds = require('./binarySearchBounds');

  var _binarySearchBounds2 = _interopRequireDefault(_binarySearchBounds);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var NOT_FOUND = 0; /**
                      * Binary Search Bounds
                      * https://github.com/mikolalysenko/interval-tree-1d
                      * Mikola Lysenko
                      *
                      * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax in an upstream dependency.
                      * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5
                      **/

  var SUCCESS = 1;
  var EMPTY = 2;

  function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
    this.mid = mid;
    this.left = left;
    this.right = right;
    this.leftPoints = leftPoints;
    this.rightPoints = rightPoints;
    this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
  }

  var proto = IntervalTreeNode.prototype;

  function copy(a, b) {
    a.mid = b.mid;
    a.left = b.left;
    a.right = b.right;
    a.leftPoints = b.leftPoints;
    a.rightPoints = b.rightPoints;
    a.count = b.count;
  }

  function rebuild(node, intervals) {
    var ntree = createIntervalTree(intervals);
    node.mid = ntree.mid;
    node.left = ntree.left;
    node.right = ntree.right;
    node.leftPoints = ntree.leftPoints;
    node.rightPoints = ntree.rightPoints;
    node.count = ntree.count;
  }

  function rebuildWithInterval(node, interval) {
    var intervals = node.intervals([]);
    intervals.push(interval);
    rebuild(node, intervals);
  }

  function rebuildWithoutInterval(node, interval) {
    var intervals = node.intervals([]);
    var idx = intervals.indexOf(interval);
    if (idx < 0) {
      return NOT_FOUND;
    }
    intervals.splice(idx, 1);
    rebuild(node, intervals);
    return SUCCESS;
  }

  proto.intervals = function (result) {
    result.push.apply(result, this.leftPoints);
    if (this.left) {
      this.left.intervals(result);
    }
    if (this.right) {
      this.right.intervals(result);
    }
    return result;
  };

  proto.insert = function (interval) {
    var weight = this.count - this.leftPoints.length;
    this.count += 1;
    if (interval[1] < this.mid) {
      if (this.left) {
        if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
          rebuildWithInterval(this, interval);
        } else {
          this.left.insert(interval);
        }
      } else {
        this.left = createIntervalTree([interval]);
      }
    } else if (interval[0] > this.mid) {
      if (this.right) {
        if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
          rebuildWithInterval(this, interval);
        } else {
          this.right.insert(interval);
        }
      } else {
        this.right = createIntervalTree([interval]);
      }
    } else {
      var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin);
      var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd);
      this.leftPoints.splice(l, 0, interval);
      this.rightPoints.splice(r, 0, interval);
    }
  };

  proto.remove = function (interval) {
    var weight = this.count - this.leftPoints;
    if (interval[1] < this.mid) {
      if (!this.left) {
        return NOT_FOUND;
      }
      var rw = this.right ? this.right.count : 0;
      if (4 * rw > 3 * (weight - 1)) {
        return rebuildWithoutInterval(this, interval);
      }
      var r = this.left.remove(interval);
      if (r === EMPTY) {
        this.left = null;
        this.count -= 1;
        return SUCCESS;
      } else if (r === SUCCESS) {
        this.count -= 1;
      }
      return r;
    } else if (interval[0] > this.mid) {
      if (!this.right) {
        return NOT_FOUND;
      }
      var lw = this.left ? this.left.count : 0;
      if (4 * lw > 3 * (weight - 1)) {
        return rebuildWithoutInterval(this, interval);
      }
      var r = this.right.remove(interval);
      if (r === EMPTY) {
        this.right = null;
        this.count -= 1;
        return SUCCESS;
      } else if (r === SUCCESS) {
        this.count -= 1;
      }
      return r;
    } else {
      if (this.count === 1) {
        if (this.leftPoints[0] === interval) {
          return EMPTY;
        } else {
          return NOT_FOUND;
        }
      }
      if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
        if (this.left && this.right) {
          var p = this;
          var n = this.left;
          while (n.right) {
            p = n;
            n = n.right;
          }
          if (p === this) {
            n.right = this.right;
          } else {
            var l = this.left;
            var r = this.right;
            p.count -= n.count;
            p.right = n.left;
            n.left = l;
            n.right = r;
          }
          copy(this, n);
          this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
        } else if (this.left) {
          copy(this, this.left);
        } else {
          copy(this, this.right);
        }
        return SUCCESS;
      }
      for (var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
        if (this.leftPoints[l][0] !== interval[0]) {
          break;
        }
        if (this.leftPoints[l] === interval) {
          this.count -= 1;
          this.leftPoints.splice(l, 1);
          for (var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {
            if (this.rightPoints[r][1] !== interval[1]) {
              break;
            } else if (this.rightPoints[r] === interval) {
              this.rightPoints.splice(r, 1);
              return SUCCESS;
            }
          }
        }
      }
      return NOT_FOUND;
    }
  };

  function reportLeftRange(arr, hi, cb) {
    for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
      var r = cb(arr[i]);
      if (r) {
        return r;
      }
    }
  }

  function reportRightRange(arr, lo, cb) {
    for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
      var r = cb(arr[i]);
      if (r) {
        return r;
      }
    }
  }

  function reportRange(arr, cb) {
    for (var i = 0; i < arr.length; ++i) {
      var r = cb(arr[i]);
      if (r) {
        return r;
      }
    }
  }

  proto.queryPoint = function (x, cb) {
    if (x < this.mid) {
      if (this.left) {
        var r = this.left.queryPoint(x, cb);
        if (r) {
          return r;
        }
      }
      return reportLeftRange(this.leftPoints, x, cb);
    } else if (x > this.mid) {
      if (this.right) {
        var r = this.right.queryPoint(x, cb);
        if (r) {
          return r;
        }
      }
      return reportRightRange(this.rightPoints, x, cb);
    } else {
      return reportRange(this.leftPoints, cb);
    }
  };

  proto.queryInterval = function (lo, hi, cb) {
    if (lo < this.mid && this.left) {
      var r = this.left.queryInterval(lo, hi, cb);
      if (r) {
        return r;
      }
    }
    if (hi > this.mid && this.right) {
      var r = this.right.queryInterval(lo, hi, cb);
      if (r) {
        return r;
      }
    }
    if (hi < this.mid) {
      return reportLeftRange(this.leftPoints, hi, cb);
    } else if (lo > this.mid) {
      return reportRightRange(this.rightPoints, lo, cb);
    } else {
      return reportRange(this.leftPoints, cb);
    }
  };

  function compareNumbers(a, b) {
    return a - b;
  }

  function compareBegin(a, b) {
    var d = a[0] - b[0];
    if (d) {
      return d;
    }
    return a[1] - b[1];
  }

  function compareEnd(a, b) {
    var d = a[1] - b[1];
    if (d) {
      return d;
    }
    return a[0] - b[0];
  }

  function createIntervalTree(intervals) {
    if (intervals.length === 0) {
      return null;
    }
    var pts = [];
    for (var i = 0; i < intervals.length; ++i) {
      pts.push(intervals[i][0], intervals[i][1]);
    }
    pts.sort(compareNumbers);

    var mid = pts[pts.length >> 1];

    var leftIntervals = [];
    var rightIntervals = [];
    var centerIntervals = [];
    for (var i = 0; i < intervals.length; ++i) {
      var s = intervals[i];
      if (s[1] < mid) {
        leftIntervals.push(s);
      } else if (mid < s[0]) {
        rightIntervals.push(s);
      } else {
        centerIntervals.push(s);
      }
    }

    //Split center intervals
    var leftPoints = centerIntervals;
    var rightPoints = centerIntervals.slice();
    leftPoints.sort(compareBegin);
    rightPoints.sort(compareEnd);

    return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);
  }

  //User friendly wrapper that makes it possible to support empty trees
  function IntervalTree(root) {
    this.root = root;
  }

  var tproto = IntervalTree.prototype;

  tproto.insert = function (interval) {
    if (this.root) {
      this.root.insert(interval);
    } else {
      this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
    }
  };

  tproto.remove = function (interval) {
    if (this.root) {
      var r = this.root.remove(interval);
      if (r === EMPTY) {
        this.root = null;
      }
      return r !== NOT_FOUND;
    }
    return false;
  };

  tproto.queryPoint = function (p, cb) {
    if (this.root) {
      return this.root.queryPoint(p, cb);
    }
  };

  tproto.queryInterval = function (lo, hi, cb) {
    if (lo <= hi && this.root) {
      return this.root.queryInterval(lo, hi, cb);
    }
  };

  Object.defineProperty(tproto, 'count', {
    get: function get() {
      if (this.root) {
        return this.root.count;
      }
      return 0;
    }
  });

  Object.defineProperty(tproto, 'intervals', {
    get: function get() {
      if (this.root) {
        return this.root.intervals([]);
      }
      return [];
    }
  });

  function createWrapper(intervals) {
    if (!intervals || intervals.length === 0) {
      return new IntervalTree(null);
    }
    return new IntervalTree(createIntervalTree(intervals));
  }
  },{"./binarySearchBounds":1243}],1246:[function(require,module,exports){
  arguments[4][824][0].apply(exports,arguments)
  },{"./lib/ReactPropTypesSecret":1250,"dup":824,"fbjs/lib/invariant":721,"fbjs/lib/warning":725}],1247:[function(require,module,exports){
  arguments[4][825][0].apply(exports,arguments)
  },{"./lib/ReactPropTypesSecret":1250,"dup":825,"fbjs/lib/emptyFunction":715,"fbjs/lib/invariant":721}],1248:[function(require,module,exports){
  arguments[4][826][0].apply(exports,arguments)
  },{"./checkPropTypes":1246,"./lib/ReactPropTypesSecret":1250,"dup":826,"fbjs/lib/emptyFunction":715,"fbjs/lib/invariant":721,"fbjs/lib/warning":725,"object-assign":822}],1249:[function(require,module,exports){
  arguments[4][827][0].apply(exports,arguments)
  },{"./factoryWithThrowingShims":1247,"./factoryWithTypeCheckers":1248,"dup":827}],1250:[function(require,module,exports){
  arguments[4][828][0].apply(exports,arguments)
  },{"dup":828}],1251:[function(require,module,exports){
  /** @license React v16.2.0
   * react.development.js
   *
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';



  if ("production" !== "production") {
    (function() {
  'use strict';

  var _assign = require('object-assign');
  var emptyObject = require('fbjs/lib/emptyObject');
  var invariant = require('fbjs/lib/invariant');
  var warning = require('fbjs/lib/warning');
  var emptyFunction = require('fbjs/lib/emptyFunction');
  var checkPropTypes = require('prop-types/checkPropTypes');

  // TODO: this is special because it gets imported during build.

  var ReactVersion = '16.2.0';

  // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.
  var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

  var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
  var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
  var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
  var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
  var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

  var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  function getIteratorFn(maybeIterable) {
    if (maybeIterable === null || typeof maybeIterable === 'undefined') {
      return null;
    }
    var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
    if (typeof maybeIterator === 'function') {
      return maybeIterator;
    }
    return null;
  }

  /**
   * WARNING: DO NOT manually require this module.
   * This is a replacement for `invariant(...)` used by the error code system
   * and will _only_ be required by the corresponding babel pass.
   * It always throws.
   */

  /**
   * Forked from fbjs/warning:
   * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
   *
   * Only change is we use console.warn instead of console.error,
   * and do nothing when 'console' is not supported.
   * This really simplifies the code.
   * ---
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var lowPriorityWarning = function () {};

  {
    var printWarning = function (format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.warn(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    lowPriorityWarning = function (condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }
      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  }

  var lowPriorityWarning$1 = lowPriorityWarning;

  var didWarnStateUpdateForUnmountedComponent = {};

  function warnNoop(publicInstance, callerName) {
    {
      var constructor = publicInstance.constructor;
      var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
      var warningKey = componentName + '.' + callerName;
      if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
        return;
      }
      warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
      didWarnStateUpdateForUnmountedComponent[warningKey] = true;
    }
  }

  /**
   * This is the abstract API for an update queue.
   */
  var ReactNoopUpdateQueue = {
    /**
     * Checks whether or not this composite component is mounted.
     * @param {ReactClass} publicInstance The instance we want to test.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function (publicInstance) {
      return false;
    },

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {?function} callback Called after component is updated.
     * @param {?string} callerName name of the calling function in the public API.
     * @internal
     */
    enqueueForceUpdate: function (publicInstance, callback, callerName) {
      warnNoop(publicInstance, 'forceUpdate');
    },

    /**
     * Replaces all of the state. Always use this or `setState` to mutate state.
     * You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} completeState Next state.
     * @param {?function} callback Called after component is updated.
     * @param {?string} callerName name of the calling function in the public API.
     * @internal
     */
    enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
      warnNoop(publicInstance, 'replaceState');
    },

    /**
     * Sets a subset of the state. This only exists because _pendingState is
     * internal. This provides a merging strategy that is not available to deep
     * properties which is confusing. TODO: Expose pendingState or don't use it
     * during the merge.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} partialState Next partial state to be merged with state.
     * @param {?function} callback Called after component is updated.
     * @param {?string} Name of the calling function in the public API.
     * @internal
     */
    enqueueSetState: function (publicInstance, partialState, callback, callerName) {
      warnNoop(publicInstance, 'setState');
    }
  };

  /**
   * Base class helpers for the updating state of a component.
   */
  function Component(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    // We initialize the default updater but the real one gets injected by the
    // renderer.
    this.updater = updater || ReactNoopUpdateQueue;
  }

  Component.prototype.isReactComponent = {};

  /**
   * Sets a subset of the state. Always use this to mutate
   * state. You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * There is no guarantee that calls to `setState` will run synchronously,
   * as they may eventually be batched together.  You can provide an optional
   * callback that will be executed when the call to setState is actually
   * completed.
   *
   * When a function is provided to setState, it will be called at some point in
   * the future (not synchronously). It will be called with the up to date
   * component arguments (state, props, context). These values can be different
   * from this.* because your function may be called after receiveProps but before
   * shouldComponentUpdate, and this new state, props, and context will not yet be
   * assigned to this.
   *
   * @param {object|function} partialState Next partial state or function to
   *        produce next partial state to be merged with current state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  Component.prototype.setState = function (partialState, callback) {
    !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
    this.updater.enqueueSetState(this, partialState, callback, 'setState');
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {?function} callback Called after update is complete.
   * @final
   * @protected
   */
  Component.prototype.forceUpdate = function (callback) {
    this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
  };

  /**
   * Deprecated APIs. These APIs used to exist on classic React classes but since
   * we would like to deprecate them, we're not going to move them over to this
   * modern base class. Instead, we define a getter that warns if it's accessed.
   */
  {
    var deprecatedAPIs = {
      isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
      replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
    };
    var defineDeprecationWarning = function (methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
          return undefined;
        }
      });
    };
    for (var fnName in deprecatedAPIs) {
      if (deprecatedAPIs.hasOwnProperty(fnName)) {
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
    }
  }

  /**
   * Base class helpers for the updating state of a component.
   */
  function PureComponent(props, context, updater) {
    // Duplicated from Component.
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    // We initialize the default updater but the real one gets injected by the
    // renderer.
    this.updater = updater || ReactNoopUpdateQueue;
  }

  function ComponentDummy() {}
  ComponentDummy.prototype = Component.prototype;
  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent;
  // Avoid an extra prototype jump for these methods.
  _assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;

  function AsyncComponent(props, context, updater) {
    // Duplicated from Component.
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    // We initialize the default updater but the real one gets injected by the
    // renderer.
    this.updater = updater || ReactNoopUpdateQueue;
  }

  var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
  asyncComponentPrototype.constructor = AsyncComponent;
  // Avoid an extra prototype jump for these methods.
  _assign(asyncComponentPrototype, Component.prototype);
  asyncComponentPrototype.unstable_isAsyncReactComponent = true;
  asyncComponentPrototype.render = function () {
    return this.props.children;
  };

  /**
   * Keeps track of the current owner.
   *
   * The current owner is the component who should own any components that are
   * currently being constructed.
   */
  var ReactCurrentOwner = {
    /**
     * @internal
     * @type {ReactComponent}
     */
    current: null
  };

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var RESERVED_PROPS = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };

  var specialPropKeyWarningShown;
  var specialPropRefWarningShown;

  function hasValidRef(config) {
    {
      if (hasOwnProperty.call(config, 'ref')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }
    return config.ref !== undefined;
  }

  function hasValidKey(config) {
    {
      if (hasOwnProperty.call(config, 'key')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }
    return config.key !== undefined;
  }

  function defineKeyPropWarningGetter(props, displayName) {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;
        warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
      }
    };
    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }

  function defineRefPropWarningGetter(props, displayName) {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;
        warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
      }
    };
    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }

  /**
   * Factory method to create a new React element. This no longer adheres to
   * the class pattern, so do not use new to call it. Also, no instanceof check
   * will work. Instead test $$typeof field against Symbol.for('react.element') to check
   * if something is a React Element.
   *
   * @param {*} type
   * @param {*} key
   * @param {string|object} ref
   * @param {*} self A *temporary* helper to detect places where `this` is
   * different from the `owner` when React.createElement is called, so that we
   * can warn. We want to get rid of owner and replace string `ref`s with arrow
   * functions, and as long as `this` and owner are the same, there will be no
   * change in behavior.
   * @param {*} source An annotation object (added by a transpiler or otherwise)
   * indicating filename, line number, and/or other information.
   * @param {*} owner
   * @param {*} props
   * @internal
   */
  var ReactElement = function (type, key, ref, self, source, owner, props) {
    var element = {
      // This tag allow us to uniquely identify this as a React Element
      $$typeof: REACT_ELEMENT_TYPE,

      // Built-in properties that belong on the element
      type: type,
      key: key,
      ref: ref,
      props: props,

      // Record the component responsible for creating this element.
      _owner: owner
    };

    {
      // The validation flag is currently mutative. We put it on
      // an external backing store so that we can freeze the whole object.
      // This can be replaced with a WeakMap once they are implemented in
      // commonly used development environments.
      element._store = {};

      // To make comparing ReactElements easier for testing purposes, we make
      // the validation flag non-enumerable (where possible, which should
      // include every environment we run tests in), so the test framework
      // ignores it.
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
      if (Object.freeze) {
        Object.freeze(element.props);
        Object.freeze(element);
      }
    }

    return element;
  };

  /**
   * Create and return a new ReactElement of the given type.
   * See https://reactjs.org/docs/react-api.html#createelement
   */
  function createElement(type, config, children) {
    var propName;

    // Reserved names are extracted
    var props = {};

    var key = null;
    var ref = null;
    var self = null;
    var source = null;

    if (config != null) {
      if (hasValidRef(config)) {
        ref = config.ref;
      }
      if (hasValidKey(config)) {
        key = '' + config.key;
      }

      self = config.__self === undefined ? null : config.__self;
      source = config.__source === undefined ? null : config.__source;
      // Remaining properties are added to a new props object
      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          props[propName] = config[propName];
        }
      }
    }

    // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.
    var childrenLength = arguments.length - 2;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }
      {
        if (Object.freeze) {
          Object.freeze(childArray);
        }
      }
      props.children = childArray;
    }

    // Resolve default props
    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;
      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }
    {
      if (key || ref) {
        if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }
          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
      }
    }
    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }

  /**
   * Return a function that produces ReactElements of a given type.
   * See https://reactjs.org/docs/react-api.html#createfactory
   */


  function cloneAndReplaceKey(oldElement, newKey) {
    var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

    return newElement;
  }

  /**
   * Clone and return a new ReactElement using element as the starting point.
   * See https://reactjs.org/docs/react-api.html#cloneelement
   */
  function cloneElement(element, config, children) {
    var propName;

    // Original props are copied
    var props = _assign({}, element.props);

    // Reserved names are extracted
    var key = element.key;
    var ref = element.ref;
    // Self is preserved since the owner is preserved.
    var self = element._self;
    // Source is preserved since cloneElement is unlikely to be targeted by a
    // transpiler, and the original source is probably a better indicator of the
    // true owner.
    var source = element._source;

    // Owner will be preserved, unless ref is overridden
    var owner = element._owner;

    if (config != null) {
      if (hasValidRef(config)) {
        // Silently steal the ref from the parent.
        ref = config.ref;
        owner = ReactCurrentOwner.current;
      }
      if (hasValidKey(config)) {
        key = '' + config.key;
      }

      // Remaining properties override existing props
      var defaultProps;
      if (element.type && element.type.defaultProps) {
        defaultProps = element.type.defaultProps;
      }
      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          if (config[propName] === undefined && defaultProps !== undefined) {
            // Resolve default props
            props[propName] = defaultProps[propName];
          } else {
            props[propName] = config[propName];
          }
        }
      }
    }

    // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.
    var childrenLength = arguments.length - 2;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }
      props.children = childArray;
    }

    return ReactElement(element.type, key, ref, self, source, owner, props);
  }

  /**
   * Verifies the object is a ReactElement.
   * See https://reactjs.org/docs/react-api.html#isvalidelement
   * @param {?object} object
   * @return {boolean} True if `object` is a valid component.
   * @final
   */
  function isValidElement(object) {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }

  var ReactDebugCurrentFrame = {};

  {
    // Component that is being worked on
    ReactDebugCurrentFrame.getCurrentStack = null;

    ReactDebugCurrentFrame.getStackAddendum = function () {
      var impl = ReactDebugCurrentFrame.getCurrentStack;
      if (impl) {
        return impl();
      }
      return null;
    };
  }

  var SEPARATOR = '.';
  var SUBSEPARATOR = ':';

  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */
  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = ('' + key).replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });

    return '$' + escapedString;
  }

  /**
   * TODO: Test that a single child and an array with one item have the same key
   * pattern.
   */

  var didWarnAboutMaps = false;

  var userProvidedKeyEscapeRegex = /\/+/g;
  function escapeUserProvidedKey(text) {
    return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
  }

  var POOL_SIZE = 10;
  var traverseContextPool = [];
  function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
    if (traverseContextPool.length) {
      var traverseContext = traverseContextPool.pop();
      traverseContext.result = mapResult;
      traverseContext.keyPrefix = keyPrefix;
      traverseContext.func = mapFunction;
      traverseContext.context = mapContext;
      traverseContext.count = 0;
      return traverseContext;
    } else {
      return {
        result: mapResult,
        keyPrefix: keyPrefix,
        func: mapFunction,
        context: mapContext,
        count: 0
      };
    }
  }

  function releaseTraverseContext(traverseContext) {
    traverseContext.result = null;
    traverseContext.keyPrefix = null;
    traverseContext.func = null;
    traverseContext.context = null;
    traverseContext.count = 0;
    if (traverseContextPool.length < POOL_SIZE) {
      traverseContextPool.push(traverseContext);
    }
  }

  /**
   * @param {?*} children Children tree container.
   * @param {!string} nameSoFar Name of the key path so far.
   * @param {!function} callback Callback to invoke with each child found.
   * @param {?*} traverseContext Used to pass information throughout the traversal
   * process.
   * @return {!number} The number of children in this subtree.
   */
  function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
    var type = typeof children;

    if (type === 'undefined' || type === 'boolean') {
      // All of the above are perceived as null.
      children = null;
    }

    var invokeCallback = false;

    if (children === null) {
      invokeCallback = true;
    } else {
      switch (type) {
        case 'string':
        case 'number':
          invokeCallback = true;
          break;
        case 'object':
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_CALL_TYPE:
            case REACT_RETURN_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = true;
          }
      }
    }

    if (invokeCallback) {
      callback(traverseContext, children,
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows.
      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
      return 1;
    }

    var child;
    var nextName;
    var subtreeCount = 0; // Count of children found in the current subtree.
    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        nextName = nextNamePrefix + getComponentKey(child, i);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else {
      var iteratorFn = getIteratorFn(children);
      if (typeof iteratorFn === 'function') {
        {
          // Warn about using Maps as children
          if (iteratorFn === children.entries) {
            warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
            didWarnAboutMaps = true;
          }
        }

        var iterator = iteratorFn.call(children);
        var step;
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else if (type === 'object') {
        var addendum = '';
        {
          addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
        }
        var childrenString = '' + children;
        invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
      }
    }

    return subtreeCount;
  }

  /**
   * Traverses children that are typically specified as `props.children`, but
   * might also be specified through attributes:
   *
   * - `traverseAllChildren(this.props.children, ...)`
   * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
   *
   * The `traverseContext` is an optional argument that is passed through the
   * entire traversal. It can be used to store accumulations or anything else that
   * the callback might find relevant.
   *
   * @param {?*} children Children tree object.
   * @param {!function} callback To invoke upon traversing each child.
   * @param {?*} traverseContext Context for traversal.
   * @return {!number} The number of children in this subtree.
   */
  function traverseAllChildren(children, callback, traverseContext) {
    if (children == null) {
      return 0;
    }

    return traverseAllChildrenImpl(children, '', callback, traverseContext);
  }

  /**
   * Generate a key string that identifies a component within a set.
   *
   * @param {*} component A component that could contain a manual key.
   * @param {number} index Index that is used if a manual key is not provided.
   * @return {string}
   */
  function getComponentKey(component, index) {
    // Do some typechecking here since we call this blindly. We want to ensure
    // that we don't block potential future ES APIs.
    if (typeof component === 'object' && component !== null && component.key != null) {
      // Explicit key
      return escape(component.key);
    }
    // Implicit key determined by the index in the set
    return index.toString(36);
  }

  function forEachSingleChild(bookKeeping, child, name) {
    var func = bookKeeping.func,
        context = bookKeeping.context;

    func.call(context, child, bookKeeping.count++);
  }

  /**
   * Iterates through children that are typically specified as `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#react.children.foreach
   *
   * The provided forEachFunc(child, index) will be called for each
   * leaf child.
   *
   * @param {?*} children Children tree container.
   * @param {function(*, int)} forEachFunc
   * @param {*} forEachContext Context for forEachContext.
   */
  function forEachChildren(children, forEachFunc, forEachContext) {
    if (children == null) {
      return children;
    }
    var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
    traverseAllChildren(children, forEachSingleChild, traverseContext);
    releaseTraverseContext(traverseContext);
  }

  function mapSingleChildIntoContext(bookKeeping, child, childKey) {
    var result = bookKeeping.result,
        keyPrefix = bookKeeping.keyPrefix,
        func = bookKeeping.func,
        context = bookKeeping.context;


    var mappedChild = func.call(context, child, bookKeeping.count++);
    if (Array.isArray(mappedChild)) {
      mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild,
        // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
      }
      result.push(mappedChild);
    }
  }

  function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
    var escapedPrefix = '';
    if (prefix != null) {
      escapedPrefix = escapeUserProvidedKey(prefix) + '/';
    }
    var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
    traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
    releaseTraverseContext(traverseContext);
  }

  /**
   * Maps children that are typically specified as `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#react.children.map
   *
   * The provided mapFunction(child, key, index) will be called for each
   * leaf child.
   *
   * @param {?*} children Children tree container.
   * @param {function(*, int)} func The map function.
   * @param {*} context Context for mapFunction.
   * @return {object} Object containing the ordered map of results.
   */
  function mapChildren(children, func, context) {
    if (children == null) {
      return children;
    }
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, func, context);
    return result;
  }

  /**
   * Count the number of children that are typically specified as
   * `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#react.children.count
   *
   * @param {?*} children Children tree container.
   * @return {number} The number of children.
   */
  function countChildren(children, context) {
    return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
  }

  /**
   * Flatten a children object (typically specified as `props.children`) and
   * return an array with appropriately re-keyed children.
   *
   * See https://reactjs.org/docs/react-api.html#react.children.toarray
   */
  function toArray(children) {
    var result = [];
    mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
    return result;
  }

  /**
   * Returns the first child in a collection of children and verifies that there
   * is only one child in the collection.
   *
   * See https://reactjs.org/docs/react-api.html#react.children.only
   *
   * The current implementation of this function assumes that a single child gets
   * passed without a wrapper, but the purpose of this helper function is to
   * abstract away the particular structure of children.
   *
   * @param {?object} children Child collection structure.
   * @return {ReactElement} The first and only `ReactElement` contained in the
   * structure.
   */
  function onlyChild(children) {
    !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
    return children;
  }

  var describeComponentFrame = function (name, source, ownerName) {
    return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
  };

  function getComponentName(fiber) {
    var type = fiber.type;

    if (typeof type === 'string') {
      return type;
    }
    if (typeof type === 'function') {
      return type.displayName || type.name;
    }
    return null;
  }

  /**
   * ReactElementValidator provides a wrapper around a element factory
   * which validates the props passed to the element. This is intended to be
   * used only in DEV and could be replaced by a static type checker for languages
   * that support it.
   */

  {
    var currentlyValidatingElement = null;

    var propTypesMisspellWarningShown = false;

    var getDisplayName = function (element) {
      if (element == null) {
        return '#empty';
      } else if (typeof element === 'string' || typeof element === 'number') {
        return '#text';
      } else if (typeof element.type === 'string') {
        return element.type;
      } else if (element.type === REACT_FRAGMENT_TYPE) {
        return 'React.Fragment';
      } else {
        return element.type.displayName || element.type.name || 'Unknown';
      }
    };

    var getStackAddendum = function () {
      var stack = '';
      if (currentlyValidatingElement) {
        var name = getDisplayName(currentlyValidatingElement);
        var owner = currentlyValidatingElement._owner;
        stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
      }
      stack += ReactDebugCurrentFrame.getStackAddendum() || '';
      return stack;
    };

    var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
  }

  function getDeclarationErrorAddendum() {
    if (ReactCurrentOwner.current) {
      var name = getComponentName(ReactCurrentOwner.current);
      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }
    return '';
  }

  function getSourceInfoErrorAddendum(elementProps) {
    if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
      var source = elementProps.__source;
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }
    return '';
  }

  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};

  function getCurrentComponentErrorInfo(parentType) {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
      if (parentName) {
        info = '\n\nCheck the top-level render call using <' + parentName + '>.';
      }
    }
    return info;
  }

  /**
   * Warn if the element doesn't have an explicit key assigned to it.
   * This element is in an array. The array could grow and shrink or be
   * reordered. All children that haven't already been validated are required to
   * have a "key" property assigned to it. Error statuses are cached so a warning
   * will only be shown once.
   *
   * @internal
   * @param {ReactElement} element Element that requires a key.
   * @param {*} parentType element's parent's type.
   */
  function validateExplicitKey(element, parentType) {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }
    element._store.validated = true;

    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.
    var childOwner = '';
    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
      // Give the component that originally created this child.
      childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
    }

    currentlyValidatingElement = element;
    {
      warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
    }
    currentlyValidatingElement = null;
  }

  /**
   * Ensure that every element either is passed in a static location, in an
   * array with an explicit keys property defined, or in an object literal
   * with valid key property.
   *
   * @internal
   * @param {ReactNode} node Statically passed child of any type.
   * @param {*} parentType node's parent's type.
   */
  function validateChildKeys(node, parentType) {
    if (typeof node !== 'object') {
      return;
    }
    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];
        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);
      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;
          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }

  /**
   * Given an element, validate that its props follow the propTypes definition,
   * provided by the type.
   *
   * @param {ReactElement} element
   */
  function validatePropTypes(element) {
    var componentClass = element.type;
    if (typeof componentClass !== 'function') {
      return;
    }
    var name = componentClass.displayName || componentClass.name;
    var propTypes = componentClass.propTypes;
    if (propTypes) {
      currentlyValidatingElement = element;
      checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
      currentlyValidatingElement = null;
    } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true;
      warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
    }
    if (typeof componentClass.getDefaultProps === 'function') {
      warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }

  /**
   * Given a fragment, validate that it can only be provided with fragment props
   * @param {ReactElement} fragment
   */
  function validateFragmentProps(fragment) {
    currentlyValidatingElement = fragment;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        if (!VALID_FRAGMENT_PROPS.has(key)) {
          warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (fragment.ref !== null) {
      warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
    }

    currentlyValidatingElement = null;
  }

  function createElementWithValidation(type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      var info = '';
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(props);
      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      info += getStackAddendum() || '';

      warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
    }

    var element = createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }

  function createFactoryWithValidation(type) {
    var validatedFactory = createElementWithValidation.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    {
      Object.defineProperty(validatedFactory, 'type', {
        enumerable: false,
        get: function () {
          lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
          Object.defineProperty(this, 'type', {
            value: type
          });
          return type;
        }
      });
    }

    return validatedFactory;
  }

  function cloneElementWithValidation(element, props, children) {
    var newElement = cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

  var React = {
    Children: {
      map: mapChildren,
      forEach: forEachChildren,
      count: countChildren,
      toArray: toArray,
      only: onlyChild
    },

    Component: Component,
    PureComponent: PureComponent,
    unstable_AsyncComponent: AsyncComponent,

    Fragment: REACT_FRAGMENT_TYPE,

    createElement: createElementWithValidation,
    cloneElement: cloneElementWithValidation,
    createFactory: createFactoryWithValidation,
    isValidElement: isValidElement,

    version: ReactVersion,

    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      ReactCurrentOwner: ReactCurrentOwner,
      // Used by renderers to avoid bundling object-assign twice in UMD bundles:
      assign: _assign
    }
  };

  {
    _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
      // These should not be included in production.
      ReactDebugCurrentFrame: ReactDebugCurrentFrame,
      // Shim for React DOM 16.0.0 which still destructured (but not used) this.
      // TODO: remove in React 17.0.
      ReactComponentTreeHook: {}
    });
  }



  var React$2 = Object.freeze({
    default: React
  });

  var React$3 = ( React$2 && React ) || React$2;

  // TODO: decide on the top-level export form.
  // This is hacky but makes it work with both Rollup and Jest.
  var react = React$3['default'] ? React$3['default'] : React$3;

  module.exports = react;
    })();
  }

  },{"fbjs/lib/emptyFunction":715,"fbjs/lib/emptyObject":716,"fbjs/lib/invariant":721,"fbjs/lib/warning":725,"object-assign":822,"prop-types/checkPropTypes":1254}],1252:[function(require,module,exports){
  /** @license React v16.2.0
   * react.production.min.js
   *
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';var m=require("object-assign"),n=require("fbjs/lib/emptyObject"),p=require("fbjs/lib/emptyFunction"),q="function"===typeof Symbol&&Symbol["for"],r=q?Symbol["for"]("react.element"):60103,t=q?Symbol["for"]("react.call"):60104,u=q?Symbol["for"]("react.return"):60105,v=q?Symbol["for"]("react.portal"):60106,w=q?Symbol["for"]("react.fragment"):60107,x="function"===typeof Symbol&&Symbol.iterator;
  function y(a){for(var b=arguments.length-1,e="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,c=0;c<b;c++)e+="\x26args[]\x3d"+encodeURIComponent(arguments[c+1]);b=Error(e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}
  var z={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function A(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}A.prototype.isReactComponent={};A.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?y("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};A.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
  function B(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}function C(){}C.prototype=A.prototype;var D=B.prototype=new C;D.constructor=B;m(D,A.prototype);D.isPureReactComponent=!0;function E(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}var F=E.prototype=new C;F.constructor=E;m(F,A.prototype);F.unstable_isAsyncReactComponent=!0;F.render=function(){return this.props.children};var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};
  function J(a,b,e){var c,d={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var h=Array(f),l=0;l<f;l++)h[l]=arguments[l+2];d.children=h}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:r,type:a,key:g,ref:k,props:d,_owner:G.current}}function K(a){return"object"===typeof a&&null!==a&&a.$$typeof===r}
  function escape(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var L=/\/+/g,M=[];function N(a,b,e,c){if(M.length){var d=M.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function O(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>M.length&&M.push(a)}
  function P(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case r:case t:case u:case v:g=!0}}if(g)return e(c,a,""===b?"."+Q(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+Q(d,k);g+=P(d,f,e,c)}else if(null===a||"undefined"===typeof a?f=null:(f=x&&a[x]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=
  f.call(a),k=0;!(d=a.next()).done;)d=d.value,f=b+Q(d,k++),g+=P(d,f,e,c);else"object"===d&&(e=""+a,y("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function R(a,b){a.func.call(a.context,b,a.count++)}
  function S(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?T(a,c,e,p.thatReturnsArgument):null!=a&&(K(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(L,"$\x26/")+"/")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function T(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(L,"$\x26/")+"/");b=N(b,g,c,d);null==a||P(a,"",S,b);O(b)}
  var U={Children:{map:function(a,b,e){if(null==a)return a;var c=[];T(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=N(null,null,b,e);null==a||P(a,"",R,b);O(b)},count:function(a){return null==a?0:P(a,"",p.thatReturnsNull,null)},toArray:function(a){var b=[];T(a,b,null,p.thatReturnsArgument);return b},only:function(a){K(a)?void 0:y("143");return a}},Component:A,PureComponent:B,unstable_AsyncComponent:E,Fragment:w,createElement:J,cloneElement:function(a,b,e){var c=m({},a.props),
  d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)H.call(b,h)&&!I.hasOwnProperty(h)&&(c[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)c.children=e;else if(1<h){f=Array(h);for(var l=0;l<h;l++)f[l]=arguments[l+2];c.children=f}return{$$typeof:r,type:a.type,key:d,ref:g,props:c,_owner:k}},createFactory:function(a){var b=J.bind(null,a);b.type=a;return b},
  isValidElement:K,version:"16.2.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:G,assign:m}},V=Object.freeze({default:U}),W=V&&U||V;module.exports=W["default"]?W["default"]:W;

  },{"fbjs/lib/emptyFunction":715,"fbjs/lib/emptyObject":716,"object-assign":822}],1253:[function(require,module,exports){
  'use strict';

  if ("production" === 'production') {
    module.exports = require('./cjs/react.production.min.js');
  } else {
    module.exports = require('./cjs/react.development.js');
  }

  },{"./cjs/react.development.js":1251,"./cjs/react.production.min.js":1252}],1254:[function(require,module,exports){
  arguments[4][824][0].apply(exports,arguments)
  },{"./lib/ReactPropTypesSecret":1255,"dup":824,"fbjs/lib/invariant":721,"fbjs/lib/warning":725}],1255:[function(require,module,exports){
  arguments[4][828][0].apply(exports,arguments)
  },{"dup":828}],1256:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  exports['default'] = applyMiddleware;

  var _compose = require('./compose');

  var _compose2 = _interopRequireDefault(_compose);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /**
   * Creates a store enhancer that applies middleware to the dispatch method
   * of the Redux store. This is handy for a variety of tasks, such as expressing
   * asynchronous actions in a concise manner, or logging every action payload.
   *
   * See `redux-thunk` package as an example of the Redux middleware.
   *
   * Because middleware is potentially asynchronous, this should be the first
   * store enhancer in the composition chain.
   *
   * Note that each middleware will be given the `dispatch` and `getState` functions
   * as named arguments.
   *
   * @param {...Function} middlewares The middleware chain to be applied.
   * @returns {Function} A store enhancer applying the middleware.
   */
  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    return function (createStore) {
      return function (reducer, preloadedState, enhancer) {
        var store = createStore(reducer, preloadedState, enhancer);
        var _dispatch = store.dispatch;
        var chain = [];

        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch(action) {
            return _dispatch(action);
          }
        };
        chain = middlewares.map(function (middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

        return _extends({}, store, {
          dispatch: _dispatch
        });
      };
    };
  }
  },{"./compose":1259}],1257:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports['default'] = bindActionCreators;
  function bindActionCreator(actionCreator, dispatch) {
    return function () {
      return dispatch(actionCreator.apply(undefined, arguments));
    };
  }

  /**
   * Turns an object whose values are action creators, into an object with the
   * same keys, but with every function wrapped into a `dispatch` call so they
   * may be invoked directly. This is just a convenience method, as you can call
   * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
   *
   * For convenience, you can also pass a single function as the first argument,
   * and get a function in return.
   *
   * @param {Function|Object} actionCreators An object whose values are action
   * creator functions. One handy way to obtain it is to use ES6 `import * as`
   * syntax. You may also pass a single function.
   *
   * @param {Function} dispatch The `dispatch` function available on your Redux
   * store.
   *
   * @returns {Function|Object} The object mimicking the original object, but with
   * every action creator wrapped into the `dispatch` call. If you passed a
   * function as `actionCreators`, the return value will also be a single
   * function.
   */
  function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === 'function') {
      return bindActionCreator(actionCreators, dispatch);
    }

    if (typeof actionCreators !== 'object' || actionCreators === null) {
      throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
    }

    var keys = Object.keys(actionCreators);
    var boundActionCreators = {};
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var actionCreator = actionCreators[key];
      if (typeof actionCreator === 'function') {
        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
      }
    }
    return boundActionCreators;
  }
  },{}],1258:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports['default'] = combineReducers;

  var _createStore = require('./createStore');

  var _isPlainObject = require('lodash/isPlainObject');

  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

  var _warning = require('./utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  function getUndefinedStateErrorMessage(key, action) {
    var actionType = action && action.type;
    var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

    return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
  }

  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    var reducerKeys = Object.keys(reducers);
    var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

    if (reducerKeys.length === 0) {
      return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
    }

    if (!(0, _isPlainObject2['default'])(inputState)) {
      return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
    }

    var unexpectedKeys = Object.keys(inputState).filter(function (key) {
      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
    });

    unexpectedKeys.forEach(function (key) {
      unexpectedKeyCache[key] = true;
    });

    if (unexpectedKeys.length > 0) {
      return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
    }
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

      if (typeof initialState === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
      }

      var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
      if (typeof reducer(undefined, { type: type }) === 'undefined') {
        throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
      }
    });
  }

  /**
   * Turns an object whose values are different reducer functions, into a single
   * reducer function. It will call every child reducer, and gather their results
   * into a single state object, whose keys correspond to the keys of the passed
   * reducer functions.
   *
   * @param {Object} reducers An object whose values correspond to different
   * reducer functions that need to be combined into one. One handy way to obtain
   * it is to use ES6 `import * as reducers` syntax. The reducers may never return
   * undefined for any action. Instead, they should return their initial state
   * if the state passed to them was undefined, and the current state for any
   * unrecognized action.
   *
   * @returns {Function} A reducer function that invokes every reducer inside the
   * passed object, and builds a state object with the same shape.
   */
  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};
    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      if ("production" !== 'production') {
        if (typeof reducers[key] === 'undefined') {
          (0, _warning2['default'])('No reducer provided for key "' + key + '"');
        }
      }

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }
    var finalReducerKeys = Object.keys(finalReducers);

    var unexpectedKeyCache = void 0;
    if ("production" !== 'production') {
      unexpectedKeyCache = {};
    }

    var shapeAssertionError = void 0;
    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination() {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var action = arguments[1];

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      if ("production" !== 'production') {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
        if (warningMessage) {
          (0, _warning2['default'])(warningMessage);
        }
      }

      var hasChanged = false;
      var nextState = {};
      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);
        if (typeof nextStateForKey === 'undefined') {
          var errorMessage = getUndefinedStateErrorMessage(_key, action);
          throw new Error(errorMessage);
        }
        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      return hasChanged ? nextState : state;
    };
  }
  },{"./createStore":1260,"./utils/warning":1262,"lodash/isPlainObject":766}],1259:[function(require,module,exports){
  "use strict";

  exports.__esModule = true;
  exports["default"] = compose;
  /**
   * Composes single-argument functions from right to left. The rightmost
   * function can take multiple arguments as it provides the signature for
   * the resulting composite function.
   *
   * @param {...Function} funcs The functions to compose.
   * @returns {Function} A function obtained by composing the argument functions
   * from right to left. For example, compose(f, g, h) is identical to doing
   * (...args) => f(g(h(...args))).
   */

  function compose() {
    for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }

    if (funcs.length === 1) {
      return funcs[0];
    }

    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(undefined, arguments));
      };
    });
  }
  },{}],1260:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.ActionTypes = undefined;
  exports['default'] = createStore;

  var _isPlainObject = require('lodash/isPlainObject');

  var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

  var _symbolObservable = require('symbol-observable');

  var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */
  var ActionTypes = exports.ActionTypes = {
    INIT: '@@redux/INIT'

    /**
     * Creates a Redux store that holds the state tree.
     * The only way to change the data in the store is to call `dispatch()` on it.
     *
     * There should only be a single store in your app. To specify how different
     * parts of the state tree respond to actions, you may combine several reducers
     * into a single reducer function by using `combineReducers`.
     *
     * @param {Function} reducer A function that returns the next state tree, given
     * the current state tree and the action to handle.
     *
     * @param {any} [preloadedState] The initial state. You may optionally specify it
     * to hydrate the state from the server in universal apps, or to restore a
     * previously serialized user session.
     * If you use `combineReducers` to produce the root reducer function, this must be
     * an object with the same shape as `combineReducers` keys.
     *
     * @param {Function} [enhancer] The store enhancer. You may optionally specify it
     * to enhance the store with third-party capabilities such as middleware,
     * time travel, persistence, etc. The only store enhancer that ships with Redux
     * is `applyMiddleware()`.
     *
     * @returns {Store} A Redux store that lets you read the state, dispatch actions
     * and subscribe to changes.
     */
  };function createStore(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error('Expected the enhancer to be a function.');
      }

      return enhancer(createStore)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }

    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */
    function getState() {
      return currentState;
    }

    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */
    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected listener to be a function.');
      }

      var isSubscribed = true;

      ensureCanMutateNextListeners();
      nextListeners.push(listener);

      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        isSubscribed = false;

        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
      };
    }

    /**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing “what changed”. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */
    function dispatch(action) {
      if (!(0, _isPlainObject2['default'])(action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }

      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }

      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;
      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }

    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error('Expected the nextReducer to be a function.');
      }

      currentReducer = nextReducer;
      dispatch({ type: ActionTypes.INIT });
    }

    /**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */
    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe(observer) {
          if (typeof observer !== 'object') {
            throw new TypeError('Expected the observer to be an object.');
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return { unsubscribe: unsubscribe };
        }
      }, _ref[_symbolObservable2['default']] = function () {
        return this;
      }, _ref;
    }

    // When a store is created, an "INIT" action is dispatched so that every
    // reducer returns their initial state. This effectively populates
    // the initial state tree.
    dispatch({ type: ActionTypes.INIT });

    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[_symbolObservable2['default']] = observable, _ref2;
  }
  },{"lodash/isPlainObject":766,"symbol-observable":1297}],1261:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

  var _createStore = require('./createStore');

  var _createStore2 = _interopRequireDefault(_createStore);

  var _combineReducers = require('./combineReducers');

  var _combineReducers2 = _interopRequireDefault(_combineReducers);

  var _bindActionCreators = require('./bindActionCreators');

  var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

  var _applyMiddleware = require('./applyMiddleware');

  var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

  var _compose = require('./compose');

  var _compose2 = _interopRequireDefault(_compose);

  var _warning = require('./utils/warning');

  var _warning2 = _interopRequireDefault(_warning);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*
  * This is a dummy function to check if the function name has been altered by minification.
  * If the function has been minified and NODE_ENV !== 'production', warn the user.
  */
  function isCrushed() {}

  if ("production" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
    (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
  }

  exports.createStore = _createStore2['default'];
  exports.combineReducers = _combineReducers2['default'];
  exports.bindActionCreators = _bindActionCreators2['default'];
  exports.applyMiddleware = _applyMiddleware2['default'];
  exports.compose = _compose2['default'];
  },{"./applyMiddleware":1256,"./bindActionCreators":1257,"./combineReducers":1258,"./compose":1259,"./createStore":1260,"./utils/warning":1262}],1262:[function(require,module,exports){
  'use strict';

  exports.__esModule = true;
  exports['default'] = warning;
  /**
   * Prints a warning in the console if it exists.
   *
   * @param {String} message The warning message.
   * @returns {void}
   */
  function warning(message) {
    /* eslint-disable no-console */
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    /* eslint-enable no-console */
    try {
      // This error was thrown as a convenience so that if you enable
      // "break on all exceptions" in your console,
      // it would pause the execution at this line.
      throw new Error(message);
      /* eslint-disable no-empty */
    } catch (e) {}
    /* eslint-enable no-empty */
  }
  },{}],1263:[function(require,module,exports){
  /*
  Slick Finder
  */"use strict"

  // Notable changes from Slick.Finder 1.0.x

  // faster bottom -> up expression matching
  // prefers mental sanity over *obsessive compulsive* milliseconds savings
  // uses prototypes instead of objects
  // tries to use matchesSelector smartly, whenever available
  // can populate objects as well as arrays
  // lots of stuff is broken or not implemented

  var parse = require("./parser")

  // utilities

  var index = 0,
      counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
      key = "uid:" + counter

  var uniqueID = function(n, xml){
      if (n === window) return "window"
      if (n === document) return "document"
      if (n === document.documentElement) return "html"

      if (xml) {
          var uid = n.getAttribute(key)
          if (!uid) {
              uid = (index++).toString(36)
              n.setAttribute(key, uid)
          }
          return uid
      } else {
          return n[key] || (n[key] = (index++).toString(36))
      }
  }

  var uniqueIDXML = function(n) {
      return uniqueID(n, true)
  }

  var isArray = Array.isArray || function(object){
      return Object.prototype.toString.call(object) === "[object Array]"
  }

  // tests

  var uniqueIndex = 0;

  var HAS = {

      GET_ELEMENT_BY_ID: function(test, id){
          id = "slick_" + (uniqueIndex++);
          // checks if the document has getElementById, and it works
          test.innerHTML = '<a id="' + id + '"></a>'
          return !!this.getElementById(id)
      },

      QUERY_SELECTOR: function(test){
          // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
          test.innerHTML = '_<style>:nth-child(2){}</style>'

          // checks if the document has querySelectorAll, and it works
          test.innerHTML = '<a class="MiX"></a>'

          return test.querySelectorAll('.MiX').length === 1
      },

      EXPANDOS: function(test, id){
          id = "slick_" + (uniqueIndex++);
          // checks if the document has elements that support expandos
          test._custom_property_ = id
          return test._custom_property_ === id
      },

      // TODO: use this ?

      // CHECKED_QUERY_SELECTOR: function(test){
      //
      //     // checks if the document supports the checked query selector
      //     test.innerHTML = '<select><option selected="selected">a</option></select>'
      //     return test.querySelectorAll(':checked').length === 1
      // },

      // TODO: use this ?

      // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
      //
      //     // checks if the document supports the empty attribute query selector
      //     test.innerHTML = '<a class=""></a>'
      //     return test.querySelectorAll('[class*=""]').length === 1
      // },

      MATCHES_SELECTOR: function(test){

          test.className = "MiX"

          // checks if the document has matchesSelector, and we can use it.

          var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

          // if matchesSelector trows errors on incorrect syntax we can use it
          if (matches) try {
              matches.call(test, ':slick')
          } catch(e){
              // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
              return matches.call(test, ".MiX") ? matches : false
          }

          return false
      },

      GET_ELEMENTS_BY_CLASS_NAME: function(test){
          test.innerHTML = '<a class="f"></a><a class="b"></a>'
          if (test.getElementsByClassName('b').length !== 1) return false

          test.firstChild.className = 'b'
          if (test.getElementsByClassName('b').length !== 2) return false

          // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
          test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
          if (test.getElementsByClassName('a').length !== 2) return false

          // tests passed
          return true
      },

      // no need to know

      // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
      //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
      //     return this.getElementById(id) !== test.firstChild
      // },

      // this is always checked for and fixed

      // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
      //
      //     // IE returns comment nodes for getElementsByTagName('*') for some documents
      //     test.appendChild(this.createComment(''))
      //     if (test.getElementsByTagName('*').length > 0) return false
      //
      //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
      //     test.innerHTML = 'foo</foo>'
      //     if (test.getElementsByTagName('*').length) return false
      //
      //     // tests passed
      //     return true
      // },

      // this is always checked for and fixed

      // STAR_QUERY_SELECTOR: function(test){
      //
      //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
      //     test.innerHTML = 'foo</foo>'
      //     return !!(test.querySelectorAll('*').length)
      // },

      GET_ATTRIBUTE: function(test){
          // tests for working getAttribute implementation
          var shout = "fus ro dah"
          test.innerHTML = '<a class="' + shout + '"></a>'
          return test.firstChild.getAttribute('class') === shout
      }

  }

  // Finder

  var Finder = function Finder(document){

      this.document        = document
      var root = this.root = document.documentElement
      this.tested          = {}

      // uniqueID

      this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

      // getAttribute

      this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

          return node.getAttribute(name)

      } : function(node, name){

          node = node.getAttributeNode(name)
          return (node && node.specified) ? node.value : null

      }

      // hasAttribute

      this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

          return node.hasAttribute(attribute)

      } : function(node, attribute) {

          node = node.getAttributeNode(attribute)
          return !!(node && node.specified)

      }

      // contains

      this.contains = (document.contains && root.contains) ? function(context, node){

          return context.contains(node)

      } : (root.compareDocumentPosition) ? function(context, node){

          return context === node || !!(context.compareDocumentPosition(node) & 16)

      } : function(context, node){

          do {
              if (node === context) return true
          } while ((node = node.parentNode))

          return false
      }

      // sort
      // credits to Sizzle (http://sizzlejs.com/)

      this.sorter = (root.compareDocumentPosition) ? function(a, b){

          if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
          return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

      } : ('sourceIndex' in root) ? function(a, b){

          if (!a.sourceIndex || !b.sourceIndex) return 0
          return a.sourceIndex - b.sourceIndex

      } : (document.createRange) ? function(a, b){

          if (!a.ownerDocument || !b.ownerDocument) return 0
          var aRange = a.ownerDocument.createRange(),
              bRange = b.ownerDocument.createRange()

          aRange.setStart(a, 0)
          aRange.setEnd(a, 0)
          bRange.setStart(b, 0)
          bRange.setEnd(b, 0)
          return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

      } : null

      this.failed = {}

      var nativeMatches = this.has("MATCHES_SELECTOR")

      if (nativeMatches) this.matchesSelector = function(node, expression){

          if (this.failed[expression]) return null

          try {
              return nativeMatches.call(node, expression)
          } catch(e){
              if (slick.debug) console.warn("matchesSelector failed on " + expression)
              this.failed[expression] = true
              return null
          }

      }

      if (this.has("QUERY_SELECTOR")){

          this.querySelectorAll = function(node, expression){

              if (this.failed[expression]) return true

              var result, _id, _expression, _combinator, _node


              // non-document rooted QSA
              // credits to Andrew Dupont

              if (node !== this.document){

                  _combinator = expression[0].combinator

                  _id         = node.getAttribute("id")
                  _expression = expression

                  if (!_id){
                      _node = node
                      _id = "__slick__"
                      _node.setAttribute("id", _id)
                  }

                  expression = "#" + _id + " " + _expression


                  // these combinators need a parentNode due to how querySelectorAll works, which is:
                  // finding all the elements that match the given selector
                  // then filtering by the ones that have the specified element as an ancestor
                  if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                      node = node.parentNode
                      if (!node) result = true
                      // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                  }

              }

              if (!result) try {
                  result = node.querySelectorAll(expression.toString())
              } catch(e){
                  if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                  result = this.failed[_expression || expression] = true
              }

              if (_node) _node.removeAttribute("id")

              return result

          }

      }

  }

  Finder.prototype.has = function(FEATURE){

      var tested        = this.tested,
          testedFEATURE = tested[FEATURE]

      if (testedFEATURE != null) return testedFEATURE

      var root     = this.root,
          document = this.document,
          testNode = document.createElement("div")

      testNode.setAttribute("style", "display: none;")

      root.appendChild(testNode)

      var TEST = HAS[FEATURE], result = false

      if (TEST) try {
          result = TEST.call(document, testNode)
      } catch(e){}

      if (slick.debug && !result) console.warn("document has no " + FEATURE)

      root.removeChild(testNode)

      return tested[FEATURE] = result

  }

  var combinators = {

      " ": function(node, part, push){

          var item, items

          var noId = !part.id, noTag = !part.tag, noClass = !part.classes

          if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
              item = node.getElementById(part.id)

              // return only if id is found, else keep checking
              // might be a tad slower on non-existing ids, but less insane

              if (item && item.getAttribute('id') === part.id){
                  items = [item]
                  noId = true
                  // if tag is star, no need to check it in match()
                  if (part.tag === "*") noTag = true
              }
          }

          if (!items){

              if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                  items = node.getElementsByClassName(part.classList)
                  noClass = true
                  // if tag is star, no need to check it in match()
                  if (part.tag === "*") noTag = true
              } else {
                  items = node.getElementsByTagName(part.tag)
                  // if tag is star, need to check it in match because it could select junk, boho
                  if (part.tag !== "*") noTag = true
              }

              if (!items || !items.length) return false

          }

          for (var i = 0; item = items[i++];)
              if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                  push(item)

          return true

      },

      ">": function(node, part, push){ // direct children
          if ((node = node.firstChild)) do {
              if (node.nodeType == 1 && this.match(node, part)) push(node)
          } while ((node = node.nextSibling))
      },

      "+": function(node, part, push){ // next sibling
          while ((node = node.nextSibling)) if (node.nodeType == 1){
              if (this.match(node, part)) push(node)
              break
          }
      },

      "^": function(node, part, push){ // first child
          node = node.firstChild
          if (node){
              if (node.nodeType === 1){
                  if (this.match(node, part)) push(node)
              } else {
                  combinators['+'].call(this, node, part, push)
              }
          }
      },

      "~": function(node, part, push){ // next siblings
          while ((node = node.nextSibling)){
              if (node.nodeType === 1 && this.match(node, part)) push(node)
          }
      },

      "++": function(node, part, push){ // next sibling and previous sibling
          combinators['+'].call(this, node, part, push)
          combinators['!+'].call(this, node, part, push)
      },

      "~~": function(node, part, push){ // next siblings and previous siblings
          combinators['~'].call(this, node, part, push)
          combinators['!~'].call(this, node, part, push)
      },

      "!": function(node, part, push){ // all parent nodes up to document
          while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
      },

      "!>": function(node, part, push){ // direct parent (one level)
          node = node.parentNode
          if (node !== this.document && this.match(node, part)) push(node)
      },

      "!+": function(node, part, push){ // previous sibling
          while ((node = node.previousSibling)) if (node.nodeType == 1){
              if (this.match(node, part)) push(node)
              break
          }
      },

      "!^": function(node, part, push){ // last child
          node = node.lastChild
          if (node){
              if (node.nodeType == 1){
                  if (this.match(node, part)) push(node)
              } else {
                  combinators['!+'].call(this, node, part, push)
              }
          }
      },

      "!~": function(node, part, push){ // previous siblings
          while ((node = node.previousSibling)){
              if (node.nodeType === 1 && this.match(node, part)) push(node)
          }
      }

  }

  Finder.prototype.search = function(context, expression, found){

      if (!context) context = this.document
      else if (!context.nodeType && context.document) context = context.document

      var expressions = parse(expression)

      // no expressions were parsed. todo: is this really necessary?
      if (!expressions || !expressions.length) throw new Error("invalid expression")

      if (!found) found = []

      var uniques, push = isArray(found) ? function(node){
          found[found.length] = node
      } : function(node){
          found[found.length++] = node
      }

      // if there is more than one expression we need to check for duplicates when we push to found
      // this simply saves the old push and wraps it around an uid dupe check.
      if (expressions.length > 1){
          uniques = {}
          var plush = push
          push = function(node){
              var uid = uniqueID(node)
              if (!uniques[uid]){
                  uniques[uid] = true
                  plush(node)
              }
          }
      }

      // walker

      var node, nodes, part

      main: for (var i = 0; expression = expressions[i++];){

          // querySelector

          // TODO: more functional tests

          // if there is querySelectorAll (and the expression does not fail) use it.
          if (!slick.noQSA && this.querySelectorAll){

              nodes = this.querySelectorAll(context, expression)
              if (nodes !== true){
                  if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                      push(node)
                  }
                  continue main
              }
          }

          // if there is only one part in the expression we don't need to check each part for duplicates.
          // todo: this might be too naive. while solid, there can be expression sequences that do not
          // produce duplicates. "body div" for instance, can never give you each div more than once.
          // "body div a" on the other hand might.
          if (expression.length === 1){

              part = expression[0]
              combinators[part.combinator].call(this, context, part, push)

          } else {

              var cs = [context], c, f, u, p = function(node){
                  var uid = uniqueID(node)
                  if (!u[uid]){
                      u[uid] = true
                      f[f.length] = node
                  }
              }

              // loop the expression parts
              for (var j = 0; part = expression[j++];){
                  f = []; u = {}
                  // loop the contexts
                  for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                  // nothing was found, the expression failed, continue to the next expression.
                  if (!f.length) continue main
                  cs = f // set the contexts for future parts (if any)
              }

              if (i === 0) found = f // first expression. directly set found.
              else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
          }

      }

      if (uniques && found && found.length > 1) this.sort(found)

      return found

  }

  Finder.prototype.sort = function(nodes){
      return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
  }

  // TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

  var pseudos = {


      // TODO: returns different results than qsa empty.

      'empty': function(){
          return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
      },

      'not': function(expression){
          return !slick.matches(this, expression)
      },

      'contains': function(text){
          return (this.innerText || this.textContent || '').indexOf(text) > -1
      },

      'first-child': function(){
          var node = this
          while ((node = node.previousSibling)) if (node.nodeType == 1) return false
          return true
      },

      'last-child': function(){
          var node = this
          while ((node = node.nextSibling)) if (node.nodeType == 1) return false
          return true
      },

      'only-child': function(){
          var prev = this
          while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

          var next = this
          while ((next = next.nextSibling)) if (next.nodeType == 1) return false

          return true
      },

      'first-of-type': function(){
          var node = this, nodeName = node.nodeName
          while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
          return true
      },

      'last-of-type': function(){
          var node = this, nodeName = node.nodeName
          while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
          return true
      },

      'only-of-type': function(){
          var prev = this, nodeName = this.nodeName
          while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
          var next = this
          while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
          return true
      },

      'enabled': function(){
          return !this.disabled
      },

      'disabled': function(){
          return this.disabled
      },

      'checked': function(){
          return this.checked || this.selected
      },

      'selected': function(){
          return this.selected
      },

      'focus': function(){
          var doc = this.ownerDocument
          return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
      },

      'root': function(){
          return (this === this.ownerDocument.documentElement)
      }

  }

  Finder.prototype.match = function(node, bit, noTag, noId, noClass){

      // TODO: more functional tests ?

      if (!slick.noQSA && this.matchesSelector){
          var matches = this.matchesSelector(node, bit)
          if (matches !== null) return matches
      }

      // normal matching

      if (!noTag && bit.tag){

          var nodeName = node.nodeName.toLowerCase()
          if (bit.tag === "*"){
              if (nodeName < "@") return false
          } else if (nodeName != bit.tag){
              return false
          }

      }

      if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

      var i, part

      if (!noClass && bit.classes){

          var className = this.getAttribute(node, "class")
          if (!className) return false

          for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
      }

      var name, value

      if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

          var operator  = part.operator,
              escaped   = part.escapedValue

          name  = part.name
          value = part.value

          if (!operator){

              if (!this.hasAttribute(node, name)) return false

          } else {

              var actual = this.getAttribute(node, name)
              if (actual == null) return false

              switch (operator){
                  case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                  case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                  case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                  case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                  case '='  : if (actual !== value) return false; break
                  case '*=' : if (actual.indexOf(value) === -1) return false; break
                  default   : return false
              }

          }
      }

      if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

          name  = part.name
          value = part.value

          if (pseudos[name]) return pseudos[name].call(node, value)

          if (value != null){
              if (this.getAttribute(node, name) !== value) return false
          } else {
              if (!this.hasAttribute(node, name)) return false
          }

      }

      return true

  }

  Finder.prototype.matches = function(node, expression){

      var expressions = parse(expression)

      if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
          return this.match(node, expressions[0][0])
      }

      // TODO: more functional tests ?

      if (!slick.noQSA && this.matchesSelector){
          var matches = this.matchesSelector(node, expressions)
          if (matches !== null) return matches
      }

      var nodes = this.search(this.document, expression, {length: 0})

      for (var i = 0, res; res = nodes[i++];) if (node === res) return true
      return false

  }

  var finders = {}

  var finder = function(context){
      var doc = context || document
      if (doc.ownerDocument) doc = doc.ownerDocument
      else if (doc.document) doc = doc.document

      if (doc.nodeType !== 9) throw new TypeError("invalid document")

      var uid = uniqueID(doc)
      return finders[uid] || (finders[uid] = new Finder(doc))
  }

  // ... API ...

  var slick = function(expression, context){
      return slick.search(expression, context)
  }

  slick.search = function(expression, context, found){
      return finder(context).search(context, expression, found)
  }

  slick.find = function(expression, context){
      return finder(context).search(context, expression)[0] || null
  }

  slick.getAttribute = function(node, name){
      return finder(node).getAttribute(node, name)
  }

  slick.hasAttribute = function(node, name){
      return finder(node).hasAttribute(node, name)
  }

  slick.contains = function(context, node){
      return finder(context).contains(context, node)
  }

  slick.matches = function(node, expression){
      return finder(node).matches(node, expression)
  }

  slick.sort = function(nodes){
      if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
      return nodes
  }

  slick.parse = parse;

  // slick.debug = true
  // slick.noQSA  = true

  module.exports = slick

  },{"./parser":1265}],1264:[function(require,module,exports){
  (function (global){
  /*
  slick
  */"use strict"

  module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./finder":1263,"./parser":1265}],1265:[function(require,module,exports){
  /*
  Slick Parser
   - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
  */"use strict"

  // Notable changes from Slick.Parser 1.0.x

  // The parser now uses 2 classes: Expressions and Expression
  // `new Expressions` produces an array-like object containing a list of Expression objects
  // - Expressions::toString() produces a cleaned up expressions string
  // `new Expression` produces an array-like object
  // - Expression::toString() produces a cleaned up expression string
  // The only exposed method is parse, which produces a (cached) `new Expressions` instance
  // parsed.raw is no longer present, use .toString()
  // parsed.expression is now useless, just use the indices
  // parsed.reverse() has been removed for now, due to its apparent uselessness
  // Other changes in the Expressions object:
  // - classNames are now unique, and save both escaped and unescaped values
  // - attributes now save both escaped and unescaped values
  // - pseudos now save both escaped and unescaped values

  var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
      unescapeRe = /\\/g

  var escape = function(string){
      // XRegExp v2.0.0-beta-3
      // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
      return (string + "").replace(escapeRe, '\\$1')
  }

  var unescape = function(string){
      return (string + "").replace(unescapeRe, '')
  }

  var slickRe = RegExp(
  /*
  #!/usr/bin/env ruby
  puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
  __END__
      "(?x)^(?:\
        \\s* ( , ) \\s*               # Separator          \n\
      | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
      |      ( \\s+ )                 # CombinatorChildren \n\
      |      ( <unicode>+ | \\* )     # Tag                \n\
      | \\#  ( <unicode>+       )     # ID                 \n\
      | \\.  ( <unicode>+       )     # ClassName          \n\
      |                               # Attribute          \n\
      \\[  \
          \\s* (<unicode1>+)  (?:  \
              \\s* ([*^$!~|]?=)  (?:  \
                  \\s* (?:\
                      ([\"']?)(.*?)\\9 \
                  )\
              )  \
          )?  \\s*  \
      \\](?!\\]) \n\
      |   :+ ( <unicode>+ )(?:\
      \\( (?:\
          (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
      ) \\)\
      )?\
      )"
  */
  "^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
      .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
      .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
      .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
  )

  // Part

  var Part = function Part(combinator){
      this.combinator = combinator || " "
      this.tag = "*"
  }

  Part.prototype.toString = function(){

      if (!this.raw){

          var xpr = "", k, part

          xpr += this.tag || "*"
          if (this.id) xpr += "#" + this.id
          if (this.classes) xpr += "." + this.classList.join(".")
          if (this.attributes) for (k = 0; part = this.attributes[k++];){
              xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
          }
          if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
              xpr += ":" + part.name
              if (part.value) xpr += "(" + part.value + ")"
          }

          this.raw = xpr

      }

      return this.raw
  }

  // Expression

  var Expression = function Expression(){
      this.length = 0
  }

  Expression.prototype.toString = function(){

      if (!this.raw){

          var xpr = ""

          for (var j = 0, bit; bit = this[j++];){
              if (j !== 1) xpr += " "
              if (bit.combinator !== " ") xpr += bit.combinator + " "
              xpr += bit
          }

          this.raw = xpr

      }

      return this.raw
  }

  var replacer = function(
      rawMatch,

      separator,
      combinator,
      combinatorChildren,

      tagName,
      id,
      className,

      attributeKey,
      attributeOperator,
      attributeQuote,
      attributeValue,

      pseudoMarker,
      pseudoClass,
      pseudoQuote,
      pseudoClassQuotedValue,
      pseudoClassValue
  ){

      var expression, current

      if (separator || !this.length){
          expression = this[this.length++] = new Expression
          if (separator) return ''
      }

      if (!expression) expression = this[this.length - 1]

      if (combinator || combinatorChildren || !expression.length){
          current = expression[expression.length++] = new Part(combinator)
      }

      if (!current) current = expression[expression.length - 1]

      if (tagName){

          current.tag = unescape(tagName)

      } else if (id){

          current.id = unescape(id)

      } else if (className){

          var unescaped = unescape(className)

          var classes = current.classes || (current.classes = {})
          if (!classes[unescaped]){
              classes[unescaped] = escape(className)
              var classList = current.classList || (current.classList = [])
              classList.push(unescaped)
              classList.sort()
          }

      } else if (pseudoClass){

          pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

          ;(current.pseudos || (current.pseudos = [])).push({
              type         : pseudoMarker.length == 1 ? 'class' : 'element',
              name         : unescape(pseudoClass),
              escapedName  : escape(pseudoClass),
              value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
              escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
          })

      } else if (attributeKey){

          attributeValue = attributeValue ? escape(attributeValue) : null

          ;(current.attributes || (current.attributes = [])).push({
              operator     : attributeOperator,
              name         : unescape(attributeKey),
              escapedName  : escape(attributeKey),
              value        : attributeValue ? unescape(attributeValue) : null,
              escapedValue : attributeValue ? escape(attributeValue) : null
          })

      }

      return ''

  }

  // Expressions

  var Expressions = function Expressions(expression){
      this.length = 0

      var self = this

      var original = expression, replaced

      while (expression){
          replaced = expression.replace(slickRe, function(){
              return replacer.apply(self, arguments)
          })
          if (replaced === expression) throw new Error(original + ' is an invalid expression')
          expression = replaced
      }
  }

  Expressions.prototype.toString = function(){
      if (!this.raw){
          var expressions = []
          for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
          this.raw = expressions.join(", ")
      }

      return this.raw
  }

  var cache = {}

  var parse = function(expression){
      if (expression == null) return null
      expression = ('' + expression).replace(/^\s+|\s+$/g, '')
      return cache[expression] || (cache[expression] = new Expressions(expression))
  }

  module.exports = parse

  },{}],1266:[function(require,module,exports){

  /**
   * `Batch' constructor
   *
   * @api public
   * @param {Number} max - optional (Default: Infinity)
   */

  module.exports = Batch;
  function Batch (max) {
    if (!(this instanceof Batch)) {
      return new Batch(max);
    }

    var self = this;

    this.m = 0; // max
    this.c = 0; // concurrency
    this.jobs = [];

    this.concurrency(Infinity);
    this.max(max);

    Object.defineProperty(this, 'length', {
      get: function () {
        return self.jobs.length;
      }
    });
  }

  /**
   * Set batch concurrency
   *
   * @api public
   * @param {Number} n
   */

  Batch.prototype.concurrency = function (n) {
    if (n > 0) {
      this.c = n;
    }
    return this;
  };

  /**
   * Set max job limit
   *
   * @api publc
   * @param {Number} n
   */

  Batch.prototype.max = function (n) {
    this.m = 'number' == typeof n && n > 0 ? n : Infinity;
    return this;
  };

  /**
   * Push job onto queue
   *
   * @api publc
   * @param {Function} fn
   */

  Batch.prototype.push = function (fn) {
    if ('function' != typeof fn) {
      throw new TypeError("expecting a function");
    } else if (this.length < this.m) {
      this.jobs.push(fn);
    }
    return this;
  };

  /**
   * Shift job off of queue
   *
   * @api public
   */

  Batch.prototype.shift = function () {
    return this.jobs.shift();
  };

  /**
   * Dequeues all queued jobs
   *
   * @api public
   * @param {Function} done - optional
   */

  Batch.prototype.run = function (done) {
    done = 'function' == typeof done ? done : Function();
    var self = this;
    var c = this.c;
    var i = 0;

    // empty queue
    if (0 == this.length) {
      return done(null);
    }

    function dequeue  () {
      var job = null;
      if (0 == self.length) {
        return false;
      }

      job = self.shift();

      if ('function' != typeof job) {
        return;
      }

      try { job(next); }
      catch (err) {
        done(err)
        return false;
      }

      function next (err) {
        if (err) {
          done(err);
        } else if (self.length) {
          dequeue();
        } else {
          done();
        }
      }
    }

    while (i++ < c) {
      if (false === dequeue()) {
        break;
      }
    }

    return this;
  };

  },{}],1267:[function(require,module,exports){
  /*jslint node: true */

  'use strict';

  var ClientRequest = require('./request').ClientRequest;

  /**
   * An autoincremented id that is used to distinguish Resolver instances.
   *
   * @type {number}
   * @private
   */
  var resolverUID = 0;

  /**
   * A resolver takes a request for a resources and sends it through the
   * transport.
   *
   * @constructs Resolver
   */
  function Resolver() {
    if (!(this instanceof Resolver))
      return new Resolver();

    /**
     * The resolver's id.
     *
     * @type {number}
     * @protected
     */
    this._id = resolverUID++;

    /**
     * An incrementing ID used for tracking requests.
     *
     * @type {number}
     * @protected
     */
    this._requestID = 0;

    /**
     * Storage for the sent request handlers waiting for a response.
     *
     * @type {Object.<string, function>}
     * @protected
     */
    this._handlers = {};
  }
  exports.Resolver = Resolver;

  /**
   * Adds a handler to the internal storage.
   *
   * @param {number} requestID The identifier for the request.
   * @param {ClientRequest} handler The handler for the request.
   * @protected
   */
  Resolver.prototype._addHandler = function(requestID, handler) {
    this._handlers[requestID] = handler;
    return this;
  };

  /**
   * Removes a handler from the internal storage.
   *
   * @param {number} requestID The identifier for the request.
   * @protected
   */
  Resolver.prototype._removeHandler = function(requestID) {
    this._handlers[requestID] = null;
    return this;
  };

  /**
   * Sends a request through the transport.
   *
   * Subclasses of this class need to implement this method.
   *
   * @param {number} requestID The id of the request.
   * @param {Object} data The payload data for the request.
   * @protected
   */
  Resolver.prototype._sendRequest = function(requestID, data) {
    throw new Error('Resolver _sendRequest not implemented.');
  };

  /**
   * Handles a response from the transport.
   *
   * @param {Object} response The response from the transport.
   * @protected
   */
  Resolver.prototype._handleResponse = function(response) {
    throw new Error('Resolver _handleResponse not implemented.');
  };

  /**
   * Dispatches a request handler with some data.
   *
   * @param {number} requestID The request handler to dispatch.
   * @param {Object} data The response data to send back.
   * @protected
   */
  Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
    var handler = this._handlers[requestID];
    if (!handler) return;
    handler._handleResponse(requestType, data);
  };

  /**
   * Resolves a request (represented by the data) through the transport.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  Resolver.prototype._resolve = function(data, onsuccess, onerror) {
    if (!data || !onsuccess || !onerror ||
        typeof onsuccess != 'function' || typeof onerror != 'function')
      throw new TypeError('Invalid argument length for `resolve`.');

    var requestID = ++this._requestID;
    var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

    this._addHandler(requestID, request);

    request.onClose = this._removeHandler.bind(this);
    request.open();

    return request;
  };

  /**
   * Resolves a single request (represented by the data) through the transport.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  Resolver.prototype.resolve = function(data, onsuccess, onerror) {
    throw new Error('Resolver resolve not implemented.');
  };

  /**
   * Resolves a subscription request (represented by the data) through the transport.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
    throw new Error('Resolver subscribe not implemented.');
  };

  },{"./request":1271}],1268:[function(require,module,exports){
  (function (global){
  /*jslint node: true */

  'use strict';

  var defer = require('spotify-deferred');
  var Resolver = require('./bootstrap').Resolver;

  /**
   * A mock resolver for a nodejs environment.
   *
   * This resolver uses regular callbacks as a transport.
   *
   * @constructs Cosmos.MockResolver
   * @extends Cosmos.Resolver
   */
  function MockResolver() {
    if (!(this instanceof MockResolver))
      return new MockResolver();
    Resolver.call(this);

    // rebind the _handleResponse method so that we can reuse it for both
    // addEventListener and removeEventListener
    this._handleResponse = this._handleResponse.bind(this);

    /**
     * The identifier for request messages.
     *
     * @type {string}
     * @protected
     */
    this._requestMessageType = 'cosmos-request';

    /**
     * The identifier for response messages.
     *
     * @type {string}
     * @protected
     */
    this._responseMessageType = 'cosmos-response';

    /**
     * Prefix for the requests ids to prevent clashes
     * with bridge requests in webplayer
     *
     * @type {string}
     * @private
     */
    this._requestIdPrefix = 'cosmos_';

    this._handlersMap = {};

    // attach the handler
    this.attach();
  }
  MockResolver.prototype = new Resolver();
  MockResolver.prototype.constructor = MockResolver;
  exports.MockResolver = MockResolver;

  /**
   * @inheritDoc
   */
  MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
    var self = this;

    var message = {
      type: this._requestMessageType,
      resolver: this._id,
      id: this._requestIdPrefix + requestID,
      name: requestName,
      payload: data.serialize ? data.serialize() : data
    };

    if (!this._handlersMap[data._action]) {
      return;
    }

    if (!this._handlersMap[data._action][data._uri]) {
      return;
    }

    this._handlersMap[data._action][data._uri](data, function (status, resp) {
      message.payload = {
        body: typeof resp !== 'undefined' ? resp : status,
        uri: data._uri,
        status: typeof resp !== 'undefined' ? status : 200
      };
      message.type = self._responseMessageType;

      var response = {
        data: message
      };
      self._handleResponse(response);
    });
  };

  /**
   * @inheritDoc
   */
  MockResolver.prototype._handleResponse = function(response) {
    var data = response.data;
    if (typeof data == 'string') {
      try {
        data = JSON.parse(response.data);
      } catch (e) {
        return;
      }
    }
    if (data.type != this._responseMessageType ||
        data.resolver != this._id ||
        !data.payload) return;
    var id = data.id || '';
    var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
    var requestName = data.name || '';
    if (!requestID || !requestName) return;
    this._dispatchResponse(requestID, requestName, data.payload);
  };

  /**
   * Attaches the resolver so that it could process calls from the window object.
   */
  MockResolver.prototype.attach = function() {
    var win = global.window;
    if (win) {
      win._cosmosRequest = this.resolve.bind(this);
    }
  };

  /**
   * Detaches the resolver so that it doesn't process calls from the window object.
   */
  MockResolver.prototype.detach = function() {
    var win = global.window;
    if (win) {
      delete win._cosmosRequest;
    }
  };

  /**
   * Specific method for the mock resolver to add request handlers
   *
   * @param {string}   method       Type of method (GET, POST, PUT, SUB)
   * @param {string}   uri          Request to handle
   * @param {Function} fn           Function that handles the request
   */
  MockResolver.prototype.addHandler = function(method, uri, fn) {
    if (!this._handlersMap[method]) {
      this._handlersMap[method] = {};
    }

    this._handlersMap[method][uri] = fn;
  };

  /**
   * Specific method for the mock resolver to remove a specific request handler
   *
   * @param {string}   method       Type of method (GET, POST, PUT, SUB)
   * @param {string}   uri          Request to handle
   */
  MockResolver.prototype.removeHandler = function(method, uri) {
    if (!this._handlersMap[method]) {
      return;
    }

    if (this._handlersMap[method][uri]) {
      delete this._handlersMap[method][uri];
    }
  };

  /**
   * Specific method for the mock resolver to remove all handlers
   */
  MockResolver.prototype.clearHandlers = function() {
    this._handlersMap = {};
  };

  /**
   * Resolves a single request (represented by the data) through the transport.
   * Single requests need to be closed immediately after the response is
   * received.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
    function onResult(callback, response) {
      defer(callback.bind(this, response));
      request.close();
    }

    var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
    return request;
  };

  /**
   * Resolves a  subscription request (represented by the data) through the transport.
   * Subscriptions stay open until they're explicitly closed.
   * Every time the request returns some data pull for next
   * batch is sent.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
    return this._resolve(data, onsuccess, onerror);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./bootstrap":1267,"spotify-deferred":1273}],1269:[function(require,module,exports){
  /*jslint node: true */

  'use strict';

  var Resolver = require('./bootstrap').Resolver;
  var defer = require('spotify-deferred');

  /**
   * A resolver for a native environment.
   *
   * This resolver uses the Stitch bridge as a transport
   *
   * @constructs Cosmos.NativeResolver
   * @extends Cosmos.Resolver
   * @param {Object} spBridge Spotify CPP/JS bridge
   */
  function NativeResolver(spBridge) {
    if (!(this instanceof NativeResolver))
      return new NativeResolver();
    if (!spBridge) {
      throw new TypeError('Missing `spBridge` parameter');
    }
    Resolver.call(this);

    this._bridge = spBridge;
  }
  NativeResolver.prototype = new Resolver();
  NativeResolver.prototype.constructor = NativeResolver;
  exports.NativeResolver = NativeResolver;

  /**
   * Defer the function call.
   * TODO: Move to the separate module
   */
  NativeResolver.prototype._defer = function(context, callback) {
    defer(callback.bind(context));
  };

  /**
   * Construct and send Cosmos message.
   */
  NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
    var self = this;
    data = (data.serialize ? data.serialize() : data);

    var args = [requestId, data];
    var caller = { self: this, id: requestId, type: requestName };

    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  };


  /**
   * Talk to bridge directly from Cosmos
   * TODO: Move to the separate module
   */
  NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
    var message = JSON.stringify({
      name: requestName,
      args: args
    });

    this._sendBridgeRequest(message, {
      onSuccess: function(data) {
        onSuccess.call(caller, JSON.parse(data));
      },
      onFailure: function(data) {
        data = JSON.parse(data);
        onError.call(caller, data);
      }
    });
  };

  /**
   * Send message to the bridge
   * @param {string} message The message to send to the bridge.
   * @param {Object.<string, function>} callbackMap The `onSuccess`
   * and `onFailure` functions to be executed after request is completed.
   * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
   */
  NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
    this._bridge.executeRequest(message, callbackMap || {});
  };

  /**
   * Handles successful responses from the bridge
   * @param {Object} data The response data.
   */
  NativeResolver.prototype._handleResponse = function(data) {
    this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
  };

  /**
   * Handles failed responses from the bridge
   * @param {Object} error The error data.
   */
  NativeResolver.prototype._handleError = function(error) {
    this.self._dispatchResponse(this.id, this.type, error);
  };

  /**
   * Resolves a single request (represented by the data) through the transport.
   * Single requests need to be closed immediately after the response is
   * received.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
    function onResult(callback, response) {
      this._defer(this, callback.bind(this, response));
      request.close();
    }

    var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
    return request;
  };

  /**
   * Resolves a  subscription request (represented by the data) through the transport.
   * Subscriptions stay open until they're explicitly closed.
   * Every time the request returns some data pull for next
   * batch is sent.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
    function onResult(callback, response) {
      callback.call(this, response);
      request.pull();
    }

    var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
    return request;
  };

  },{"./bootstrap":1267,"spotify-deferred":1273}],1270:[function(require,module,exports){
  (function (global){
  /*jslint node: true */

  'use strict';

  var defer = require('spotify-deferred');
  var Resolver = require('./bootstrap').Resolver;

  /**
   * A resolver for a web-based environment.
   *
   * This resolver uses postMessage as a transport.
   *
   * @constructs Cosmos.WebResolver
   * @extends Cosmos.Resolver
   * @type {string=} opt_target The optional target for the postMessage calls.
   */
  function WebResolver(opt_target) {
    if (!(this instanceof WebResolver))
      return new WebResolver(opt_target);
    Resolver.call(this);

    /**
     * The target for postMessage calls.
     *
     * @type {string}
     * @protected
     */
    this._target = opt_target || '*';

    // rebind the _handleResponse method so that we can reuse it for both
    // addEventListener and removeEventListener
    this._handleResponse = this._handleResponse.bind(this);

    /**
     * The identifier for request messages.
     *
     * @type {string}
     * @protected
     */
    this._requestMessageType = 'cosmos-request';

    /**
     * The identifier for response messages.
     *
     * @type {string}
     * @protected
     */
    this._responseMessageType = 'cosmos-response';

    /**
     * Prefix for the requests ids to prevent clashes
     * with bridge requests in webplayer
     *
     * @type {string}
     * @private
     */
    this._requestIdPrefix = 'cosmos_';

    // attach the handler
    this.attach();
  }
  WebResolver.prototype = new Resolver();
  WebResolver.prototype.constructor = WebResolver;
  exports.WebResolver = WebResolver;

  /**
   * @inheritDoc
   */
  WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
    var top = global.window.top;

    var message = {
      type: this._requestMessageType,
      resolver: this._id,
      id: this._requestIdPrefix + requestID,
      name: requestName,
      payload: data.serialize ? data.serialize() : data
    };
    top.postMessage(JSON.stringify(message), this._target);
  };

  /**
   * @inheritDoc
   */
  WebResolver.prototype._handleResponse = function(response) {
    var data = response.data;
    if (typeof data == 'string') {
      try {
        data = JSON.parse(response.data);
      } catch (e) {
        return;
      }
    }
    if (data.type != this._responseMessageType ||
        data.resolver != this._id ||
        !data.payload) return;
    var id = data.id || '';
    var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
    var requestName = data.name || '';
    if (!requestID || !requestName) return;
    this._dispatchResponse(requestID, requestName, data.payload);
  };

  /**
   * Attaches the resolver so that it could process postMessage calls.
   */
  WebResolver.prototype.attach = function() {
    var win = global.window;
    if (win.addEvent && !win.addEventListener) {
      win.addEvent('onmessage', this._handleResponse);
    } else {
      win.addEventListener('message', this._handleResponse, false);
    }
  };

  /**
   * Detaches the resolver so that it doesn't process postMessage calls.
   */
  WebResolver.prototype.detach = function() {
    var win = global.window;
    if (win.removeEvent && !win.removeEventListener) {
      win.removeEvent('onmessage', this._handleResponse);
    } else {
      win.removeEventListener('message', this._handleResponse, false);
    }
  };

  /**
   * Resolves a single request (represented by the data) through the transport.
   * Single requests need to be closed immediately after the response is
   * received.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
    function onResult(callback, response) {
      defer(callback.bind(this, response));
      request.close();
    }

    var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
    return request;
  };

  /**
   * Resolves a  subscription request (represented by the data) through the transport.
   * Subscriptions stay open until they're explicitly closed.
   * Every time the request returns some data pull for next
   * batch is sent.
   *
   * @param {Object} data The data representing the request.
   * @param {function} onsuccess The success handler for the request.
   * @param {function} onerror The error handler for the request.
   */
  WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
    return this._resolve(data, onsuccess, onerror);
  };

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./bootstrap":1267,"spotify-deferred":1273}],1271:[function(require,module,exports){
  /*jslint node: true */

  'use strict';

  var defer = require('spotify-deferred');

  /**
   * The representation of the connection to the client.
   * With introduction of Cosmos subscription the model of making
   * client requests changed.
   * Each Cosmos requests now needs to be explicitly cancelled to
   * close the connection.
   * Simple requests that only send or retrieve data (e.g POST and GET)
   * need to send 'cosmos_request_cancel' message immediately after the response
   * is received.
   * Subscription requests need to send a 'cosmos_request_pull' message every time
   * they receive data. The consumer of the subscription needs to cancel the subscription
   * when no more data should be sent from the provider.
   */
  function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

    /**
     * Request identifier.
     * @type {number}
     */
    this._requestId = requestId;

    /**
     * Either web or native request resolver.
     * @type {Cosmos.Resolver}
     */
    this._resolver = resolver;

    /**
     * Data that should be passed with every request.
     * @type {*}
     */
    this._requestData = data;

    /**
     * Triggered on success
     * @type {function}
     */
    this._successCallback = onsuccess;

    /**
     * Triggered on error
     * @type {function}
     */
    this._errorCallback = onerror;

    /**
     * Current state of the request.
     * @type {ClientRequest.status}
     */
    this._status = ClientRequest.status.INITIALIZED;
  }
  exports.ClientRequest = ClientRequest;

  /**
   * Possible state of the ClientRequest instance.
   */
  ClientRequest.status = {
    INITIALIZED: 'INITIALIZED',
    CLOSED: 'CLOSED',
    OPEN: 'OPEN'
  };

  /**
   * Possible desktop bridge messages.
   */
  ClientRequest.messages = {
    OPEN: 'cosmos_request_create',
    PULL: 'cosmos_request_pull',
    CLOSE: 'cosmos_request_cancel'
  };

  /**
   * Opens the connection with the client.
   */
  ClientRequest.prototype.open = function() {
    if (this._status === ClientRequest.status.INITIALIZED) {
      this._status = ClientRequest.status.OPEN;
      this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
    }
  };

  /**
   * Send pull request for the open connection.
   * For subscriptions pull should resolve to a
   * piece of data.
   */
  ClientRequest.prototype.pull = function() {
    if (this._status === ClientRequest.status.OPEN) {
      this._sendRequest(ClientRequest.messages.PULL, this._requestData);
    }
    return this._status;
  };

  /**
   * Closes the connection with the client.
   */
  ClientRequest.prototype.close = function() {
    if (this._status === ClientRequest.status.OPEN) {
      this._status = ClientRequest.status.CLOSE;
      this._sendRequest(ClientRequest.messages.CLOSE);
    }
  };

  ClientRequest.prototype.onClose = function() {};

  /**
   * Sends the request to the platform specific resolver
   * @param {string} requestName The message type. One of the {ClientRequest.messages}.
   * @param {object?} data The data to send with the request.
   */
  ClientRequest.prototype._sendRequest = function(requestName, data) {
    this._resolver._sendRequest(requestName, this._requestId, data || {});
  };

  /**
   * Handles the response for the given request
   * @param {String} requestName The message type. One of the {ClientRequest.messages}.
   * @param {Object} data The response data.
   */
  ClientRequest.prototype._handleResponse = function(requestName, data) {
    var self = this;
    var status = data && data.status;
    var callback;

    if (requestName === ClientRequest.messages.CLOSE) {
      this._successCallback = null;
      this._errorCallback = null;
      this._requestData = null;
      this.onClose(this._requestId);
      return;
    }

    callback = this._successCallback;
    callback = typeof callback === 'function' ? callback : function() {};
    defer(callback.bind(this, data));
  };

  },{"spotify-deferred":1273}],1272:[function(require,module,exports){
  (function (global){
  'use strict';

  var window = global.window || {};
  var process = global.process;

  var common = require('cosmos-common-js');
  var Resolver = require('./scripts/resolver').Resolver;

  var SPResolver = null;
  var spResolver = null;

  var hasNativeBridge = window._getSpotifyModule &&
      typeof window._getSpotifyModule === 'function' &&
      window._getSpotifyModule('bridge');

  var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
  var isNodeJs = process && nodeRegex.test(process.argv0);

  if (!isNodeJs) {
    if (hasNativeBridge) {
      SPResolver = require('./env/bootstrap.native.js').NativeResolver;
      spResolver = new SPResolver(hasNativeBridge);
    } else {
      SPResolver = require('./env/bootstrap.web.js').WebResolver;
      spResolver = new SPResolver();
    }
  } else {
    SPResolver = require('./env/bootstrap.mock.js').MockResolver;
    spResolver = new SPResolver();

    exports.mockResolver = {
      addHandler: spResolver.addHandler.bind(spResolver),
      removeHandler: spResolver.removeHandler.bind(spResolver),
      clearHandlers: spResolver.clearHandlers.bind(spResolver)
    };
  }

  exports.Resolver = Resolver;
  exports.Action = common.request.Action;
  exports.Request = common.request.Request;
  exports.Response = common.response.Response;
  exports.resolver = spResolver ? new Resolver(spResolver) : null;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./env/bootstrap.mock.js":1268,"./env/bootstrap.native.js":1269,"./env/bootstrap.web.js":1270,"./scripts/resolver":1274,"cosmos-common-js":699}],1273:[function(require,module,exports){
  (function() {
    /**
     * @file
     * Introduces a function called "defer" that allows functions to be
     * executed in the next available tick.
     *
     * Unlike "setTimeout", "defer" executes the function at the nearest
     * possible time without clamping.
     *
     * @see Spotify.defer
     */
    'use strict';

    var hasWindow = typeof window != 'undefined';
    var hasDefineProperty = typeof Object.defineProperty == 'function';

    if (hasWindow && window.__modDefFn) {
      // If deferred has been attached to the global scope
      module.exports = window.__modDefFn;
      return;
    }

    /**
     * Storage for deferred functions to be executed.
     *
     * @type {Array.<function()>}
     * @private
     */
    var deferred = [];


    /**
     * A bound version of the postMessage routine used to trigger deferred
     * execution.
     *
     * @type {function()}
     * @private
     */
    var send;
    var origin;

    if (hasWindow && window.postMessage) {
      origin = (window.location.origin ||
            window.location.protocol + '//' + window.location.hostname);
      send = window.postMessage.bind(window, '@execute_deferreds', origin);
      if (!window.__hasDeferredHandler) {
        if (hasDefineProperty) {
          Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
        } else {
          window.__hasDeferredHandler = 1;
        }
        var handler = function(e) {
          if (e.origin != origin && e.data != '@execute_deferreds') {
            return;
          }
          executeDeferreds();
        };
        if (window.addEventListener) {
          window.addEventListener('message', handler);
        } else {
          window.attachEvent('onmessage', handler);
        }
      }
    } else if (typeof setImmediate != 'undefined') {
      send = setImmediate.bind(null, executeDeferreds);
    } else {
      send = setTimeout.bind(null, executeDeferreds, 10);
    }


    /**
     * Executes the deferred functions when the window
     * receives an 'execute_deferreds' message.
     *
     * @private
     */
    function executeDeferreds() {
      var fns = deferred.splice(0);
      if (!fns.length) return;
      for (var i = 0, l = fns.length; i < l; i++) {
        try {
          fns[i]();
        } finally {
          // Do nothing.
          null;
        }
      }
    }


    /**
     * Executes the function applied at the nearest possible time without
     * clamping.
     *
     * @param {function()} fn The function to execute.
     */
    var defer = function(fn) {
      var trigger = !deferred.length;
      deferred.push(fn);
      if (trigger) send();
    };

    if (hasWindow && !window.__modDefFn) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__modDefFn', {value: defer});
      } else {
        window.__modDefFn = defer;
      }
    }

    /**
     * Export public interface
     */
    module.exports = defer;

  })();

  },{}],1274:[function(require,module,exports){
  var common = require('cosmos-common-js');

  var Request = common.request.Request;
  var Action = common.request.Action;
  var Response = common.response.Response;

  /**
   * Checks whether a status is successful.
   *
   * We define a successful status to be something within the 200 to 299 range.
   *
   * @param {number} status The status to check.
   */
  function _isSuccessStatus(status) {
    // This constitutes a successfull status.
    return (status >= 200 && status <= 299);
  };


  function Resolver(spResolver) {
    if (!spResolver || typeof spResolver.resolve !== 'function') {
      throw TypeError('Incorrect resolver argument');
    }

    this._resolver = spResolver;
  }

  /**
   * The basic, generic method of sending the requests.
   *
   * For params description:
   * @borrows Resolver#_resolve as Resolver#resolve
   */
  Resolver.prototype.resolve = function(request, callback) {
    return this._resolve(request, callback);
  };

  /**
   * Convenience method for doing GET requests.
   * resolver.get('sp://player') is an equivalent of
   * resolver.resolve(new Request('GET', 'sp://player')).
   *
   * @param {string|Object.<string, object>} options If is a string
   * will be parsed as url. If more data is needed, object notation
   * should be used.
   *  param options.url {string} The url of the request.
   *  param options.body {object=} The request body.
   *  param options.headers {object=} The request headers.
   * @param {function(error=, object?)} callback The function
   * executed after the request has been completed.
   *
   * @return {RequestHandler} The cancellable request handler.
   */
  Resolver.prototype.get = function(options, callback) {
    return this._resolveFromParams(Action.GET, options, callback);
  };

  /**
   * Convenience method for doing POST requests.
   * resolver.post('sp://player') is an equivalent of
   * resolver.resolve(new Request('POST', 'sp://player'))
   *
   * @see Resolver#get for params description and returned value.
   */
  Resolver.prototype.post = function(options, callback) {
    return this._resolveFromParams(Action.POST, options, callback);
  };

  /**
   * Convenience method for doing SUB requests.
   * resolver.subscribe('sp://player') is an equivalent of
   * resolver.resolve(new Request('SUB', 'sp://player'))
   *
   * @see Resolver#get for params description and returned value.
   */
  Resolver.prototype.subscribe = function(options, callback) {
    return this._resolveFromParams(Action.SUB, options, callback);
  };

  /**
   * Convenience method for doing PUT requests.
   * resolver.put('sp://ads/v1/settings/session') is an equivalent of
   * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
   *
   * @see Resolver#get for params description and returned value.
   */
  Resolver.prototype.put = function(options, callback) {
    return this._resolveFromParams(Action.PUT, options, callback);
  };

  /**
   * Convenience method for doing PATCH requests.
   * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
   * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
   *
   * @see Resolver#get for params description and returned value.
   */
  Resolver.prototype.patch = function(options, callback) {
    return this._resolveFromParams(Action.PATCH, options, callback);
  };

  /**
   * Convenience method for doing DELETE requests.
   * resolver.delete('sp://player') is an equivalent of
   * resolver.resolve(new Request('DELETE', 'sp://player'))
   *
   * @see Resolver#get for params description and returned value.
   */
  Resolver.prototype.delete = function(options, callback) {
    return this._resolveFromParams(Action.DELETE, options, callback);
  };

  /**
   * @private
   * Sends the request to the platform specific request resolver.
   * If the request action is 'SUB' it will send subscribe request
   * In any other case it will send simple resolve request.
   *
   * @param {Cosmos.Request} request A request object.
   * @param {function(error=, object?)} callback The function
   * executed after the request has been completed.
   *
   * @return {RequestHandler} The cancellable request handler.
   */
  Resolver.prototype._resolve = function(request, callback) {
    if (!callback || typeof callback !== 'function') {
      callback = function() {};
    }

    var requestHandler;

    function onSuccess(serverResponse) {
      if (!requestHandler._request) {
        return;
      }

      var response = Response.fromObject(serverResponse);
      if (!response) {
        var error = new Error(
          'Failed to parse response: ' + JSON.stringify(serverResponse));
        return callback(error);
      }

      if (_isSuccessStatus(response.getStatusCode())) {
        return callback(null, response);
      } else {
        // Extract just the initial part of the request uri. It's good to have something
        // but it is also good to avoid having everything, since that can hurt dashboards
        // that group error messages.
        var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
        var errorMessage = (
          response.getHeader("error") ||
          "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
        var error = new Error(errorMessage);
        error.response = response;
        return callback(error, response);
      }
    }

    function onError(serverResponse) {
      return callback(serverResponse instanceof Error ?
        serverResponse :
        new Error('Request failed: ' + JSON.stringify(serverResponse)));
    }

    var resolveFn = request.getAction() === Action.SUB ?
        this._resolver.subscribe : this._resolver.resolve;

    var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

    requestHandler = new RequestHandler(clientRequest);
    return requestHandler;
  };

  /**
   * @private
   * Creates Request object from supplied params.
   * @param {string} method Request method. One of the Request.Action.
   * @param {string|Object.<string, object>} options If is a string
   * will be parsed as url. If more data is needed, object notation
   * should be used.
   *  param options.url {string} The url of the request.
   *  param options.body {object=} The request body.
   *  param options.headers {object=} The request headers.
   * @param {function(error=, object?)} callback The function
   * executed after the request has been completed.
   *
   * @return {RequestHandler} The cancellable request handler.
   */
  Resolver.prototype._resolveFromParams = function(method, options, callback) {
    options = options || {};

    var url = typeof options === 'string' ? options : options.url;
    var headers = options.headers;
    var body = options.body;

    var request = new Request(method, url, headers, body);

    return this._resolve(request, callback);
  };

  /**
   * The object that wraps the clientRequest
   * in a very simple interface.
   * Separates the implementation of the ClientRequest
   * from the request handler returned by Cosmos API.
   *
   * @param {Cosmos.ClientRequest} request The object
   * representing the newly opened request to the client.
   * Usually a request will be a subscription that
   * needs a close handler.
   */
  function RequestHandler(request) {
    if (!request || typeof request.close !== 'function')
      throw new TypeError('Invalid `request` argument.');

    this._request = request;
  }

  /**
   * Closes the request and removes the object.
   */
  RequestHandler.prototype.cancel = function() {
    if (this._request) {
      this._request.close();
      this._request = null;
    }
  };

  exports.Resolver = Resolver;

  },{"cosmos-common-js":699}],1275:[function(require,module,exports){
  (function() {
    /**
     * @file
     * Introduces a function called "defer" that allows functions to be
     * executed in the next available tick.
     *
     * Unlike "setTimeout", "defer" executes the function at the nearest
     * possible time without clamping.
     *
     * @see Spotify.defer
     */
    'use strict';

    var hasWindow = typeof window != 'undefined';
    var hasDefineProperty = typeof Object.defineProperty == 'function';

    if (hasWindow && window.__modDefFn) {
      // If deferred has been attached to the global scope
      module.exports = window.__modDefFn;
      return;
    }

    /**
     * Storage for deferred functions to be executed.
     *
     * @type {Array.<function()>}
     * @private
     */
    var deferred = [];


    /**
     * A bound version of the postMessage routine used to trigger deferred
     * execution.
     *
     * @type {function()}
     * @private
     */
    var send;
    var origin;

    function bindSendDom() {
      origin = (window.location.origin ||
            window.location.protocol + '//' + window.location.hostname);
      send = window.postMessage.bind(window, '@execute_deferreds', origin);
      if (!window.__hasDeferredHandler) {
        if (hasDefineProperty) {
          Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
        } else {
          window.__hasDeferredHandler = 1;
        }
        var handler = function(e) {
          if (e.origin != origin && e.data != '@execute_deferreds') {
            return;
          }
          executeDeferreds();
        };
        if (window.addEventListener) {
          window.addEventListener('message', handler);
        } else {
          window.attachEvent('onmessage', handler);
        }
      }
    }

    function bindSendImmediate() {
      send = setImmediate.bind(null, executeDeferreds);
    }

    function bindSendTimeout() {
      send = setTimeout.bind(null, executeDeferreds, 10);
    }

    function bindSendAuto() {
      if (hasWindow && window.postMessage) {
        bindSendDom();
      } else if (typeof setImmediate != 'undefined') {
        bindSendImmediate();
      } else {
        bindSendTimeout();
      }
    }

    bindSendAuto();

    /**
     * Executes the deferred functions when the window
     * receives an 'execute_deferreds' message.
     *
     * @private
     */
    function executeDeferreds() {
      var fns = deferred.splice(0);
      if (!fns.length) return;
      for (var i = 0, l = fns.length; i < l; i++) {
        try {
          fns[i]();
        } finally {
          // Do nothing.
          null;
        }
      }
    }


    /**
     * Executes the function applied at the nearest possible time without
     * clamping.
     *
     * @param {function()} fn The function to execute.
     */
    var defer = function(fn) {
      var trigger = !deferred.length;
      deferred.push(fn);
      if (trigger) send();
    };

    if (hasWindow && !window.__modDefFn) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__modDefFn', {value: defer});
      } else {
        window.__modDefFn = defer;
      }
    }

    /**
     * Export interface for binding send method to a particular implementation,
     * which is intended primarily for use by integration tests where the send method
     * can be explicitly set to immediate/timeout, even if mock DOM globals exist.
     */
    defer.use = {
      auto: bindSendAuto,
      dom: bindSendDom,
      immediate: bindSendImmediate,
      timeout: bindSendTimeout,
    };

    /**
     * Export public interface
     */
    module.exports = defer;

  })();

  },{}],1276:[function(require,module,exports){
  arguments[4][1273][0].apply(exports,arguments)
  },{"dup":1273}],1277:[function(require,module,exports){
  /**
   * @module spotify-eventemitter
   */
  'use strict';

  /**
   * @private
   */
  var _defer = require('spotify-deferred');

  /**
   * The event handlers.
   *
   * @typedef {Array.<function>}
   * @private
   */
  var EventHandlers;

  /**
   * Represents an Event.
   *
   * **NOTE**: The Event class is an internal class: you cannot instantiate it
   * directly. Instead, you should use the provided
   * {@link module:spotify-eventemitter.createEvent} function.
   *
   * @constructor
   * @param {string} type The type name of the event object.
   * @param {Object} props An object that will be added as properties of the
   *     event object.
   * @see {@link module:spotify-eventemitter.createEvent}
   */
  function Event(type, props) {
    /**
     * The type of the event.
     *
     * @type {string}
     */
    this.type = type;

    /**
     * A flag for whether preventDefault was called.
     *
     * @type {boolean}
     * @private
     */
    this._prevented = false;

    /**
     * A flag for whether stopPropagation was called
     *
     * @type {boolean}
     * @private
     */
    this._stopped = false;

    /**
     * A flag for whether stopImmediatePropagation was called.
     *
     * @type {boolean}
     * @private
     */
    this._immediateStopped = false;

    if (props) {
      for (var key in props) {
        if (key == 'type') {
          continue;
        }
        this[key] = props[key];
      }
    }
  }

  /**
   * Prevents the default operation for the event.
   */
  Event.prototype.preventDefault = function() {
    this._prevented = true;
  };

  /**
   * Returns whether preventDefault was called on the event.
   *
   * @return {boolean} True if preventDefault was called, false otherwise.
   */
  Event.prototype.isDefaultPrevented = function() {
    return this._prevented;
  };

  /**
   * Stops the propagation of the event.
   */
  Event.prototype.stopPropagation = function() {
    this._stopped = true;
  };

  /**
   * Returns whether stopPropagation was called on the event.
   *
   * @return {boolean} True if stopPropagation was called, false otherwise.
   */
  Event.prototype.isPropagationStopped = function() {
    return this._stopped;
  };

  /**
   * Stops the immediate propagation of the event.
   *
   * Handlers added after any event handler calling this method will not receive
   * the event.
   */
  Event.prototype.stopImmediatePropagation = function() {
    this._immediateStopped = true;
  };

  /**
   * Returns whether stopImmediatePropagation was called on the event.
   *
   * @return {boolean} True if stopImmediatePropagation was called, false
   *     otherwise.
   */
  Event.prototype.isImmediatePropagationStopped = function() {
    return this._immediateStopped;
  };

  /**
   * An EventEmitter is an object that can be listened to for events.
   *
   * Instances of this class are not usually used directly; instead, a class that
   * needs EventEmitter functionality would inherit from the EventEmitter class
   * so that it's instances can use events.
   *
   * @constructor
   * @alias module:spotify-eventemitter
   *
   * @example <caption>Direct usage</caption>
   * var EventEmitter = require('spotify-eventemitter');
   * var emitter = new EventEmitter();
   * emitter.addListener('someEvent', function() {
   *     console.log('someEvent fired!');
   * });
   * emitter.emit('someEvent');
   * @example <caption>Inheritance</caption>
   * var EventEmitter = require('spotify-eventemitter');
   * var inherit = require('spotify-inherit/inherit');
   *
   * function MyClass() {
   *   EventEmitter.call(this);
   * }
   * inherit(MyClass, EventEmitter);
   *
   * var instance = new MyClass();
   * instance.addListener('someEvent', function() {
   *     console.log('someEvent fired!');
   * });
   * instance.emit('someEvent');
   */
  function EventEmitter() {
    /**
     * A map of event names to event handlers.
     *
     * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
     * @private
     */
    this._listenerMap = {};
  }

  /**
   * Creates a new Event object.
   *
   * @param {string} type The type name of the event.
   * @param {Object=} opt_params An object containing properties for the new event
   *     object.
   * @return {module:spotify-eventemitter~Event} The new event object.
   */
  EventEmitter.createEvent = function(type, opt_params) {
    return new Event(type, opt_params);
  };

  /**
   * Adds an event listener to the emitter.
   *
   * This method is idempotent: calling it multiple times using the same type
   * and listener arguments will only set the listener once. This behaviour is
   * done to prevent accidental additions of the same event listener.
   *
   * @param {string} type The type of event to listen to.
   * @param {function} listener A function to be called when the emitter fires
   *     the event specified in the type.
   * @return {module:spotify-eventemitter} The event emitter.
   */
  EventEmitter.prototype.addListener = function(type, listener) {
    var _listenerMap = this._listenerMap || (this._listenerMap = {});
    var listeners = _listenerMap[type] || (_listenerMap[type] = []);
    if (listeners.indexOf(listener) != -1) {
      // Handler already added, return quickly.
      return this;
    }
    listeners.push(listener);
    return this;
  };

  /**
   * Adds multiple event listeners to the emitter.
   *
   * @param {Object.<string, function>} eventListeners An object, the keys of
   *     which correspond to the name of events to listen to, and the value of
   *     each of these keys should be a function that would be added as the
   *     listener for that event.
   * @return {module:spotify-eventemitter} The event emitter.
   */
  EventEmitter.prototype.addListeners = function(eventListeners) {
    for (var type in eventListeners) {
      this.addListener(type, eventListeners[type]);
    }
    return this;
  };

  /**
   * Adds a "once" event listener to the emitter, which will be removed right
   * after it has been fired.
   *
   * In order to achieve the "once" behaviour, the listener argument passed to
   * this method is wrapped in a function, which is then returned by the method.
   *
   * Because of this wrapping, this method is not idempotent: calling it multiple
   * times with the same type and listener arguments will result to multiple
   * event listeners attached.
   *
   * @param {string} type The type of event to listen to.
   * @param {function} listener A function to be called when the emitter fires
   *     the event specified in the type and then automatically removed.
   * @return {function} The function used to wrap the listener function argument.
   *     This function can be used as an argument to removeEvent.
   */
  EventEmitter.prototype.addOnceListener = function(type, listener) {
    var wrapper = function() {
      this.removeListener(type, wrapper);
      return listener.apply(this, arguments);
    };
    this.addListener(type, wrapper);
    return wrapper;
  };

  /**
   * Removes an event listener from the emitter.
   *
   * @param {string} type The type of event to remove.
   * @param {function} listener The listener function to remove. This must be a
   *     function that was added previously using addEvent.
   * @return {module:spotify-eventemitter} The event emitter.
   */
  EventEmitter.prototype.removeListener = function(type, listener) {
    var _listenerMap = this._listenerMap;
    var listeners = _listenerMap && _listenerMap[type];
    if (!listeners) {
      return this;
    }
    var index = listeners.indexOf(listener);
    if (index == -1) {
      return this;
    }
    listeners.splice(index, 1);
    if (!listeners.length) {
      _listenerMap[type] = null;
    }
    return this;
  };

  /**
   * Removes all event listeners from the emitter for a particular type.
   * If no event type is given, all event listeners will be removed.
   *
   * @param {string=} opt_type The event type to remove.
   * @return {module:spotify-eventemitter} The event emitter.
   */
  EventEmitter.prototype.removeAllListeners = function(opt_type) {
    var _listenerMap = this._listenerMap;
    if (!_listenerMap) {
      return this;
    }

    if (opt_type === undefined) {
      this._listenerMap = {};
      return this;
    }

    _listenerMap[opt_type] = null;
    return this;
  };

  /**
   * Removes multiple event listeners from the emitter.
   *
   * @param {Object.<string, function>} eventListeners An object, the keys of
   *     which correspond to the name of events to listen to, and the value of
   *     each of these keys should be a function that would be added as the
   *     listener for that event.
   * @return {module:spotify-eventemitter} The event emitter.
   */
  EventEmitter.prototype.removeListeners = function(eventListeners) {
    for (var type in eventListeners) {
      this.removeListener(type, eventListeners[type]);
    }
    return this;
  };

  /**
   * Creates and emits an event on the emitter.
   *
   * This method invokes all the added event listeners of the `type` provided in
   * the order they were added, passing in a new Event object created using the
   * provided `type` and `opt_params` arguments.
   *
   * This method emits events asynchronously: the listeners are not called until
   * the next run loop.
   *
   * @param {string} type The type name of the event to emit.
   * @param {Object=} opt_params An object containing parameters for the Event
   *     object.
   * @return {module:spotify-eventemitter~Event} The Event object that was
   *     created.
   */
  EventEmitter.prototype.emit = function(type, opt_params) {
    var event = new Event(type, opt_params);
    _defer(function() {
      this.emitEventSync(event);
    }.bind(this));
    return event;
  };

  /**
   * Emits an event on the emitter.
   *
   * This method invokes all the added event listeners of the `type` of the
   * `event` provided in the order they were added, passing in the `event` as an
   * argument.
   *
   * This method emits events asynchronously: the listeners are not called until
   * the next run loop.
   *
   * @param {module:spotify-eventemitter~Event} event The Event object.
   * @return {module:spotify-eventemitter~Event} The Event object that was passed.
   */
  EventEmitter.prototype.emitEvent = function(event) {
    _defer(function() {
      this.emitEventSync(event);
    }.bind(this));
    return event;
  };

  /**
   * Creates and synchronously emits an event on the emitter.
   *
   * This method invokes all the added event listeners of the `type` provided in
   * the order they were added, passing in a new Event object created using the
   * provided `type` and `opt_params` arguments.
   *
   * @param {string} type The type name of event to emit.
   * @param {Object=} opt_params An object containing parameters for the event
   *     object.
   * @return {module:spotify-eventemitter~Event} The Event object that was
   *     created.
   */
  EventEmitter.prototype.emitSync = function(type, opt_params) {
    var event = new Event(type, opt_params);
    this.emitEventSync(event);
    return event;
  };

  /**
   * Synchronously emits an event on the emitter.
   *
   * This method invokes all the added event listeners of the `type` of the
   * `event` provided in the order they were added, passing in the `event` as an
   * argument.
   *
   * @param {module:spotify-eventemitter~Event} event The Event object.
   * @return {module:spotify-eventemitter~Event} The Event object that was passed.
   */
  EventEmitter.prototype.emitEventSync = function(event) {
    var type = event.type;
    var _listenerMap = this._listenerMap;
    var listeners = _listenerMap && _listenerMap[type];
    if (!listeners || !listeners.length) {
      return event;
    }
    listeners = listeners.slice(0);
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].call(this, event);
      if (event.isImmediatePropagationStopped()) {
        break;
      }
    }
    return event;
  };

  /**
   * Adds an event listener to the emitter.
   *
   * **NOTE**: This method is an alias of
   * {@link module:spotify-eventemitter#addListener}.
   *
   * This method is idempotent: calling it multiple times using the same type
   * and listener arguments will only set the listener once. This behaviour is
   * done to prevent accidental additions of the same event listener.
   *
   * @param {string} type The type of event to listen to.
   * @param {function} listener A function to be called when the emitter fires
   *     the event specified in the type.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#addListener}
   */
  EventEmitter.prototype.on = function(type, listener) {
    return this.addListener(type, listener);
  };

  /**
   * Adds a "once" event listener to the emitter, which will be removed right
   * after it has been fired.
   *
   * **NOTE**: This method is an alias of
   * {@link module:spotify-eventemitter#addOnceListener}.
   *
   * In order to achieve the "once" behaviour, the listener argument passed to
   * this method is wrapped in a function, which is then returned by the method.
   *
   * Because of this wrapping, this method is not idempotent: calling it multiple
   * times with the same type and listener arguments will result to multiple
   * event listeners attached.
   *
   * @param {string} type The type of event to listen to.
   * @param {function} listener A function to be called when the emitter fires
   *     the event specified in the type and then automatically removed.
   * @return {function} The function used to wrap the listener function argument.
   *     This function can be used as an argument to removeEvent.
   * @see {@link module:spotify-eventemitter#addOnceListener}
   */
  EventEmitter.prototype.once = function(type, listener) {
    return this.addOnceListener(type, listener);
  };

  // DEPRECATED METHODS:

  /**
   * Adds an event listener to the emitter.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#addListener}.
   *
   * This method is idempotent: calling it multiple times using the same type
   * and listener arguments will only set the listener once. This behaviour is
   * done to prevent accidental additions of the same event listener.
   *
   * @deprecated since v2.0.0.
   * @param {string} type The type of event to listen to.
   * @param {function} listener A function to be called when the emitter fires
   *     the event specified in the type.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#addListener}
   */
  EventEmitter.prototype.addEvent = function(type, listener) {
    return this.addListener(type, listener);
  };

  /**
   * Adds multiple event listeners to the emitter.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#addListeners}.
   *
   * @deprecated since v2.0.0.
   * @param {Object.<string, function>} eventListeners An object, the keys of
   *     which correspond to the name of events to listen to, and the value of
   *     each of these keys should be a function that would be added as the
   *     listener for that event.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#addListeners}
   */
  EventEmitter.prototype.addEvents = function(eventListeners) {
    return this.addListeners(eventListeners);
  };

  /**
   * Adds a "once" event listener to the emitter, which will be removed right
   * after it has been fired.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#addOnceListener}.
   *
   * In order to achieve the "once" behaviour, the listener argument passed to
   * this method is wrapped in a function, which is then returned by the method.
   *
   * Because of this wrapping, this method is not idempotent: calling it multiple
   * times with the same type and listener arguments will result to multiple
   * event listeners attached.
   *
   * @deprecated since v2.0.0.
   * @param {string} type The type of event to listen to.
   * @param {function} listener A function to be called when the emitter fires
   *     the event specified in the type and then automatically removed.
   * @return {function} The function used to wrap the listener function argument.
   *     This function can be used as an argument to removeEvent.
   * @see {@link module:spotify-eventemitter#addOnceListener}
   */
  EventEmitter.prototype.addOnceEvent = function(type, listener) {
    return this.addOnceListener(type, listener);
  };

  /**
   * Removes an event listener from the emitter.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#removeListener}.
   *
   * @deprecated since v2.0.0.
   * @param {string} type The type of event to remove.
   * @param {function} listener The listener function to remove. This must be a
   *     function that was added previously using addEvent.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#removeListener}
   */
  EventEmitter.prototype.removeEvent = function(type, listener) {
    return this.removeListener(type, listener);
  };

  /**
   * Removes multiple event listeners from the emitter.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#removeListeners}.
   *
   * @deprecated since v2.0.0.
   * @param {Object.<string, function>} events An object, the keys of which
   *     correspond to the name of events to remove, and the value of each of
   *     these keys should be a function that would be removed as a listener.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#removeListeners}
   */
  EventEmitter.prototype.removeEvents = function(eventListeners) {
    return this.removeListeners(eventListeners);
  };

  /**
   * Fires an event on the emitter, optionally passing arguments to the listeners.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#emit}.
   *
   * This method fire events asynchronously: the listeners are not called until
   * the next run loop. A third boolean parameter can be passed to change this
   * behaviour.
   *
   * @deprecated since v2.0.0.
   * @param {string} type The type of event to fire.
   * @param {Array.<*>=} opt_args A set of objects that would be passed to the
   *     event listeners as arguments.
   * @param {boolean=} opt_priority Passing true will fire the event synchronously.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#emit}
   */
  EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
    if (opt_priority) {
      this.fireEventSync(type, opt_args);
    } else {
      var self = this;
      _defer(function() { self.fireEventSync(type, opt_args); });
    }
    return this;
  };

  /**
   * Fires an event on the emitter synchronously, optionally passing arguments to
   * the listeners.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#emitSync}.
   *
   * @deprecated since v2.0.0.
   * @param {string} type The type of event to fire.
   * @param {Array.<*>=} opt_args A set of objects that would be passed to the
   *     event listeners as arguments.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#emitSync}
   */
  EventEmitter.prototype.fireEventSync = function(type, opt_args) {
    var self = this;
    var events = this._listenerMap && this._listenerMap[type];
    if (!events || !events.length) return this;
    events = events.slice(0);
    var i, l;
    if (!opt_args) {
      for (i = 0, l = events.length; i < l; i++) {
        events[i].call(self);
      }
    } else {
      if (!Array.isArray(opt_args)) {
        opt_args = [opt_args];
      }
      for (i = 0, l = events.length; i < l; i++) {
        events[i].apply(self, opt_args);
      }
    }
    return this;
  };

  /**
   * Removes an event listener or all event listeners from the emitter.
   *
   * **NOTE**: This method has been deprecated in favor of
   * {@link module:spotify-eventemitter#removeListener}.
   *
   * @deprecated since v2.0.0.
   * @param {string} type The type of event to remove.
   * @param {function=} opt_listener The listener function to remove. This must be
   *     a function that was added previously using addEvent. If this parameter is
   *     not given, all event listeners of the corresponding `type` argument will
   *     be removed.
   * @return {module:spotify-eventemitter} The event emitter.
   * @see {@link module:spotify-eventemitter#removeListener}
   * @see {@link module:spotify-eventemitter#removeListeners}
   */
  EventEmitter.prototype.off = function(type, opt_listener) {
    if (typeof opt_listener === 'function') {
      return this.removeEvent(type, opt_listener);
    }
    // if no listener set, remove all the listeners from the event
    this._listenerMap[type] = null;
    return this;
  };

  /**
   * Exporting
   */
  module.exports = EventEmitter;

  },{"spotify-deferred":1276}],1278:[function(require,module,exports){
  'use strict';

  /**
   * Function to add properties to an object
   * @param {Object} obj The input object
   * @param {Object} args The objects which are going to be injected
   * @return {Object} The extended object
   */
  var extend = function(obj, args) {
    var source;

    for (var i = 1; i < arguments.length; i++) {
      source = arguments[i];
      if (source) {
        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            obj[prop] = source[prop];
          }
        }
      }
    }
    return obj;
  };


  /**
   * Export public interface
   */
  module.exports = extend;

  },{}],1279:[function(require,module,exports){
  'use strict';

  module.exports = {
    inherit: require('./inherit'),
    extend: require('./extend')
  };

  },{"./extend":1278,"./inherit":1280}],1280:[function(require,module,exports){
  'use strict';

  /**
   * Makes a class inherit from a superclass' prototype indirectly.
   *
   * @param {Spotify.ClassLike} Sub The class that will inherit.
   * @param {Spotify.ClassLike} Super The class to inherit from.
   */
  var inherit = function(Sub, Super) {
    var superProto = Super.prototype;
    function Superclass() {}
    Superclass.prototype = Sub._super = superProto;
    Superclass.prototype.constructor = Super;
    Sub.prototype = new Superclass();
  };


  /**
   * Export public interface
   */
  module.exports = inherit;

  },{}],1281:[function(require,module,exports){
  /**
   * Copyright (c) 2017 Spotify AB
   *
   * Fast base62 encoder/decoder.
   *
   * Usage:
   *
   *   Base62.toHex('1C0pasJ0dS2Z46GKh2puYo') // -> '34ff970885ca8fa02c0d6e459377d5d0'
   *                         ^^^
   *                          |
   *               Length-22 base62-encoded ID.
   *         Lengths other than 22 or invalid base62 IDs
   *                  are not supported.
   *
   *   Base62.fromHex('34ff970885ca8fa02c0d6e459377d5d0') // -> '1C0pasJ0dS2Z46GKh2puYo'
   *                         ^^^
   *                          |
   *               Length-32 hex-encoded ID.
   *         Lengths other than 32 are not supported.
   *
   * Written by @ludde, programatically tested and documented by @felipec.
   */
  (function() {
    // Alphabets
    var HEX16 = '0123456789abcdef';
    var BASE62 =
      '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

    // Hexadecimal fragments
    var HEX256 = [];
    HEX256.length = 256;
    for (var i = 0; i < 256; i++) {
      HEX256[i] = HEX16[i >> 4] + HEX16[i & 0xf];
    }

    // Look-up tables
    var ID62 = [];
    ID62.length = 128;
    for (var i = 0; i < BASE62.length; ++i) {
      ID62[BASE62.charCodeAt(i)] = i;
    }
    var ID16 = [];
    for (var i = 0; i < 16; i++) {
      ID16[HEX16.charCodeAt(i)] = i;
    }
    for (var i = 0; i < 6; i++) {
      ID16['ABCDEF'.charCodeAt(i)] = 10 + i;
    }

    var Base62 = {
      toHex: function(s) {
        if (s.length !== 22) {
          // Can only parse base62 ids with length == 22.
          // Invalid base62 ids will lead to garbage in the output.
          return null;
        }

        // 1 / (2^32)
        var MAX_INT_INV = 2.3283064365386963e-10;
        // 2^32
        var MAX_INT = 0x100000000;
        // 62^3
        var P62_3 = 238328;

        var p0, p1, p2, p3;
        var v;
        // First 7 characters fit in 2^53
        // prettier-ignore
        p0 =
          ID62[s.charCodeAt(0)] * 56800235584 +  // * 62^6
          ID62[s.charCodeAt(1)] * 916132832 +    // * 62^5
          ID62[s.charCodeAt(2)] * 14776336 +     // * 62^4
          ID62[s.charCodeAt(3)] * 238328 +       // * 62^3
          ID62[s.charCodeAt(4)] * 3844 +         // * 62^2
          ID62[s.charCodeAt(5)] * 62 +           // * 62^1
          ID62[s.charCodeAt(6)];                 // * 62^0
        p1 = (p0 * MAX_INT_INV) | 0;
        p0 -= p1 * MAX_INT;
        // 62^10 < 2^64
        v =
          ID62[s.charCodeAt(7)] * 3844 +
          ID62[s.charCodeAt(8)] * 62 +
          ID62[s.charCodeAt(9)];
        (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
        p1 = p1 * P62_3 + v;
        // 62^13 < 2^96
        v =
          ID62[s.charCodeAt(10)] * 3844 +
          ID62[s.charCodeAt(11)] * 62 +
          ID62[s.charCodeAt(12)];
        (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
        (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
        p2 = v;
        // 62^16 < 2^96
        v =
          ID62[s.charCodeAt(13)] * 3844 +
          ID62[s.charCodeAt(14)] * 62 +
          ID62[s.charCodeAt(15)];
        (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
        (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
        p2 = p2 * P62_3 + v;
        // 62^19 < 2^128
        v =
          ID62[s.charCodeAt(16)] * 3844 +
          ID62[s.charCodeAt(17)] * 62 +
          ID62[s.charCodeAt(18)];
        (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
        (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
        (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
        p3 = v;
        v =
          ID62[s.charCodeAt(19)] * 3844 +
          ID62[s.charCodeAt(20)] * 62 +
          ID62[s.charCodeAt(21)];
        (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
        (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
        (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
        (p3 = p3 * P62_3 + v), (p3 = p3 - (v = (p3 * MAX_INT_INV) | 0) * MAX_INT);
        if (v) {
          // carry not allowed
          return null;
        }
        // prettier-ignore
        return HEX256[p3>>>24]+HEX256[(p3>>>16)&0xFF]+HEX256[(p3>>>8)&0xFF]+HEX256[(p3)&0xFF] +
               HEX256[p2>>>24]+HEX256[(p2>>>16)&0xFF]+HEX256[(p2>>>8)&0xFF]+HEX256[(p2)&0xFF] +
               HEX256[p1>>>24]+HEX256[(p1>>>16)&0xFF]+HEX256[(p1>>>8)&0xFF]+HEX256[(p1)&0xFF] +
               HEX256[p0>>>24]+HEX256[(p0>>>16)&0xFF]+HEX256[(p0>>>8)&0xFF]+HEX256[(p0)&0xFF];
      },

      fromHex: function(s) {
        var i;
        var p0 = 0, p1 = 0, p2 = 0;
        for (i = 0; i < 10; i++) p2 = p2 * 16 + ID16[s.charCodeAt(i)];
        for (i = 0; i < 11; i++) p1 = p1 * 16 + ID16[s.charCodeAt(i + 10)];
        for (i = 0; i < 11; i++) p0 = p0 * 16 + ID16[s.charCodeAt(i + 21)];
        if (isNaN(p0 + p1 + p2)) {
          return null;
        }
        var P16_11 = 17592186044416; // 16^11
        var INV_62 = 1.0 / 62;

        var acc;
        var ret = '';
        i = 0;
        for (; i < 7; ++i) {
          acc = p2;
          p2 = Math.floor(acc * INV_62);
          acc = (acc - p2 * 62) * P16_11 + p1;
          p1 = Math.floor(acc * INV_62);
          acc = (acc - p1 * 62) * P16_11 + p0;
          p0 = Math.floor(acc * INV_62);
          ret = BASE62[acc - p0 * 62] + ret;
        }
        p1 += p2 * P16_11;
        for (; i < 15; ++i) {
          acc = p1;
          p1 = Math.floor(acc * INV_62);
          acc = (acc - p1 * 62) * P16_11 + p0;
          p0 = Math.floor(acc * INV_62);
          ret = BASE62[acc - p0 * 62] + ret;
        }
        p0 += p1 * P16_11;
        for (; i < 21; ++i) {
          acc = p0;
          p0 = Math.floor(acc * INV_62);
          ret = BASE62[acc - p0 * 62] + ret;
        }
        return BASE62[p0] + ret;
      },

      // Expose the lookup tables
      HEX256: HEX256, // number -> 'hh'
      ID16: ID16,  // hexadecimal char code -> 0..15
      ID62: ID62,  // base62 char code -> 0..61
    };

    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
      module.exports = Base62;
    } else {
      window.Base62 = Base62;
    }
  })();

  },{}],1282:[function(require,module,exports){
  'use strict';

  /**
   * @private
   */
  var Base62 = require('./base62');

  /**
   * The URI prefix for URIs.
   *
   * @const
   * @private
   */
  var URI_PREFIX = 'spotify:';

  /**
   * The URL prefix for Play.
   *
   * @const
   * @private
   */
  var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

  /**
   * The HTTPS URL prefix for Play.
   *
   * @const
   * @private
   */
  var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

  /**
   * The URL prefix for Open.
   *
   * @const
   * @private
   */
  var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

  /**
   * The HTTPS URL prefix for Open.
   *
   * @const
   * @private
   */
  var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

  var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
  var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


  /**
   * The format for the URI to parse.
   *
   * @enum {number}
   * @private
   */
  var Format = {
    URI: 0,
    URL: 1
  };

  /**
   * Represents the result of a URI splitting operation.
   *
   * @typedef {{
   *    format: Format,
   *    components: Array.<string>
   * }}
   * @see _splitIntoComponents
   * @private
   */
  var SplittedURI;

  /**
   * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
   *
   * @param {string} str A string URI to split.
   * @return {SplittedURI} The parsed URI.
   * @private
   */
  var _splitIntoComponents = function(str) {
    var components;
    var format;
    var query;
    var anchor;

    var querySplit = str.split('?');
    if (querySplit.length > 1) {
      str = querySplit.shift();
      query = querySplit.pop();

      var queryHashSplit = query.split('#');
      if (queryHashSplit.length > 1) {
        query = queryHashSplit.shift();
        anchor = queryHashSplit.pop();
      }

      query = decodeQueryString(query);
    }

    var hashSplit = str.split('#');
    if (hashSplit.length > 1) {
      // first token
      str = hashSplit.shift();
      // last token
      anchor = hashSplit.pop();
    }

    if (str.indexOf(URI_PREFIX) === 0) {
      components = str.slice(URI_PREFIX.length).split(':');
      format = Format.URI;
    } else {
      // For HTTP URLs, ignore any query string argument
      str = str.split('?')[0];

      if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
        components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
      } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
        components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
      } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
        components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
      } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
        components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
      } else {
        throw ERROR_INVALID;
      }
      format = Format.URL;
    }

    if (anchor) {
      components.push(anchor);
    }

    return {
      format: format,
      components: components,
      query: query
    };
  };

  /**
   * Encodes a component according to a format.
   *
   * @param {string} component A component string.
   * @param {Format} format A format.
   * @return {string} An encoded component string.
   * @private
   */
  var _encodeComponent = function(component, format) {
    component = encodeURIComponent(component);
    if (format === Format.URI) {
      component = component.replace(/%20/g, '+');
    }

    // encode characters that are not encoded by default by encodeURIComponent
    // but that the Spotify URI spec encodes: !'*()
    component = component.replace(/[!'()]/g, escape);
    component = component.replace(/\*/g, '%2A');

    return component;
  };

  /**
   * Decodes a component according to a format.
   *
   * @param {string} component An encoded component string.
   * @param {Format} format A format.
   * @return {string} An decoded component string.
   * @private
   */
  var _decodeComponent = function(component, format) {
    var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
    return decodeURIComponent(part);
  };

  /**
   * Returns the components of a URI as an array.
   *
   * @param {URI} uri A uri.
   * @param {Format} format The output format.
   * @return {Array.<string>} An array of uri components.
   * @private
   */
  var _getComponents = function(uri, format) {
    var base62;
    if (uri.id) {
      base62 = uri._base62Id;
    }

    var components;
    var i;
    var len;
    switch (uri.type) {
      case URI.Type.ALBUM:
        components = [URI.Type.ALBUM, base62];
        if (uri.disc) {
          components.push(uri.disc);
        }
        return components;
      case URI.Type.AD:
        return [URI.Type.AD, uri._base62Id];
      case URI.Type.ARTIST:
        return [URI.Type.ARTIST, base62];
      case URI.Type.ARTIST_TOPLIST:
        return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
      case URI.Type.SEARCH:
        return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
      case URI.Type.TRACK:
        if (uri.context || uri.play) {
          base62 += encodeQueryString({
            context: uri.context,
            play: uri.play
          });
        }
        if (uri.anchor) {
          base62 += '#' + uri.anchor;
        }
        return [URI.Type.TRACK, base62];
      case URI.Type.TRACKSET:
        var trackIds = [];
        for (i = 0, len = uri.tracks.length; i < len; i++) {
          trackIds.push(uri.tracks[i]._base62Id);
        }
        trackIds = [trackIds.join(',')];
        // Index can be 0 sometimes (required for trackset)
        if (uri.index !== null) {
          trackIds.push('#', uri.index);
        }
        return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
      case URI.Type.FACEBOOK:
        return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
      case URI.Type.AUDIO_FILE:
        return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
      case URI.Type.FOLDER:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
      case URI.Type.FOLLOWERS:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
      case URI.Type.FOLLOWING:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
      case URI.Type.PLAYLIST:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
      case URI.Type.PLAYLIST_V2:
        return [URI.Type.PLAYLIST, base62];
      case URI.Type.STARRED:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
      case URI.Type.TEMP_PLAYLIST:
        return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
      case URI.Type.CONTEXT_GROUP:
        return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
      case URI.Type.USER_TOPLIST:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
      // Legacy Toplist
      case URI.Type.USER_TOP_TRACKS:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
      case URI.Type.TOPLIST:
        return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
      case URI.Type.INBOX:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
      case URI.Type.ROOTLIST:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
      case URI.Type.PUBLISHED_ROOTLIST:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
      case URI.Type.COLLECTION_TRACK_LIST:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
      case URI.Type.PROFILE:
        if (uri.args && uri.args.length > 0)
          return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
        return [URI.Type.USER, _encodeComponent(uri.username, format)];
      case URI.Type.LOCAL_ARTIST:
        return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
      case URI.Type.LOCAL_ALBUM:
        return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
      case URI.Type.LOCAL:
        return [URI.Type.LOCAL,
          _encodeComponent(uri.artist, format),
          _encodeComponent(uri.album, format),
          _encodeComponent(uri.track, format),
          uri.duration];
      case URI.Type.LIBRARY:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
      case URI.Type.IMAGE:
        return [URI.Type.IMAGE, uri._base62Id];
      case URI.Type.MOSAIC:
        components = uri.ids.slice(0);
        components.unshift(URI.Type.MOSAIC);
        return components;
      case URI.Type.RADIO:
        return [URI.Type.RADIO, uri.args];
      case URI.Type.SPECIAL:
        components = [URI.Type.SPECIAL];
        var args = uri.args || [];
        for (i = 0, len = args.length; i < len; ++i)
          components.push(_encodeComponent(args[i], format));
        return components;
      case URI.Type.STATION:
        components = [URI.Type.STATION];
        var args = uri.args || [];
        for (i = 0, len = args.length; i < len; i++) {
          components.push(_encodeComponent(args[i], format));
        }
        return components;
      case URI.Type.APPLICATION:
        components = [URI.Type.APP, uri._base62Id];
        var args = uri.args || [];
        for (i = 0, len = args.length; i < len; ++i)
          components.push(_encodeComponent(args[i], format));
        return components;
      case URI.Type.COLLECTION_ALBUM:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
      case URI.Type.COLLECTION_MISSING_ALBUM:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
      case URI.Type.COLLECTION_ARTIST:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
      case URI.Type.COLLECTION:
        return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
      case URI.Type.EPISODE:
        if (uri.context || uri.play) {
          base62 += encodeQueryString({
            context: uri.context,
            play: uri.play
          });
        }
        return [URI.Type.EPISODE, base62];
      case URI.Type.SHOW:
        return [URI.Type.SHOW, base62];
      case URI.Type.CONCERT:
        return [URI.Type.CONCERT, base62];
      default:
        throw ERROR_INVALID;
    }
  };

  var encodeQueryString = function(values) {
    var str = '?';
    for (var i in values) {
      if (values.hasOwnProperty(i) && values[i] !== undefined) {
        if (str.length > 1) {
          str += '&';
        }
        str += i + '=' + encodeURIComponent(values[i]);
      }
    }
    return str;
  };

  var decodeQueryString = function(str) {
    return str.split('&').reduce(function(object, pair) {
      pair = pair.split('=');
      object[pair[0]] = decodeURIComponent(pair[1]);
      return object;
    }, {});
  };

  /**
   * Parses the components of a URI into a real URI object.
   *
   * @param {Array.<string>} components The components of the URI as a string
   *     array.
   * @param {Format} format The format of the source string.
   * @return {URI} The URI object.
   * @private
   */
  var _parseFromComponents = function(components, format, query) {
    var _current = 0;
    query = query || {};

    var _getNextComponent = function() {
      return components[_current++];
    };

    var _getIdComponent = function() {
      var component = _getNextComponent();

      if (component.length > 22) {
        throw new Error('Invalid ID');
      }
      return component;
    };

    var _getRemainingComponents = function() {
      return components.slice(_current);
    };

    var _getRemainingString = function() {
      var separator = (format == Format.URI) ? ':' : '/';
      return components.slice(_current).join(separator);
    };

    var part = _getNextComponent();
    var id;
    var i;
    var len;

    switch (part) {
      case URI.Type.ALBUM:
        return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
      case URI.Type.AD:
        return URI.adURI(_getNextComponent());
      case URI.Type.ARTIST:
        id = _getIdComponent();
        if (_getNextComponent() == URI.Type.TOP) {
          return URI.artistToplistURI(id, _getNextComponent());
        } else {
          return URI.artistURI(id);
        }
      case URI.Type.AUDIO_FILE:
        return URI.audioFileURI(_getNextComponent(), _getNextComponent());
      case URI.Type.TEMP_PLAYLIST:
        return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
      case URI.Type.PLAYLIST:
        return URI.playlistV2URI(_getIdComponent());
      case URI.Type.SEARCH:
        return URI.searchURI(_decodeComponent(_getRemainingString(), format));
      case URI.Type.TRACK:
        return URI.trackURI(_getIdComponent(), _getNextComponent(), query.context, query.play);
      case URI.Type.TRACKSET:
        var name = _decodeComponent(_getNextComponent());
        var tracksArray = _getNextComponent();
        var hashSign = _getNextComponent();
        var index = parseInt(_getNextComponent(), 10);
        // Sanity check: %23 is URL code for "#"
        if (hashSign !== '%23' || isNaN(index)) {
          index = null;
        }
        var tracksetTracks = [];
        if (tracksArray) {
          tracksArray = _decodeComponent(tracksArray).split(',');
          for (i = 0, len = tracksArray.length; i < len; i++) {
            var trackId = tracksArray[i];
            tracksetTracks.push(URI.trackURI(trackId));
          }
        }
        return URI.tracksetURI(tracksetTracks, name, index);
      case URI.Type.CONTEXT_GROUP:
        return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
      case URI.Type.TOP:
        var type = _getNextComponent();
        if (_getNextComponent() == URI.Type.GLOBAL) {
          return URI.toplistURI(type, null, true);
        } else {
          return URI.toplistURI(type, _getNextComponent(), false);
        }
      case URI.Type.USER:
        var username = _decodeComponent(_getNextComponent(), format);
        var text = _getNextComponent();
        if (username == URI.Type.FACEBOOK && text != null) {
          return URI.facebookURI(parseInt(text, 10));
        } else if (text != null) {
          switch (text) {
            case URI.Type.PLAYLIST:
              return URI.playlistURI(username, _getIdComponent());
            case URI.Type.FOLDER:
              return URI.folderURI(username, _getIdComponent());
            case URI.Type.COLLECTION_TRACK_LIST:
              return URI.collectionTrackList(username, _getIdComponent());
            case URI.Type.COLLECTION:
              var collectionItemType = _getNextComponent();
              switch (collectionItemType) {
                case URI.Type.ALBUM:
                  id = _getIdComponent();
                  if (_getNextComponent() === 'missing') {
                    return URI.collectionMissingAlbumURI(username, id);
                  } else {
                    return URI.collectionAlbumURI(username, id);
                  }
                case URI.Type.ARTIST:
                  return URI.collectionArtistURI(username, _getIdComponent());
                default:
                  return URI.collectionURI(username, collectionItemType);
              }
            case URI.Type.STARRED:
              return URI.starredURI(username);
            case URI.Type.FOLLOWERS:
              return URI.followersURI(username);
            case URI.Type.FOLLOWING:
              return URI.followingURI(username);
            case URI.Type.TOP:
              return URI.userToplistURI(username, _getNextComponent());
            case URI.Type.INBOX:
              return URI.inboxURI(username);
            case URI.Type.ROOTLIST:
              return URI.rootlistURI(username);
            case URI.Type.PUBLISHED_ROOTLIST:
              return URI.publishedRootlistURI(username);
            case URI.Type.TOPLIST:
              // legacy toplist
              return URI.userTopTracksURI(username);
            case URI.Type.LIBRARY:
              return URI.libraryURI(username, _getNextComponent());
          }
        }
        var rem = _getRemainingComponents();
        if (text != null && rem.length > 0) {
          return URI.profileURI(username, [text].concat(rem));
        } else if (text != null) {
          return URI.profileURI(username, [text]);
        } else {
          return URI.profileURI(username);
        }
      case URI.Type.LOCAL:
        var artistNameComponent = _getNextComponent();
        var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
        var albumNameComponent = _getNextComponent();
        var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
        var trackNameComponent = _getNextComponent();
        var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
        var durationComponent = _getNextComponent();
        var duration = parseInt(durationComponent, 10);
        if (trackNameComponent !== undefined) {
          return URI.localURI(artistName, albumName, trackName, duration);
        } else if (albumNameComponent !== undefined) {
          return URI.localAlbumURI(artistName, albumName);
        } else {
          return URI.localArtistURI(artistName);
        }
      case URI.Type.IMAGE:
        return URI.imageURI(_getIdComponent());
      case URI.Type.MOSAIC:
        return URI.mosaicURI(components.slice(_current));
      case URI.Type.RADIO:
        return URI.radioURI(_getRemainingString());
      case URI.Type.SPECIAL:
        var args = _getRemainingComponents();
        for (i = 0, len = args.length; i < len; ++i)
          args[i] = _decodeComponent(args[i], format);
        return URI.specialURI(args);
      case URI.Type.STATION:
        return URI.stationURI(_getRemainingComponents());
      case URI.Type.EPISODE:
        return URI.episodeURI(_getIdComponent(), query.context, query.play);
      case URI.Type.SHOW:
        return URI.showURI(_getIdComponent());
      case URI.Type.CONCERT:
        return URI.concertURI(_getIdComponent());
      case '':
        break;
      default:
        if (part === URI.Type.APP) {
          id = _getNextComponent();
        } else {
          id = part;
        }
        var decodedId = _decodeComponent(id, format);
        if (_encodeComponent(decodedId, format) !== id) {
          break;
        }
        var args = _getRemainingComponents();
        for (i = 0, len = args.length; i < len; ++i)
          args[i] = _decodeComponent(args[i], format);
        return URI.applicationURI(decodedId, args);
    }

    throw ERROR_INVALID;
  };

  /**
   * A class holding information about a uri.
   *
   * @constructor
   * @param {URI.Type} type
   * @param {Object} props
   */
  function URI(type, props) {
    this.type = type;

    // Merge properties into URI object.
    for (var prop in props) {
      if (typeof props[prop] == 'function') {
        continue;
      }
      this[prop] = props[prop];
    }
  }

  // Lazy convert the id to hexadecimal only when requested
  Object.defineProperty(URI.prototype, 'id', {
    get: function() {
      if (!this._hexId) {
        this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
      }
      return this._hexId;
    },
    set: function(id) {
      this._base62Id = id ? URI.hexToId(id) : undefined;
      this._hexId = undefined;
    },
    enumerable: true,
    configurable: true
  });

  /**
   * Creates an application URI object from the current URI object.
   *
   * If the current URI object is already an application type, a copy is made.
   *
   * @return {URI} The current URI as an application URI.
   */
  URI.prototype.toAppType = function() {
    if (this.type == URI.Type.APPLICATION) {
      return URI.applicationURI(this.id, this.args);
    } else {
      var components = _getComponents(this, Format.URL);
      var id = components.shift();
      var len = components.length;
      if (len) {
        while (len--) {
          components[len] = _decodeComponent(components[len], Format.URL);
        }
      }
      if (this.type == URI.Type.RADIO) {
        components = components.shift().split(':');
      }
      var result = URI.applicationURI(id, components);
      return result;
    }
  };

  /**
   * Creates a URI object from an application URI object.
   *
   * If the current URI object is not an application type, a copy is made.
   *
   * @return {URI} The current URI as a real typed URI.
   */
  URI.prototype.toRealType = function() {
    if (this.type == URI.Type.APPLICATION) {
      return _parseFromComponents([this.id].concat(this.args), Format.URI);
    } else {
      return new URI(null, this);
    }
  };

  /**
   * Returns the URI representation of this URI.
   *
   * @return {String} The URI representation of this uri.
   */
  URI.prototype.toURI = function() {
    return URI_PREFIX + _getComponents(this, Format.URI).join(':');
  };

  /**
   * Returns the String representation of this URI.
   *
   * @return {String} The URI representation of this uri.
   * @see {URI#toURI}
   */
  URI.prototype.toString = function() {
    return this.toURI();
  };

  /**
   * Get the URL path of this uri.
   *
   * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
   * @return {String} The path of this uri.
   */
  URI.prototype.toURLPath = function(opt_leadingSlash) {
    var components = _getComponents(this, Format.URL);
    if (components[0] === URI.Type.APP) {
      components.shift();
    }

    // Some URIs are allowed to have empty components. It should be investigated
    // whether we need to strip empty components at all from any URIs. For now,
    // we check specifically for tracksets and local tracks and strip empty
    // components for all other URIs.
    //
    // For tracksets, it's permissible to have a path that looks like
    // 'trackset//trackURI' because the identifier parameter for a trackset can
    // be blank. For local tracks, some metadata can be missing, like missing
    // album name would be 'spotify:local:artist::track:duration'.
    var isTrackset = components[0] === URI.Type.TRACKSET;
    var isLocalTrack = components[0] === URI.Type.LOCAL;
    var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

    if (shouldStripEmptyComponents) {
      var _temp = [];
      for (var i = 0, l = components.length; i < l; i++) {
        var component = components[i];
        if (!!component) {
          _temp.push(component);
        }
      }
      components = _temp;
    }
    var path = components.join('/');
    return opt_leadingSlash ? '/' + path : path;
  };

  /**
   * Returns the Play URL string for the uri.
   *
   * @return {string} The Play URL string for the uri.
   */
  URI.prototype.toPlayURL = function() {
      return PLAY_HTTPS_PREFIX + this.toURLPath();
  };

  /**
   * Returns the URL string for the uri.
   *
   * @return {string} The URL string for the uri.
   * @see {URL#toPlayURL}
   */
  URI.prototype.toURL = function() {
    return this.toPlayURL();
  };

  /**
   * Returns the Open URL string for the uri.
   *
   * @return {string} The Open URL string for the uri.
   */
  URI.prototype.toOpenURL = function() {
    return OPEN_HTTPS_PREFIX + this.toURLPath();
  };

  /**
   * Returns the Play HTTPS URL string for the uri.
   *
   * @return {string} The Play HTTPS URL string for the uri.
   */
  URI.prototype.toSecurePlayURL = function() {
      return this.toPlayURL();
  };

  /**
   * Returns the HTTPS URL string for the uri.
   *
   * @return {string} The HTTPS URL string for the uri.
   * @see {URL#toSecurePlayURL}
   */
  URI.prototype.toSecureURL = function() {
    return this.toPlayURL();
  };

  /**
   * Returns the Open HTTPS URL string for the uri.
   *
   * @return {string} The Open HTTPS URL string for the uri.
   */
  URI.prototype.toSecureOpenURL = function() {
    return this.toOpenURL();
  };

  /**
   * Returns the id of the uri as a bytestring.
   *
   * @return {Array} The id of the uri as a bytestring.
   */
  URI.prototype.idToByteString = function() {
    var hexId = Base62.toHex(this._base62Id);
    if (!hexId) {
      var zero = '';
      for (var i = 0; i < 16; i++) {
        zero += String.fromCharCode(0);
      }
      return zero;
    }
    var data = '';
    for (var i = 0; i < 32; i += 2) {
      var upper = Base62.ID16[hexId.charCodeAt(i)];
      var lower = Base62.ID16[hexId.charCodeAt(i + 1)];
      var byte = (upper << 4) + lower;
      data += String.fromCharCode(byte);
    }
    return data;
  };

  URI.prototype.getPath = function() {
    var uri = this.toString().replace(/[#?].*/, '');
    return uri;
  }

  URI.prototype.getBase62Id = function() {
    return this._base62Id;
  }


  /**
  * Checks whether two URI:s refer to the same thing even though they might
  * not necessarily be equal.
  *
  * These two Playlist URIs, for example, refer to the same playlist:
  *
  *   spotify:user:napstersean:playlist:3vxotOnOGDlZXyzJPLFnm2
  *   spotify:playlist:3vxotOnOGDlZXyzJPLFnm2
  *
  * @param {*} uri The uri to compare identity for.
  * @return {boolean} Whether they shared idenitity
  */
  URI.prototype.isSameIdentity = function(uri) {
    var uriObject = URI.from(uri);
    if (!uriObject) return false;
    if (this.toString() === uri.toString()) return true;
    if (
      (this.type === URI.Type.PLAYLIST || this.type === URI.Type.PLAYLIST_V2) &&
      (uriObject.type === URI.Type.PLAYLIST || uriObject.type === URI.Type.PLAYLIST_V2)
    ) {
      return this.id === uriObject.id;
    } else if (this.type === URI.Type.STATION && uriObject.type === URI.Type.STATION) {
      var thisStationContextUriObject = _parseFromComponents(this.args, Format.URI);
      return !!thisStationContextUriObject &&
        thisStationContextUriObject.isSameIdentity(
          _parseFromComponents(uriObject.args, Format.URI)
        );
    } else {
      return false;
    }
  }

  /**
   * The various URI Types.
   *
   * Note that some of the types in this enum are not real URI types, but are
   * actually URI particles. They are marked so.
   *
   * @enum {string}
   */
  URI.Type = {
    EMPTY: 'empty',
    ALBUM: 'album',
    AD: 'ad',
    /** URI particle; not an actual URI. */
    APP: 'app',
    APPLICATION: 'application',
    ARTIST: 'artist',
    ARTIST_TOPLIST: 'artist-toplist',
    AUDIO_FILE: 'audiofile',
    COLLECTION: 'collection',
    COLLECTION_ALBUM: 'collection-album',
    COLLECTION_MISSING_ALBUM: 'collection-missing-album',
    COLLECTION_ARTIST: 'collection-artist',
    CONTEXT_GROUP: 'context-group',
    EPISODE: 'episode',
    /** URI particle; not an actual URI. */
    FACEBOOK: 'facebook',
    FOLDER: 'folder',
    FOLLOWERS: 'followers',
    FOLLOWING: 'following',
    /** URI particle; not an actual URI. */
    GLOBAL: 'global',
    IMAGE: 'image',
    INBOX: 'inbox',
    LOCAL_ARTIST: 'local-artist',
    LOCAL_ALBUM: 'local-album',
    LOCAL: 'local',
    LIBRARY: 'library',
    MOSAIC: 'mosaic',
    PLAYLIST: 'playlist',
    /** Only used for URI classification. Not a valid URI fragment. */
    PLAYLIST_V2: 'playlist-v2',
    PROFILE: 'profile',
    PUBLISHED_ROOTLIST: 'published-rootlist',
    RADIO: 'radio',
    ROOTLIST: 'rootlist',
    COLLECTION_TRACK_LIST: 'collectiontracklist',
    SEARCH: 'search',
    SHOW: 'show',
    CONCERT: 'concert',
    SPECIAL: 'special',
    STARRED: 'starred',
    STATION: 'station',
    TEMP_PLAYLIST: 'temp-playlist',
    /** URI particle; not an actual URI. */
    TOP: 'top',
    TOPLIST: 'toplist',
    TRACK: 'track',
    TRACKSET: 'trackset',
    /** URI particle; not an actual URI. */
    USER: 'user',
    USER_TOPLIST: 'user-toplist',
    USER_TOP_TRACKS: 'user-top-tracks',
    /** Deprecated contant. Please use USER_TOP_TRACKS. */
    USET_TOP_TRACKS: 'user-top-tracks'
  };

  /**
   * Creates a new URI object from a parsed string argument.
   *
   * @param {string} str The string that will be parsed into a URI object.
   * @throws TypeError If the string argument is not a valid URI, a TypeError will
   *     be thrown.
   * @return {URI} The parsed URI object.
   */
  URI.fromString = function(str) {
    var splitted = _splitIntoComponents(str);
    return _parseFromComponents(splitted.components, splitted.format, splitted.query);
  };

  /**
   * Parses a given object into a URI instance.
   *
   * Unlike URI.fromString, this function could receive any kind of value. If
   * the value is already a URI instance, it is simply returned.
   * Otherwise the value will be stringified before parsing.
   *
   * This function also does not throw an error like URI.fromString, but
   * instead simply returns null if it can't parse the value.
   *
   * @param {*} value The value to parse.
   * @return {URI?} The corresponding URI instance, or null if the
   *     passed value is not a valid value.
   */
  URI.from = function(value) {
    try {
      if (value instanceof URI) {
        return value;
      }
      if (typeof value == 'object' && value.type) {
        return new URI(null, value);
      }
      return URI.fromString(value.toString());
    } catch(e) {
      return null;
    }
  };

  /**
   * Creates a new URI from a bytestring.
   *
   * @param {URI.Type} type The type of the URI.
   * @param {ByteString} idByteString The ID of the URI as a bytestring.
   * @param {Object} opt_args Optional arguments to the URI constructor.
   * @return {URI} The URI object created.
   */
  URI.fromByteString = function(type, idByteString, opt_args) {
    while (idByteString.length != 16) {
      idByteString = String.fromCharCode(0) + idByteString;
    }
    var hexId = '';
    for (var i = 0; i < idByteString.length; i++) {
      var byte = idByteString.charCodeAt(i);
      hexId += Base62.HEX256[byte];
    }
    var id = Base62.fromHex(hexId);
    var args = opt_args || {};
    args.id = id;
    return new URI(type, args);
  };

  /**
   * Clones a given SpotifyURI instance.
   *
   * @param {URI} uri The uri to clone.
   * @return {URI?} An instance of URI.
   */
  URI.clone = function(uri) {
    if (!(uri instanceof URI)) {
      return null;
    }
    return new URI(null, uri);
  };

  /**
   * @deprecated
   */
  URI.getCanonical = function(username) {
    return this.getCanonical(username);
  };

  /**
   * Returns the canonical representation of a username.
   *
   * @param {string} username The username to encode.
   * @return {string} The encoded canonical representation of the username.
   */
  URI.getCanonicalUsername = function(username) {
    return _encodeComponent(username, Format.URI);
  };

  /**
   * Returns the non-canonical representation of a username.
   *
   * @param {string} username The username to encode.
   * @return {string} The unencoded canonical representation of the username.
   */
  URI.getDisplayUsername = function(username) {
    return _decodeComponent(username, Format.URI);
  };

  /**
   * Returns the hex representation of a Base62 encoded id.
   *
   * @param {string} id The base62 encoded id.
   * @return {string} The hex representation of the base62 id.
   */
  URI.idToHex = function(id) {
    if (id.length == 22) {
      return Base62.toHex(id);
    }
    return id;
  };

  /**
   * Returns the base62 representation of a hex encoded id.
   *
   * @param {string} hex The hex encoded id.
   * @return {string} The base62 representation of the id.
   */
  URI.hexToId = function(hex) {
    if (hex.length == 32) {
      return Base62.fromHex(hex);
    }
    return hex;
  };

  /**
   * Creates a new empty URI.
   *
   * @return {URI} The empty URI.
   */
  URI.emptyURI = function() {
    return new URI(URI.Type.EMPTY, {});
  };

  /**
   * Creates a new 'album' type URI.
   *
   * @param {string} id The id of the album.
   * @param {number} disc The disc number of the album.
   * @return {URI} The album URI.
   */
  URI.albumURI = function(id, disc) {
    return new URI(URI.Type.ALBUM, {id: id, disc: disc});
  };

  /**
   * Creates a new 'ad' type URI.
   *
   * @param {string} id The id of the ad.
   * @return {URI} The ad URI.
   */
  URI.adURI = function(id) {
    return new URI(URI.Type.AD, {id: id});
  };

  /**
   * Creates a new 'audiofile' type URI.
   *
   * @param {string} extension The extension of the audiofile.
   * @param {string} id The id of the extension.
   * @return {URI} The audiofile URI.
   */
  URI.audioFileURI = function(extension, id) {
    return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
  };

  /**
   * Creates a new 'artist' type URI.
   *
   * @param {string} id The id of the artist.
   * @return {URI} The artist URI.
   */
  URI.artistURI = function(id) {
    return new URI(URI.Type.ARTIST, {id: id});
  };

  /**
   * Creates a new 'artist-toplist' type URI.
   *
   * @param {string} id The id of the artist.
   * @param {string} toplist The toplist type.
   * @return {URI} The artist-toplist URI.
   */
  URI.artistToplistURI = function(id, toplist) {
    return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
  };

  /**
   * Creates a new 'search' type URI.
   *
   * @param {string} query The unencoded search query.
   * @return {URI} The search URI
   */
  URI.searchURI = function(query) {
    return new URI(URI.Type.SEARCH, {query: query});
  };

  /**
   * Creates a new 'track' type URI.
   *
   * @param {string} id The id of the track.
   * @param {string} anchor The point in the track formatted as mm:ss
   * @return {URI} The track URI.
   */
  URI.trackURI = function(id, anchor, context, play) {
    return new URI(URI.Type.TRACK, {
      id: id,
      anchor: anchor,
      context: context ? URI.fromString(context) : context,
      play: play
    });
  };

  /**
   * Creates a new 'trackset' type URI.
   *
   * @param {Array.<URI>} tracks An array of 'track' type URIs.
   * @param {string} name The name of the trackset.
   * @param {number} index The index in the trackset.
   * @return {URI} The trackset URI.
   */
  URI.tracksetURI = function(tracks, name, index) {
    return new URI(URI.Type.TRACKSET, {
      tracks: tracks,
      name: name || '',
      index: isNaN(index) ? null : index
    });
  };

  /**
   * Creates a new 'facebook' type URI.
   *
   * @param {string} uid The user id.
   * @return {URI} The facebook URI.
   */
  URI.facebookURI = function(uid) {
    return new URI(URI.Type.FACEBOOK, {uid: uid});
  };

  /**
   * Creates a new 'followers' type URI.
   *
   * @param {string} username The non-canonical username.
   * @return {URI} The followers URI.
   */
  URI.followersURI = function(username) {
    return new URI(URI.Type.FOLLOWERS, {username: username});
  };

  /**
   * Creates a new 'following' type URI.
   *
   * @param {string} username The non-canonical username.
   * @return {URI} The following URI.
   */
  URI.followingURI = function(username) {
    return new URI(URI.Type.FOLLOWING, {username: username});
  };

  /**
   * Creates a new 'playlist' type URI.
   *
   * @param {string} username The non-canonical username of the playlist owner.
   * @param {string} id The id of the playlist.
   * @return {URI} The playlist URI.
   */
  URI.playlistURI = function(username, id) {
    return new URI(URI.Type.PLAYLIST, {username: username, id: id});
  };

  /**
   * Creates a new 'playlist-v2' type URI.
   *
   * @param {string} id The id of the playlist.
   * @return {URI} The playlist URI.
   */
  URI.playlistV2URI = function(id) {
    return new URI(URI.Type.PLAYLIST_V2, {id: id});
  };

  /**
   * Creates a new 'folder' type URI.
   *
   * @param {string} username The non-canonical username of the folder owner.
   * @param {string} id The id of the folder.
   * @return {URI} The folder URI.
   */
  URI.folderURI = function(username, id) {
    return new URI(URI.Type.FOLDER, {username: username, id: id});
  };

  /**
   * Creates a new 'collectiontracklist' type URI.
   *
   * @param {string} username The non-canonical username of the collection owner.
   * @param {string} id The id of the tracklist.
   * @return {URI} The collectiontracklist URI.
   */
  URI.collectionTrackList = function(username, id) {
    return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
  };

  /**
   * Creates a new 'starred' type URI.
   *
   * @param {string} username The non-canonical username of the starred list owner.
   * @return {URI} The starred URI.
   */
  URI.starredURI = function(username) {
    return new URI(URI.Type.STARRED, {username: username});
  };

  /**
   * Creates a new 'user-toplist' type URI.
   *
   * @param {string} username The non-canonical username of the toplist owner.
   * @param {string} toplist The toplist type.
   * @return {URI} The user-toplist URI.
   */
  URI.userToplistURI = function(username, toplist) {
    return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
  };

  /**
   * Creates a new 'user-top-tracks' type URI.
   *
   * @deprecated
   * @param {string} username The non-canonical username of the toplist owner.
   * @return {URI} The user-top-tracks URI.
   */
  URI.userTopTracksURI = function(username) {
    return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
  };

  /**
   * Creates a new 'toplist' type URI.
   *
   * @param {string} toplist The toplist type.
   * @param {string} country The country code for the toplist.
   * @param {boolean} global True if this is a global rather than a country list.
   * @return {URI} The toplist URI.
   */
  URI.toplistURI = function(toplist, country, global) {
    return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
  };

  /**
   * Creates a new 'inbox' type URI.
   *
   * @param {string} username The non-canonical username of the inbox owner.
   * @return {URI} The inbox URI.
   */
  URI.inboxURI = function(username) {
    return new URI(URI.Type.INBOX, {username: username});
  };

  /**
   * Creates a new 'rootlist' type URI.
   *
   * @param {string} username The non-canonical username of the rootlist owner.
   * @return {URI} The rootlist URI.
   */
  URI.rootlistURI = function(username) {
    return new URI(URI.Type.ROOTLIST, {username: username});
  };

  /**
   * Creates a new 'published-rootlist' type URI.
   *
   * @param {string} username The non-canonical username of the published-rootlist owner.
   * @return {URI} The published-rootlist URI.
   */
  URI.publishedRootlistURI = function(username) {
    return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
  };

  /**
   * Creates a new 'local-artist' type URI.
   *
   * @param {string} artist The artist name.
   * @return {URI} The local-artist URI.
   */
  URI.localArtistURI = function(artist) {
    return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
  };

  /**
   * Creates a new 'local-album' type URI.
   *
   * @param {string} artist The artist name.
   * @param {string} album The album name.
   * @return {URI} The local-album URI.
   */
  URI.localAlbumURI = function(artist, album) {
    return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
  };

  /**
   * Creates a new 'local' type URI.
   *
   * @param {string} artist The artist name.
   * @param {string} album The album name.
   * @param {string} track The track name.
   * @param {number} duration The track duration in ms.
   * @return {URI} The local URI.
   */
  URI.localURI = function(artist, album, track, duration) {
    return new URI(URI.Type.LOCAL, {
      artist: artist,
      album: album,
      track: track,
      duration: duration
    });
  };

  /**
   * Creates a new 'library' type URI.
   *
   * @param {string} username The non-canonical username of the rootlist owner.
   * @param {string} category The category of the library.
   * @return {URI} The library URI.
   */
  URI.libraryURI = function(username, category) {
    return new URI(URI.Type.LIBRARY, {username: username, category: category});
  };

  /**
   * Creates a new 'collection' type URI.
   *
   * @param {string} username The non-canonical username of the rootlist owner.
   * @param {string} category The category of the collection.
   * @return {URI} The collection URI.
   */
  URI.collectionURI = function(username, category) {
    return new URI(URI.Type.COLLECTION, {username: username, category: category});
  };

  /**
   * Creates a new 'temp-playlist' type URI.
   *
   * @param {string} origin The origin of the temporary playlist.
   * @param {string} data Additional data for the playlist.
   * @return {URI} The temp-playlist URI.
   */
  URI.temporaryPlaylistURI = function(origin, data) {
    return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
  };

  /**
   * Creates a new 'context-group' type URI.
   *
   * @deprecated
   * @param {string} origin The origin of the temporary playlist.
   * @param {string} name The name of the context group.
   * @return {URI} The context-group URI.
   */
  URI.contextGroupURI = function(origin, name) {
    return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
  };

  /**
   * Creates a new 'profile' type URI.
   *
   * @param {string} username The non-canonical username of the rootlist owner.
   * @param {Array.<string>} args A list of arguments.
   * @return {URI} The profile URI.
   */
  URI.profileURI = function(username, args) {
    return new URI(URI.Type.PROFILE, {username: username, args: args});
  };

  /**
   * Creates a new 'image' type URI.
   *
   * @param {string} id The id of the image.
   * @return {URI} The image URI.
   */
  URI.imageURI = function(id) {
    return new URI(URI.Type.IMAGE, {id: id});
  };

  /**
   * Creates a new 'mosaic' type URI.
   *
   * @param {Array.<string>} ids The ids of the mosaic immages.
   * @return {URI} The mosaic URI.
   */
  URI.mosaicURI = function(ids) {
    return new URI(URI.Type.MOSAIC, {ids: ids});
  };

  /**
   * Creates a new 'radio' type URI.
   *
   * @param {string} args The radio seed arguments.
   * @return {URI} The radio URI.
   */
  URI.radioURI = function(args) {
    args = typeof args === 'undefined' ? '' : args;
    return new URI(URI.Type.RADIO, {args: args});
  };

  /**
   * Creates a new 'special' type URI.
   *
   * @param {Array.<string>} args An array containing the other arguments.
   * @return {URI} The special URI.
   */
  URI.specialURI = function(args) {
    args = typeof args === 'undefined' ? [] : args;
    return new URI(URI.Type.SPECIAL, {args: args});
  };

  /**
   * Creates a new 'station' type URI.
   *
   * @param {Array.<string>} args An array of arguments for the station.
   * @return {URI} The station URI.
   */
  URI.stationURI = function(args) {
    args = typeof args === 'undefined' ? [] : args;
    return new URI(URI.Type.STATION, {args: args});
  };

  /**
   * Creates a new 'application' type URI.
   *
   * @param {string} id The id of the application.
   * @param {Array.<string>} args An array containing the arguments to the app.
   * @return {URI} The application URI.
   */
  URI.applicationURI = function(id, args) {
    args = typeof args === 'undefined' ? [] : args;
    return new URI(URI.Type.APPLICATION, {id: id, args: args});
  };

  /**
   * Creates a new 'collection-album' type URI.
   *
   * @param {string} username The non-canonical username of the rootlist owner.
   * @param {string} id The id of the album.
   * @return {URI} The collection-album URI.
   */
  URI.collectionAlbumURI = function(username, id) {
    return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
  };

  /**
   * Creates a new 'collection-album-missing' type URI.
   *
   * @param {string} username The non-canonical username of the rootlist owner.
   * @param {string} id The id of the album.
   * @return {URI} The collection-album-missing URI.
   */
  URI.collectionMissingAlbumURI = function(username, id) {
    return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
  };

  /**
   * Creates a new 'collection-artist' type URI.
   *
   * @param {string} username The non-canonical username of the rootlist owner.
   * @param {string} id The id of the artist.
   * @return {URI} The collection-artist URI.
   */
  URI.collectionArtistURI = function(username, id) {
    return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
  };

  /**
   * Creates a new 'episode' type URI.
   *
   * @param {string} id The id of the episode.
   * @param {string} context An optional context URI
   * @param {boolean} play Toggles autoplay in the episode URI
   * @return {URI} The episode URI.
   */
  URI.episodeURI = function(id, context, play) {
    return new URI(URI.Type.EPISODE, {
      id: id,
      context: context ? URI.fromString(context) : context,
      play: play
    });
  };

  /**
   * Creates a new 'show' type URI.
   *
   * @param {string} id The id of the show.
   * @return {URI} The show URI.
   */
  URI.showURI = function(id) {
    return new URI(URI.Type.SHOW, {id: id});
  };

  /**
   * Creates a new 'concert' type URI.
   *
   * @param {string} id The id of the concert.
   * @return {URI} The concert URI.
   */
  URI.concertURI = function(id) {
    return new URI(URI.Type.CONCERT, {id: id});
  };

  URI.isAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ALBUM; };
  URI.isAd = function(uri) { return (URI.from(uri) || {}).type === URI.Type.AD; };
  URI.isApplication = function(uri) { return (URI.from(uri) || {}).type === URI.Type.APPLICATION; };
  URI.isArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ARTIST; };
  URI.isCollection = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION; };
  URI.isCollectionAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION_ALBUM; };
  URI.isCollectionArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.COLLECTION_ARTIST; };
  URI.isEpisode = function(uri) { return (URI.from(uri) || {}).type === URI.Type.EPISODE; };
  URI.isFacebook = function(uri) { return (URI.from(uri) || {}).type === URI.Type.FACEBOOK; };
  URI.isFolder = function(uri) { return (URI.from(uri) || {}).type === URI.Type.FOLDER; };
  URI.isLocalArtist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL_ARTIST; };
  URI.isLocalAlbum = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL_ALBUM; };
  URI.isLocalTrack = function(uri) { return (URI.from(uri) || {}).type === URI.Type.LOCAL; };
  URI.isMosaic = function(uri) { return (URI.from(uri) || {}).type === URI.Type.MOSAIC; };
  URI.isPlaylistV1 = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PLAYLIST; };
  URI.isPlaylistV2 = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PLAYLIST_V2; };
  URI.isRadio = function(uri) { return (URI.from(uri) || {}).type === URI.Type.RADIO; };
  URI.isRootlist = function(uri) { return (URI.from(uri) || {}).type === URI.Type.ROOTLIST; };
  URI.isSearch = function(uri) { return (URI.from(uri) || {}).type === URI.Type.SEARCH; };
  URI.isShow = function(uri) { return (URI.from(uri) || {}).type === URI.Type.SHOW; };
  URI.isConcert = function(uri) { return (URI.from(uri) || {}).type === URI.Type.CONCERT; };
  URI.isStation = function(uri) { return (URI.from(uri) || {}).type === URI.Type.STATION; };
  URI.isTrack = function(uri) { return (URI.from(uri) || {}).type === URI.Type.TRACK; };
  URI.isProfile = function(uri) { return (URI.from(uri) || {}).type === URI.Type.PROFILE; };
  URI.isPlaylistV1OrV2 = function(uri) {
    var uriObject = URI.from(uri);
    return !!uriObject && (uriObject.type === URI.Type.PLAYLIST || uriObject.type === URI.Type.PLAYLIST_V2);
  };

  /**
   * Export public interface
   */
  module.exports = URI;

  },{"./base62":1281}],1283:[function(require,module,exports){
  var v2 = require('./v2');

  exports.v2 = v2;

  /**
   * Export the current version of the player API
   */
  for (var key in v2) {
    exports[key] = v2[key];
  }

  },{"./v2":1284}],1284:[function(require,module,exports){
  var player = require("./player");
  var types = require("./types");
  var play = require("./play");
  var play_history = require("./play_history");

  exports.Play = play.Play;
  exports.Player = player.Player;
  exports.PlayHistory = play_history.PlayHistory;
  exports.PlayerContext = types.Context;
  exports.PlayOptions = types.PlayOptions;
  exports.PlayerRestrictions = types.Restrictions;
  exports.PlayerSuppressions = types.Suppressions;
  exports.PlayerTrack = types.Track;
  exports.PlayerContextPage = types.ContextPage;
  exports.IndexPath = types.IndexPath;

  },{"./play":1285,"./play_history":1286,"./player":1287,"./types":1288}],1285:[function(require,module,exports){
  var cosmos = require('spotify-cosmos-api');
  var nodefn = require('when/node');

  /**
   * Play is exposed as Player.Play. It represents a prepared playback action.
   * Play objects are obtained from the preparePlay method on the Player; the
   * constructor is not a public API.
   *
   * Instantiating a Play object does not make a Cosmos request, the caller is
   * expected to make that call and pass in a promise of the result in the
   * createSessionPromise parameter.
   *
   * @param {Cosmos.resolver} resolver The resolver to send requests to.
   * @param {Promise} createSessionPromise A promise of a Cosmos.Response for
   *     the call to sp://player/v2/xyz/session.
   * @param {Player} player The player that initiated the call.
   * @param {function()=Number} getTime Clock. Should usually return
   *     new Date().getTime()
   * @param {module:spotify-player/types.Context} The context that was passed
   *     to the preparePlay call.
   * @param {Cosmos.PlayOptions=} opt_options The options that were passed to
   *     the preparePlay call.
   */
  function Play(resolver, createSessionPromise, player, getTime, context, opt_options) {
    if (!(this instanceof Play)) {
      return new Play(resolver, createSessionPromise, player, getTime, context, opt_options);
    }

    if (!resolver || !createSessionPromise || !player || !getTime || !context) {
      throw new TypeError('Missing parameters for Play');
    }

    /**
     * @type {Cosmos.resolver}
     */
    this._resolver = resolver;

    /**
     * @type {Promise}
     */
    this._createSessionPromise = createSessionPromise;

    /**
     * @type {Player}
     */
    this._player = player;

    /**
     * @type {function()=Number}
     */
    this._getTime = getTime;

    /**
     * @type {module:spotify-player/types.Context}
     */
    this._context = context;

    /**
     * @type {Cosmos.PlayOptions=}
     */
    this._opt_options = opt_options;
  }

  /**
   * @return Promise of the session URL
   */
  Play.prototype._sessionUrl = function() {
    return this._createSessionPromise.then(function(response) {
      return response.getJSONBody().session;
    });
  };

  Play.prototype._createPlayRequest = function(sessionUrl) {
    var body = {
      logging_params: {
        command_initiated_time: this._getTime()
      }
    };
    return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/play', null, body);
  };

  Play.prototype._createUpdateRequest = function(sessionUrl, body) {
    body.logging_params = {
      command_initiated_time: this._getTime()
    };
    return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/update', null, body);
  };

  /**
   * Perform the playback action that this handle represents.
   *
   * It is legal to call play more than once, but the playback action is only
   * prefetched the first time. If subsequent preparation is required, a new
   * Play object should be obtained.
   */
  Play.prototype.play = function(opt_callback) {
    opt_callback = opt_callback || function() {};

    var self = this;
    if (this._createSessionPromise) {
      this._sessionUrl()
        .then(function(sessionUrl) {
          return nodefn.call(
            self._resolver.resolve.bind(self._resolver), self._createPlayRequest(sessionUrl));
        })
        .done(function() {
            opt_callback(null);
          }, function(error) {
            if (error.response && error.response.getStatusCode() === 404) {
              // The session has been invalidated. Try again without prefetching.
              self._createSessionPromise = null;
              self.play(opt_callback);
            } else {
              var wrappedError = new Error('Failed to prepare player session: ' + error.message);
              wrappedError.cause = function() { return error; };
              opt_callback(wrappedError);
            }
          });
    } else {
      this._player.play(this._context, this._opt_options, opt_callback);
    }
  };

  Play.prototype._update = function(body, opt_callback) {
    opt_callback = opt_callback || function() {};

    var self = this;
    if (!this._createSessionPromise) {
      return opt_callback(new Error('Cannot update invalidated Play'));
    }

    this._sessionUrl()
      .then(function(sessionUrl) {
        return nodefn.call(
          self._resolver.resolve.bind(self._resolver), self._createUpdateRequest(sessionUrl, body));
      })
      .done(function() {
          opt_callback(null);
        }, function(error) {
          var wrappedError = new Error('Failed to update player session: ' + error.message);
          wrappedError.cause = function() { return error; };
          opt_callback(wrappedError);
        });
  };

  Play.prototype.updateContext = function(context, opt_callback) {
    this._update({ context: context }, opt_callback);
  };

  Play.prototype.updatePage = function(page, opt_callback) {
    this._update({ page: page }, opt_callback);
  };

  Play.prototype.updateTrack = function(track, opt_callback) {
    this._update({ track: track }, opt_callback);
  };

  Play.prototype.updateViewUri = function(view_uri, opt_callback) {
    this._update({ view_uri: view_uri }, opt_callback);
  };

  /**
   * Invalidate the handle. This will cause any ongoing prefetching work to be
   * cancelled. It is good if any holder of a handle calls this method as soon
   * as it knows that it is not interested in its play action anymore.
   *
   * It is illegal to call play after this has been called. Invalidating an
   * invalidated Play is a no-op.
   */
  Play.prototype.invalidate = function(opt_callback) {
    if (!this._createSessionPromise) {
      // Already invalidated
      return;
    }

    opt_callback = opt_callback || function() {};

    var self = this;
    this._sessionUrl().done(function(sessionUrl) {
      var request = new cosmos.Request(
        cosmos.Action.DELETE, sessionUrl, null, null);
      self._resolver.resolve(request, function() {
        opt_callback(null);
      });
    }, function() {
      // Ignore errors
      opt_callback(null);
    });

    this._createSessionPromise = null;
  };

  exports.Play = Play;

  },{"spotify-cosmos-api":1294,"when/node":1322}],1286:[function(require,module,exports){
  var cosmos = require('spotify-cosmos-api');

  var PLAY_HISTORY_URI = 'sp://play-history/v1';

  function PlayHistory(resolver) {
    if (!(this instanceof PlayHistory)) {
      return new PlayHistory(resolver);
    }

    if (!resolver) {
      throw new TypeError('Missing resolver for PlayHistory');
    }

    /**
     * @type {Cosmos.resolver}
     */
    this._resolver = resolver;
  }

  /**
   * Gets the tracks in the play history.
   *
   * @param {function(Error, Cosmos.Response=)} callback The function
   *    that will be called when the queue is available.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  PlayHistory.prototype.get = function(callback) {
    var request = new cosmos.Request(cosmos.Action.GET, PLAY_HISTORY_URI);
    return this._resolver.resolve(request, callback);
  };

  /**
   * Subscribe to play history. There will be an initial callback when subscribing.
   *
   * @param {function(Error, Cosmos.Response=)} callback The function
   *    that will be called when the queue changes.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
   PlayHistory.prototype.subscribe = function(callback) {
    var request = new cosmos.Request(cosmos.Action.SUB, PLAY_HISTORY_URI);
    return this._resolver.resolve(request, callback);
  };

  exports.PlayHistory = PlayHistory;

  },{"spotify-cosmos-api":1294}],1287:[function(require,module,exports){
  var cosmos = require('spotify-cosmos-api');
  var nodefn = require('when/node');
  var play = require('./play');

  var PLAYER_URI = 'sp://player/v2/';
  var DEFAULT_PLAYER_ID = 'main';

  /**
   * The object decribing the context for the playback
   * Can be used to pass viewUri or externalReferrer specific
   * for the play action.
   *
   * @typedef {Object} ContextConfig
   * @property {Cosmos.PlayerContext} context The context to play
   * @property {string=} opt_viewId Optional. Set to override the default viewUri
   * @property {string=} opt_externalReferrer Optional. Set to indicate that
   *      the playback is owne by external website/app.
   */

  /**
   * Player is the main entry point to control music playback with cosmos.
   *
   * Player in itself isn't what deals with playback; it is merely an object
   * that controls playback and provides ability to observe the player state.
   * There can be more than one Player object at the same time, and they
   * will sync up as one would expect.
   *
   * In practice there will be at least one Player object per feature that
   * wants to control playback. The feature can choose to create one per view
   * or have only one object, it doesn't really matter.
   *
   * @param {Cosmos.resolver} resolver The resolver to send requests to.
   * @param {String} viewUri The uri of the view that owns the playback.
   * @param {String} featureIdentifier The identifier of the feature that started
   *     playback. This is arguably the most important field of this class. It is
   *     used for logging messages, in particular EndSong and EndVideo. (In EndSong,
   *     it ends up in source_start / source_end.) It should be a short human
   *     readable name of the feature, for example "radio", "album", "playlist".
   *     Ideally, it should be the same for a given feature across platforms.
   *
   *     Each feature should have only one string constant that it passes in here.
   *     You must not pass lots of distinct values here; for instance do not send
   *     something that contains the username or artist identifier.
   * @param {String} featureVersion The version of the feature. It often makes sense to set
   *     this value to the version of the spm package, for instance "0.7.5".
   * @param {{playerId: string}} opt_options The additional parameters for the player.
   *  param {string} options.playerId Can be used to override the id of the player
   *      which will result in a different endpoint for the player requests.
   */
  function Player(resolver, viewUri, featureIdentifier, featureVersion, opt_options) {
    if (!(this instanceof Player)) {
      return new Player(resolver, viewUri, featureIdentifier, featureVersion);
    }

    if (!resolver || !viewUri || !featureIdentifier || !featureVersion) {
      throw new TypeError('Missing parameters for Player');
    }

    this._getTime = opt_options && opt_options.getTime || function() {
      return new Date().getTime();
    };

    /**
     * @type {string}
     */
    this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

    /**
     * @type {string}
     */
    this._referrerIdentifier = opt_options && opt_options.referrerIdentifier;

    /**
     * @type {Cosmos.resolver}
     */
    this._resolver = resolver;

    /**
     * @type {string}
     */
    this._viewUri = viewUri;

    /**
     * @type {string}
     */
    this._featureId = featureIdentifier;

    /**
     * @type {string}
     */
    this._featureVersion = featureVersion;
  }

  /**
   * The actions that can be understood by the PlayerResolver
   * in Cosmos Router.
   */
  Player.Actions = {
    PROBE_PLAY: 'probe_play',
    PLAY: 'play',
    SESSION: 'session',
    STOP: 'stop',
    UPDATE: 'update',
    PAUSE: 'pause',
    RESUME: 'resume',
    SKIP_NEXT: 'skip_next',
    SKIP_PREV: 'skip_prev',
    SHUFFLE: 'set_shuffling_context',
    REPEAT_CONTEXT: 'set_repeating_context',
    REPEAT_TRACK: 'set_repeating_track',
    SEEK_TO: 'seek_to'
  };

  /**
   * Private helper method for probe_play, play, and preparePlay
   */
  Player.prototype._playOrPrepareOrProbe = function(action, context, opt_options, opt_callback) {
    if (!context) {
      throw new TypeError('Invalid `context` object');
    }

    // Allow to not send the opt_options
    if (opt_options instanceof Function && !opt_callback) {
      opt_callback = opt_options;
      opt_options = null;
    }

    var params = {};
    params.context = context;
    params.play_origin = this._makePlayOrigin();
    params.options = opt_options;

    return this._sendRequestWithParams(action, params, opt_callback);
  };

  /**
   * Add a track to the manually queued tracks.
   *
   * @param {module:spotify-player/types.Track} track The track to add to the queue.
   * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.addToQueue = function(track, opt_callback) {
    if (!track) {
      throw new TypeError('Invalid `track` object');
    }
    return this._sendRequestWithParams('add_to_queue', { track: track }, opt_callback);
  };

  /**
   * Asks the player if the given context is allowed to be played. This presents
   * the same API as play, but it will not actually initiate playback. Rather the
   * response status code will indicate if playback is permitted (200 OK) or not
   * (403 Forbidden).
   *
   * @see {@link Player#play}
   */
  Player.prototype.probePlay = function(context, opt_options, opt_callback) {
    return this._playOrPrepareOrProbe(Player.Actions.PROBE_PLAY, context, opt_options, opt_callback);
  };

  /**
   * Plays the given context.
   * Since both options and callback are optional this method can
   * take from 1 to 3 arguments. if callback is specified, it has to be
   * the last argument:
   *
   *    player.play(myContext);
   *    player.play(myContext, myPlayOptions);
   *    player.play(myContext, function myCallback() {});
   *    player.play(myContext, myPlayOptions, function myCallback() {});
   *
   * @param {module:spotify-player/types.Context} context The context to play.
   * @param {Cosmos.PlayOptions=} opt_options Optional play options.
   * @param {function(Error, Cosmos.Response?)=} opt_callback Optional
   *    callback that will be executed after player request is resolved.
   *
   *    NOTE: The reponse in the callback only has information about the
   *    request itself (i.e. if it was resolved correctly). If you want to have
   *    information about currently playing context you should subscribe to
   *    player events or fetch the current state using. getContext.
   *
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.play = function(context, opt_options, opt_callback) {
    return this._playOrPrepareOrProbe(Player.Actions.PLAY, context, opt_options, opt_callback);
  };

  /**
   * This method is like play, but it doesn't actually initiate playback, it
   * merely expresses intent that the user is rather likely going to do a play
   * action like this soon.
   *
   * @return {Player.Play} A handle that is used for actually performing the
   *     playback action. When the object will no longer be used, the user is
   *     responsible for calling invalidate on it, otherwise it will keep
   *     holding resources. As long as this object is not invalidated, the
   *     playback system will take that as a hint that it should try to prepare
   *     playback like this.
   */
  Player.prototype.preparePlay = function(context, opt_options) {
    var sessionPromise = nodefn.call(
      this._playOrPrepareOrProbe.bind(this), Player.Actions.SESSION, context, opt_options);

    return new play.Play(this._resolver, sessionPromise, this, this._getTime, context, opt_options);
  };

  /**
   * Stop the playback and clear the context.
   *
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.stop = function(opt_callback) {
    return this._sendRequestWithAction(Player.Actions.STOP, opt_callback);
  };

  /**
   * Update the current context.
   * Deprecated, use update functions for handle returned by preparePlay instead.
   *
   * @param {module:spotify-player/types.Context} context The context to update to.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.update = function(context, opt_callback) {
    if (!context) {
      throw new TypeError('Invalid `context` object');
    }
    var params = { context: context };
    return this._sendRequestWithParams(Player.Actions.UPDATE, params, opt_callback);
  };

  /**
   * Resume the playback.
   *
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.resume = function(opt_callback) {
    return this._sendRequestWithAction(Player.Actions.RESUME, opt_callback);
  };

  /**
   * Pause the playback.
   *
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.pause = function(opt_callback) {
    return this._sendRequestWithAction(Player.Actions.PAUSE, opt_callback);
  };

  /**
   * Skip to the previous song.
   *
   * @param {Object=} opt_skip_options The object with the skip options
   *    like allow_seeking
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.skipToPrevTrack = function(opt_skip_options, opt_callback) {
    if (arguments.length === 1) {
      // In order to keep backwards compatibility we still need to support
      // passing just the callback as the first parameter
      if (typeof opt_skip_options === 'function') {
        opt_callback = opt_skip_options;
        opt_skip_options = null;
      }
    }
    var params = {};
    if (opt_skip_options) {
      params.options = opt_skip_options;
    }
    return this._sendRequestWithParams(Player.Actions.SKIP_PREV, params, opt_callback);
  };

  /**
   * Skip to the next song.
   *
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.skipToNextTrack = function(opt_options, opt_callback) {
    if (arguments.length === 1) {
      // In order to keep backwards compatibility we still need to support
      // passing just the callback as the first parameter
      if (typeof opt_options === 'function') {
        opt_callback = opt_options;
        opt_options = null;
      }
    }
    var params = {};
    if (opt_options) {
      params.options = opt_options;
    }
    return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, params, opt_callback);
  };

  /**
   * Skip backwards until it gets to the specified track. This method never skips
   * to the beginning of the current track. For that, use seekTo.
   *
   * @discussion If the reverse runs out of tracks or skipping becomes disallowed
   *    for some other reason, this method will give up when it can no longer
   *    continue. This means that calling this for MFT users will almost
   *    certainly be a bad idea.
   *
   *    The intended purpose of this method is to make it possible to implement
   *    a view of the current future/reverse and allow the user to skip in it.
   *
   *    This method will look at the track URI and the track's UID (if present)
   *    to determine when it has reached its goal.
   *
   * @param {Object} track The track object, as it was provided from the
   *    player state reverse.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.skipToSpecificPrevTrack = function(track, opt_callback) {
    return this._sendRequestWithParams(Player.Actions.SKIP_PREV, { track: track }, opt_callback);
  };

  /**
   * Skip forwards until it gets to the specified track.
   *
   * @discussion See discussion for -skipToPreviousTrack:
   *
   * @param {Object} track The track object, as it was provided from the
   *    player state reverse.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.skipToSpecificNextTrack = function(track, opt_callback) {
    return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, { track: track }, opt_callback);
  };

  /**
   * Deprecated alias for skipToPrevTrack
   */
  Player.prototype.skipToPrev = Player.prototype.skipToPrevTrack;

  /**
   * Deprecated alias for skipToNextTrack
   */
  Player.prototype.skipToNext = Player.prototype.skipToNextTrack;

  /**
   * Set the shuffle flag
   *
   * @param {boolean} isShuffling The value of the flag to set.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.setShufflingContext = function(isShuffling, opt_callback) {
    return this._sendRequestWithParam(Player.Actions.SHUFFLE, isShuffling, opt_callback);
  };

  /**
   * Repeat the whole context
   *
   * @param {boolean} isRepeating The value of the flag to set.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.setRepeatingContext = function(isRepeating, opt_callback) {
    return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT, isRepeating, opt_callback);
  };

  /**
   * Repeat the single track
   *
   * @param {boolean} isRepeating The value of the flag to set.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.setRepeatingTrack = function(isRepeating, opt_callback) {
    return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK, isRepeating, opt_callback);
  };

  /**
   * Set the seek position. It should be set in seconds.
   *
   * @param {boolean} positionInMs Position to seek to in miliseconds.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.seekTo = function(positionInMs, opt_callback) {
    return this._sendRequestWithParam(Player.Actions.SEEK_TO, positionInMs, opt_callback);
  };

  /**
   * Gets the current player state as an opaque string that can later be used to restore the
   * current state.
   *
   * @param {function(Error, Cosmos.Response=)} callback The function
   *    that will be called when the snapshot is available.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.save = function(callback) {
    var requestUri = this.getPlayerEndpointUri() + '/snapshot';
    var request = new cosmos.Request(cosmos.Action.GET, requestUri);
    return this._resolver.resolve(request, callback);
  };

  /**
   * Restores a state string that was previously saved by save().
   *
   * @param {string} state The state to restore.
   * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.restore = function(state, opt_callback) {
    var requestUri = this.getPlayerEndpointUri() + '/snapshot';
    var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
    return this._resolver.resolve(request, opt_callback);
  };

  /**
   * Gets the current player queue as an string that can later be modified to replace
   * the current queue.
   *
   * @param {function(Error, Cosmos.Response=)} callback The function
   *    that will be called when the queue is available.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */

  Player.prototype.getQueue = function(callback) {
    var requestUri = this.getPlayerEndpointUri() + '/queue';
    var request = new cosmos.Request(cosmos.Action.GET, requestUri);
    return this._resolver.resolve(request, callback);
  };

  /**
   * Replace the player queue. The state will not replace the current one of the player if
   * the revision does not match the current revision of the player. This happens when
   * the player queue was changed elsewhere by the time it was received until it was set.
   * A response-status of 409 will inform about this situation.
   *
   * @param {string} state The queue-state to replace with.
   * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.setQueue = function(state, opt_callback) {
    var requestUri = this.getPlayerEndpointUri() + '/queue';
    var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
    return this._resolver.resolve(request, opt_callback);
  };

  /**
   * Subscribe to queue changes. There will be an initial callback when subscribing.
   */
  Player.prototype.subscribeToQueue = function(callback) {
    var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/queue');
    return this._resolver.resolve(request, callback);
  };

  /**
   * Get the current player state.
   *
   * @param {function(Error, Cosmos.Response=)} callback The function
   *    that will be called when the state is available.
   * @param {Object=} opt_params The additional parameters for the request.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype.getState = function(callback, opt_params) {
    var request = new cosmos.Request(
      cosmos.Action.GET, this.getPlayerEndpointUriWithParams(opt_params));
    return this._resolver.resolve(request, callback);
  };

  /**
   * Subscribe to the player events
   *
   * @param {function(Error, Cosmos.Response=)} callback The function
   *    that will be called every time the event occurs.
   * @param {Object=} opt_params The additional parameters for the request.
   * @return {RequestHandle} The subscription handle.
   *
   *    This object can be used to cancel the subscription
   *    by calling 'cancel()' on it:
   *
   *    var sub = player.subscribe(function(err, response) { });
   *    sub.cancel();
   */
  Player.prototype.subscribe = function(callback, opt_params) {
    var request = new cosmos.Request(
      cosmos.Action.SUB, this.getPlayerEndpointUriWithParams(opt_params));
    return this._resolver.resolve(request, callback);
  };

  /**
   * Subscribe to player error events
   */
  Player.prototype.onError = function(callback) {
    var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/error');
    return this._resolver.resolve(request, callback);
  };

  Player.prototype._makePlayOrigin = function() {
    return {
      view_uri: this._viewUri,
      feature_identifier: this._featureId,
      feature_version: this._featureVersion,
      referrer_identifier: this._referrerIdentifier
    };
  };

  Player.prototype.getPlayerEndpointUri = function() {
    return PLAYER_URI + this._id;
  };

  Player.prototype.getPlayerEndpointUriWithParams = function(params) {
    params = params || {};

    var paramsArray = Object.keys(params).reduce(function(arr, key) {
      arr.push(key + '=' + encodeURIComponent(params[key]));
      return arr;
    }, []);

    if (paramsArray.length > 0) {
      return this.getPlayerEndpointUri() + '?' + paramsArray.join('&');
    } else {
      return this.getPlayerEndpointUri();
    }
  };

  /**
   * @private
   * Sends context-less request.
   *
   * @param {string} action The action to perform on the player.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype._sendRequestWithAction = function(action, opt_callback) {
    return this._sendRequestWithParams(action, null, opt_callback);
  };

  /**
   * @private
   * Sends the request that only expects the single value in the body.
   *
   * @param {string} action The action to perform on the player.
   * @param {*} paramValue The value to send to the player.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype._sendRequestWithParam = function(action, paramValue, opt_callback) {
    var params = {
      value: paramValue
    };
    return this._sendRequestWithParams(action, params, opt_callback);
  };

  /**
   * @private
   * Sends request with context and optional options.
   *
   * @param {string} action The action to perform on the player.
   * @param {Object?} params The context to play.
   * @param {function=} opt_callback If specified will be executed
   *    after request is resolved.
   * @return {Cosmos.RequestHandler} The object representing current request.
   */
  Player.prototype._sendRequestWithParams = function(action, params, opt_callback) {
    var requestUri = this.getPlayerEndpointUri() + '/' + action;
    var body = params || {};
    body.logging_params = {
      command_initiated_time: this._getTime()
    };
    var request = new cosmos.Request(
      cosmos.Action.POST, requestUri, null, body);
    return this._resolver.resolve(request, opt_callback);
  };

  exports.Player = Player;

  },{"./play":1285,"spotify-cosmos-api":1294,"when/node":1322}],1288:[function(require,module,exports){
  /**
   * A PlayerTrack represents a single track in a context.
   *
   * @typedef {Object}
   * @property {String} uri
   *    The URI of the track. This will be one of the Spotify URIs, such as
   *    spotify:track:GID or spotify:local:DATA.
   * @property {String} album_uri
   *    The URI of the album that the track appears on. This property must always
   *    be set if the track URI is set. This is a requirement so that functions
   *    like MFT rules and biased shuffle can operate without having to fetch
   *    additional metadata for each track.
   * @property {String} artist_uri
   *    The URI of the main artist of the track. This property must always be set
   *    if the track URI is set. This is a requirement so that functions like MFT
   *    rules and biased shuffle can operate without having to fetch additional
   *    metadata for each track.
   * @property {Object} metadata
   *    A map with custom metadata for the track. This map can hold anything that
   *    the feature decides to put in it. Features should be prepared that the
   *    metadata can disappear and be able to work around that situation.
   *    The metadata is passed around and persisted, so it will usually stick
   *    around, but there are certain situations where the data is lost because of
   *    transferring the track over legacy protocols, to Connect enabled speakers
   *    and back.
   */
  exports.Track;

  /**
   * PlayerRestrictions is used to encapsulate limitations of a player or a
   * context. The caller can specify that restrictions should apply when playing a
   * given context (see PlayerContext.restrictions), and a player can notify that
   * restrictions (see PlayState.restrictions).
   *
   * @typedef {Object}
   * @property {Array.<String>} disallow_skipping_prev_reasons
   *    The reasons why skipping to the previous track should be / is disallowed.
   * @property {Array.<String>} disallow_skipping_next_reasons
   *    The reasons why skipping to the next track should be / is disallowed.
   * @property {Array.<String>} disallow_peeking_prev_reasons
   *    The reasons why peeking at the previous track should be / is disallowed.
   * @property {Array.<String>} disallow_peeking_next_reasons
   *    The reasons why peeking at the next track should be / is disallowed.
   * @property {Array.<String>} disallow_skipping_to_reasons
   *    The reasons why skipping to a specific track should be / is disallowed.
   * @property {Array.<String>} disallow_pausing_reasons
   *    The reasons why pausing playback should be / is disallowed.
   * @property {Array.<String>} disallow_resuming_reasons
   *    The reasons why resuming playback should be / is disallowed.
   * @property {Array.<String>} disallow_toggling_repeat_context_reasons
   *    The reasons why toggling repeat context should be / is disallowed.
   * @property {Array.<String>} disallow_toggling_repeat_track_reasons
   *    The reasons why toggling repeat track should be / is disallowed.
   * @property {Array.<String>} disallow_toggling_shuffle_reasons
   *    The reasons why toggling shuffle should be / is disallowed.
   * @property {Array.<String>} disallow_seeking_reasons
   *    The reasons why seeking within a track should be / is disallowed.
   * @property {Array.<String>} disallow_muting_reasons
   *    The reasons why muting audio should be / is disallowed.
   */
  exports.Restrictions;

  /**
   * PlayerSuppressions are used to disable certain player rules while playing a
   * context. The caller can specify that suppressions should apply when playing a
   * context (see PlayerOptions.suppressions), and a player can notify those
   * suppressions (see PlayState.suppressions).
   *
   * @typedef {Object}
   * @property {Array.<String>} providers
   *    The provider identifiers of the rules that should be disabled.
   */
  exports.Suppressions;

  /**
   * An object representing the index of the track to play within a context.
   * In the simplest case there is only one page thus its index should be 0.
   *
   * @typedef {Object}
   * @property {Number} page The index of the page to find the track in.
   * @property {Number} track The index of the track in the page.
   */
  exports.IndexPath;

  /**
   * This structure holds options that should be applied to the player: they are
   * either specified at a global or per-context level. When they are specified
   * globally, finishing the current context or starting to play a new context
   * does not change the player options: specifying them at a context-level means
   * that the previous global setting will be restored when the player is asked to
   * play another context.
   *
   * @typedef {Object}
   * @property {Boolean} shuffling_context
   *    Specifies if the player should shuffle the context or not.
   * @property {Boolean} repeating_context
   *    Specifies if the player should repeat the context or not.
   * @property {Boolean} repeating_track
   *    Specifies if the player should repeat the current track or not.
   */
  exports.PlayerOptions;

  /**
   * Options for a specific playback request. This object can specify for instance
   * which track to play within the given context, where to seek within the track
   * etc.
   *
   * @typedef {Object}
   * @property {module:spotify-player/types.IndexPath} skip_to_index
   *    The index in the context to start playing from. It is possible to specify
   *    a page that is not yet loaded, in which case the page will be downloaded
   *    before playback starts. The context player state will indicate that the
   *    playback is delayed because of loading the page.
   * @property {Number} seek_to
   *    The number of milliseconds to seek into the track when starting to
   *    play it.
   * @property {Boolean} initially_paused
   *    When this property is set, the context player will load the context but
   *    will not start playing audio for the first track. The is_paused property
   *    is set in the context player state to indicate that playback is paused. To
   *    start playing the track, call the `resume` method on the context player.
   * @property {module:spotify-player/types.PlayerOptions} player_options_override
   *    Use this to temporarily override the player options for this play request
   *    only. This can for instance be used to implement shuffle play buttons that
   *    enable shuffling but only for this particular context.
   */
  exports.PlayOptions;

  /**
   * Allows the list of tracks that will be played to be split up into chunks.
   * Pages may loaded or unloaded: an unloaded page will be loaded by the player
   * when it needs more tracks to play.
   *
   * @typedef {Object}
   * @property {String} page_url
   *     The URL of this page. If this property is set to a valid URL, it will be
   *     used to fetch the tracks of the page. The URL must be something that is
   *     supported by the context page loader in use, e.g., Hermes endpoints or
   *     Spotify playlist URIs. In the latter case, the context page loader will
   *     trigger the loaded signal each time the underlying playlist changes. If
   *     the tracks for the (static) context page are already provided in the
   *     tracks property, the page is considered loaded and the URL can be left
   *     empty.
   * @property {String} next_page_url
   *     The URL of the next context page. When the context page is stored in a
   *     context, the next page URL will be used to automatically append new pages
   *     at the end of the pages (or the fallback page) array. The new page
   *     will have its page URL set according to the next page URL of the last
   *     page in the context. The context page loaded will be used at some point
   *     to fetch the tracks for the new page. When the new page is fetched from
   *     the backend, it can also have the next page URL set, and yet another page
   *     is added to the context.
   * @property {Array<module:spotify-player/types.Track>} tracks
   *     An optional array with the tracks of this context page. When the context
   *     page is not loaded, the property is not initialized, and a context page
   *     loader will be used to fetch a loaded version of the page. In a loaded
   *     page this property will be set to an array of tracks. Note that the array
   *     can be empty, which means that the page does not have any tracks. This is
   *     not the same as a page that is not loaded, which may or may not have
   *     tracks.
   */
  exports.ContextPage;

  /**
   * Describes a set of tracks to be played.
   *
   * @typedef {Object}
   * @property {String} entity_uri
   *    An optional Spotify URI that represents what this entire context contains.
   *    For established entities like playlist, album, artist, this should be their
   *    respective URIs. This can be used for inter-feature playback status
   *    indication.
   *
   *    For instance, when the search page starts to play an artist, it should
   *    provide the artist URI in this field. The playback status indication for
   *    that artist in the search result list should be set if the current context
   *    entity URI matches the artist URI. On the artist page, the artist play
   *    button should also look at the entity URI for playback indication.
   * @property {Object} metadata
   *    A map with custom metadata for the track. This map can hold anything that
   *    the feature decides to put in it. Features should be prepared that the
   *    metadata can disappear and be able to work around that situation.
   *    The metadata is passed around and persisted, so it will usually stick
   *    around, but there are certain situations where the data is lost because of
   *    transferring the track over legacy protocols, to Connect enabled speakers
   *    and back.
   * @property {Array<module:spotify-player/types.ContextPage>} pages
   *    An array of context pages that contain the tracks that should be played
   *    for this context. The context pages may or may not be loaded when passing
   *    the context to the player for playback. Note that if the last context page
   *    has a next page URL, at some point a new context page will be added to the
   *    end of the array, for that page URL. This will happen when playback is
   *    nearing the end of the available context pages.
   * @property {module:spotify-player/types.Restricitions} restrictions
   *    The restrictons that should be applied to the player when playing tracks
   *    from the context, e.g., whether the user is allowed to skip backward and
   *    forward in the context or enable shuffling and repeating. Note that the
   *    actual restrictions of the player at any given moment is decided not only
   *    by the context restrictions but also by the rules that are applied, e.g.,
   *    the MFT rules will always disable skipping backward, and will disable
   *    skipping forward as well when the user has reached the maximum number of
   *    skips allowed per time period.
   */
  exports.Context;

  },{}],1289:[function(require,module,exports){
  arguments[4][1267][0].apply(exports,arguments)
  },{"./request":1293,"dup":1267}],1290:[function(require,module,exports){
  arguments[4][1268][0].apply(exports,arguments)
  },{"./bootstrap":1289,"dup":1268,"spotify-deferred":1296}],1291:[function(require,module,exports){
  arguments[4][1269][0].apply(exports,arguments)
  },{"./bootstrap":1289,"dup":1269,"spotify-deferred":1296}],1292:[function(require,module,exports){
  arguments[4][1270][0].apply(exports,arguments)
  },{"./bootstrap":1289,"dup":1270,"spotify-deferred":1296}],1293:[function(require,module,exports){
  arguments[4][1271][0].apply(exports,arguments)
  },{"dup":1271,"spotify-deferred":1296}],1294:[function(require,module,exports){
  (function (global){
  'use strict';

  var window = global.window || {};
  var process = global.process;

  var common = require('cosmos-common-js');
  var Resolver = require('./scripts/resolver').Resolver;

  var SPResolver = null;
  var spResolver = null;

  var hasNativeBridge = window._getSpotifyModule &&
      typeof window._getSpotifyModule === 'function' &&
      window._getSpotifyModule('bridge');

  var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
  var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

  if (!isNodeJs) {
    if (hasNativeBridge) {
      SPResolver = require('./env/bootstrap.native.js').NativeResolver;
      spResolver = new SPResolver(hasNativeBridge);
    } else {
      SPResolver = require('./env/bootstrap.web.js').WebResolver;
      spResolver = new SPResolver();
    }
  } else {
    SPResolver = require('./env/bootstrap.mock.js').MockResolver;
    spResolver = new SPResolver();

    exports.mockResolver = {
      addHandler: spResolver.addHandler.bind(spResolver),
      removeHandler: spResolver.removeHandler.bind(spResolver),
      clearHandlers: spResolver.clearHandlers.bind(spResolver)
    };
  }

  exports.Resolver = Resolver;
  exports.Action = common.request.Action;
  exports.Request = common.request.Request;
  exports.Response = common.response.Response;
  exports.resolver = spResolver ? new Resolver(spResolver) : null;

  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./env/bootstrap.mock.js":1290,"./env/bootstrap.native.js":1291,"./env/bootstrap.web.js":1292,"./scripts/resolver":1295,"cosmos-common-js":699}],1295:[function(require,module,exports){
  arguments[4][1274][0].apply(exports,arguments)
  },{"cosmos-common-js":699,"dup":1274}],1296:[function(require,module,exports){
  arguments[4][1273][0].apply(exports,arguments)
  },{"dup":1273}],1297:[function(require,module,exports){
  (function (global){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _ponyfill = require('./ponyfill.js');

  var _ponyfill2 = _interopRequireDefault(_ponyfill);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  var root; /* global window */


  if (typeof self !== 'undefined') {
    root = self;
  } else if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof module !== 'undefined') {
    root = module;
  } else {
    root = Function('return this')();
  }

  var result = (0, _ponyfill2['default'])(root);
  exports['default'] = result;
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./ponyfill.js":1298}],1298:[function(require,module,exports){
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports['default'] = symbolObservablePonyfill;
  function symbolObservablePonyfill(root) {
    var result;
    var _Symbol = root.Symbol;

    if (typeof _Symbol === 'function') {
      if (_Symbol.observable) {
        result = _Symbol.observable;
      } else {
        result = _Symbol('observable');
        _Symbol.observable = result;
      }
    } else {
      result = '@@observable';
    }

    return result;
  };
  },{}],1299:[function(require,module,exports){
  //     Underscore.js 1.8.3
  //     http://underscorejs.org
  //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
      push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
      nativeIsArray      = Array.isArray,
      nativeKeys         = Object.keys,
      nativeBind         = FuncProto.bind,
      nativeCreate       = Object.create;

    // Naked function reference for surrogate-prototype-swapping.
    var Ctor = function(){};

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object.
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.8.3';

    // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.
    var optimizeCb = function(func, context, argCount) {
      if (context === void 0) return func;
      switch (argCount == null ? 3 : argCount) {
        case 1: return function(value) {
          return func.call(context, value);
        };
        case 2: return function(value, other) {
          return func.call(context, value, other);
        };
        case 3: return function(value, index, collection) {
          return func.call(context, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
      }
      return function() {
        return func.apply(context, arguments);
      };
    };

    // A mostly-internal function to generate callbacks that can be applied
    // to each element in a collection, returning the desired result — either
    // identity, an arbitrary callback, a property matcher, or a property accessor.
    var cb = function(value, context, argCount) {
      if (value == null) return _.identity;
      if (_.isFunction(value)) return optimizeCb(value, context, argCount);
      if (_.isObject(value)) return _.matcher(value);
      return _.property(value);
    };
    _.iteratee = function(value, context) {
      return cb(value, context, Infinity);
    };

    // An internal function for creating assigner functions.
    var createAssigner = function(keysFunc, undefinedOnly) {
      return function(obj) {
        var length = arguments.length;
        if (length < 2 || obj == null) return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
          }
        }
        return obj;
      };
    };

    // An internal function for creating a new object that inherits from another.
    var baseCreate = function(prototype) {
      if (!_.isObject(prototype)) return {};
      if (nativeCreate) return nativeCreate(prototype);
      Ctor.prototype = prototype;
      var result = new Ctor;
      Ctor.prototype = null;
      return result;
    };

    var property = function(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    };

    // Helper for collection methods to determine whether a collection
    // should be iterated as an array or as an object
    // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = property('length');
    var isArrayLike = function(collection) {
      var length = getLength(collection);
      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.
    _.each = _.forEach = function(obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i, length;
      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
          iteratee(obj[keys[i]], keys[i], obj);
        }
      }
      return obj;
    };

    // Return the results of applying the iteratee to each element.
    _.map = _.collect = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          results = Array(length);
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };

    // Create a reducing function iterating left or right.
    function createReduce(dir) {
      // Optimized iterator function as using arguments.length
      // in the main function will deoptimize the, see #1991.
      function iterator(obj, iteratee, memo, keys, index, length) {
        for (; index >= 0 && index < length; index += dir) {
          var currentKey = keys ? keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      }

      return function(obj, iteratee, memo, context) {
        iteratee = optimizeCb(iteratee, context, 4);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        // Determine the initial value if none is provided.
        if (arguments.length < 3) {
          memo = obj[keys ? keys[index] : index];
          index += dir;
        }
        return iterator(obj, iteratee, memo, keys, index, length);
      };
    }

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.
    _.reduce = _.foldl = _.inject = createReduce(1);

    // The right-associative version of reduce, also known as `foldr`.
    _.reduceRight = _.foldr = createReduce(-1);

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, predicate, context) {
      var key;
      if (isArrayLike(obj)) {
        key = _.findIndex(obj, predicate, context);
      } else {
        key = _.findKey(obj, predicate, context);
      }
      if (key !== void 0 && key !== -1) return obj[key];
    };

    // Return all the elements that pass a truth test.
    // Aliased as `select`.
    _.filter = _.select = function(obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);
      _.each(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, predicate, context) {
      return _.filter(obj, _.negate(cb(predicate)), context);
    };

    // Determine whether all of the elements match a truth test.
    // Aliased as `all`.
    _.every = _.all = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
      }
      return true;
    };

    // Determine if at least one element in the object matches a truth test.
    // Aliased as `any`.
    _.some = _.any = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
      }
      return false;
    };

    // Determine if the array or object contains a given item (using `===`).
    // Aliased as `includes` and `include`.
    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      if (typeof fromIndex != 'number' || guard) fromIndex = 0;
      return _.indexOf(obj, item, fromIndex) >= 0;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        var func = isFunc ? method : value[method];
        return func == null ? func : func.apply(value, args);
      });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, _.property(key));
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs) {
      return _.filter(obj, _.matcher(attrs));
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.find(obj, _.matcher(attrs));
    };

    // Return the maximum element (or element-based computation).
    _.max = function(obj, iteratee, context) {
      var result = -Infinity, lastComputed = -Infinity,
          value, computed;
      if (iteratee == null && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iteratee, context) {
      var result = Infinity, lastComputed = Infinity,
          value, computed;
      if (iteratee == null && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Shuffle a collection, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    _.shuffle = function(obj) {
      var set = isArrayLike(obj) ? obj : _.values(obj);
      var length = set.length;
      var shuffled = Array(length);
      for (var index = 0, rand; index < length; index++) {
        rand = _.random(0, index);
        if (rand !== index) shuffled[index] = shuffled[rand];
        shuffled[rand] = set[index];
      }
      return shuffled;
    };

    // Sample **n** random values from a collection.
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // Sort the object's values by a criterion produced by an iteratee.
    _.sortBy = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iteratee(value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
      return function(obj, iteratee, context) {
        var result = {};
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, value, key) {
      if (_.has(result, key)) result[key].push(value); else result[key] = [value];
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, value, key) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, value, key) {
      if (_.has(result, key)) result[key]++; else result[key] = 1;
    });

    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (isArrayLike(obj)) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    };

    // Split a collection into two arrays: one whose elements all satisfy the given
    // predicate, and one whose elements all do not satisfy the predicate.
    _.partition = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var pass = [], fail = [];
      _.each(obj, function(value, key, obj) {
        (predicate(value, key, obj) ? pass : fail).push(value);
      });
      return [pass, fail];
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null) return void 0;
      if (n == null || guard) return array[0];
      return _.initial(array, array.length - n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array.
    _.last = function(array, n, guard) {
      if (array == null) return void 0;
      if (n == null || guard) return array[array.length - 1];
      return _.rest(array, Math.max(0, array.length - n));
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, strict, startIndex) {
      var output = [], idx = 0;
      for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
        var value = input[i];
        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
          //flatten current level of array or arguments object
          if (!shallow) value = flatten(value, shallow, strict);
          var j = 0, len = value.length;
          output.length += len;
          while (j < len) {
            output[idx++] = value[j++];
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, false);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
      if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null) iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0, length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted) {
          if (!i || seen !== computed) result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!_.contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!_.contains(result, value)) {
          result.push(value);
        }
      }
      return result;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
      return _.uniq(flatten(arguments, true, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0, length = getLength(array); i < length; i++) {
        var item = array[i];
        if (_.contains(result, item)) continue;
        for (var j = 1; j < argsLength; j++) {
          if (!_.contains(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
      }
      return result;
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
      var rest = flatten(arguments, true, true, 1);
      return _.filter(array, function(value){
        return !_.contains(rest, value);
      });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
      return _.unzip(arguments);
    };

    // Complement of _.zip. Unzip accepts an array of arrays and groups
    // each array's elements on shared indices
    _.unzip = function(array) {
      var length = array && _.max(array, getLength).length || 0;
      var result = Array(length);

      for (var index = 0; index < length; index++) {
        result[index] = _.pluck(array, index);
      }
      return result;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
      var result = {};
      for (var i = 0, length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // Generator function to create the findIndex and findLastIndex functions
    function createPredicateIndexFinder(dir) {
      return function(array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array)) return index;
        }
        return -1;
      };
    }

    // Returns the first index on an array-like that passes a predicate test
    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1);

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0, high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
      }
      return low;
    };

    // Generator function to create the indexOf and lastIndexOf functions
    function createIndexFinder(dir, predicateFind, sortedIndex) {
      return function(array, item, idx) {
        var i = 0, length = getLength(array);
        if (typeof idx == 'number') {
          if (dir > 0) {
              i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
              length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), _.isNaN);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item) return idx;
        }
        return -1;
      };
    }

    // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      step = step || 1;

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Determines whether to execute a function as a constructor
    // or a normal function with the provided arguments
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (_.isObject(result)) return result;
      return self;
    };

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
      if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
      var args = slice.call(arguments, 2);
      var bound = function() {
        return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
      };
      return bound;
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. _ acts
    // as a placeholder, allowing any combination of arguments to be pre-filled.
    _.partial = function(func) {
      var boundArgs = slice.call(arguments, 1);
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    };

    // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.
    _.bindAll = function(obj) {
      var i, length = arguments.length, key;
      if (length <= 1) throw new Error('bindAll must be passed function names');
      for (i = 1; i < length; i++) {
        key = arguments[i];
        obj[key] = _.bind(obj[key], obj);
      }
      return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function(){
        return func.apply(null, args);
      }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = _.partial(_.delay, _, 1);

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      if (!options) options = {};
      var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };
      return function() {
        var now = _.now();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, args, context, timestamp, result;

      var later = function() {
        var last = _.now() - timestamp;

        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          }
        }
      };

      return function() {
        context = this;
        args = arguments;
        timestamp = _.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return _.partial(wrapper, func);
    };

    // Returns a negated version of the passed-in predicate.
    _.negate = function(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--) result = args[i].call(this, result);
        return result;
      };
    };

    // Returns a function that will only be executed on and after the Nth call.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Returns a function that will only be executed up to (but not including) the Nth call.
    _.before = function(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }
        if (times <= 1) func = null;
        return memo;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = _.partial(_.before, 2);

    // Object Functions
    // ----------------

    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                        'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

    function collectNonEnumProps(obj, keys) {
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

      // Constructor is a special case.
      var prop = 'constructor';
      if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
          keys.push(prop);
        }
      }
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = function(obj) {
      if (!_.isObject(obj)) return [];
      if (nativeKeys) return nativeKeys(obj);
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    };

    // Retrieve all the property names of an object.
    _.allKeys = function(obj) {
      if (!_.isObject(obj)) return [];
      var keys = [];
      for (var key in obj) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Returns the results of applying the iteratee to each element of the object
    // In contrast to _.map it returns an object
    _.mapObject = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys =  _.keys(obj),
            length = keys.length,
            results = {},
            currentKey;
        for (var index = 0; index < length; index++) {
          currentKey = keys[index];
          results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = createAssigner(_.allKeys);

    // Assigns a given object with all the own properties in the passed-in object(s)
    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
    _.extendOwn = _.assign = createAssigner(_.keys);

    // Returns the first key on an object that passes a predicate test
    _.findKey = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = _.keys(obj), key;
      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (predicate(obj[key], key, obj)) return key;
      }
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(object, oiteratee, context) {
      var result = {}, obj = object, iteratee, keys;
      if (obj == null) return result;
      if (_.isFunction(oiteratee)) {
        keys = _.allKeys(obj);
        iteratee = optimizeCb(oiteratee, context);
      } else {
        keys = flatten(arguments, false, false, 1);
        iteratee = function(value, key, obj) { return key in obj; };
        obj = Object(obj);
      }
      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
      return result;
    };

     // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj, iteratee, context) {
      if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
      } else {
        var keys = _.map(flatten(arguments, false, false, 1), String);
        iteratee = function(value, key) {
          return !_.contains(keys, key);
        };
      }
      return _.pick(obj, iteratee, context);
    };

    // Fill in a given object with default properties.
    _.defaults = createAssigner(_.allKeys, true);

    // Creates an object that inherits from the given prototype object.
    // If additional properties are provided then they will be added to the
    // created object.
    _.create = function(prototype, props) {
      var result = baseCreate(prototype);
      if (props) _.extendOwn(result, props);
      return result;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Returns whether an object has a given set of `key:value` pairs.
    _.isMatch = function(object, attrs) {
      var keys = _.keys(attrs), length = keys.length;
      if (object == null) return !length;
      var obj = Object(object);
      for (var i = 0; i < length; i++) {
        var key = keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };


    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      // A strict comparison is necessary because `null == undefined`.
      if (a == null || b == null) return a === b;
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className !== toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN
          if (+a !== +a) return +b !== +b;
          // An `egal` comparison is performed for other numeric values.
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b;
      }

      var areArrays = className === '[object Array]';
      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false;

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                                 _.isFunction(bCtor) && bCtor instanceof bCtor)
                            && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

      // Initializing stack of traversed objects.
      // It's done here since we only need them for objects and arrays comparison.
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
      }

      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);

      // Recursively compare objects and arrays.
      if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
      } else {
        // Deep compare objects.
        var keys = _.keys(a), key;
        length = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (_.keys(b).length !== length) return false;
        while (length--) {
          // Deep compare each member
          key = keys[length];
          if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return true;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
      return _.keys(obj).length === 0;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) === '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE < 9), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return _.has(obj, 'callee');
      };
    }

    // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
    // IE 11 (#1621), and in Safari 8 (#1929).
    if (typeof /./ != 'function' && typeof Int8Array != 'object') {
      _.isFunction = function(obj) {
        return typeof obj == 'function' || false;
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj !== +obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iteratees.
    _.identity = function(value) {
      return value;
    };

    // Predicate-generating functions. Often useful outside of Underscore.
    _.constant = function(value) {
      return function() {
        return value;
      };
    };

    _.noop = function(){};

    _.property = property;

    // Generates a function for a given object that returns a given property.
    _.propertyOf = function(obj) {
      return obj == null ? function(){} : function(key) {
        return obj[key];
      };
    };

    // Returns a predicate for checking whether an object has a given set of
    // `key:value` pairs.
    _.matcher = _.matches = function(attrs) {
      attrs = _.extendOwn({}, attrs);
      return function(obj) {
        return _.isMatch(obj, attrs);
      };
    };

    // Run a function **n** times.
    _.times = function(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);
      for (var i = 0; i < n; i++) accum[i] = iteratee(i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // A (possibly faster) way to get the current timestamp as an integer.
    _.now = Date.now || function() {
      return new Date().getTime();
    };

     // List of HTML entities for escaping.
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };
    var unescapeMap = _.invert(escapeMap);

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    var createEscaper = function(map) {
      var escaper = function(match) {
        return map[match];
      };
      // Regexes for identifying a key that needs to be escaped
      var source = '(?:' + _.keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);

    // If the value of the named `property` is a function then invoke it with the
    // `object` as context; otherwise, return it.
    _.result = function(object, property, fallback) {
      var value = object == null ? void 0 : object[property];
      if (value === void 0) {
        value = fallback;
      }
      return _.isFunction(value) ? value.call(object) : value;
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g,
      escape      : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

    var escapeChar = function(match) {
      return '\\' + escapes[match];
    };

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.
    _.template = function(text, settings, oldSettings) {
      if (!settings && oldSettings) settings = oldSettings;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escaper, escapeChar);
        index = offset + match.length;

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }

        // Adobe VMs need the match returned to produce the correct offest.
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + 'return __p;\n';

      try {
        var render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled source as a convenience for precompilation.
      var argument = settings.variable || 'obj';
      template.source = 'function(' + argument + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function. Start chaining a wrapped Underscore object.
    _.chain = function(obj) {
      var instance = _(obj);
      instance._chain = true;
      return instance;
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(instance, obj) {
      return instance._chain ? _(obj).chain() : obj;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      _.each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result(this, func.apply(_, args));
        };
      });
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
        return result(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    _.each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result(this, method.apply(this._wrapped, arguments));
      };
    });

    // Extracts the result from a wrapped and chained object.
    _.prototype.value = function() {
      return this._wrapped;
    };

    // Provide unwrapping proxy for some methods used in engine operations
    // such as arithmetic and JSON stringification.
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

    _.prototype.toString = function() {
      return '' + this._wrapped;
    };

    // AMD registration happens at the end for compatibility with AMD loaders
    // that may not enforce next-turn semantics on modules. Even though general
    // practice for AMD registration is to be anonymous, underscore registers
    // as a named module because, like jQuery, it is a base library that is
    // popular enough to be bundled in a third party lib, but not be part of
    // an AMD load request. Those cases could generate an error when an
    // anonymous define() is called outside of a loader request.
    if (typeof define === 'function' && define.amd) {
      define('underscore', [], function() {
        return _;
      });
    }
  }.call(this));

  },{}],1300:[function(require,module,exports){
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }

  },{}],1301:[function(require,module,exports){
  module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object'
      && typeof arg.copy === 'function'
      && typeof arg.fill === 'function'
      && typeof arg.readUInt8 === 'function';
  }
  },{}],1302:[function(require,module,exports){
  (function (process,global){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  };


  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  exports.deprecate = function(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global.process)) {
      return function() {
        return exports.deprecate(fn, msg).apply(this, arguments);
      };
    }

    if (process.noDeprecation === true) {
      return fn;
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  };


  var debugs = {};
  var debugEnviron;
  exports.debuglog = function(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = process.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = process.pid;
        debugs[set] = function() {
          var msg = exports.format.apply(exports, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  };


  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      exports._extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports.inspect = inspect;


  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray(ar) {
    return Array.isArray(ar);
  }
  exports.isArray = isArray;

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  exports.isBoolean = isBoolean;

  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;

  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;

  function isNumber(arg) {
    return typeof arg === 'number';
  }
  exports.isNumber = isNumber;

  function isString(arg) {
    return typeof arg === 'string';
  }
  exports.isString = isString;

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  exports.isSymbol = isSymbol;

  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }
  exports.isRegExp = isRegExp;

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  exports.isObject = isObject;

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }
  exports.isDate = isDate;

  function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }
  exports.isError = isError;

  function isFunction(arg) {
    return typeof arg === 'function';
  }
  exports.isFunction = isFunction;

  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }
  exports.isPrimitive = isPrimitive;

  exports.isBuffer = require('./support/isBuffer');

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }


  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }


  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

  // 26 Feb 16:19:34
  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }


  // log is just a thin wrapper to console.log that prepends a timestamp
  exports.log = function() {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
  };


  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * The Function.prototype.inherits from lang.js rewritten as a standalone
   * function (not on Function.prototype). NOTE: If this file is to be loaded
   * during bootstrapping this function needs to be rewritten using some native
   * functions as prototype setup using normal JavaScript does not work as
   * expected during bootstrapping (see mirror.js in r114903).
   *
   * @param {function} ctor Constructor function which needs to inherit the
   *     prototype.
   * @param {function} superCtor Constructor function to inherit prototype from.
   */
  exports.inherits = require('inherits');

  exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  };

  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  },{"./support/isBuffer":1301,"_process":823,"inherits":1300}],1303:[function(require,module,exports){
  /*
   * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate
   * TimeUUID based on dates for range selections.
   * @see http://www.ietf.org/rfc/rfc4122.txt
   **/

  function UUIDjs() {
  };

  UUIDjs.maxFromBits = function(bits) {
    return Math.pow(2, bits);
  };

  UUIDjs.limitUI04 = UUIDjs.maxFromBits(4);
  UUIDjs.limitUI06 = UUIDjs.maxFromBits(6);
  UUIDjs.limitUI08 = UUIDjs.maxFromBits(8);
  UUIDjs.limitUI12 = UUIDjs.maxFromBits(12);
  UUIDjs.limitUI14 = UUIDjs.maxFromBits(14);
  UUIDjs.limitUI16 = UUIDjs.maxFromBits(16);
  UUIDjs.limitUI32 = UUIDjs.maxFromBits(32);
  UUIDjs.limitUI40 = UUIDjs.maxFromBits(40);
  UUIDjs.limitUI48 = UUIDjs.maxFromBits(48);

  // Returns a random integer between min and max
  // Using Math.round() will give you a non-uniform distribution!
  // @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  UUIDjs.randomUI04 = function() {
    return getRandomInt(0, UUIDjs.limitUI04-1);
  };
  UUIDjs.randomUI06 = function() {
    return getRandomInt(0, UUIDjs.limitUI06-1);
  };
  UUIDjs.randomUI08 = function() {
    return getRandomInt(0, UUIDjs.limitUI08-1);
  };
  UUIDjs.randomUI12 = function() {
    return getRandomInt(0, UUIDjs.limitUI12-1);
  };
  UUIDjs.randomUI14 = function() {
    return getRandomInt(0, UUIDjs.limitUI14-1);
  };
  UUIDjs.randomUI16 = function() {
    return getRandomInt(0, UUIDjs.limitUI16-1);
  };
  UUIDjs.randomUI32 = function() {
    return getRandomInt(0, UUIDjs.limitUI32-1);
  };
  UUIDjs.randomUI40 = function() {
    return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);
  };
  UUIDjs.randomUI48 = function() {
    return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
  };

  UUIDjs.paddedString = function(string, length, z) {
    string = String(string);
    z = (!z) ? '0' : z;
    var i = length - string.length;
    for (; i > 0; i >>>= 1, z += z) {
      if (i & 1) {
        string = z + string;
      }
    }
    return string;
  };

  UUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
    this.version = (timeHiAndVersion >> 12) & 0xF;
    this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)
               + '-'
               + UUIDjs.paddedString(timeMid.toString(16), 4)
               + '-'
               + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)
               + '-'
               + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)
               + UUIDjs.paddedString(clockSeqLow.toString(16), 2)
               + '-'
               + UUIDjs.paddedString(node.toString(16), 12);
    return this;
  };

  UUIDjs.prototype.toString = function() {
    return this.hex;
  };
  UUIDjs.prototype.toURN = function() {
    return 'urn:uuid:' + this.hex;
  };

  UUIDjs.prototype.toBytes = function() {
    var parts = this.hex.split('-');
    var ints = [];
    var intPos = 0;
    for (var i = 0; i < parts.length; i++) {
      for (var j = 0; j < parts[i].length; j+=2) {
        ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);
      }
    }
    return ints;
  };

  UUIDjs.prototype.equals = function(uuid) {
    if (!(uuid instanceof UUID)) {
      return false;
    }
    if (this.hex !== uuid.hex) {
      return false;
    }
    return true;
  };

  UUIDjs.getTimeFieldValues = function(time) {
    var ts = time - Date.UTC(1582, 9, 15);
    var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
    return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
              mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
  };

  UUIDjs._create4 = function() {
    return new UUIDjs().fromParts(
      UUIDjs.randomUI32(),
      UUIDjs.randomUI16(),
      0x4000 | UUIDjs.randomUI12(),
      0x80   | UUIDjs.randomUI06(),
      UUIDjs.randomUI08(),
      UUIDjs.randomUI48()
    );
  };

  UUIDjs._create1 = function() {
    var now = new Date().getTime();
    var sequence = UUIDjs.randomUI14();
    var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();
    var tick = UUIDjs.randomUI04();
    var timestamp = 0;
    var timestampRatio = 1/4;

    if (now != timestamp) {
      if (now < timestamp) {
        sequence++;
      }
      timestamp = now;
      tick = UUIDjs.randomUI04();
    } else if (Math.random() < timestampRatio && tick < 9984) {
      tick += 1 + UUIDjs.randomUI04();
    } else {
      sequence++;
    }

    var tf = UUIDjs.getTimeFieldValues(timestamp);
    var tl = tf.low + tick;
    var thav = (tf.hi & 0xFFF) | 0x1000;

    sequence &= 0x3FFF;
    var cshar = (sequence >>> 8) | 0x80;
    var csl = sequence & 0xFF;

    return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);
  };

  UUIDjs.create = function(version) {
    version = version || 4;
    return this['_create' + version]();
  };

  UUIDjs.fromTime = function(time, last) {
    last = (!last) ? false : last;
    var tf = UUIDjs.getTimeFieldValues(time);
    var tl = tf.low;
    var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'
    if (last === false) {
      return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);
    } else {
      return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);
    }
  };

  UUIDjs.firstFromTime = function(time) {
    return UUIDjs.fromTime(time, false);
  };
  UUIDjs.lastFromTime = function(time) {
    return UUIDjs.fromTime(time, true);
  };

  UUIDjs.fromURN = function(strId) {
    var r, p = /^(?:urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\})?$/i;
    if ((r = p.exec(strId))) {
      return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),
                              parseInt(r[3], 16), parseInt(r[4], 16),
                              parseInt(r[5], 16), parseInt(r[6], 16));
    }
    return null;
  };

  UUIDjs.fromBytes = function(ints) {
    if (ints.length < 5) {
      return null;
    }
    var str = '';
    var pos = 0;
    var parts = [4, 2, 2, 2, 6];
    for (var i = 0; i < parts.length; i++) {
      for (var j = 0; j < parts[i]; j++) {
        var octet = ints[pos++].toString(16);
        if (octet.length == 1) {
          octet = '0' + octet;
        }
        str += octet;
      }
      if (parts[i] !== 6) {
        str += '-';
      }
    }
    return UUIDjs.fromURN(str);
  };

  UUIDjs.fromBinary = function(binary) {
    var ints = [];
    for (var i = 0; i < binary.length; i++) {
      ints[i] = binary.charCodeAt(i);
      if (ints[i] > 255 || ints[i] < 0) {
        throw new Error('Unexpected byte in binary data.');
      }
    }
    return UUIDjs.fromBytes(ints);
  };

  // Aliases to support legacy code. Do not use these when writing new code as
  // they may be removed in future versions!
  UUIDjs.new = function() {
    return this.create(4);
  };
  UUIDjs.newTS = function() {
    return this.create(1);
  };

  module.exports = UUIDjs;

  },{}],1304:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function (require) {

    var makePromise = require('./makePromise');
    var Scheduler = require('./Scheduler');
    var async = require('./env').asap;

    return makePromise({
      scheduler: new Scheduler(async)
    });

  });
  })(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

  },{"./Scheduler":1305,"./env":1317,"./makePromise":1320}],1305:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    // Credit to Twisol (https://github.com/Twisol) for suggesting
    // this type of extensible queue + trampoline approach for next-tick conflation.

    /**
     * Async task scheduler
     * @param {function} async function to schedule a single async function
     * @constructor
     */
    function Scheduler(async) {
      this._async = async;
      this._running = false;

      this._queue = this;
      this._queueLen = 0;
      this._afterQueue = {};
      this._afterQueueLen = 0;

      var self = this;
      this.drain = function() {
        self._drain();
      };
    }

    /**
     * Enqueue a task
     * @param {{ run:function }} task
     */
    Scheduler.prototype.enqueue = function(task) {
      this._queue[this._queueLen++] = task;
      this.run();
    };

    /**
     * Enqueue a task to run after the main task queue
     * @param {{ run:function }} task
     */
    Scheduler.prototype.afterQueue = function(task) {
      this._afterQueue[this._afterQueueLen++] = task;
      this.run();
    };

    Scheduler.prototype.run = function() {
      if (!this._running) {
        this._running = true;
        this._async(this.drain);
      }
    };

    /**
     * Drain the handler queue entirely, and then the after queue
     */
    Scheduler.prototype._drain = function() {
      var i = 0;
      for (; i < this._queueLen; ++i) {
        this._queue[i].run();
        this._queue[i] = void 0;
      }

      this._queueLen = 0;
      this._running = false;

      for (i = 0; i < this._afterQueueLen; ++i) {
        this._afterQueue[i].run();
        this._afterQueue[i] = void 0;
      }

      this._afterQueueLen = 0;
    };

    return Scheduler;

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1306:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    /**
     * Custom error type for promises rejected by promise.timeout
     * @param {string} message
     * @constructor
     */
    function TimeoutError (message) {
      Error.call(this);
      this.message = message;
      this.name = TimeoutError.name;
      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(this, TimeoutError);
      }
    }

    TimeoutError.prototype = Object.create(Error.prototype);
    TimeoutError.prototype.constructor = TimeoutError;

    return TimeoutError;
  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
  },{}],1307:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    makeApply.tryCatchResolve = tryCatchResolve;

    return makeApply;

    function makeApply(Promise, call) {
      if(arguments.length < 2) {
        call = tryCatchResolve;
      }

      return apply;

      function apply(f, thisArg, args) {
        var p = Promise._defer();
        var l = args.length;
        var params = new Array(l);
        callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

        return p;
      }

      function callAndResolve(c, h) {
        if(c.i < 0) {
          return call(c.f, c.thisArg, c.params, h);
        }

        var handler = Promise._handler(c.args[c.i]);
        handler.fold(callAndResolveNext, c, void 0, h);
      }

      function callAndResolveNext(c, x, h) {
        c.params[c.i] = x;
        c.i -= 1;
        callAndResolve(c, h);
      }
    }

    function tryCatchResolve(f, thisArg, args, resolver) {
      try {
        resolver.resolve(f.apply(thisArg, args));
      } catch(e) {
        resolver.reject(e);
      }
    }

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



  },{}],1308:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function(require) {

    var state = require('../state');
    var applier = require('../apply');

    return function array(Promise) {

      var applyFold = applier(Promise);
      var toPromise = Promise.resolve;
      var all = Promise.all;

      var ar = Array.prototype.reduce;
      var arr = Array.prototype.reduceRight;
      var slice = Array.prototype.slice;

      // Additional array combinators

      Promise.any = any;
      Promise.some = some;
      Promise.settle = settle;

      Promise.map = map;
      Promise.filter = filter;
      Promise.reduce = reduce;
      Promise.reduceRight = reduceRight;

      /**
       * When this promise fulfills with an array, do
       * onFulfilled.apply(void 0, array)
       * @param {function} onFulfilled function to apply
       * @returns {Promise} promise for the result of applying onFulfilled
       */
      Promise.prototype.spread = function(onFulfilled) {
        return this.then(all).then(function(array) {
          return onFulfilled.apply(this, array);
        });
      };

      return Promise;

      /**
       * One-winner competitive race.
       * Return a promise that will fulfill when one of the promises
       * in the input array fulfills, or will reject when all promises
       * have rejected.
       * @param {array} promises
       * @returns {Promise} promise for the first fulfilled value
       */
      function any(promises) {
        var p = Promise._defer();
        var resolver = p._handler;
        var l = promises.length>>>0;

        var pending = l;
        var errors = [];

        for (var h, x, i = 0; i < l; ++i) {
          x = promises[i];
          if(x === void 0 && !(i in promises)) {
            --pending;
            continue;
          }

          h = Promise._handler(x);
          if(h.state() > 0) {
            resolver.become(h);
            Promise._visitRemaining(promises, i, h);
            break;
          } else {
            h.visit(resolver, handleFulfill, handleReject);
          }
        }

        if(pending === 0) {
          resolver.reject(new RangeError('any(): array must not be empty'));
        }

        return p;

        function handleFulfill(x) {
          /*jshint validthis:true*/
          errors = null;
          this.resolve(x); // this === resolver
        }

        function handleReject(e) {
          /*jshint validthis:true*/
          if(this.resolved) { // this === resolver
            return;
          }

          errors.push(e);
          if(--pending === 0) {
            this.reject(errors);
          }
        }
      }

      /**
       * N-winner competitive race
       * Return a promise that will fulfill when n input promises have
       * fulfilled, or will reject when it becomes impossible for n
       * input promises to fulfill (ie when promises.length - n + 1
       * have rejected)
       * @param {array} promises
       * @param {number} n
       * @returns {Promise} promise for the earliest n fulfillment values
       *
       * @deprecated
       */
      function some(promises, n) {
        /*jshint maxcomplexity:7*/
        var p = Promise._defer();
        var resolver = p._handler;

        var results = [];
        var errors = [];

        var l = promises.length>>>0;
        var nFulfill = 0;
        var nReject;
        var x, i; // reused in both for() loops

        // First pass: count actual array items
        for(i=0; i<l; ++i) {
          x = promises[i];
          if(x === void 0 && !(i in promises)) {
            continue;
          }
          ++nFulfill;
        }

        // Compute actual goals
        n = Math.max(n, 0);
        nReject = (nFulfill - n + 1);
        nFulfill = Math.min(n, nFulfill);

        if(n > nFulfill) {
          resolver.reject(new RangeError('some(): array must contain at least '
          + n + ' item(s), but had ' + nFulfill));
        } else if(nFulfill === 0) {
          resolver.resolve(results);
        }

        // Second pass: observe each array item, make progress toward goals
        for(i=0; i<l; ++i) {
          x = promises[i];
          if(x === void 0 && !(i in promises)) {
            continue;
          }

          Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
        }

        return p;

        function fulfill(x) {
          /*jshint validthis:true*/
          if(this.resolved) { // this === resolver
            return;
          }

          results.push(x);
          if(--nFulfill === 0) {
            errors = null;
            this.resolve(results);
          }
        }

        function reject(e) {
          /*jshint validthis:true*/
          if(this.resolved) { // this === resolver
            return;
          }

          errors.push(e);
          if(--nReject === 0) {
            results = null;
            this.reject(errors);
          }
        }
      }

      /**
       * Apply f to the value of each promise in a list of promises
       * and return a new list containing the results.
       * @param {array} promises
       * @param {function(x:*, index:Number):*} f mapping function
       * @returns {Promise}
       */
      function map(promises, f) {
        return Promise._traverse(f, promises);
      }

      /**
       * Filter the provided array of promises using the provided predicate.  Input may
       * contain promises and values
       * @param {Array} promises array of promises and values
       * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
       *  Must return truthy (or promise for truthy) for items to retain.
       * @returns {Promise} promise that will fulfill with an array containing all items
       *  for which predicate returned truthy.
       */
      function filter(promises, predicate) {
        var a = slice.call(promises);
        return Promise._traverse(predicate, a).then(function(keep) {
          return filterSync(a, keep);
        });
      }

      function filterSync(promises, keep) {
        // Safe because we know all promises have fulfilled if we've made it this far
        var l = keep.length;
        var filtered = new Array(l);
        for(var i=0, j=0; i<l; ++i) {
          if(keep[i]) {
            filtered[j++] = Promise._handler(promises[i]).value;
          }
        }
        filtered.length = j;
        return filtered;

      }

      /**
       * Return a promise that will always fulfill with an array containing
       * the outcome states of all input promises.  The returned promise
       * will never reject.
       * @param {Array} promises
       * @returns {Promise} promise for array of settled state descriptors
       */
      function settle(promises) {
        return all(promises.map(settleOne));
      }

      function settleOne(p) {
        var h = Promise._handler(p);
        if(h.state() === 0) {
          return toPromise(p).then(state.fulfilled, state.rejected);
        }

        h._unreport();
        return state.inspect(h);
      }

      /**
       * Traditional reduce function, similar to `Array.prototype.reduce()`, but
       * input may contain promises and/or values, and reduceFunc
       * may return either a value or a promise, *and* initialValue may
       * be a promise for the starting value.
       * @param {Array|Promise} promises array or promise for an array of anything,
       *      may contain a mix of promises and values.
       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
       * @returns {Promise} that will resolve to the final reduced value
       */
      function reduce(promises, f /*, initialValue */) {
        return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
            : ar.call(promises, liftCombine(f));
      }

      /**
       * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
       * input may contain promises and/or values, and reduceFunc
       * may return either a value or a promise, *and* initialValue may
       * be a promise for the starting value.
       * @param {Array|Promise} promises array or promise for an array of anything,
       *      may contain a mix of promises and values.
       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
       * @returns {Promise} that will resolve to the final reduced value
       */
      function reduceRight(promises, f /*, initialValue */) {
        return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
            : arr.call(promises, liftCombine(f));
      }

      function liftCombine(f) {
        return function(z, x, i) {
          return applyFold(f, void 0, [z,x,i]);
        };
      }
    };

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

  },{"../apply":1307,"../state":1321}],1309:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return function flow(Promise) {

      var resolve = Promise.resolve;
      var reject = Promise.reject;
      var origCatch = Promise.prototype['catch'];

      /**
       * Handle the ultimate fulfillment value or rejection reason, and assume
       * responsibility for all errors.  If an error propagates out of result
       * or handleFatalError, it will be rethrown to the host, resulting in a
       * loud stack track on most platforms and a crash on some.
       * @param {function?} onResult
       * @param {function?} onError
       * @returns {undefined}
       */
      Promise.prototype.done = function(onResult, onError) {
        this._handler.visit(this._handler.receiver, onResult, onError);
      };

      /**
       * Add Error-type and predicate matching to catch.  Examples:
       * promise.catch(TypeError, handleTypeError)
       *   .catch(predicate, handleMatchedErrors)
       *   .catch(handleRemainingErrors)
       * @param onRejected
       * @returns {*}
       */
      Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
        if (arguments.length < 2) {
          return origCatch.call(this, onRejected);
        }

        if(typeof onRejected !== 'function') {
          return this.ensure(rejectInvalidPredicate);
        }

        return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
      };

      /**
       * Wraps the provided catch handler, so that it will only be called
       * if the predicate evaluates truthy
       * @param {?function} handler
       * @param {function} predicate
       * @returns {function} conditional catch handler
       */
      function createCatchFilter(handler, predicate) {
        return function(e) {
          return evaluatePredicate(e, predicate)
            ? handler.call(this, e)
            : reject(e);
        };
      }

      /**
       * Ensures that onFulfilledOrRejected will be called regardless of whether
       * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
       * receive the promises' value or reason.  Any returned value will be disregarded.
       * onFulfilledOrRejected may throw or return a rejected promise to signal
       * an additional error.
       * @param {function} handler handler to be called regardless of
       *  fulfillment or rejection
       * @returns {Promise}
       */
      Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
        if(typeof handler !== 'function') {
          return this;
        }

        return this.then(function(x) {
          return runSideEffect(handler, this, identity, x);
        }, function(e) {
          return runSideEffect(handler, this, reject, e);
        });
      };

      function runSideEffect (handler, thisArg, propagate, value) {
        var result = handler.call(thisArg);
        return maybeThenable(result)
          ? propagateValue(result, propagate, value)
          : propagate(value);
      }

      function propagateValue (result, propagate, x) {
        return resolve(result).then(function () {
          return propagate(x);
        });
      }

      /**
       * Recover from a failure by returning a defaultValue.  If defaultValue
       * is a promise, it's fulfillment value will be used.  If defaultValue is
       * a promise that rejects, the returned promise will reject with the
       * same reason.
       * @param {*} defaultValue
       * @returns {Promise} new promise
       */
      Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
        return this.then(void 0, function() {
          return defaultValue;
        });
      };

      /**
       * Shortcut for .then(function() { return value; })
       * @param  {*} value
       * @return {Promise} a promise that:
       *  - is fulfilled if value is not a promise, or
       *  - if value is a promise, will fulfill with its value, or reject
       *    with its reason.
       */
      Promise.prototype['yield'] = function(value) {
        return this.then(function() {
          return value;
        });
      };

      /**
       * Runs a side effect when this promise fulfills, without changing the
       * fulfillment value.
       * @param {function} onFulfilledSideEffect
       * @returns {Promise}
       */
      Promise.prototype.tap = function(onFulfilledSideEffect) {
        return this.then(onFulfilledSideEffect)['yield'](this);
      };

      return Promise;
    };

    function rejectInvalidPredicate() {
      throw new TypeError('catch predicate must be a function');
    }

    function evaluatePredicate(e, predicate) {
      return isError(predicate) ? e instanceof predicate : predicate(e);
    }

    function isError(predicate) {
      return predicate === Error
        || (predicate != null && predicate.prototype instanceof Error);
    }

    function maybeThenable(x) {
      return (typeof x === 'object' || typeof x === 'function') && x !== null;
    }

    function identity(x) {
      return x;
    }

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1310:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */
  /** @author Jeff Escalante */

  (function(define) { 'use strict';
  define(function() {

    return function fold(Promise) {

      Promise.prototype.fold = function(f, z) {
        var promise = this._beget();

        this._handler.fold(function(z, x, to) {
          Promise._handler(z).fold(function(x, z, to) {
            to.resolve(f.call(this, z, x));
          }, x, this, to);
        }, z, promise._handler.receiver, promise._handler);

        return promise;
      };

      return Promise;
    };

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1311:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function(require) {

    var inspect = require('../state').inspect;

    return function inspection(Promise) {

      Promise.prototype.inspect = function() {
        return inspect(Promise._handler(this));
      };

      return Promise;
    };

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

  },{"../state":1321}],1312:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return function generate(Promise) {

      var resolve = Promise.resolve;

      Promise.iterate = iterate;
      Promise.unfold = unfold;

      return Promise;

      /**
       * @deprecated Use github.com/cujojs/most streams and most.iterate
       * Generate a (potentially infinite) stream of promised values:
       * x, f(x), f(f(x)), etc. until condition(x) returns true
       * @param {function} f function to generate a new x from the previous x
       * @param {function} condition function that, given the current x, returns
       *  truthy when the iterate should stop
       * @param {function} handler function to handle the value produced by f
       * @param {*|Promise} x starting value, may be a promise
       * @return {Promise} the result of the last call to f before
       *  condition returns true
       */
      function iterate(f, condition, handler, x) {
        return unfold(function(x) {
          return [x, f(x)];
        }, condition, handler, x);
      }

      /**
       * @deprecated Use github.com/cujojs/most streams and most.unfold
       * Generate a (potentially infinite) stream of promised values
       * by applying handler(generator(seed)) iteratively until
       * condition(seed) returns true.
       * @param {function} unspool function that generates a [value, newSeed]
       *  given a seed.
       * @param {function} condition function that, given the current seed, returns
       *  truthy when the unfold should stop
       * @param {function} handler function to handle the value produced by unspool
       * @param x {*|Promise} starting value, may be a promise
       * @return {Promise} the result of the last value produced by unspool before
       *  condition returns true
       */
      function unfold(unspool, condition, handler, x) {
        return resolve(x).then(function(seed) {
          return resolve(condition(seed)).then(function(done) {
            return done ? seed : resolve(unspool(seed)).spread(next);
          });
        });

        function next(item, newSeed) {
          return resolve(handler(item)).then(function() {
            return unfold(unspool, condition, handler, newSeed);
          });
        }
      }
    };

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1313:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return function progress(Promise) {

      /**
       * @deprecated
       * Register a progress handler for this promise
       * @param {function} onProgress
       * @returns {Promise}
       */
      Promise.prototype.progress = function(onProgress) {
        return this.then(void 0, void 0, onProgress);
      };

      return Promise;
    };

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1314:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function(require) {

    var env = require('../env');
    var TimeoutError = require('../TimeoutError');

    function setTimeout(f, ms, x, y) {
      return env.setTimer(function() {
        f(x, y, ms);
      }, ms);
    }

    return function timed(Promise) {
      /**
       * Return a new promise whose fulfillment value is revealed only
       * after ms milliseconds
       * @param {number} ms milliseconds
       * @returns {Promise}
       */
      Promise.prototype.delay = function(ms) {
        var p = this._beget();
        this._handler.fold(handleDelay, ms, void 0, p._handler);
        return p;
      };

      function handleDelay(ms, x, h) {
        setTimeout(resolveDelay, ms, x, h);
      }

      function resolveDelay(x, h) {
        h.resolve(x);
      }

      /**
       * Return a new promise that rejects after ms milliseconds unless
       * this promise fulfills earlier, in which case the returned promise
       * fulfills with the same value.
       * @param {number} ms milliseconds
       * @param {Error|*=} reason optional rejection reason to use, defaults
       *   to a TimeoutError if not provided
       * @returns {Promise}
       */
      Promise.prototype.timeout = function(ms, reason) {
        var p = this._beget();
        var h = p._handler;

        var t = setTimeout(onTimeout, ms, reason, p._handler);

        this._handler.visit(h,
          function onFulfill(x) {
            env.clearTimer(t);
            this.resolve(x); // this = h
          },
          function onReject(x) {
            env.clearTimer(t);
            this.reject(x); // this = h
          },
          h.notify);

        return p;
      };

      function onTimeout(reason, h, ms) {
        var e = typeof reason === 'undefined'
          ? new TimeoutError('timed out after ' + ms + 'ms')
          : reason;
        h.reject(e);
      }

      return Promise;
    };

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

  },{"../TimeoutError":1306,"../env":1317}],1315:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function(require) {

    var setTimer = require('../env').setTimer;
    var format = require('../format');

    return function unhandledRejection(Promise) {

      var logError = noop;
      var logInfo = noop;
      var localConsole;

      if(typeof console !== 'undefined') {
        // Alias console to prevent things like uglify's drop_console option from
        // removing console.log/error. Unhandled rejections fall into the same
        // category as uncaught exceptions, and build tools shouldn't silence them.
        localConsole = console;
        logError = typeof localConsole.error !== 'undefined'
          ? function (e) { localConsole.error(e); }
          : function (e) { localConsole.log(e); };

        logInfo = typeof localConsole.info !== 'undefined'
          ? function (e) { localConsole.info(e); }
          : function (e) { localConsole.log(e); };
      }

      Promise.onPotentiallyUnhandledRejection = function(rejection) {
        enqueue(report, rejection);
      };

      Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
        enqueue(unreport, rejection);
      };

      Promise.onFatalRejection = function(rejection) {
        enqueue(throwit, rejection.value);
      };

      var tasks = [];
      var reported = [];
      var running = null;

      function report(r) {
        if(!r.handled) {
          reported.push(r);
          logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
        }
      }

      function unreport(r) {
        var i = reported.indexOf(r);
        if(i >= 0) {
          reported.splice(i, 1);
          logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
        }
      }

      function enqueue(f, x) {
        tasks.push(f, x);
        if(running === null) {
          running = setTimer(flush, 0);
        }
      }

      function flush() {
        running = null;
        while(tasks.length > 0) {
          tasks.shift()(tasks.shift());
        }
      }

      return Promise;
    };

    function throwit(e) {
      throw e;
    }

    function noop() {}

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

  },{"../env":1317,"../format":1318}],1316:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return function addWith(Promise) {
      /**
       * Returns a promise whose handlers will be called with `this` set to
       * the supplied receiver.  Subsequent promises derived from the
       * returned promise will also have their handlers called with receiver
       * as `this`. Calling `with` with undefined or no arguments will return
       * a promise whose handlers will again be called in the usual Promises/A+
       * way (no `this`) thus safely undoing any previous `with` in the
       * promise chain.
       *
       * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
       * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
       *
       * @param {object} receiver `this` value for all handlers attached to
       *  the returned promise.
       * @returns {Promise}
       */
      Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
        var p = this._beget();
        var child = p._handler;
        child.receiver = receiver;
        this._handler.chain(child, receiver);
        return p;
      };

      return Promise;
    };

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


  },{}],1317:[function(require,module,exports){
  (function (process){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  /*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
  (function(define) { 'use strict';
  define(function(require) {
    /*jshint maxcomplexity:6*/

    // Sniff "best" async scheduling option
    // Prefer process.nextTick or MutationObserver, then check for
    // setTimeout, and finally vertx, since its the only env that doesn't
    // have setTimeout

    var MutationObs;
    var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

    // Default env
    var setTimer = function(f, ms) { return setTimeout(f, ms); };
    var clearTimer = function(t) { return clearTimeout(t); };
    var asap = function (f) { return capturedSetTimeout(f, 0); };

    // Detect specific env
    if (isNode()) { // Node
      asap = function (f) { return process.nextTick(f); };

    } else if (MutationObs = hasMutationObserver()) { // Modern browser
      asap = initMutationObserver(MutationObs);

    } else if (!capturedSetTimeout) { // vert.x
      var vertxRequire = require;
      var vertx = vertxRequire('vertx');
      setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
      clearTimer = vertx.cancelTimer;
      asap = vertx.runOnLoop || vertx.runOnContext;
    }

    return {
      setTimer: setTimer,
      clearTimer: clearTimer,
      asap: asap
    };

    function isNode () {
      return typeof process !== 'undefined' &&
        Object.prototype.toString.call(process) === '[object process]';
    }

    function hasMutationObserver () {
      return (typeof MutationObserver === 'function' && MutationObserver) ||
        (typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
    }

    function initMutationObserver(MutationObserver) {
      var scheduled;
      var node = document.createTextNode('');
      var o = new MutationObserver(run);
      o.observe(node, { characterData: true });

      function run() {
        var f = scheduled;
        scheduled = void 0;
        f();
      }

      var i = 0;
      return function (f) {
        scheduled = f;
        node.data = (i ^= 1);
      };
    }
  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

  }).call(this,require('_process'))
  },{"_process":823}],1318:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return {
      formatError: formatError,
      formatObject: formatObject,
      tryStringify: tryStringify
    };

    /**
     * Format an error into a string.  If e is an Error and has a stack property,
     * it's returned.  Otherwise, e is formatted using formatObject, with a
     * warning added about e not being a proper Error.
     * @param {*} e
     * @returns {String} formatted string, suitable for output to developers
     */
    function formatError(e) {
      var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
      return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
    }

    /**
     * Format an object, detecting "plain" objects and running them through
     * JSON.stringify if possible.
     * @param {Object} o
     * @returns {string}
     */
    function formatObject(o) {
      var s = String(o);
      if(s === '[object Object]' && typeof JSON !== 'undefined') {
        s = tryStringify(o, s);
      }
      return s;
    }

    /**
     * Try to return the result of JSON.stringify(x).  If that fails, return
     * defaultValue
     * @param {*} x
     * @param {*} defaultValue
     * @returns {String|*} JSON.stringify(x) or defaultValue
     */
    function tryStringify(x, defaultValue) {
      try {
        return JSON.stringify(x);
      } catch(e) {
        return defaultValue;
      }
    }

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1319:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return function liftAll(liftOne, combine, dst, src) {
      if(typeof combine === 'undefined') {
        combine = defaultCombine;
      }

      return Object.keys(src).reduce(function(dst, key) {
        var f = src[key];
        return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
      }, typeof dst === 'undefined' ? defaultDst(src) : dst);
    };

    function defaultCombine(o, f, k) {
      o[k] = f;
      return o;
    }

    function defaultDst(src) {
      return typeof src === 'function' ? src.bind() : Object.create(src);
    }
  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1320:[function(require,module,exports){
  (function (process){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return function makePromise(environment) {

      var tasks = environment.scheduler;
      var emitRejection = initEmitRejection();

      var objectCreate = Object.create ||
        function(proto) {
          function Child() {}
          Child.prototype = proto;
          return new Child();
        };

      /**
       * Create a promise whose fate is determined by resolver
       * @constructor
       * @returns {Promise} promise
       * @name Promise
       */
      function Promise(resolver, handler) {
        this._handler = resolver === Handler ? handler : init(resolver);
      }

      /**
       * Run the supplied resolver
       * @param resolver
       * @returns {Pending}
       */
      function init(resolver) {
        var handler = new Pending();

        try {
          resolver(promiseResolve, promiseReject, promiseNotify);
        } catch (e) {
          promiseReject(e);
        }

        return handler;

        /**
         * Transition from pre-resolution state to post-resolution state, notifying
         * all listeners of the ultimate fulfillment or rejection
         * @param {*} x resolution value
         */
        function promiseResolve (x) {
          handler.resolve(x);
        }
        /**
         * Reject this promise with reason, which will be used verbatim
         * @param {Error|*} reason rejection reason, strongly suggested
         *   to be an Error type
         */
        function promiseReject (reason) {
          handler.reject(reason);
        }

        /**
         * @deprecated
         * Issue a progress event, notifying all progress listeners
         * @param {*} x progress event payload to pass to all listeners
         */
        function promiseNotify (x) {
          handler.notify(x);
        }
      }

      // Creation

      Promise.resolve = resolve;
      Promise.reject = reject;
      Promise.never = never;

      Promise._defer = defer;
      Promise._handler = getHandler;

      /**
       * Returns a trusted promise. If x is already a trusted promise, it is
       * returned, otherwise returns a new trusted Promise which follows x.
       * @param  {*} x
       * @return {Promise} promise
       */
      function resolve(x) {
        return isPromise(x) ? x
          : new Promise(Handler, new Async(getHandler(x)));
      }

      /**
       * Return a reject promise with x as its reason (x is used verbatim)
       * @param {*} x
       * @returns {Promise} rejected promise
       */
      function reject(x) {
        return new Promise(Handler, new Async(new Rejected(x)));
      }

      /**
       * Return a promise that remains pending forever
       * @returns {Promise} forever-pending promise.
       */
      function never() {
        return foreverPendingPromise; // Should be frozen
      }

      /**
       * Creates an internal {promise, resolver} pair
       * @private
       * @returns {Promise}
       */
      function defer() {
        return new Promise(Handler, new Pending());
      }

      // Transformation and flow control

      /**
       * Transform this promise's fulfillment value, returning a new Promise
       * for the transformed result.  If the promise cannot be fulfilled, onRejected
       * is called with the reason.  onProgress *may* be called with updates toward
       * this promise's fulfillment.
       * @param {function=} onFulfilled fulfillment handler
       * @param {function=} onRejected rejection handler
       * @param {function=} onProgress @deprecated progress handler
       * @return {Promise} new promise
       */
      Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
        var parent = this._handler;
        var state = parent.join().state();

        if ((typeof onFulfilled !== 'function' && state > 0) ||
          (typeof onRejected !== 'function' && state < 0)) {
          // Short circuit: value will not change, simply share handler
          return new this.constructor(Handler, parent);
        }

        var p = this._beget();
        var child = p._handler;

        parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

        return p;
      };

      /**
       * If this promise cannot be fulfilled due to an error, call onRejected to
       * handle the error. Shortcut for .then(undefined, onRejected)
       * @param {function?} onRejected
       * @return {Promise}
       */
      Promise.prototype['catch'] = function(onRejected) {
        return this.then(void 0, onRejected);
      };

      /**
       * Creates a new, pending promise of the same type as this promise
       * @private
       * @returns {Promise}
       */
      Promise.prototype._beget = function() {
        return begetFrom(this._handler, this.constructor);
      };

      function begetFrom(parent, Promise) {
        var child = new Pending(parent.receiver, parent.join().context);
        return new Promise(Handler, child);
      }

      // Array combinators

      Promise.all = all;
      Promise.race = race;
      Promise._traverse = traverse;

      /**
       * Return a promise that will fulfill when all promises in the
       * input array have fulfilled, or will reject when one of the
       * promises rejects.
       * @param {array} promises array of promises
       * @returns {Promise} promise for array of fulfillment values
       */
      function all(promises) {
        return traverseWith(snd, null, promises);
      }

      /**
       * Array<Promise<X>> -> Promise<Array<f(X)>>
       * @private
       * @param {function} f function to apply to each promise's value
       * @param {Array} promises array of promises
       * @returns {Promise} promise for transformed values
       */
      function traverse(f, promises) {
        return traverseWith(tryCatch2, f, promises);
      }

      function traverseWith(tryMap, f, promises) {
        var handler = typeof f === 'function' ? mapAt : settleAt;

        var resolver = new Pending();
        var pending = promises.length >>> 0;
        var results = new Array(pending);

        for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
          x = promises[i];

          if (x === void 0 && !(i in promises)) {
            --pending;
            continue;
          }

          traverseAt(promises, handler, i, x, resolver);
        }

        if(pending === 0) {
          resolver.become(new Fulfilled(results));
        }

        return new Promise(Handler, resolver);

        function mapAt(i, x, resolver) {
          if(!resolver.resolved) {
            traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
          }
        }

        function settleAt(i, x, resolver) {
          results[i] = x;
          if(--pending === 0) {
            resolver.become(new Fulfilled(results));
          }
        }
      }

      function traverseAt(promises, handler, i, x, resolver) {
        if (maybeThenable(x)) {
          var h = getHandlerMaybeThenable(x);
          var s = h.state();

          if (s === 0) {
            h.fold(handler, i, void 0, resolver);
          } else if (s > 0) {
            handler(i, h.value, resolver);
          } else {
            resolver.become(h);
            visitRemaining(promises, i+1, h);
          }
        } else {
          handler(i, x, resolver);
        }
      }

      Promise._visitRemaining = visitRemaining;
      function visitRemaining(promises, start, handler) {
        for(var i=start; i<promises.length; ++i) {
          markAsHandled(getHandler(promises[i]), handler);
        }
      }

      function markAsHandled(h, handler) {
        if(h === handler) {
          return;
        }

        var s = h.state();
        if(s === 0) {
          h.visit(h, void 0, h._unreport);
        } else if(s < 0) {
          h._unreport();
        }
      }

      /**
       * Fulfill-reject competitive race. Return a promise that will settle
       * to the same state as the earliest input promise to settle.
       *
       * WARNING: The ES6 Promise spec requires that race()ing an empty array
       * must return a promise that is pending forever.  This implementation
       * returns a singleton forever-pending promise, the same singleton that is
       * returned by Promise.never(), thus can be checked with ===
       *
       * @param {array} promises array of promises to race
       * @returns {Promise} if input is non-empty, a promise that will settle
       * to the same outcome as the earliest input promise to settle. if empty
       * is empty, returns a promise that will never settle.
       */
      function race(promises) {
        if(typeof promises !== 'object' || promises === null) {
          return reject(new TypeError('non-iterable passed to race()'));
        }

        // Sigh, race([]) is untestable unless we return *something*
        // that is recognizable without calling .then() on it.
        return promises.length === 0 ? never()
           : promises.length === 1 ? resolve(promises[0])
           : runRace(promises);
      }

      function runRace(promises) {
        var resolver = new Pending();
        var i, x, h;
        for(i=0; i<promises.length; ++i) {
          x = promises[i];
          if (x === void 0 && !(i in promises)) {
            continue;
          }

          h = getHandler(x);
          if(h.state() !== 0) {
            resolver.become(h);
            visitRemaining(promises, i+1, h);
            break;
          } else {
            h.visit(resolver, resolver.resolve, resolver.reject);
          }
        }
        return new Promise(Handler, resolver);
      }

      // Promise internals
      // Below this, everything is @private

      /**
       * Get an appropriate handler for x, without checking for cycles
       * @param {*} x
       * @returns {object} handler
       */
      function getHandler(x) {
        if(isPromise(x)) {
          return x._handler.join();
        }
        return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
      }

      /**
       * Get a handler for thenable x.
       * NOTE: You must only call this if maybeThenable(x) == true
       * @param {object|function|Promise} x
       * @returns {object} handler
       */
      function getHandlerMaybeThenable(x) {
        return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
      }

      /**
       * Get a handler for potentially untrusted thenable x
       * @param {*} x
       * @returns {object} handler
       */
      function getHandlerUntrusted(x) {
        try {
          var untrustedThen = x.then;
          return typeof untrustedThen === 'function'
            ? new Thenable(untrustedThen, x)
            : new Fulfilled(x);
        } catch(e) {
          return new Rejected(e);
        }
      }

      /**
       * Handler for a promise that is pending forever
       * @constructor
       */
      function Handler() {}

      Handler.prototype.when
        = Handler.prototype.become
        = Handler.prototype.notify // deprecated
        = Handler.prototype.fail
        = Handler.prototype._unreport
        = Handler.prototype._report
        = noop;

      Handler.prototype._state = 0;

      Handler.prototype.state = function() {
        return this._state;
      };

      /**
       * Recursively collapse handler chain to find the handler
       * nearest to the fully resolved value.
       * @returns {object} handler nearest the fully resolved value
       */
      Handler.prototype.join = function() {
        var h = this;
        while(h.handler !== void 0) {
          h = h.handler;
        }
        return h;
      };

      Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
        this.when({
          resolver: to,
          receiver: receiver,
          fulfilled: fulfilled,
          rejected: rejected,
          progress: progress
        });
      };

      Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
        this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
      };

      Handler.prototype.fold = function(f, z, c, to) {
        this.when(new Fold(f, z, c, to));
      };

      /**
       * Handler that invokes fail() on any handler it becomes
       * @constructor
       */
      function FailIfRejected() {}

      inherit(Handler, FailIfRejected);

      FailIfRejected.prototype.become = function(h) {
        h.fail();
      };

      var failIfRejected = new FailIfRejected();

      /**
       * Handler that manages a queue of consumers waiting on a pending promise
       * @constructor
       */
      function Pending(receiver, inheritedContext) {
        Promise.createContext(this, inheritedContext);

        this.consumers = void 0;
        this.receiver = receiver;
        this.handler = void 0;
        this.resolved = false;
      }

      inherit(Handler, Pending);

      Pending.prototype._state = 0;

      Pending.prototype.resolve = function(x) {
        this.become(getHandler(x));
      };

      Pending.prototype.reject = function(x) {
        if(this.resolved) {
          return;
        }

        this.become(new Rejected(x));
      };

      Pending.prototype.join = function() {
        if (!this.resolved) {
          return this;
        }

        var h = this;

        while (h.handler !== void 0) {
          h = h.handler;
          if (h === this) {
            return this.handler = cycle();
          }
        }

        return h;
      };

      Pending.prototype.run = function() {
        var q = this.consumers;
        var handler = this.handler;
        this.handler = this.handler.join();
        this.consumers = void 0;

        for (var i = 0; i < q.length; ++i) {
          handler.when(q[i]);
        }
      };

      Pending.prototype.become = function(handler) {
        if(this.resolved) {
          return;
        }

        this.resolved = true;
        this.handler = handler;
        if(this.consumers !== void 0) {
          tasks.enqueue(this);
        }

        if(this.context !== void 0) {
          handler._report(this.context);
        }
      };

      Pending.prototype.when = function(continuation) {
        if(this.resolved) {
          tasks.enqueue(new ContinuationTask(continuation, this.handler));
        } else {
          if(this.consumers === void 0) {
            this.consumers = [continuation];
          } else {
            this.consumers.push(continuation);
          }
        }
      };

      /**
       * @deprecated
       */
      Pending.prototype.notify = function(x) {
        if(!this.resolved) {
          tasks.enqueue(new ProgressTask(x, this));
        }
      };

      Pending.prototype.fail = function(context) {
        var c = typeof context === 'undefined' ? this.context : context;
        this.resolved && this.handler.join().fail(c);
      };

      Pending.prototype._report = function(context) {
        this.resolved && this.handler.join()._report(context);
      };

      Pending.prototype._unreport = function() {
        this.resolved && this.handler.join()._unreport();
      };

      /**
       * Wrap another handler and force it into a future stack
       * @param {object} handler
       * @constructor
       */
      function Async(handler) {
        this.handler = handler;
      }

      inherit(Handler, Async);

      Async.prototype.when = function(continuation) {
        tasks.enqueue(new ContinuationTask(continuation, this));
      };

      Async.prototype._report = function(context) {
        this.join()._report(context);
      };

      Async.prototype._unreport = function() {
        this.join()._unreport();
      };

      /**
       * Handler that wraps an untrusted thenable and assimilates it in a future stack
       * @param {function} then
       * @param {{then: function}} thenable
       * @constructor
       */
      function Thenable(then, thenable) {
        Pending.call(this);
        tasks.enqueue(new AssimilateTask(then, thenable, this));
      }

      inherit(Pending, Thenable);

      /**
       * Handler for a fulfilled promise
       * @param {*} x fulfillment value
       * @constructor
       */
      function Fulfilled(x) {
        Promise.createContext(this);
        this.value = x;
      }

      inherit(Handler, Fulfilled);

      Fulfilled.prototype._state = 1;

      Fulfilled.prototype.fold = function(f, z, c, to) {
        runContinuation3(f, z, this, c, to);
      };

      Fulfilled.prototype.when = function(cont) {
        runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
      };

      var errorId = 0;

      /**
       * Handler for a rejected promise
       * @param {*} x rejection reason
       * @constructor
       */
      function Rejected(x) {
        Promise.createContext(this);

        this.id = ++errorId;
        this.value = x;
        this.handled = false;
        this.reported = false;

        this._report();
      }

      inherit(Handler, Rejected);

      Rejected.prototype._state = -1;

      Rejected.prototype.fold = function(f, z, c, to) {
        to.become(this);
      };

      Rejected.prototype.when = function(cont) {
        if(typeof cont.rejected === 'function') {
          this._unreport();
        }
        runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
      };

      Rejected.prototype._report = function(context) {
        tasks.afterQueue(new ReportTask(this, context));
      };

      Rejected.prototype._unreport = function() {
        if(this.handled) {
          return;
        }
        this.handled = true;
        tasks.afterQueue(new UnreportTask(this));
      };

      Rejected.prototype.fail = function(context) {
        this.reported = true;
        emitRejection('unhandledRejection', this);
        Promise.onFatalRejection(this, context === void 0 ? this.context : context);
      };

      function ReportTask(rejection, context) {
        this.rejection = rejection;
        this.context = context;
      }

      ReportTask.prototype.run = function() {
        if(!this.rejection.handled && !this.rejection.reported) {
          this.rejection.reported = true;
          emitRejection('unhandledRejection', this.rejection) ||
            Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
        }
      };

      function UnreportTask(rejection) {
        this.rejection = rejection;
      }

      UnreportTask.prototype.run = function() {
        if(this.rejection.reported) {
          emitRejection('rejectionHandled', this.rejection) ||
            Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
        }
      };

      // Unhandled rejection hooks
      // By default, everything is a noop

      Promise.createContext
        = Promise.enterContext
        = Promise.exitContext
        = Promise.onPotentiallyUnhandledRejection
        = Promise.onPotentiallyUnhandledRejectionHandled
        = Promise.onFatalRejection
        = noop;

      // Errors and singletons

      var foreverPendingHandler = new Handler();
      var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

      function cycle() {
        return new Rejected(new TypeError('Promise cycle'));
      }

      // Task runners

      /**
       * Run a single consumer
       * @constructor
       */
      function ContinuationTask(continuation, handler) {
        this.continuation = continuation;
        this.handler = handler;
      }

      ContinuationTask.prototype.run = function() {
        this.handler.join().when(this.continuation);
      };

      /**
       * Run a queue of progress handlers
       * @constructor
       */
      function ProgressTask(value, handler) {
        this.handler = handler;
        this.value = value;
      }

      ProgressTask.prototype.run = function() {
        var q = this.handler.consumers;
        if(q === void 0) {
          return;
        }

        for (var c, i = 0; i < q.length; ++i) {
          c = q[i];
          runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
        }
      };

      /**
       * Assimilate a thenable, sending it's value to resolver
       * @param {function} then
       * @param {object|function} thenable
       * @param {object} resolver
       * @constructor
       */
      function AssimilateTask(then, thenable, resolver) {
        this._then = then;
        this.thenable = thenable;
        this.resolver = resolver;
      }

      AssimilateTask.prototype.run = function() {
        var h = this.resolver;
        tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

        function _resolve(x) { h.resolve(x); }
        function _reject(x)  { h.reject(x); }
        function _notify(x)  { h.notify(x); }
      };

      function tryAssimilate(then, thenable, resolve, reject, notify) {
        try {
          then.call(thenable, resolve, reject, notify);
        } catch (e) {
          reject(e);
        }
      }

      /**
       * Fold a handler value with z
       * @constructor
       */
      function Fold(f, z, c, to) {
        this.f = f; this.z = z; this.c = c; this.to = to;
        this.resolver = failIfRejected;
        this.receiver = this;
      }

      Fold.prototype.fulfilled = function(x) {
        this.f.call(this.c, this.z, x, this.to);
      };

      Fold.prototype.rejected = function(x) {
        this.to.reject(x);
      };

      Fold.prototype.progress = function(x) {
        this.to.notify(x);
      };

      // Other helpers

      /**
       * @param {*} x
       * @returns {boolean} true iff x is a trusted Promise
       */
      function isPromise(x) {
        return x instanceof Promise;
      }

      /**
       * Test just enough to rule out primitives, in order to take faster
       * paths in some code
       * @param {*} x
       * @returns {boolean} false iff x is guaranteed *not* to be a thenable
       */
      function maybeThenable(x) {
        return (typeof x === 'object' || typeof x === 'function') && x !== null;
      }

      function runContinuation1(f, h, receiver, next) {
        if(typeof f !== 'function') {
          return next.become(h);
        }

        Promise.enterContext(h);
        tryCatchReject(f, h.value, receiver, next);
        Promise.exitContext();
      }

      function runContinuation3(f, x, h, receiver, next) {
        if(typeof f !== 'function') {
          return next.become(h);
        }

        Promise.enterContext(h);
        tryCatchReject3(f, x, h.value, receiver, next);
        Promise.exitContext();
      }

      /**
       * @deprecated
       */
      function runNotify(f, x, h, receiver, next) {
        if(typeof f !== 'function') {
          return next.notify(x);
        }

        Promise.enterContext(h);
        tryCatchReturn(f, x, receiver, next);
        Promise.exitContext();
      }

      function tryCatch2(f, a, b) {
        try {
          return f(a, b);
        } catch(e) {
          return reject(e);
        }
      }

      /**
       * Return f.call(thisArg, x), or if it throws return a rejected promise for
       * the thrown exception
       */
      function tryCatchReject(f, x, thisArg, next) {
        try {
          next.become(getHandler(f.call(thisArg, x)));
        } catch(e) {
          next.become(new Rejected(e));
        }
      }

      /**
       * Same as above, but includes the extra argument parameter.
       */
      function tryCatchReject3(f, x, y, thisArg, next) {
        try {
          f.call(thisArg, x, y, next);
        } catch(e) {
          next.become(new Rejected(e));
        }
      }

      /**
       * @deprecated
       * Return f.call(thisArg, x), or if it throws, *return* the exception
       */
      function tryCatchReturn(f, x, thisArg, next) {
        try {
          next.notify(f.call(thisArg, x));
        } catch(e) {
          next.notify(e);
        }
      }

      function inherit(Parent, Child) {
        Child.prototype = objectCreate(Parent.prototype);
        Child.prototype.constructor = Child;
      }

      function snd(x, y) {
        return y;
      }

      function noop() {}

      function initEmitRejection() {
        /*global process, self, CustomEvent*/
        if(typeof process !== 'undefined' && process !== null
          && typeof process.emit === 'function') {
          // Returning falsy here means to call the default
          // onPotentiallyUnhandledRejection API.  This is safe even in
          // browserify since process.emit always returns falsy in browserify:
          // https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
          return function(type, rejection) {
            return type === 'unhandledRejection'
              ? process.emit(type, rejection.value, rejection)
              : process.emit(type, rejection);
          };
        } else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
          return (function(noop, self, CustomEvent) {
            var hasCustomEvent = false;
            try {
              var ev = new CustomEvent('unhandledRejection');
              hasCustomEvent = ev instanceof CustomEvent;
            } catch (e) {}

            return !hasCustomEvent ? noop : function(type, rejection) {
              var ev = new CustomEvent(type, {
                detail: {
                  reason: rejection.value,
                  key: rejection
                },
                bubbles: false,
                cancelable: true
              });

              return !self.dispatchEvent(ev);
            };
          }(noop, self, CustomEvent));
        }

        return noop;
      }

      return Promise;
    };
  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  }).call(this,require('_process'))
  },{"_process":823}],1321:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */
  /** @author Brian Cavalier */
  /** @author John Hann */

  (function(define) { 'use strict';
  define(function() {

    return {
      pending: toPendingState,
      fulfilled: toFulfilledState,
      rejected: toRejectedState,
      inspect: inspect
    };

    function toPendingState() {
      return { state: 'pending' };
    }

    function toRejectedState(e) {
      return { state: 'rejected', reason: e };
    }

    function toFulfilledState(x) {
      return { state: 'fulfilled', value: x };
    }

    function inspect(handler) {
      var state = handler.state();
      return state === 0 ? toPendingState()
         : state > 0   ? toFulfilledState(handler.value)
                       : toRejectedState(handler.value);
    }

  });
  }(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

  },{}],1322:[function(require,module,exports){
  /** @license MIT License (c) copyright 2013 original author or authors */

  /**
   * Collection of helpers for interfacing with node-style asynchronous functions
   * using promises.
   *
   * @author Brian Cavalier
   * @contributor Renato Zannon
   */

  (function(define) {
  define(function(require) {

    var when = require('./when');
    var _liftAll = require('./lib/liftAll');
    var setTimer = require('./lib/env').setTimer;
    var slice = Array.prototype.slice;

    var _apply = require('./lib/apply')(when.Promise, dispatch);

    return {
      lift: lift,
      liftAll: liftAll,
      apply: apply,
      call: call,
      createCallback: createCallback,
      bindCallback: bindCallback,
      liftCallback: liftCallback
    };

    /**
     * Takes a node-style async function and calls it immediately (with an optional
     * array of arguments or promises for arguments). It returns a promise whose
     * resolution depends on whether the async functions calls its callback with the
     * conventional error argument or not.
     *
     * With this it becomes possible to leverage existing APIs while still reaping
     * the benefits of promises.
     *
     * @example
     *    function onlySmallNumbers(n, callback) {
     *		if(n < 10) {
     *			callback(null, n + 10);
     *		} else {
     *			callback(new Error("Calculation failed"));
     *		}
     *	}
     *
     *    var nodefn = require("when/node/function");
     *
     *    // Logs '15'
     *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
     *
     *    // Logs 'Calculation failed'
     *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
     *
     * @param {function} f node-style function that will be called
     * @param {Array} [args] array of arguments to func
     * @returns {Promise} promise for the value func passes to its callback
     */
    function apply(f, args) {
      return _apply(f, this, args || []);
    }

    function dispatch(f, thisArg, args, h) {
      var cb = createCallback(h);
      try {
        switch(args.length) {
          case 2: f.call(thisArg, args[0], args[1], cb); break;
          case 1: f.call(thisArg, args[0], cb); break;
          case 0: f.call(thisArg, cb); break;
          default:
            args.push(cb);
            f.apply(thisArg, args);
        }
      } catch(e) {
        h.reject(e);
      }
    }

    /**
     * Has the same behavior that {@link apply} has, with the difference that the
     * arguments to the function are provided individually, while {@link apply} accepts
     * a single array.
     *
     * @example
     *    function sumSmallNumbers(x, y, callback) {
     *		var result = x + y;
     *		if(result < 10) {
     *			callback(null, result);
     *		} else {
     *			callback(new Error("Calculation failed"));
     *		}
     *	}
     *
     *    // Logs '5'
     *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
     *
     *    // Logs 'Calculation failed'
     *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
     *
     * @param {function} f node-style function that will be called
     * @param {...*} [args] arguments that will be forwarded to the function
     * @returns {Promise} promise for the value func passes to its callback
     */
    function call(f /*, args... */) {
      return _apply(f, this, slice.call(arguments, 1));
    }

    /**
     * Takes a node-style function and returns new function that wraps the
     * original and, instead of taking a callback, returns a promise. Also, it
     * knows how to handle promises given as arguments, waiting for their
     * resolution before executing.
     *
     * Upon execution, the orginal function is executed as well. If it passes
     * a truthy value as the first argument to the callback, it will be
     * interpreted as an error condition, and the promise will be rejected
     * with it. Otherwise, the call is considered a resolution, and the promise
     * is resolved with the callback's second argument.
     *
     * @example
     *    var fs = require("fs"), nodefn = require("when/node/function");
     *
     *    var promiseRead = nodefn.lift(fs.readFile);
     *
     *    // The promise is resolved with the contents of the file if everything
     *    // goes ok
     *    promiseRead('exists.txt').then(console.log, console.error);
     *
     *    // And will be rejected if something doesn't work out
     *    // (e.g. the files does not exist)
     *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
     *
     *
     * @param {Function} f node-style function to be lifted
     * @param {...*} [args] arguments to be prepended for the new function @deprecated
     * @returns {Function} a promise-returning function
     */
    function lift(f /*, args... */) {
      var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
      return function() {
        // TODO: Simplify once partialing has been removed
        var l = args1.length;
        var al = arguments.length;
        var args = new Array(al + l);
        var i;
        for(i=0; i<l; ++i) {
          args[i] = args1[i];
        }
        for(i=0; i<al; ++i) {
          args[i+l] = arguments[i];
        }
        return _apply(f, this, args);
      };
    }

    /**
     * Lift all the functions/methods on src
     * @param {object|function} src source whose functions will be lifted
     * @param {function?} combine optional function for customizing the lifting
     *  process. It is passed dst, the lifted function, and the property name of
     *  the original function on src.
     * @param {(object|function)?} dst option destination host onto which to place lifted
     *  functions. If not provided, liftAll returns a new object.
     * @returns {*} If dst is provided, returns dst with lifted functions as
     *  properties.  If dst not provided, returns a new object with lifted functions.
     */
    function liftAll(src, combine, dst) {
      return _liftAll(lift, combine, dst, src);
    }

    /**
     * Takes an object that responds to the resolver interface, and returns
     * a function that will resolve or reject it depending on how it is called.
     *
     * @example
     *	function callbackTakingFunction(callback) {
     *		if(somethingWrongHappened) {
     *			callback(error);
     *		} else {
     *			callback(null, interestingValue);
     *		}
     *	}
     *
     *	var when = require('when'), nodefn = require('when/node/function');
     *
     *	var deferred = when.defer();
     *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
     *
     *	deferred.promise.then(function(interestingValue) {
     *		// Use interestingValue
     *	});
     *
     * @param {Resolver} resolver that will be 'attached' to the callback
     * @returns {Function} a node-style callback function
     */
    function createCallback(resolver) {
      return function(err, value) {
        if(err) {
          resolver.reject(err);
        } else if(arguments.length > 2) {
          resolver.resolve(slice.call(arguments, 1));
        } else {
          resolver.resolve(value);
        }
      };
    }

    /**
     * Attaches a node-style callback to a promise, ensuring the callback is
     * called for either fulfillment or rejection. Returns a promise with the same
     * state as the passed-in promise.
     *
     * @example
     *	var deferred = when.defer();
     *
     *	function callback(err, value) {
     *		// Handle err or use value
     *	}
     *
     *	bindCallback(deferred.promise, callback);
     *
     *	deferred.resolve('interesting value');
     *
     * @param {Promise} promise The promise to be attached to.
     * @param {Function} callback The node-style callback to attach.
     * @returns {Promise} A promise with the same state as the passed-in promise.
     */
    function bindCallback(promise, callback) {
      promise = when(promise);

      if (callback) {
        promise.then(success, wrapped);
      }

      return promise;

      function success(value) {
        wrapped(null, value);
      }

      function wrapped(err, value) {
        setTimer(function () {
          callback(err, value);
        }, 0);
      }
    }

    /**
     * Takes a node-style callback and returns new function that accepts a
     * promise, calling the original callback when the promise is either
     * fulfilled or rejected with the appropriate arguments.
     *
     * @example
     *	var deferred = when.defer();
     *
     *	function callback(err, value) {
     *		// Handle err or use value
     *	}
     *
     *	var wrapped = liftCallback(callback);
     *
     *	// `wrapped` can now be passed around at will
     *	wrapped(deferred.promise);
     *
     *	deferred.resolve('interesting value');
     *
     * @param {Function} callback The node-style callback to wrap.
     * @returns {Function} The lifted, promise-accepting function.
     */
    function liftCallback(callback) {
      return function(promise) {
        return bindCallback(promise, callback);
      };
    }
  });

  })(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




  },{"./lib/apply":1307,"./lib/env":1317,"./lib/liftAll":1319,"./when":1323}],1323:[function(require,module,exports){
  /** @license MIT License (c) copyright 2010-2014 original author or authors */

  /**
   * Promises/A+ and when() implementation
   * when is part of the cujoJS family of libraries (http://cujojs.com/)
   * @author Brian Cavalier
   * @author John Hann
   */
  (function(define) { 'use strict';
  define(function (require) {

    var timed = require('./lib/decorators/timed');
    var array = require('./lib/decorators/array');
    var flow = require('./lib/decorators/flow');
    var fold = require('./lib/decorators/fold');
    var inspect = require('./lib/decorators/inspect');
    var generate = require('./lib/decorators/iterate');
    var progress = require('./lib/decorators/progress');
    var withThis = require('./lib/decorators/with');
    var unhandledRejection = require('./lib/decorators/unhandledRejection');
    var TimeoutError = require('./lib/TimeoutError');

    var Promise = [array, flow, fold, generate, progress,
      inspect, withThis, timed, unhandledRejection]
      .reduce(function(Promise, feature) {
        return feature(Promise);
      }, require('./lib/Promise'));

    var apply = require('./lib/apply')(Promise);

    // Public API

    when.promise     = promise;              // Create a pending promise
    when.resolve     = Promise.resolve;      // Create a resolved promise
    when.reject      = Promise.reject;       // Create a rejected promise

    when.lift        = lift;                 // lift a function to return promises
    when['try']      = attempt;              // call a function and return a promise
    when.attempt     = attempt;              // alias for when.try

    when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
    when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

    when.join        = join;                 // Join 2 or more promises

    when.all         = all;                  // Resolve a list of promises
    when.settle      = settle;               // Settle a list of promises

    when.any         = lift(Promise.any);    // One-winner race
    when.some        = lift(Promise.some);   // Multi-winner race
    when.race        = lift(Promise.race);   // First-to-settle race

    when.map         = map;                  // Array.map() for promises
    when.filter      = filter;               // Array.filter() for promises
    when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
    when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

    when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

    when.Promise     = Promise;              // Promise constructor
    when.defer       = defer;                // Create a {promise, resolve, reject} tuple

    // Error types

    when.TimeoutError = TimeoutError;

    /**
     * Get a trusted promise for x, or by transforming x with onFulfilled
     *
     * @param {*} x
     * @param {function?} onFulfilled callback to be called when x is
     *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
     *   will be invoked immediately.
     * @param {function?} onRejected callback to be called when x is
     *   rejected.
     * @param {function?} onProgress callback to be called when progress updates
     *   are issued for x. @deprecated
     * @returns {Promise} a new promise that will fulfill with the return
     *   value of callback or errback or the completion value of promiseOrValue if
     *   callback and/or errback is not supplied.
     */
    function when(x, onFulfilled, onRejected, onProgress) {
      var p = Promise.resolve(x);
      if (arguments.length < 2) {
        return p;
      }

      return p.then(onFulfilled, onRejected, onProgress);
    }

    /**
     * Creates a new promise whose fate is determined by resolver.
     * @param {function} resolver function(resolve, reject, notify)
     * @returns {Promise} promise whose fate is determine by resolver
     */
    function promise(resolver) {
      return new Promise(resolver);
    }

    /**
     * Lift the supplied function, creating a version of f that returns
     * promises, and accepts promises as arguments.
     * @param {function} f
     * @returns {Function} version of f that returns promises
     */
    function lift(f) {
      return function() {
        for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
          a[i] = arguments[i];
        }
        return apply(f, this, a);
      };
    }

    /**
     * Call f in a future turn, with the supplied args, and return a promise
     * for the result.
     * @param {function} f
     * @returns {Promise}
     */
    function attempt(f /*, args... */) {
      /*jshint validthis:true */
      for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
        a[i] = arguments[i+1];
      }
      return apply(f, this, a);
    }

    /**
     * Creates a {promise, resolver} pair, either or both of which
     * may be given out safely to consumers.
     * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
     */
    function defer() {
      return new Deferred();
    }

    function Deferred() {
      var p = Promise._defer();

      function resolve(x) { p._handler.resolve(x); }
      function reject(x) { p._handler.reject(x); }
      function notify(x) { p._handler.notify(x); }

      this.promise = p;
      this.resolve = resolve;
      this.reject = reject;
      this.notify = notify;
      this.resolver = { resolve: resolve, reject: reject, notify: notify };
    }

    /**
     * Determines if x is promise-like, i.e. a thenable object
     * NOTE: Will return true for *any thenable object*, and isn't truly
     * safe, since it may attempt to access the `then` property of x (i.e.
     *  clever/malicious getters may do weird things)
     * @param {*} x anything
     * @returns {boolean} true if x is promise-like
     */
    function isPromiseLike(x) {
      return x && typeof x.then === 'function';
    }

    /**
     * Return a promise that will resolve only once all the supplied arguments
     * have resolved. The resolution value of the returned promise will be an array
     * containing the resolution values of each of the arguments.
     * @param {...*} arguments may be a mix of promises and values
     * @returns {Promise}
     */
    function join(/* ...promises */) {
      return Promise.all(arguments);
    }

    /**
     * Return a promise that will fulfill once all input promises have
     * fulfilled, or reject when any one input promise rejects.
     * @param {array|Promise} promises array (or promise for an array) of promises
     * @returns {Promise}
     */
    function all(promises) {
      return when(promises, Promise.all);
    }

    /**
     * Return a promise that will always fulfill with an array containing
     * the outcome states of all input promises.  The returned promise
     * will only reject if `promises` itself is a rejected promise.
     * @param {array|Promise} promises array (or promise for an array) of promises
     * @returns {Promise} promise for array of settled state descriptors
     */
    function settle(promises) {
      return when(promises, Promise.settle);
    }

    /**
     * Promise-aware array map function, similar to `Array.prototype.map()`,
     * but input array may contain promises or values.
     * @param {Array|Promise} promises array of anything, may contain promises and values
     * @param {function(x:*, index:Number):*} mapFunc map function which may
     *  return a promise or value
     * @returns {Promise} promise that will fulfill with an array of mapped values
     *  or reject if any input promise rejects.
     */
    function map(promises, mapFunc) {
      return when(promises, function(promises) {
        return Promise.map(promises, mapFunc);
      });
    }

    /**
     * Filter the provided array of promises using the provided predicate.  Input may
     * contain promises and values
     * @param {Array|Promise} promises array of promises and values
     * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
     *  Must return truthy (or promise for truthy) for items to retain.
     * @returns {Promise} promise that will fulfill with an array containing all items
     *  for which predicate returned truthy.
     */
    function filter(promises, predicate) {
      return when(promises, function(promises) {
        return Promise.filter(promises, predicate);
      });
    }

    return when;
  });
  })(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

  },{"./lib/Promise":1304,"./lib/TimeoutError":1306,"./lib/apply":1307,"./lib/decorators/array":1308,"./lib/decorators/flow":1309,"./lib/decorators/fold":1310,"./lib/decorators/inspect":1311,"./lib/decorators/iterate":1312,"./lib/decorators/progress":1313,"./lib/decorators/timed":1314,"./lib/decorators/unhandledRejection":1315,"./lib/decorators/with":1316}]},{},[24]);
